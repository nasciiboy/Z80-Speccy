<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es" dir="ltr" class="js" lang="es"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="UTF-8">
  <title>Curso de Ensamblador Z80</title>
<link type="text/css" rel="stylesheet" href="css.css">
</head>
<body class="flatly dokuwiki mode_show tpl_dokuwiki-template-bootstrap3 dw-page-on-panel" data-page-id="cursos:ensamblador:indice">
      <article id="dokuwiki__content" class="container">
            <div class="dw-content ">
<h1 id="curso-de-ensamblador-z80-de-compiler-software">Curso de Ensamblador Z80 de Compiler Software</h1>
<div class="level1">
<ol class="fix-media-list-overlap">
<li><a href="#prologo">Prólogo y objetivos del curso</a>.</li>
<li><a href="#introduccion-y-conceptos-basicos">Introducción y conceptos básicos</a>.</li>
<li><a href="#arquitectura-y-funcionamiento-del-spectrum">Arquitectura y Funcionamiento del Spectrum</a>.</li>
<li><a href="#lenguaje-ensamblador-del-z80-i">Lenguaje Ensamblador del Z80 (I)</a>: Arquitectura del Z80 e Instrucciones básicas.</li>
<li><a href="#lenguaje-ensamblador-del-z80-ii">Lenguaje Ensamblador del Z80 (II)</a>: Desplazamientos de memoria, bits y operaciones lógicas.</li>
<li><a href="#lenguaje-ensamblador-del-z80-iii">Lenguaje Ensamblador del Z80 (III)</a>: Instrucciones condicionales.</li>
<li><a href="#lenguaje-ensamblador-del-z80-iv">Lenguaje Ensamblador del Z80 (IV)</a>: La pila y las llamadas a subrutinas.</li>
<li><a href="#lenguaje-ensamblador-del-z80-v">Lenguaje Ensamblador del Z80 (V)</a>: Puertos de E/S y Tabla de Opcodes.</li>
<li><a href="#save-y-loadalmacenamiento-en-cinta">Rutinas de carga</a>: Save y Load (almacenamiento en cinta).</li>
<li><a href="#lectura-del-teclado-en-el-spectrum">Lectura del teclado</a> en el Spectrum: teoría y rutinas.</li>
<li><a href="#interrupciones-del-procesador-z80">Interrupciones del microprocesador Z80</a>: rutinas ISR.</li>
<li><a href="#paginacion-de-memoria-128k">Paginación de memoria</a>: Paginación de bancos de memoria en modelos de 128K.</li>
<li><a href="#graficos-ila-videomemoria-del-spectrum">Gráficos en el Spectrum (I)</a>: la videomemoria: imagen y atributos.</li>
<li><a href="#graficos-y-iicalculo-de-direcciones-y-coordenadas">Gráficos en el Spectrum (y II)</a>: Cálculo de direcciones y coordenadas.</li>
<li><a href="#graficos-y-iiisprites-y-graficos-en-baja-resolucion-bloques">Gráficos en el Spectrum (y III)</a>: Sprites y gráficos en baja resolución (gráficos de bloques).</li>
<li><a href="#graficos-y-ivfuentes-de-texto">Gráficos en el Spectrum (y IV)</a>: Fuentes de texto.</li>
<li><a href="#graficos-y-vtecnicas-de-mapeado-por-bloques">Gráficos en el Spectrum (y V)</a>: Técnicas de mapeado por bloques (tilemaps).</li>
<li><a href="#compresion-y-descompresion-rle">Compresión y Descompresión RLE</a> de gráficos, sonido, y datos.</li>
</ol>

<p>
<br>

</p>

</div>
</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content ">
<p>
<br>

</p>

<h1 id="prologo">Prólogo</h1>
<div class="level1">

<p>
<br>

 <strong>“Programación en ensamblador de Z80 para el microordenador Sinclair ZX Spectrum.”</strong>
<br>

<br>

</p>

<p>
 Mucha gente se preguntará cómo es posible que, en pleno 2011, exista
alguien con interés en escribir y publicar un curso sobre esta temática.
 Apenas un par de centenares o miles de personas en todo el mundo pueden
 estar realmente interesadas en la lectura de un curso como este.
</p>

<p>
 Sin embargo, he dedicado gran cantidad de horas a escribir y depurar
este texto y sus ejemplos. ¿El motivo? Simplemente, no se me ocurre una
mejor forma de concentrar en un único elemento mi pasión por el ZX
Spectrum, la programación en ensamblador, el desarrollo de programas y
los videojuegos.
</p>

<p>
 Puedo y debo decir que el ZX Spectrum cambió mi vida. Aquella tarde de
viernes de 1989 en la que mis padres aparecieron por la puerta con un
Spectrum +2A de segunda mano, junto a una caja llena de revistas
Microhobby y cintas de juegos y programas, cambió el que hubiera sido mi
 futuro profesional, orientándolo hacia el mundo de la Ingeniería, la
Electrónica y las Telecomunicaciones.
</p>

<p>
 Como todos, empecé exprimiendo el Spectrum a través de los juegos
profesionales que se vendían para la popular máquina de Sinclair. En
paralelo a los juegos, comencé a leer los ejemplares de las revistas
Microhobby que habíamos adquirido junto al ordenador.
</p>

<p>
 Mi relación inicial con Microhobby fue las que supongo que tendrían
muchos usuarios sin interés por la programación: directo a las páginas
con análisis, fotos y notas de juegos. Como mucho, como curiosidad
tecleaba alguno de los listados en BASIC de la sección de trucos,
maravillándome con sencillas melodías, o psicodélicos efectos de colores
 con el borde.
</p>

<p>
 Esos listados en BASIC, tan sencillos, despertaron mi curiosidad por
“cómo se hacen estos juegos”. Poco a poco se produjo el cambio: mi
interés por jugar pasó a ser interés, mucho interés, por desarrollar.
</p>

<p>
 Microhobby fue la herramienta mediante la cual aprendí BASIC y
ensamblador de Z80. Como la completa revista que era, entre sus páginas
de análisis de juegos podías encontrar fantásticos artículos y listados
animándote a programar pequeñas rutinas y juegos.
</p>

<p>
 Casi sin darme tiempo para disfrutar de lo que estaba aprendiendo,
llegó el fin de la revista Microhobby y el ocaso comercial del Spectrum
en España. Las consolas ocuparon el espacio lúdico del Spectrum y el PC
se convirtió en la herramienta de programación estándar. El Spectrum
pasó para mí al olvido hasta que la revista Micromanía publicó el
emulador “SPECTRUM” de Pedro Gimeno.
</p>

<p>
 Este emulador, y todos los que aparecieron en la década de los 90,
sirvió para que la gente no olvidara el Spectrum y todo el legado que
nos había dejado.
</p>

<p>
 Ya a principios del siglo XXI, el Spectrum volvió a ser mi centro de
atención: inicialmente, desarrollé el emulador ASpectrum con el que
mejoré en gran parte mis conocimientos sobre la arquitectura del
Spectrum y la programación en lenguaje ensamblador de Z80.
</p>

<p>
 Una vez ASpectrum fue una realidad, comencé a realizar sencillos juegos
 con Z88DK en C con pequeñas rutinas en ensamblador integradas en el
código. Se despertó de nuevo en mí el interés por desarrollar juegos de
Spectrum y de escribir tutoriales y cursos con todo lo que iba
rememorando o aprendiendo.
</p>

<p>
 En esa época (años 2002 - 2003) se fundó Compiler Software y se editó
la revista MagazineZX en el portal Speccy.org, incluyendo diversos
cursos de programación en C con Z88DK y en ensamblador de Z80 con pasmo.
 Estos cursos, finalmente, se han ampliado y materializado en el texto
que estáis leyendo.
</p>

<p>
<br>

</p>

</div>

<h2 id="objetivos-y-desarrollo-del-curso">Objetivos y desarrollo del curso</h2>
<div class="level2">

<p>
 El objetivo principal de este curso, libro, o gran tutorial es que un
lector con conocimientos básicos de programación pueda aprender
fácilmente ensamblador de Z80 aplicado al desarrollo de juegos y
utilidades de Spectrum.
</p>

<p>
 Con este curso pretendemos enseñar al lector:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> La arquitectura del Sinclair ZX Spectrum: se describen sus componentes internos y cómo se interrelacionan.
</li>
<li> La arquitectura del microprocesador Z80: sus registros y su juego de instrucciones.
</li>
<li> La sintaxis del lenguaje ensamblador de Z80: nmemónicos del lenguaje.
</li>
<li> Cómo utilizar el ensamblador PASMO para ensamblar nuestros programas en ASM de Z80.
</li>
<li> Acceso a los periféricos del Spectrum: Teclado, Joystick, etc.
</li>
<li> Gráficos en el Spectrum: Sprites, Fuentes de texto, Impresión de mapeados, etc.
</li>
<li> Funciones avanzadas de los modelos 128K: paginación de memoria.
</li>
<li> Rutinas auxiliares: subrutinas de carga, compresión RLE, Interrupciones del procesador.
</li>
<li> Subrutinas útiles para el desarrollo de programas.
</li>
</ul>

<p>
<br>

</p>

<p>
 Al escribirlo he intentado ponerme en la piel del programador que desea
 empezar con el lenguaje ensamblador, por lo que los dos primeros
capítulos describen la arquitectura del Spectrum y del Z80. Los
siguientes cinco capítulos tratan sobre la sintaxis del lenguaje
ensamblador, donde el lector aprenderá las “piezas básicas” con las que
construir programas en ensamblador para cualquier microordenador basado
en el procesador Z80 de Zilog.
</p>

<p>
 A partir del octavo capítulo nos centramos única y exclusivamente en el
 Spectrum, profundizando en todas las diferentes áreas que puedan sernos
 de utilidad para el desarrollo de juegos o programas: lectura del
teclado, temporización, impresión de gráficos, técnicas de mapeado,
carga desde cinta, etc.
</p>

<p>
 A lo largo del texto se presentan múltiples ejemplos y rutinas para que
 el lector pueda verificar la teoría descrita así como utilizarlas
directamente en sus propios programas.
</p>

<p>
 Cuando se escribe una rutina para un procesador tan “limitado” como el
Z80 suelen presentarse 2 opciones: escribir una rutina comprensible, o
escribir una rutina optimizada. El objetivo del curso es que el lector
aprenda programación en ensamblador y por lo tanto debe de poder
comprender las rutinas que se presentan, por lo que en el desarrollo de
los ejemplos y las rutinas ha primado la comprensión frente a la
optimización en aquellos casos en que ambas opciones chocaban.
</p>

<p>
 Esto no quiere decir que las rutinas no sean óptimas: al contrario, se
han diseñado para que sean siempre lo más óptimas posible siempre y
cuando eso no implique hacerlas incomprensibles para el lector. Aún así,
 un programador avanzado podrá (y deberá) darles una pequeña vuelta de
tuerca adicional para exprimir ciclos de reloj a la rutina y hacerla aún
 un poco más rápida. Ese podría ser el objetivo del lector una vez
acabado el curso y de cara al diseño de un programa.
</p>

<p>
 Si un lector sin conocimientos de ensamblador, tras leer el curso,
acaba decidiendo programar un juego y utiliza o mejora las rutinas que
se presentan en este texto, podremos decir que el curso ha conseguido su
 objetivo.
</p>

<p>
 Espero que disfrutéis tanto leyéndolo como yo escribiéndolo.
</p>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="introduccion-y-conceptos-basicos">Introducción y conceptos básicos</h1>
<div class="level1">

<p>
<br>

</p>

</div>

<h2 id="los-limites-de-basic">Los límites de BASIC</h2>
<div class="level2">

<p>
 Todos aquel lector que haya programado en BASIC conocerá sin duda la
principal limitación de este sencillo lenguaje de alto nivel: es lento,
muy lento. A cambio de su sencillez pagamos una penalización enorme en
velocidad.
</p>

<p>
 BASIC es un lenguaje interpretado, lo que quiere decir que el Spectrum
(más bien el intérprete BASIC integrado en la ROM) tiene que leer línea a
 línea nuestro programa, decodificar lo que estamos diciendo en lenguaje
 BASIC, traducirlo a instrucciones comprensibles por el procesador y
ejecutarlo, todo ello en tiempo real.
</p>

<p>
 Eso implica que cada vez que se ejecuta el programa BASIC, para cada
línea del programa se ejecuta un proceso de lectura, decodificación,
traducción y ejecución. Este proceso es lento e implica que no sólo se
está ejecutando nuestro programa sino que debajo de él tenemos al
intérprete de BASIC realizando todas estas tareas y restándonos parte de
 la potencia de CPU del Spectrum, que ya de por sí no es especialmente
potente.
</p>

<p>
 No importa lo elegantemente optimizado que esté nuestro programa en
BASIC, el proceso de interpretación en sí hará que se ejecute con una
lentitud que no podemos salvar.
</p>

<p>
 BASIC tiene una serie de trucos más o menos conocidos para acelerar su
ejecución: escribir muchas instrucciones en una sóla línea BASIC, poner
las rutinas que más velocidad necesitan en las primeras líneas de
programa, reducir el nombre (en longitud) de las variables, etc. Pero al
 final llegamos a un punto en que no podemos mejorar nuestros programas
en cuanto a velocidad.
</p>

<p>
<br>

<img src="img/basic.gif" class="mediacenter" alt="Lenguaje BASIC y su intérprete"/>
<br>

</p>
<div style="text-align: center;"><em>El editor del intérprete de BASIC</em></div>
<p>
<br>

</p>

<p>
 Para muchos, el BASIC del Spectrum es un comienzo prácticamente
obligado para programar, pero si queremos realizar programas con la
calidad del software comercial no puede ser la herramienta a utilizar.
Dejando de lado que sigue siendo una herramienta muy útil para programar
 en el Spectrum, para muchos llega la hora de dar el siguiente paso.
</p>

<p>
<br>

</p>

</div>

<h2 id="alternativas-a-basic">Alternativas a BASIC</h2>
<div class="level2">

<p>
 Aparte de realizar programas para el intérprete de BASIC existen
múltiples alternativas para programar juegos y aplicaciones que expriman
 al máximo nuestra máquina:
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit4" id="subrutinas-en-ensamblador-dentro-de-un-programa-basic">Subrutinas en ensamblador dentro de un programa BASIC</h3>
<div class="level3">

<p>
Para empezar, como primera opción, podemos realizar pequeñas rutinas en
ensamblador y utilizarlas desde nuestros programas en BASIC. El lenguaje
 ensamblador se trata del lenguaje más cercano a lo que es el código
binario que entiende directamente un microprocesador. Es de bajo nivel,
es decir, está más lejos del lenguaje humano de lo que está BASIC, y a
la vez está muy cerca del lenguaje que entiende el microprocesador de
nuestro Spectrum.
</p>

<p>
En BASIC, una instrucción es traducida por el intérprete BASIC a una
serie más o menos larga de comandos en lenguaje máquina. Por ejemplo, <strong>10 PRINT “HOLA”</strong>,
 se traduce como una serie de comandos en lenguaje máquina que podrían
ser algo como “para cada una de las letras de la palabra HOLA, realiza
todas las operaciones necesarias para mostrar en pantalla todos los
píxels que forman dichas letras, actualizando la posición del cursor y
usando el color INK y PAPER actual”.
</p>

<p>
 Una instrucción BASIC equivale a una gran cantidad de instrucciones en código máquina.
</p>

<p>
 Por contra, una instrucción en lenguaje ensamblador equivale a una sóla
 instrucción en lenguaje máquina: hablamos directamente el lenguaje de
la máquina, sólo que en vez de hacerlo con unos y ceros, lo hacemos en
un lenguaje que tiene unas determinadas reglas de sintaxis y que el
“programa ensamblador” se encarga de traducir a código máquina. Es por
eso que programar en ensamblador es de “bajo nivel”: hablamos
directamente al nivel de la máquina, y por eso mismo los programas son
más complicados de escribir, de leer y de mantener que un programa en
BASIC, donde se habla un lenguaje más natural y que es traducido a lo
que la máquina entiende.
</p>
<pre class="code z80"><span class="co1">;</span>
<span class="co1">; Rutina de multiplicación en lenguaje ensamblador:</span>
<span class="co1">;</span>
<span class="co1">; MULTIPLICA: Multiplica DE*BC</span>
<span class="co1">;</span>
<span class="co1">;       Entrada:        DE: Multiplicando,  </span>
<span class="co1">;                       BC: Multiplicador</span>
<span class="co1">;       Salida:         HL: Resultado.</span>
&nbsp;
MULTIPLICA:
        <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">0</span>            <span class="co1">; HL = 0</span>
MULTI<span class="re1">01</span>:
        <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">DE</span>          <span class="co1">; Sumamos HL = HL + DE</span>
        <span class="kw1">DEC</span> <span class="kw2">BC</span>
        <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
        <span class="kw1">OR</span> <span class="kw2">C</span>
        <span class="kw1">JR</span> NZ, MULTI<span class="re1">01</span>      <span class="co1">; Lo repetimos BC veces</span>
        <span class="kw1">RET</span>                 <span class="co1">; Volver de la rutina</span></pre>

<p>
 La primera de las opciones que estamos tratando, la de programar
rutinas en ensamblador y utilizarlas después desde programas en BASIC
seguiría el siguiente ciclo de desarrollo:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Programamos una rutina en lenguaje
ensamblador que realice una función concreta: por ejemplo, dibujar el
personaje o enemigos de nuestro juego, borrar la pantalla, actualizar
los marcadores, etc.
</li>
<li> Ensamblamos la rutina con un
programa ensamblador y obtenemos un bloque de datos que contiene la
traducción del programa que hemos escrito a código máquina directamente
comprensible por el microprocesador.
</li>
<li> Cargamos en memoria el bloque de
datos de código máquina que acabamos de obtener mediante un LOAD “” CODE
 o POKEando cada byte de este bloque de datos en memoria.
</li>
<li> Programamos nuestro programa en
BASIC, y llamamos a la rutina que hemos programando cuando la
necesitemos utilizando RANDOMIZE USR hacia la dirección en que hemos
cargado o POKEado la rutina.
</li>
</ul>

<p>
<br>

</p>

<p>
 Es decir: realizamos una rutina o un conjunto de rutinas en ensamblador y mediante un <em>programa ensamblador</em>,
 traducimos el código ASM a código que entiende directamente la máquina
(código binario) y lo salvamos en cinta (o si es corto, anotamos sus
valores para meterlos en DATAs). Después, al inicio de nuestro programa,
 introducimos ese código binario en memoria de forma que lo podamos
llamar en cualquier momento desde BASIC con RANDOMIZE USR.
</p>

<p>
 Esto permite realizar rutinas importantes y críticas en lenguaje
ensamblador, y mantener el esqueleto del programa principal en BASIC.
Las rutinas creadas en ensamblador son llamadas desde BASIC con la
instrucción <strong>USR</strong> en aquellos puntos del programa en que las necesitemos.
</p>

<p>
 Más adelante en este capítulo veremos un ejemplo de cómo realizar el
ensamblado de una rutina en ensamblador, su carga en memoria y su
utilización desde un programa en BASIC.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit5" id="compilando-el-programa-basic-con-un-compilador">Compilando el programa BASIC con un compilador</h3>
<div class="level3">

<p>
 Aunque utilicemos rutinas en ensamblador llamadas desde BASIC,
seguiremos lastrados por la velocidad del intérprete y los tiempos de
ejecución de las partes del programa que no están escritas en
ensamblador.
</p>

<p>
 Como una segunda opción alternativa a la integración BASIC-ASM, tenemos
 la opción de utilizar un compilador de BASIC para compilar nuestros
programas y traducirlos a código máquina sin pasar por ningún intérprete
 de BASIC.
</p>

<p>
 Mediante un compilador de BASIC, a partir de un programa de código
fuente en BASIC obtenemos un ejecutable que podremos cargar directamente
 en memoria y ejecutarlo sin necesidad de utilizar el intérprete del
sistema.
</p>

<p>
 La labor de interpretación del código BASIC se hace igualmente, pero se
 hace antes, ya que en lugar de ejecutar, el resultado de la
interpretación se graba ya “traducido” en cinta. Un programa en BASIC
compilado y ejecutado de este modo es muchísimo más rápido que el mismo
programa ejecutado en el intérprete de BASIC del Spectrum.
</p>

<p>
 <strong>MCODER</strong>, uno de los compiladores nativos de BASIC más
conocidos, es una buena solución, y para muchos puede ser suficiente
para muchas de sus creaciones. Nuestra querida DINAMIC realizó sus
primeros juegos en BASIC con MCODER: hablamos de Babaliba, Saimazoom, o
la utilidad Artist.  MCODER tiene unas limitaciones que no tienen porqué
 ser especialmente problemáticas si las conocemos, las aceptamos, y
realizamos nuestros programas teniéndolas en cuenta. Por ejemplo, no
podemos utilizar vectores (creados con DIM en BASIC), y el manejo de
cadenas sufre algunos cambios de sintaxis, entre otros.
</p>

<p>
 La principal desventaja de MCODER es que es un compilador BASIC nativo,
 es decir, que es software para Spectrum que debemos ejecutar dentro de
un emulador o la máquina real lo que nos puede ralentizar a la hora de
programar.
</p>

<p>
 Una opción mucho más aconsejable es la de utilizar un compilador cruzado como <strong>ZX Basic Compiler</strong> (ZXB Compiler).
</p>

<p>
 Un <strong>compilador cruzado</strong> es un compilador que se ejecuta
en una plataforma diferente de la plataforma destino, pero genera código
 para ésta. Por ejemplo, podemos escribir nuestro programa BASIC en un
editor de textos en un PC (fuera del Spectrum), compilarlo con un
compilador cruzado, y obtener un binario con código máquina de Spectrum,
 listo para ser ejecutado en un emulador o en una máquina real. De esta
forma nos beneficiamos de las mayores capacidades de nuestra plataforma
de desarrollo (un PC) para conseguir código compilado para un Spectrum.
</p>

<p>
 En este caso, el compilador cruzado ZX Basic Compiler permite compilar
programas escritos en un dialecto BASIC estándar y genera un fichero de
instrucciones en ensamblador que podemos ensamblar con ensambladores
cruzados.
</p>

<p>
 El ciclo de desarrollo para la compilación de programas BASIC sería similar al siguiente:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Programamos nuestro juego en
lenguaje BASIC escribiendo el programa en un editor de textos estándar
de nuestra plataforma de desarrollo.
</li>
<li> Grabamos el código de nuestro programa como un fichero .BAS.
</li>
<li> Mediante el compilador cruzado,
compilamos el fichero .BAS y obtenemos un fichero binario de código
máquina, normalmente con un cargador BASIC incluído al principio del
mismo.
</li>
<li> Cargamos ese código máquina en nuestro Spectrum o emulador con un simple LOAD “”.
</li>
<li> El programa se carga y ejecuta como cualquier otro juego comercial.
</li>
</ul>

<p>
<br>

</p>

<p>
 Es una opción muy interesante para quien quiera seguir programando en
BASIC y obtener la potencia que el intérprete de BASIC le resta.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit6" id="programando-en-lenguaje-c">Programando en Lenguaje C</h3>
<div class="level3">

<p>
 Otra opción es la de aprender lenguaje C y realizar programas
íntegramente en C que son compilados (al igual que hace ZX Basic
Compiler) y trasladados a código binario que ejecutará el Spectrum.
</p>

<p>
 Podemos ver el lenguaje C (en el Spectrum) como una manera de realizar
programas bastante rápidos saltándonos las limitaciones de BASIC. No
llega a ser ensamblador, pero desde luego es mucho más rápido que BASIC
(y que BASIC compilado).
</p>

<p>
 C es un lenguaje muy potente y de alto nivel que genera un código
bastante óptimo y cuyos binarios tienen una velocidad de ejecución
muchísimo más cercana a la de programas en ensamblador que a la de
programas BASIC interpretados.
</p>

<p>
 El desarrollo de un juego o programa en C se realizaría de forma similar al caso de los compiladores BASIC:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Programamos nuestro juego en
lenguaje C escribiendo el programa en un editor de textos estándar de
nuestra plataforma de desarrollo.
</li>
<li> Grabamos el código de nuestro programa como un fichero .C .
</li>
<li> Mediante el compilador cruzado,
compilamos el fichero .C y obtenemos un fichero binario de código
máquina, normalmente con un cargador BASIC incluído al principio del
mismo.
</li>
<li> Cargamos ese código máquina en nuestro Spectrum o emulador con un simple LOAD “”.
</li>
<li> El programa se carga y ejecuta como cualquier otro juego comercial.
</li>
</ul>

<p>
<br>

</p>

<p>
 Para quien ya conozca el lenguaje C y se desenvuelva bien con él, utilizar un compilador cruzado como pueda serlo <strong>Z88DK</strong> será sin duda un gran opción. Programando en C se puede hacer prácticamente cualquier aplicación y un gran número de juegos.
</p>

<p>
 Además, se puede embeber código ensamblador dentro de las rutinas en C,
 con lo cual se puede decir que no estamos limitados por el lenguaje C a
 la hora de realizar tareas que requieren un control muy preciso de la
máquina.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit7" id="realizando-el-programa-completo-en-ensamblador">Realizando el programa completo en ensamblador</h3>
<div class="level3">

<p>
 Finalmente, la última opción: nos hemos decidido y queremos escribir
programas directamente en el lenguaje que comprende la máquina, ya que
queremos controlar todo lo que realiza el microprocesador.
</p>

<p>
 Con la opción que hemos elegido, escribiremos el código del programa íntegramente en <strong>lenguaje ensamblador</strong> (<em>assembler language</em> en inglés, o ASM para abreviar).
</p>

<p>
 Con BASIC compilado y con C, es el compilador quien transforma nuestros
 comandos en código máquina. En el lenguaje ensamblador, la
“compilación” (conocida como proceso de ensamblado) del programa en
código máquina es una mera traducción ya que cada instrucción en
ensamblador se traduce en una instrucción en código máquina, como
veremos más adelante.
</p>

<p>
 Para programar en ensamblador seguiremos el siguiente proceso:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Programamos nuestro juego en
lenguaje ensamblador escribiendo el programa en un editor de textos
estándar de nuestra plataforma de desarrollo.
</li>
<li> Grabamos el código de nuestro programa como un fichero .ASM .
</li>
<li> Mediante el ensamblador cruzado,
ensamblamos el fichero .ASM y obtenemos un fichero binario de código
máquina, normalmente con un cargador BASIC incluído al principio del
mismo.
</li>
<li> Cargamos ese código máquina en nuestro Spectrum o emulador con un simple LOAD “”.
</li>
<li> El programa se carga y ejecuta como cualquier otro juego comercial.
</li>
</ul>

<p>
<br>

</p>

<p>
 Es importante destacar que el desarrollo de un programa en ASM requiere
 mucho más tiempo, un mejor diseño y muchos más conocimientos del
hardware que utilizar cualquier otro lenguaje. Un programa en BASIC
sencillo puede tener 1000 líneas, pero el mismo programa en ASM puede
tener perfectamente 10000, 50000, o muchas más líneas.
</p>

<p>
 En ensamblador no tenemos funciones de alto nivel que realicen
determinadas tareas por nosotros: no existe PRINT para imprimir cosas
por pantalla, si queremos imprimir texto tenemos que imprimir una a una
las letras, calculando posiciones, píxeles, colores, y escribiendo en la
 videomemoria nosotros mismos. Podemos apoyarnos en una serie de rutinas
 que hay en la ROM del Spectrum (que son las que utiliza BASIC), pero en
 general, para la mayoría de las tareas, lo tendremos que hacer todo
manualmente.
</p>

<p>
 Un ejemplo muy sencillo: en BASIC podemos multiplicar 2 números de
forma muy simple con el operador “*”. En ensamblador, no existe un
comando para multiplicar 2 números. No existe dicho comando porque el
micro Z80 tiene definida la operación de suma (ADD) y la de resta (SUB),
 por ejemplo, pero no tiene ninguna instrucción para multiplicar o
dividir. Y si queremos multiplicar 2 números, tendremos que hacer una
rutina en ensamblador que lo haga (como la rutina que hemos visto en el
apartado anterior) y llamarla cada vez que necesitemos realizar una
multiplicación.
</p>

<p>
 Es posible que el anterior párrafo parezca demasiado “duro” para los
programadores acostumbrados a BASIC y que lo anteriormente explicado
parezca un panorama desolador, pero esa es la realidad con el
ensamblador: cada instrucción en ensamblador se corresponde con una
instrucción de la CPU Z80. Si se quiere hacer algo más complejo que lo
que permite directamente la CPU, nos lo hemos de construir nosotros
mismos a base de utilizar esas instrucciones. Una multiplicación se
puede realizar como una serie de sumas, por ejemplo, como hemos visto en
 la rutina MULT del apartado anterior.
</p>

<p>
 Descrito visualmente, en BASIC para construir una casa te dan paredes
completas, ventanas, escaleras y puertas, y combinándolos te construyes
la casa. En ASM, por contra, lo que te dan es un martillo, clavos, un
cincel, madera y roca, y a partir de eso tienes que construir tú todos
los elementos del programa.
</p>

<p>
 Obviamente, no tendremos que escribir miles de rutinas antes de poder
programar cualquier cosa: existen rutinas ya disponibles que podemos
aprovechar. En Internet, en revistas Microhobby, en libros de
programación de Z80, en la ROM del Spectrum, encontraremos rutinas
listas para utilizar y que nos permitirán multiplicar, dividir, imprimir
 cadenas de texto, y muchas otras cosas.
</p>

<p>
 Además, cada nueva rutina que programemos podremos reutilizarla en
futuros programas, por lo que el inicio es duro pero a partir de cierto
momento dispondremos de bibliotecas de rutinas que podremos integrar en
nuestros programas para reducir el tiempo de desarrollo.
</p>

<p>
<br>

</p>

</div>

<h2 id="por-que-aprender-asm-ensamblador-de-z80">Por qué aprender ASM (ensamblador) de Z80</h2>
<div class="level2">

<p>
 Está claro que cada lenguaje tiene su campo de aplicación, y utilizar
BASIC para hacer una herramienta interactiva para el usuario (con mucho
tratamiento de textos, o de gráficos) o bien para hacer un programa
basado en texto, o una pequeña base de datos o similar puede ser
suficiente para muchos casos.
</p>

<p>
Donde realmente tiene interés la programación en lenguaje ensamblador es
 en la creación de determinadas rutinas, programas o juegos orientados a
 exprimir el hardware de la máquina, es decir: aquellos programas
orientados a escribir rápidamente gráficos en pantalla, reproducir
música, o controlar el teclado con gran precisión. Nos estamos
refiriendo principalmente a los juegos.
</p>

<p>
 Ensamblador es el lenguaje ideal para programar juegos que requieran
gran velocidad de ejecución. Como veremos en el futuro, dibujar en
pantalla se reduce a escribir valores en memoria (en una zona concreta
de la memoria). Leer del teclado se reduce a leer los valores que hay en
 determinados puertos de entrada/salida de la CPU, y la reproducción de
música se realiza mediante escrituras en otros puertos. Para realizar
esto se requiere mucha sincronización y un control total de la máquina, y
 esto es lo que nos ofrece ensamblador.
</p>

<p>
 Este curso está diseñado con los siguientes objetivos en mente:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Conocer el hardware del Spectrum, y cómo funciona internamente.
</li>
<li> Conocer el juego de instrucciones del microprocesador Z80 que lleva el Spectrum.
</li>
<li> Saber realizar programas en lenguaje ASM (ensamblador) del Z80.
</li>
<li> Aprender a realizar pequeñas rutinas
 que hagan tareas determinadas y que sean después reutilizables desde
otros programas o desde BASIC.
</li>
<li> Con la práctica, ser capaces de escribir un juego o programa entero en ASM.
</li>
</ul>

<p>
<br>

</p>

<p>
 Proporcionaremos al lector todos los conceptos necesarios para
conseguir estos objetivos. El resto lo aportará el tiempo que nos
impliquemos y la experiencia que vayamos adoptando programando en
ensamblador. No se puede escribir un juego completo en ensamblador la
primera vez que uno se acerca a este lenguaje, pero sí que puede uno
realizar una pequeña rutina que haga una tarea concreta en un pequeño
programa BASIC. La segunda vez, en lugar de una pequeña rutina hará un
conjunto de rutinas para un juego mayor, y, con la práctica, el dominio
del lenguaje se puede convertir para muchos en una manera diferente o
mejor de programar: directamente en ensamblador.
</p>

<p>
Queremos destacar un pequeño detalle: programar en ensamblador no es
fácil. Este curso deberían seguirlo aquellas personas con ciertos
conocimientos sobre programación que se sientan preparadas para dar el
paso al lenguaje ensamblador. Si tienes conocimientos de hardware, sabes
 cómo funciona un microprocesador, has realizado uno o más programas o
juegos en BASIC u otros lenguajes o sabes lo que es binario, decimal y
hexadecimal (si sabes cualquiera de esas cosas), entonces no te costará
nada seguir este curso. Si, por el contrario, no has programado nunca, y
 todo lo que hemos hablado no te suena de nada, necesitarás mucha
voluntad y consultar muchos otros textos externos (o al menos aplicarte
mucho) para poder seguirnos.
</p>

<p>
Un requerimiento casi imprescindible es que el lector debe de conocer
fundamentos básicos del sistema de codificación decimal, hexadecimal y
binario. Como ya sabéis, nosotros expresamos los números en base
decimal, pero esos mismos números se pueden expresar también en
hexadecimal, o en binario. Son diferentes formas de representar el mismo
 número, y para distinguir unas formas de otras se colocan prefijos o
sufijos que nos indican la base utilizada. A lo largo del curso se
utilizarán las siguientes convenciones de prefijo de formato:
</p>
<div class="table-responsive sectionedit9"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Prefijo </th><th class="col1"> Tipo de dato </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> $ </td><td class="col1"> Valor hexadecimal </td>
	</tr>
	<tr class="row2">
		<td class="col0"> % </td><td class="col1"> Valor en binario </td>
	</tr>
	<tr class="row3">
		<td class="col0"> Ninguno </td><td class="col1"> Valor en decimal </td>
	</tr>
</tbody></table></div>

<p>
Para seguir el curso es muy importante que el lector sepa distinguir
unas bases de codificación de otras y que sepa (con más o menos
facilidad) pasar números de una base a otra. Quien no sepa esto lo puede
 hacer con práctica, conforme va siguiendo el curso.
</p>
<div class="table-responsive sectionedit10"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> DECIMAL </th><th class="col1"> HEXADECIMAL </th><th class="col2"> BINARIO </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 64d ó 64 </td><td class="col1"> $40 ó 40h </td><td class="col2"> %01000000 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 255d ó 255 </td><td class="col1"> $FF ó FFh </td><td class="col2"> %11111111 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 3d ó 3 </td><td class="col1"> $03 ó 03h </td><td class="col2"> %00000011 </td>
	</tr>
</tbody></table></div>

<p>
 Y tras este preámbulo, podemos pasar a lo que es el curso en sí.
</p>

<p>
<br>

</p>

</div>

<h2 id="el-codigo-maquina-del-microprocesador-z80">El código máquina del microprocesador Z80</h2>
<div class="level2">

<p>
 El microprocesador Z80 (Z80A en el caso del Spectrum) es un pequeño
chip de 40 pines de conexión, cada uno de las cuales está conectada a
diferentes señales. Uno de los pines es la alimentación eléctrica, otro
la conexión al reloj/cristal de 3.50Mhz, 8 pines suponen el bus de datos
 y 16 el bus de direcciones, etc.
</p>

<p>
<br>

<img src="img/z80a.jpg" class="mediacenter" alt="| Z80A "/>
<br>

</p>

<p>
 Estas “patillas” de datos y direcciones están físicamente conectadas a
través de pistas eléctricas a la memoria, el teclado, el cassette, etc.
Utilizando las patillas de direcciones el procesador selecciona
“posiciones de memoria” en la memoria, y recibe las instrucciones de los
 programas a través de las 8 señales del bus de datos.
</p>

<p>
 Una señal (el estado de cada una de las patillas del micro en un
instante concreto) puede tener 2 estados: sin tensión eléctrica (0
Voltios físicos, o señal lógica “0”), o con tensión eléctrica (5 Voltios
 físicos, o señal lógica “1”). El procesador recibe a través de las 8
patillas del bus de datos 8 señales que conforman una ristra de unos y
ceros como puedan serlo 01000100 o 11001100, por ejemplo.
</p>

<p>
 Los diseñadores del Z80 le otorgaron mediante circuitos en su interior
una serie de registros de almacenamiento (A, B, C, D, E, F, H, L, etc.)
que pueden alojar números, y la capacidad de ejecutar una serie de
instrucciones (sumar, restar, comparar, etc.) entre ellos (y también
entre ellos y otras posiciones de memoria).
</p>

<p>
 Cada posible conjunto de señales entre 00000000 y 11111111 se
corresponde con una de estas posibles operaciones mediante un
“diccionario interno” que le dice al Z80 qué debe de hacer según la
instrucción que se le está solicitando.
</p>

<p>
 Cuando el microprocesador obtiene de la memoria la siguiente
instrucción del programa a ejecutar y obtiene, por ejemplo, un conjunto
de señales “01010000”, el Z80 sabe que tiene que sumar el contenido de
su registro interno A con el del registro interno B, y dejar el
resultado en A.
</p>

<p>
 Es decir, entiende un número binario de 8 digítos que recibe en forma
de señales binarias como una instrucción concreta a ejecutar. Este valor
 numérico es lo que se conoce como un “<strong>Opcode</strong>” o “<strong>código de operación</strong>”, ya que un <strong>código</strong> (01010000) le indica al procesador qué <strong>operación</strong> ejecutar (A = A + B).
</p>

<p>
 Un programa en código máquina no es más que una ristra de código
binarios de 8 dígitos (de instrucciones) que le indican al Z80 qué
operaciones ejecutar en un orden concreto. El procesador leerá una a una
 la ristra de códigos binarios que forman el programa y ejecutará cada
una de las instrucciones con que se corresponde cada código.
</p>

<p>
 El Z80 utiliza un registro interno especial llamado PC (Program Counter
 o Contador de Programa) para saber cuál es la dirección de la
instrucción actual con la que está trabajando y lo incrementa tras cada
instrucción para poder seguir el flujo del programa.
</p>

<p>
 Cuando arrancamos nuestro Spectrum, todos los registros del Z80 (A, B,
C, PC, etc) valen 0, por lo que el Spectrum empieza a leer desde la
memoria en la posición 0, instrucción tras instrucción, incrementando el
 valor de PC tras ejecutar cada una de ellas. Este programa “inicial”
que ejecuta nuestro Spectrum es nada más y nada menos que el intérprete
de BASIC, escrito para Sinclair por ingenierios de Nine Tiles
Information Handlind Ltd.
</p>

<p>
 Este código máquina con todo el programa que supone el intérprete BASIC
 está almacenado como ristra de instrucciones en un chip del Spectrum
llamado ROM cuyo contenido no se borra al apagar el ordenador.
</p>

<p>
 Programar en código máquina no es fácil, puesto que no es inmediata la
correspondencia entre una ristra de unos y ceros y la instrucción que
ejecutará el procesador. Una vez escrito un programa, es también muy
complicado de depurar en busca de errores, puesto que todo lo que
tenemos son miles o decenas de miles de ristras de 8 dígitos binarios.
</p>

<p>
 Veamos algunas instrucciones en código máquina y el efecto que tienen en el procesador cuando le pedimos ejecutarlas:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit12"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Instrucción en hexadecimal </th><th class="col1"> Señales en bus de datos (binario) </th><th class="col2"> Instrucción ejecutada </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> $09 </td><td class="col1"> 00001001 </td><td class="col2"> HL = HL + BC </td>
	</tr>
	<tr class="row2">
		<td class="col0"> $50 </td><td class="col1"> 01010000 </td><td class="col2"> A = A + B </td>
	</tr>
	<tr class="row3">
		<td class="col0"> $3C </td><td class="col1"> 00111100 </td><td class="col2"> Incrementar A  →  A = A + 1 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> $3D </td><td class="col1"> 00111101 </td><td class="col2"> Decrementar A  → A = A - 1 </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 El conjunto completo de operaciones que puede realizar el procesador
representado por los opcodes asociados a los mismos se conoce como <strong>juego de instrucciones del procesador</strong>.
</p>

<p>
 Recordar todos los códigos de operación del juego de instrucciones es
muy complejo y la programación en base a utilizar ristras de números es
prácticamente inmanejable. Debido a esta complejidad y dificultad, nunca
 se programa directamente en código máquina sino que se realiza en <strong>lenguaje ensamblador</strong>.
</p>

<p>
<br>

</p>

</div>

<h2 id="el-lenguaje-ensamblador">El lenguaje ensamblador</h2>
<div class="level2">

<p>
 El lenguaje ensamblador es una “versión humana” del lenguaje máquina en
 la que asociamos un “nombre” (técnicamente conocido como mnenónico) a
cada instrucción de 8 bits del procesador.
</p>

<p>
 Así, en lugar de definir la suma de A = A + B como “<strong>001010000</strong>”, la definimos como “<strong>ADD A, B</strong>”,
 lo cual es mucho más legible e intuitivo a la hora de programar y
depurar y sigue siendo igual de compacto, existiendo una correspondencia
 exacta de 1 instrucción ASM = 1 instrucción en código máquina.
</p>

<p>
 De esta forma, podemos programar utilizando un conjunto de
instrucciones en lenguaje “humano”, que no llegan a ser tan
especializadas y de tanto alto nivel como en BASIC ya que el objetivo
del lenguaje ensamblador es dotar de un nombre “legible” a cada
microinstrucción disponible en el procesador.
</p>

<p>
 Al programar en lenguaje ensamblador, lo hacemos pues en este lenguaje
humano con instrucciones como “ADD A, B”, “LD A, 20” o “CALL subrutina”.
 El problema es que el microprocesador no entiende este lenguaje humano,
 ya que él sólo entiende las señales de 8 dígitos binarios que lee de la
 memoria.
</p>

<p>
 Para solucionar esto se necesita un programa llamado “<strong>programa ensamblador</strong>” o simplemente <strong>ensamblador</strong> o <strong>assembler</strong>,
 que lee nuestros programas en lenguaje ensamblador y convierte cada
instrucción en ensamblador en la correspondiente instrucción código
máquina. El resultado de la conversión de cada instrucción se va
almacenando de forma consecutiva para acabar obteniendo un bloque de
datos que contiene la traducción a código máquina de todo el programa
que hemos solicitado ensamblar.
</p>

<p>
 Para realizar este proceso, el programa ensamblador se vale de una
tabla de ensamblado que relaciona cada instrucción en ensamblador con la
 instrucción en código máquina que realiza la misma acción. Así, cuando
lee en nuestro programa “ADD A, B”, lo traduce por un “001010000” que es
 lo que realmente almacena en el programa en código máquina resultante.
</p>

<p>
 En resumen: como resultado de un proceso de ensamblado, el ensamblador
convierte un programa en este “lenguaje ensamblador” a una ristra de
dígitos binarios en memoria que se corresponden, en código máquina, con
las instrucciones que nosotros hemos solicitado realizar al procesador
en ensamblador.
</p>

<p>
 Una vez el programa está totalmente acabado (asumiendo que no tenga
fallos y no sea necesario depurarlo) sólo es necesario realizar una vez
el proceso de ensamblado. Por ejemplo, los programadores de un juego
ensamblarán el listado del mismo, obtendrán una ristra de dígitos
binarios en memoria, y la salvarán en cinta. Lo que se distribuye a los
usuarios es el programa en código máquina que el Spectrum cargará en
memoria y ejecutará.
</p>

<p>
 El proceso de ensamblado puede ser manual: nosotros podemos utilizar
una tabla de traducción instrucciones → opcodes y traducir manualmente
cada instrucción en el opcode correspondiente. No obstante, lo más
normal es utilizar un programa ensamblador, que automatiza este proceso
por nosotros.
</p>

<p>
 En este curso, programaremos nuestras rutinas o programas en lenguaje
ensamblador en un fichero de texto con extensión .asm, y con un programa
 ensamblador cruzado lo traduciremos al código binario que entiende la
CPU del Spectrum. Ese código binario puede ser ejecutado, instrucción a
instrucción, por el Z80, realizando las tareas que nosotros le
encomendemos en nuestro programa.
</p>

<p>
 En este capítulo no vamos a ver la sintaxis e instrucciones disponibles
 en el ensamblador del microprocesador Z80: eso será algo que haremos
capítulo a capítulo del curso. Por ahora nos debe bastar conocer que el
lenguaje ensamblador es mucho más limitado en cuanto a instrucciones que
 BASIC, y que, a base de pequeñas piezas, debemos montar nuestro
programa entero, que será sin duda mucho más rápido en cuanto a
ejecución.
</p>

<p>
 Como las piezas de construcción son tan pequeñas, para hacer tareas que
 son muy sencillas en BASIC, en ensamblador necesitaremos muchas líneas
de programa, es por eso que los programas en ensamblador en general
requieren más tiempo de desarrollo y se vuelven más complicados de
mantener (de realizar cambios, modificaciones) y de leer conforme
crecen. Debido a esto cobra especial importancia hacer un diseño en
papel de los bloques del programa (y seguirlo) antes de programar una
sóla línea del mismo. También se hacen especialmente importantes los
comentarios que introduzcamos en nuestro código, ya que clarificarán su
lectura en el futuro. El diseño es CLAVE y VITAL a la hora de programar:
 sólo se debe implementar lo que está diseñado previamente, y cualquier
modificación de las especificaciones debe resultar en una modificación
del diseño.
</p>

<p>
Así pues, resumiendo, lo que haremos a lo largo de este curso será
aprender la arquitectura interna del Spectrum, su funcionamiento a nivel
 de CPU, y los fundamentos de su lenguaje ensamblador, con el objetivo
de programar rutinas que integraremos en nuestros programas BASIC, o
bien programas completos en ensamblador que serán totalmente
independientes del lenguaje BASIC.
</p>

<p>
<br>

</p>

</div>

<h2 id="ejemplointegrar-codigo-maquina-en-programas-basic">Ejemplo: Integrar código máquina en programas BASIC</h2>
<div class="level2">

<p>
Supongamos que sabemos ensamblador y queremos mejorar la velocidad de un
 programa BASIC utilizando una rutina en código máquina. El lector se
preguntará: “¿cómo podemos hacer esto?”.
</p>

<p>
La integración de rutinas en código máquina dentro de programas BASIC se realiza a grandes rasgos de la siguiente forma:
</p>

<p>
 Primero escribimos nuestra rutina en ensamblador, por ejemplo una
rutina que realiza un borrado de la pantalla mucho más rápidamente que
realizarlo en BASIC, o una rutina de impresión de Sprites o gráficos,
etc.
</p>

<p>
 Una vez escrito el programa o la rutina, la ensamblamos (de la manera
que sea: manualmente o mediante un programa ensamblador) y obtenemos en
lugar del código ASM una serie de valores numéricos que representan los
códigos de instrucción en código máquina que se corresponden con nuestro
 listado ASM.
</p>

<p>
 La siguiente figura muestra a título de ejemplo parte de una tabla de
ensamblado manual, como la que utilizaban en la década de los 80 y 90
los programadores que no podían comprar un software ensamblador:
</p>

<p>
<br>

<img src="img/tablamanual.gif" class="mediacenter" alt="Parte de una tabla de ensamblado manual"/>
<br>

</p>

<p>
 Utilizando la anterior tabla, o bien un programa ensamblador, transformamos nuestro programa ensamblador en código máquina.
</p>

<p>
 Tras el proceso de ensamblado y la obtención del código máquina,
nuestro programa en BASIC debe cargar esos valores en memoria (mediante
LOAD “” CODE o mediante instrucciones POKE) y después saltar a la
dirección donde hemos POKEADO la rutina para ejecutarla.
</p>

<p>
 Veamos un ejemplo de todo esto. Supongamos el siguiente programa en
BASIC, que está pensado para rellenar toda la pantalla con un patrón de
píxeles determinado:
</p>
<pre class="code basic">10 FOR n=16384 TO 23295
20 POKE n, 162
30 NEXT n</pre>

<p>
 Lo que hace este programa en BASIC es escribir un valor (el 162)
directamente en la memoria de vídeo (en próximas entregas veremos qué
significa esto) y, en resumen, lo que consigue es dibujar en pantalla
con unos colores determinados. Si ejecutamos el programa en BASIC
veremos lo siguiente:
</p>

<p>
<br>

<img src="img/1_ejemplo1.gif" class="mediacenter" alt="Salida del programa BASIC de ejemplo"/>
<br>

</p>

<p>
 Tras teclear y ejecutar el programa, si medimos el tiempo necesario
para “pintar” toda la pantalla obtendremos que tarda aproximadamente 1
minuto y 15 segundos.
</p>

<p>
A continuación vamos a ver el mismo programa escrito en lenguaje ensamblador:
</p>
<pre class="code z80"><span class="co1">; Listado 2: Rellenado de pantalla</span>
  ORG <span class="nu0">4</span><span class="re1">0000</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">62</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">69</span><span class="re1">11</span>
  <span class="kw1">LDIR</span>
  <span class="kw1">RET</span></pre>

<p>
 Si ensamblamos este programa con un programa ensamblador y lo
ejecutamos, veremos que tarda menos de 1 segundo en ejecutar la misma
tarea. Es en ejemplos tan sencillos como este donde podemos ver la
diferencia de velocidad entre BASIC y ASM.
</p>

<p>
Supongamos que ensamblamos a mano el listado anterior, mediante una
tabla de conversión de Instrucciones ASM a Códigos de Operación
(opcodes) del Z80, ensamblando manualmente (tenemos una tabla de
conversión en el mismo manual del +2, por ejemplo).
</p>

<p>
 Ensamblar a mano, como ya hemos dicho, consiste en escribir el programa
 y después traducirlo a códigos de operación consultando una tabla que
nos dé el código correspondiente a cada instrucción en ensamblador.
</p>

<p>
 Así pues, ensamblamos manualmente la siguiente rutina:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">62</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">69</span><span class="re1">11</span>
  <span class="kw1">LDIR</span>
  <span class="kw1">RET</span></pre>

<p>
 Tras el ensamblado del código ensamblador obtendremos el siguiente código máquina (una rutina de 15 bytes de tamaño):
</p>
<pre class="code">  $21, $00, $40, $3e, $a2, $77, $11, $01, $40, $01, $ff, $1a, $ed, $b0, $c9</pre>

<p>
O, en base decimal:
</p>
<pre class="code">  33, 0, 64, 62, 162, 119, 17, 1, 64, 1, 255, 26, 237, 176, 201</pre>

<p>
 Como ya hemos visto en la definición de “código máquina”, esta extraña
ristra de bytes para nosotros incomprensible tiene un total significado
para nuestro Spectrum: cuando él encuentra, por ejemplo, los bytes “62,
162”, sabe que eso quiere decir “LD A, 162”; cuando encuentra el byte
“201”, sabe que tiene que ejecutar un “RET”, y así con todas las demás
instrucciones.
</p>

<p>
 Un detalle: si no queremos ensamblar a mano podemos ensamblar el
programa con un ensamblador como “PASMO” o “z80asm” y después obtener
esos números abriendo el fichero .bin resultando con un editor
hexadecimal (que no de texto).
</p>

<p>
 A continuación vamos a BASIC y tecleamos el siguiente programa:
</p>
<pre class="code basic">10 CLEAR 39999
20 DATA 33, 0, 64, 62, 162, 119, 17, 1, 64, 1, 255, 26, 237, 176, 201
30 FOR n=0 TO 14
40 READ I
50 POKE (40000+n), I
60 NEXT n</pre>

<p>
 Este programa guarda a partir de la dirección 40000 los diferentes
bytes del DATA (usando POKE), almacenando así nuestra rutina en memoria.
</p>

<p>
 Tras esto ejecutamos un RANDOMIZE USR 40000 lo que provoca la ejecución
 de la rutina posicionada en la dirección 40000, que justo es la rutina
que hemos ensamblado a mano y pokeado mediante el programa en BASIC.
</p>

<p>
Lo que hemos hecho en el programa BASIC es:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Con el CLEAR nos aseguramos de que
tenemos libre la memoria desde 40000 hacia arriba (hacemos que BASIC se
situe por debajo de esa memoria).
</li>
<li> La línea DATA contiene el código máquina de nuestra rutina.
</li>
<li> Con el bucle FOR hemos POKEado la rutina en memoria a partir de la dirección 40000 (desde 40000 a 40015).
</li>
<li> El RANDOMIZE USR 40000 salta la
ejecución del Z80 a la dirección 40000, donde está nuestra rutina.
Recordad que nuestra rutina acaba con un RET, que es una instrucción de
retorno que finaliza la rutina y realiza una “vuelta” al BASIC.
</li>
</ul>

<p>
<br>

</p>

<p>
 Siguiendo este mismo procedimiento podemos generar todas las rutinas
que necesitemos y ensamblarlas, obteniendo ristras de código máquina que
 meteremos en DATAs y pokearemos en memoria.
</p>

<p>
 Otra opción, para evitar los DATAs y los POKEs, es grabar en cinta el
fichero BIN resultante del ensamblado (convertido a TAP) tras nuestro
programa en BASIC, y realizar en nuestro programa un <strong>LOAD “” CODE DIRECCION_DESTINO</strong> de forma que carguemos todo el código binario ensamblado en memoria.
</p>

<p>
 Podemos así realizar muchas rutinas en un mismo fichero ASM y
ensamblarlas y cargarlas en memoria de una sola vez. Tras tenerlas en
memoria, tan sólo necesitaremos saber la dirección de inicio de cada una
 de las rutinas para llamarlas con el <strong>RANDOMIZE USR DIRECCION_RUTINA</strong> correspondiente en cualquier momento de nuestro programa BASIC.
</p>

<p>
Para hacer esto, ese fichero ASM podría tener una forma como la siguiente:
</p>
<pre class="code z80"><span class="co1">; La rutina 1</span>
  ORG <span class="nu0">4</span><span class="re1">0000</span>
rutina<span class="re1">1</span>:
  <span class="br0">(</span>...<span class="br0">)</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">; La rutina 2</span>
  ORG <span class="nu0">4</span><span class="re1">1000</span>
rutina2:
  <span class="br0">(</span>...<span class="br0">)</span>
  <span class="kw1">RET</span></pre>

<p>
 También podemos ensamblarlas por separado y después cargarlas con varios LOAD “” CODE.
</p>

<p>
 Hay que tener mucho cuidado a la hora de teclear los DATAs (y de
ensamblar) si lo hacemos a mano, porque equivocarnos en un sólo número
cambiaría totalmente el significado del programa y no haría lo que
debería haber hecho el programa correctamente pokeado en memoria.
</p>

<p>
 Un detalle más avanzado sobre ejecutar rutinas desde BASIC es el hecho
de que podamos necesitar pasar parámetros a una rutina, o recibir un
valor de retorno desde una rutina.
</p>

<p>
 Pasar parámetros a una rutina significa indicarle a la rutina uno o más
 valores para que haga algo con ellos. Por ejemplo, si tenemos una
rutina que borra la pantalla con un determinado patrón o color, podría
ser interesante poder pasarle a la rutina el valor a escribir en memoria
 (el patrón). Esto se puede hacer de muchas formas: la más sencilla
sería utilizar una posición libre de memoria para escribir el patrón, y
que la rutina lea de ella. Por ejemplo, si cargamos nuestro código
máquina en la dirección 40000 y consecutivas, podemos por ejemplo usar
la dirección 50000 para escribir uno (o más) parámetros para las
rutinas. Un ejemplo:
</p>
<pre class="code z80">   <span class="co1">; Listado 3: Rellenado de pantalla</span>
   <span class="co1">; recibiendo el patron como parametro.</span>
   ORG <span class="nu0">4</span><span class="re1">0000</span>
&nbsp;
   <span class="co1">; En vez de 162, ponemos en A lo que hay en la</span>
   <span class="co1">; dirección de memoria 50000</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">5</span><span class="re1">0000</span><span class="br0">)</span>
&nbsp;
   <span class="co1">; El resto del programa es igual:</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">69</span><span class="re1">11</span>
   <span class="kw1">LDIR</span>
   <span class="kw1">RET</span></pre>

<p>
Nuestro programa en BASIC a la hora de llamar a esta rutina (una vez ensamblada y pokeada en memoria) haría:
</p>
<pre class="code basic">   POKE 50000, 162
   RANDOMIZE USR 40000</pre>

<p>
Este código produciría la misma ejecución que el ejemplo anterior,
porque como parámetro estamos pasando el valor 162, pero podríamos
llamar de nuevo a la misma función en cualquier otro punto de nuestro
programa pasando otro parámetro diferente a la misma, cambiando el valor
 de la dirección 50000 de la memoria. Esto rellenaría la pantalla con un
 patrón que deseemos, pudiendo ser éste diferente del utilizado en el
anterior ejemplo, simplemente variando el valor pokeado en la dirección
50000 (el parámetro de la rutina).
</p>

<p>
En el caso de necesitar más de un parámetro, podemos usar direcciones
consecutivas de memoria: en una rutina de dibujado de sprites, podemos
pasar la X en la dirección 50000, la Y en la 50001, y en la 50002 y
50003 la dirección en memoria (2 bytes porque las direcciones de memoria
 son de 16 bits) donde tenemos el Sprite a dibujar, por ejemplo. Todo
eso lo veremos con más detalle en posteriores capítulos. En este ejemplo
 hemos utilizado la dirección 50000, pero lo normal es utilizar
direcciones concretas y reservadas dentro del propio programa ensamblado
 para asegurar que no hay colisión con otras rutinas que pueda haber o
podamos necesitar instalar en la dirección 50000.
</p>

<p>
 Además de recibir parámetros, puede sernos interesante la posibilidad
de devolver a BASIC el resultado de la ejecución de nuestro programa.
Por ejemplo, supongamos que realizamos una rutina en ensamblador que
hace un determinado cálculo y debe devolver, tras todo el proceso, un
valor. Ese valor lo queremos asignar a una variable de nuestro programa
BASIC para continuar trabajando con él.
</p>

<p>
 Un ejemplo: imaginemos que realizamos una rutina que calcula el
factorial de un número de una manera mucho más rapida que su equivalente
 en BASIC. Para devolver el valor a BASIC en nuestra rutina ASM, una vez
 realizados los cálculos, debemos dejarlo dentro del registro BC justo
antes de hacer el RET. Una vez programada la rutina y pokeada, la
llamamos mediante:
</p>
<pre class="code basic"> LET VALOR=USR 40000</pre>

<p>
Con esto la variable de BASIC VALOR contendrá la salida de nuestra
rutina (concretamente, el valor del registro BC antes de ejecutar el
RET). Las rutinas sólo pueden devolver un valor (el registro BC), aunque
 siempre podemos (dentro de nuestra rutina BASIC) escribir valores en
direcciones de memoria y leerlos después con PEEK dentro de BASIC (al
igual que hacemos para pasar parámetros).
</p>

<p>
<br>

</p>

</div>

<h2 id="codigo-maquina-en-microhobby">Código máquina en MICROHOBBY</h2>
<div class="level2">

<p>
 Lo que hemos visto hasta ahora es que podemos programar pequeñas
rutinas y llamarlas desde programas en BASIC fácilmente. Todavía no
hemos aprendido nada del lenguaje en sí mismo, pero se han asentado
muchos de los conceptos necesarios para entenderlo en las próximas
entregas del curso.
</p>

<p>
En realidad, muchos de nosotros hemos introducido código máquina en
nuestros Spectrums sin saberlo, cuando tecleabamos los listados de
programa que venían en la fabulosa revista Microhobby. Muchos de los
programas nos hacían introducir código máquina, aunque no lo pareciera.
</p>

<p>
 Algunas veces lo hacíamos en forma de DATAs, integrados en el programa
BASIC que estábamos tecleando, pero otras lo hacíamos mediante el famoso
 <strong>Cargador Universal de Código Máquina</strong> (CUCM).
</p>

<p>
 Para que os hagáis una idea de qué era el CUCM de Microhobby, no era
más que un programa en el cual tecleabamos los códigos binarios de
rutinas ASM ensambladas previamente. Se tecleaba una larga línea de
números en hexadecimal agrupados juntos (ver la siguiente figura), y
cada 10 bytes o pares de dígitos se debía introducir un número a modo de
 CRC que aseguraba que los 10 dígitos (20 caracteres) anteriores habían
sido introducidos correctamente. Este CRC podía no ser más que la suma
de todos los valores anteriores, para asegurarse de que no habíamos
tecleado incorrectamente el listado.
</p>

<p>
<br>

<img src="img/cucm.jpg" class="mediacenter" alt="Ejemplo de listado para el CUCM de MH"/>
<br>

</p>

<p>
 Al acabar la introducción en todo el listado en el CUCM, se nos daba la
 opción de grabarlo. Al grabarlo indicábamos el tamaño de la rutina en
bytes y la dirección donde la ibamos a alojar en memoria (en el ejemplo
de la captura, la rutina se alojaría en la dirección 53000 y tenía 115
bytes de tamaño). El CUCM todo lo que hacía era un simple:
</p>
<pre class="code basic">  SAVE "DATOS.BIN" CODE 53000, 115</pre>

<p>
 Esto grababa el bloque de código máquina en cinta (justo tras nuestro
programa en BASIC), de forma que el juego en algún momento cargaba esta
rutina con LOAD “” CODE, y podía utilizarla mediante un RANDOMIZE USR
53000.
</p>

<p>
<br>

</p>

</div>

<h2 id="pasmoensamblador-cruzado">PASMO: ensamblador cruzado</h2>
<div class="level2">

<p>
El lector se preguntará: “Ensamblar programas a mano es muy costoso y
complejo, ¿cómo vamos a ensamblar los listados que veamos a lo largo del
 curso, o los que yo realice para ir practicando o para que sean mis
propias rutinas o programas?”.
</p>

<p>
 Sencillo: lo haremos con pasmo, un programa ensamblador cruzado. Pasmo
nos permitirá programar en un PC o MAC (utilizando nuestro editor de
textos habitual), y después ensamblar ese fichero .asm que hemos
realizado, obteniendo un fichero .BIN (o directamente un .TAP).
</p>

<p>
 Los programadores “originales” en la época del Spectrum tenían que
utilizar programas ensamblador nativos como MONS y GENS para todo el
proceso de desarrollo. Estos programas (que corren sobre el Spectrum)
implicaban teclear los programas en el teclado del Spectrum, grabarlos
en cinta, ensamblar y grabar el resultado en cinta, etc. Actualmente es
mucho más cómodo usar ensambladores cruzados como los que usaremos en
nuestro curso.
</p>

<p>
Nuestra opción preferente como ensamblador cruzado es Pasmo. Pasmo es un
 ensamblador cruzado, opensource y multiplataforma. Con Pasmo podremos
programar en nuestro PC, grabar un fichero ASM y ensamblarlo
cómodamente, sin cintas de por medio. Tras todo el proceso de
desarrollo, podremos llevar el programa resultante a una cinta (o disco)
 y ejecutarlo por lo tanto en un Spectrum real, pero lo que es el
proceso de desarrollo se realiza en un PC, con toda la comodidad que eso
 conlleva.
</p>

<p>
 Pasmo en su versión para Windows/DOS es un simple ejecutable
(pasmo.exe) acompañado de ficheros README de información. Podemos mover
el fichero pasmo.exe a cualquier directorio que esté en el PATH o
directamente ensamblar programas (siempre desde la línea de comandos o
CMD, no directamente mediante “doble click” al ejecutable) en el
directorio en el que lo tengamos copiado.
</p>

<p>
 La versión para Linux viene en formato código fuente (y se compila con
un simple make) y su binario “pasmo” lo podemos copiar, por ejemplo, en
/usr/local/bin.
</p>

<p>
<br>

<br>

<strong>Generando código binario para programas BASIC</strong>
<br>

</p>

<p>
 Iremos viendo el uso de pasmo conforme lo vayamos utilizando, pero a
título de ejemplo, veamos cómo se ensamblaría el programa que vimos en
el apartado de integración de BASIC y ASM. Primero tecleamos el programa
 en un fichero de texto y después pasmo para ensamblarlo:
</p>
<pre class="code">  pasmo ejemplo1.asm ejemplo1.bin</pre>

<p>
 Como resultado del proceso de ensamblado obtendremos un fichero .bin
que contiene el código máquina que podremos utilizar directamente en los
 DATAs de nuestro programa en BASIC.
</p>

<p>
 El fichero .bin es binario, por lo que para obtener los valores
numéricos que introducir en los datas debemos utilizar un editor
hexadecimal o alguna utilidad como “hexdump” de Linux:
</p>
<pre class="code">  $ hexdump -C ejemplo1.bin
  00000000  21 00 40 3e a2 77 11 01 40 01 ff 1a ed b0 c9</pre>

<p>
 Ahí tenemos los datos listos para convertirlos a decimal y pasarlos a
sentencias DATA. Si el código es largo y no queremos teclear en DATAs la
 rutina, podemos convertir el BIN en un fichero TAP ensamblando el
programa mediante:
</p>
<pre class="code">  pasmo --tap ejemplo1.asm ejemplo1.tap</pre>

<p>
 Este fichero tap contendrá ahora un tap con el código binario compilado
 tal y como si lo hubieras introducido en memoria y grabado con SAVE “”
CODE, para ser cargado posteriormente en nuestro programa BASIC con LOAD
 “” CODE.
</p>

<p>
 Esta segunda opción (LOAD “” CODE) es la más cómoda, pues nos evita el
pokeado de valores en memoria, pero implica ubicar el bloque de datos a
cargar con LOAD “” CODE a continuación del programa en BASIC dentro del
fichero .tap.
</p>

<p>
 Para realizar esta concatenación escribimos las rutinas en un fichero
.ASM y las compilamos con “pasmo --tap fichero.asm bloque_cm.tap”.
Después, escribimos nuestro programa en BASIC y lo salvamos en cinta,
obteniendo otro fichero tap (programa_basic.tap).
</p>

<p>
 Tras esto tenemos que crear un TAP o un TZX que contenga primero el
bloque BASIC y después el bloque de código máquina, de forma que el
bloque BASIC podrá cargar el bloque de código máquina con un LOAD “”
CODE DIRECCION, TAMANYO_BLOQUE_CM.
</p>

<p>
 Podemos realizar esto con herramientas de gestión de ficheros TAP/TZX
o, sin necesidad de utilizar emuladores o herramientas adicionales,
mediante concatenación de ficheros:
</p>
<ul class="fix-media-list-overlap">
<li> Linux: cat programa_basic.tap bloque_cm.tap &gt; programa_completo.tap
</li>
<li> Windows: copy /b programa_basic.tap +bloque_cm.tap programa_completo.tap
</li>
</ul>

<p>
<br>

<br>

<strong>Generando un binario desde un programa íntegramente en ensamblador</strong>
<br>

</p>

<p>
 Si estamos realizando un programa completo en ensamblador, sin ninguna
parte en BASIC, deberemos  compilar el programa mediante “<strong>pasmo --tapbas fichero.asm fichero.tap</strong>”.
 La opción --tapbas añade una cabecera BASIC que carga el bloque código
máquina en la dirección indicada por la sentencia ORG del programa en
ensamblador (por ejemplo, 40000).
</p>

<p>
 El fichero resultante del ensamblado será un TAP sin autoejecución
listo para cargar en el Spectrum y que deberemos lanzar con un RANDOMIZE
 USR 40000.
</p>

<p>
 Finalmente, si agregamos una sentencia END a nuestro programa y le
agregamos la dirección de inicio (ORG) del mismo, en ese caso “pasmo
--tapbas” agregará el RANDOMIZE USR correspondiente al listado BASIC y el
 programa se autoejecutará al ser cargado.
</p>
<pre class="code z80"><span class="co1">; Pruebas de ensamblador para z80-asm</span>
<span class="co1">; Santiago Romero aka NoP/Compiler</span>
&nbsp;
&nbsp;
 ORG <span class="nu0">4</span><span class="re1">0000</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">62</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">69</span><span class="re1">11</span>
   <span class="kw1">LDIR</span>
   <span class="kw1">RET</span>
 END <span class="nu0">4</span><span class="re1">0000</span>            <span class="co1">; Pasmo añade RANDOMIZE USR 40000</span></pre>

<p>
 El resultado del ensamblado de este ejemplo con --tapbas será directamente ejecutable en un Spectrum con un simple LOAD “”.
</p>

<p>
<br>

</p>

</div>

<h2 id="en-resumen">En resumen</h2>
<div class="level2">

<p>
En esta entrega hemos definido las bases del curso de ensamblador de
Z80, comenzando por las limitaciones de BASIC y la necesidad de conocer
un lenguaje más potente y rápido. Hemos visto qué aspecto tiene el
código en ensamblador (aunque todavía no conozcamos la sintaxis) y, muy
importante, hemos visto cómo se integra este código en ensamblador
dentro de programas en BASIC.
</p>

<p>
 Por último, hemos conocido una utilidad (pasmo) que nos permitirá, a lo
 largo del curso, ensamblar todos los programas que realicemos, así como
 probarlos en un emulador o integrar rutinas en nuestros programas
BASIC.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/01_ejemplo1.bas">Ejemplo de rellenado de pantalla en BASIC (fuente)</a>
</li>
<li><a href="src/01_ejemplo1-bas.tap">Ejemplo de rellenado de pantalla en BASIC (tap)</a>
</li>
<li><a href="src/01_ejemplo1.asm">Ejemplo de rellenado de pantalla en ASM (fuente)</a>
</li>
<li><a href="src/01_ejemplo1-asm.tap">Ejemplo de rellenado de pantalla en ASM (tap)</a>
</li>
<li><a href="src/01_ejemplo1.bin">Código binario del ejemplo ejemplo1.asm</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt26.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt26.html">Capítulo 26 del manual de +3</a>.</div>
</li>
<li><div class="li"> <a href="http://zxbcompiler.speccy.org/" class="urlextern" title="http://zxbcompiler.speccy.org/">ZX Basic Compiler</a>.</div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">Pasmo</a>.</div>
</li>
<li><div class="li"> <a href="http://aspectrum.sourceforge.net/" class="urlextern" title="http://aspectrum.sourceforge.net/">Aspectrum</a>.</div>
</li>
<li><div class="li"> <a href="http://www-physics.mps.ohio-state.edu/~prewett/hexedit/" class="urlextern" title="http://www-physics.mps.ohio-state.edu/~prewett/hexedit/">Hexedit</a>.</div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="arquitectura-y-funcionamiento-del-spectrum">Arquitectura y funcionamiento del Spectrum</h1>
<div class="level1">

<p>
<br>

</p>

</div>

<h2 id="la-arquitectura-del-spectrum">La Arquitectura del Spectrum</h2>
<div class="level2">

<p>
 Antes de comenzar a programar en lenguaje ensamblador para Spectrum
necesitamos conocer su arquitectura: ¿qué hay dentro de nuestro pequeño
ordenador y cómo funciona internamente? ¿Cómo procesa las instrucciones
código máquina?
</p>

<p>
 En BASIC muchas veces podemos olvidarnos de los detalles a nivel de
hardware (precisamente ese es el objetivo de un lenguaje de Alto Nivel
como es BASIC), pero en ensamblador no: al escribir los programas en un
lenguaje con traducción directa al código máquina es imprescindible
conocer cómo funciona internamente el procesador al cual le estamos
dando instrucciones.
</p>

<p>
 En este capítulo veremos una visión simplificada de la arquitectura
hardware del Spectrum pero que en el fondo es todo lo que necesitaremos
para el desarrollo de la mayoría de programas. Bajar hasta el nivel de
la electrónica en sí sería una labor para otro tipo de cursos y tendría
su principal aplicación en el desarrollo de hardware más que de
software.
</p>

<p>
 Comencemos con un esquema de cómo es internamente nuestro Spectrum a
nivel de hardware, y después comentaremos uno a uno los elementos que lo
 componen:
</p>

<p>
<br>

<img src="img/esquema_zx.gif" class="mediacenter" alt="Esquema del hardware de un ZX Spectrum"/>
<br>

</p>

<p>
En un vistazo general, podemos ver que el microprocesador Z80 se conecta
 mediante los puertos de entrada/salida de la CPU a los periféricos
externos (teclado, cassette y altavoz de audio), pudiendo leer el estado
 de los mismos (leer del teclado, leer del cassette) y escribir en ellos
 (escribir en el altavoz para reproducir sonido, escribir en el
cassette) por medio de estas conexiones conocidas como “I/O Ports”.
</p>

<p>
Al mismo tiempo, los Buses de Datos y de Direcciones conectan al
microprocesador con la memoria. Esta conexión es la que permite que el
Z80 pueda leer y escribir en cualquier posición de la RAM, y leer datos
de la ROM (que, juntas, conforman la totalidad de la memoria
disponible).
</p>

<p>
Cuando encendemos el Spectrum, el microprocesador Z80 se dedicada a leer
 valores de la memoria, decodificar a qué instrucción se corresponde el
valor que acaba de leer, y ejecutarlo, continuando el proceso con la
siguiente posición de memoria. Así pues, empezando por la posición 0000,
 el Spectrum comienza a leer instrucciones y a ejecutarlas, una a una.
</p>

<p>
Al comienzo de la memoria, desde la posición 0 hasta la 16384 (16KB) tenemos mapeada la ROM (<em>Read Only Memory</em>
 o memoria de sólo lectura) del Spectrum, que contiene instrucciones de
programa preprogramadas y que no podemos modificar: contiene las
funciones básicas del “sistema operativo” del Spectrum, incluyendo el
intérprete de BASIC.
</p>

<p>
Después de estos primeros 16KB de memoria (la ROM) viene el resto de la memoria disponible: la memoria RAM (<em>Random Access Memory</em>
 o memoria de acceso aleatorio). Esta es la parte de la memoria en la
que nuestros programas pueden trabajar: en ella alojaremos el código del
 programa, las variables del mismo, etc.
</p>

<p>
Por otro lado, el microprocesador Z80 tiene una serie de registros
internos con los que trabaja y que son los que manipula y utiliza para
ejecutar las instrucciones almacenadas en la memoria.
</p>

<p>
Por último, el puerto de expansión del Spectrum permite conectar nuevos
periféricos (como el adaptador de Joystick Kempston o el Interface 1 ó
2) directamente a las patillas de la CPU, ampliando las funcionalidades
del ordenador.
</p>

<p>
Veamos más detalladamente los diferentes componentes de la arquitectura del Spectrum, y cómo funcionan.
</p>

<p>
<br>

</p>

</div>

<h2 id="el-microprocesador-z80">El microprocesador Z80</h2>
<div class="level2">

<p>
Como podemos distinguir en el esquema, el cerebro de nuestro Spectrum es
 un microprocesador Zilog Z80A a 3,54Mhz. Un microprocesador es un
circuito integrado que consta (principalmente) de registros,
microcódigo, puertos de entrada/salida, un bus de datos y uno de
direcciones.
</p>

<p>
<br>

<img src="img/z80.jpg" class="mediacenter" alt="Imagen de un C.I. Z80 de Zilog"/>
<br>

</p>

<p>
Los registros son contenedores de valores numéricos que residen dentro
de la misma CPU. En el caso del Z80, tiene 2 juegos de registros (los
registros en uso, y los registros alternativos o <em>shadow</em>).
</p>

<p>
 Cada uno de los 2 juegos de registro está formado por las mismas “piezas”: Tenemos por un lado registros de un byte como <strong>A, F, B, C, D, E, H, L, I</strong> y <strong>R</strong>, y registros de dos bytes como <strong>IX, IY, SP</strong> y <strong>PC</strong>.
 Los registros de un byte pueden contener valores de 8 bits, es decir,
de 0 a 255, y los de 2 bytes pueden contener valores de 16 bits
(0-65535).
</p>

<p>
 Algunos de los registros que hemos nombrado pueden agruparse para
formar registros de mayor tamaño y así poder realizar operaciones que
requieran valores mayores que los que se pueden representar con 8 bits.
Por ejemplo, <strong>H</strong> y <strong>L</strong> pueden formar juntos el registro <strong>HL</strong> con el que realizar operaciones de 16 bits concretas.
</p>

<p>
 Veremos los registros en detalle en el próximo capítulo (así como el
segundo juego de registros disponible), pero podemos hacernos a la idea
de que los registros son simples variables de 8 ó 16 bits que
utilizaremos en nuestros programas en ensamblador. Así, podremos cargar
un valor en un registro (<strong>LD A, 25</strong>), sumar un registro con otro (<strong>ADD A, B</strong>), activar o desactivar determinados bits de un registro (<strong>SET 7, A</strong>), etc.
</p>

<p>
<br>

<img src="img/debugger1.gif" class="mediacenter" alt="Parte del debugger de FUSE mostrando los registros de la CPU"/>
<br>

</p>

<p>
El juego de registros es todo lo que tenemos (aparte de la memoria) para
 realizar operaciones en nuestro programa: siempre que estemos operando
con datos o utilizando variables, tendrá que ser por fuerza un registro,
 o una posición de memoria que usemos como variable. Por ejemplo,
podemos escribir el siguiente programa en ensamblador, que sumaría dos
números:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">10</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">2</span><span class="re1">0</span>
  <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span></pre>

<p>
El anterior programa, una vez ensamblado y ejecutado en un Z80, vendría a decir:
</p>
<ul class="fix-media-list-overlap">
<li> Carga en el registro A el valor “10”.
</li>
<li class="level2"> Carga en el registro B el valor “20”.
</li>
<li class="level2"> Suma el valor del registro A con el del registro B y deja el resultado en el registro A (A=A+B).
</li>
</ul>

<p>
Tras ejecutar el anterior programa en un Z80, el contenido del registro A sería 30 (10+20).
</p>

<p>
Cuando tratemos las diferentes instrucciones del Z80 veremos en más
detalle los registros, su tamaño, cómo se agrupan, y de qué forma
podemos usarlos para operar entre ellos y realizar nuestras rutinas o
programas.
</p>

<p>
Finalmente, existe un registro especial del procesador llamado PC
(Program Counter, o Contador de Programa). Este registro es de 16 bits
(puede contener un valor entre 0 y 65535), y su utilidad es la de
apuntar a la dirección de memoria de la siguiente instrucción a
ejecutar. Así, cuando arrancamos nuestro Spectrum, el registro PC vale
$0000, con lo que lo primero que se ejecuta en el Spectrum es el código
que hay en $0000. Una vez leído y ejecutado ese primer código de
instrucción, se incrementa PC para apuntar al siguiente, y así
continuadamente.
</p>

<p>
Los programas se ejecutan linealmente mediante un ciclo basado en: Leer
instrucción en la dirección de memoria apuntada por PC, incrementar
registro PC, ejecutar instrucción. Posteriormente veremos más acerca de
PC.
</p>

<p>
Ya hemos visto qué son los registros del microprocesador. Ahora bien, en
 el ejemplo anterior, ¿cómo sabe el microprocesador qué tiene que hacer
cuando se encuentra un comando “LD” o “ADD”? Esto es tarea del
microcódigo. El microcódigo del microprocesador es una definición de qué
 tiene que hacer el microprocesador ante cada una de las posibles
órdenes que nosotros le demos.
</p>

<p>
Por ejemplo, cuando el microprocesador está ejecutando nuestro anterior
programa y lee los valores numéricos correspondientes a “LD A, 10”, el
Z80 utiliza el microcódigo encargado de mover el valor 10 al registro A.
 Este microcódigo no es más que una secuencia de señales hardware y
cambios de estados electrónicos cuyo resultado será, exactamente,
activar y desactivar BITs en el registro A (que no es más que una serie
de 8 biestables electrónicos que pueden estar a 0 voltios o a 5 voltios
cada uno de ellos, representando el estado de los 8 bits del registro
A). Lo mismo ocurrirá cuando se lea la instrucción “LD B, 20”, sólo que
se ejecutará otra porción de microcódigo que lo que hará será modificar
el registro B.
</p>

<p>
Este microcódigo está dentro del microprocesador porque sus diseñadores
implementaron todas y cada una de las operaciones que puede hacer el
Z80. Cuando pedimos meter un valor en un registro, leer el valor de un
registro, sumar un registro con otro, escribir el valor de un registro
en una dirección de memoria, saltar a otra parte del programa, etc, para
 cada una de esas situaciones, hay un microcódigo (implementado mediante
 hardware) que realiza esa tarea.
</p>

<p>
Nosotros no tendremos que preocuparnos pués de cómo hace el Z80 las
cosas internamente a nivel de microcódigo, aunque es bueno que conozcáis
 cómo llega el Spectrum a ejecutar nuestros comandos: gracias al
microcódigo.
</p>

<p>
<br>

</p>

</div>

<h2 id="puertos-de-entradasalida">Puertos de entrada/salida</h2>
<div class="level2">

<p>
 Si examinamos físicamente un microprocesador Z80A, podremos distinguir
40 patillas o pines de conexión. Además de los pines que se utilizan
para alimentar el Z80 desde la fuente de alimentación, existen otra
serie de patillas para “Puertos de Entrada/Salida” y “Bus de datos y de
direcciones”. Éstas se utilizan para la conexión del microprocesador con
 el resto de elementos del ordenador.
</p>

<p>
<br>

<img src="img/pinout.gif" class="mediacenter" alt="Las 40 patillas del microprocesador Z80. donde vemos el bus de direcciones (A0 a A15) y el bus de datos (D0 a D7), que se conectan a los puertos de entrada/salida y a la memoria"/>
<br>

</p>

<p>
Los registros del microprocesador y el microcódigo son hardware interno
del procesador, y ninguna de las patillas que podemos ver en la imagen
anterior nos comunica con ellos. Es el procesador (internamente) quien
lee/modifica los registros o quien ejecuta microcódigo cuando nosotros
se lo decimos mediante las instrucciones de nuestro programa.
</p>

<p>
Pero nuestro procesador, como hemos dicho, necesita conectarse con
elementos del exterior, entre ellos (y casi exclusivamente en el caso
del Spectrum) tenemos la memoria, el teclado, el altavoz y la unidad de
cinta.
</p>

<p>
Visto de un modo muy simple, el Z80 puede acceder a través de una serie
de patillas a múltiples elementos externos. Esos elementos se conectan a
 la CPU Z80 a través de las patillas de “Buses de datos y direcciones”
(que podemos leer en los puertos de Entrada/Salida). Una vez conectados
(la conexión se realiza físicamente a nivel de hardware, con pistas en
la placa base del Spectrum), el microprocesador Z80 puede leer los
valores que el dispositivo pone en esas pistas, o puede escribir valores
 en esas pistas para que el dispositivo los utilice.
</p>

<p>
 Supongamos el ejemplo del teclado: un teclado es (a un nivel muy
simple) una matriz de pulsadores. Al final de toda esa matriz de
pulsadores, lo que acabamos teniendo es un valor numérico cuyos bits nos
 indican la teclas pulsadas. Pues bien, esos bits es lo que el mismo
teclado pone en los “cables” que lo unen con el Z80, concretamente en el
 bus de datos.
</p>

<p>
 El teclado se conecta a la CPU mediante conexión a los buses de
direcciones y de datos y gracias a esto el microprocesador (y nuestro
programa) puede leer en todo momento su estado (y saber qué teclas están
 pulsadas y cuales no) leyendo del puerto correspondiente.
</p>

<p>
<br>

<img src="img/teclado.jpg" class="mediacenter" alt="Matriz de teclado del Spectrum y conexiones al Z80"/>
<br>

</p>

<p>
 Así, en nuestros programas podemos leer el estado del teclado mediante (por ejemplo):
</p>
<pre class="code basic">5  REM Mostrando el estado de la fila 1-5 del teclado
10 LET puerto=63486
20 LET V=IN puerto: PRINT AT 20,0; V ; "  " : GO TO 20</pre>

<p>
 Este ejemplo lee (en un bucle infinito) una de las diferentes filas del
 teclado, mediante la lectura del puerto 63486 (F7FEh) con la
instrucción de lectura de puertos de BASIC “IN”. El estado de las 5
teclas que van desde el “1” hasta el “5” del teclado del Spectrum está
conectado a 5 “hilos” de los 8 que llegan al puerto 63486 del micro Z80.

</p>

<p>
 Si no hay ninguna tecla pulsada, el estado de estos 5 bits será un “1”
lógico, que a nivel de hardware serán 5 Voltios. Cuando se pulsa una
tecla, el teclado pone a “0” lógico (a 0 voltios) el “hilo”
correspondiente de esos 8, y nosotros podemos conocer el estado de la
tecla leyendo dicho puerto y mirando el bit en cuestión.
</p>

<p>
 Al ejecutar el ejemplo BASIC anterior, veremos que la pulsación de la
tecla “1” cambiará el valor que aparece en pantalla. Si pasamos los
diferentes valores que aparecen a binario y nos fijamos en el estado de
los 5 últimos bits, nos daremos cuenta como al pulsar y soltar las
diferentes teclas del 1 al 5 estaremos variando esos bits entre 0 (al
pulsarlas) y 1 (al liberarlas). Los 3 bits más altos del byte debemos
ignorarlos en nuestro ejemplo, ya que no tienen relación con el teclado.
</p>

<p>
 En resumen: Si no hay ninguna tecla pulsada, los 5 bits más bajos del
byte que hay en el puerto estarán todos a 1, mientras que si se pulsa
alguna de las teclas del 1 al 5, el bit correspondiente a dicha tecla
pasará a estado 0. Nosotros podemos leer el estado del puerto y saber,
mirando los unos y los ceros, si las teclas están pulsadas o no. Esto es
 posible gracias a la interconexión del teclado (un periférico) y el
microprocesador a través del bus de direcciones (el identificador que
permite al microprocesador saber qué puerto queremos leer) y de datos
(el lugar donde recogemos el valor puesto por el periférico).
</p>

<p>
<br>

<img src="img/leer_teclado.gif" class="mediacenter" alt="Pulsando &quot;1&quot;, ponemos a 0 el bit 0, pasando de 191 a 190"/>
<br>

</p>

<p>
 Así, leyendo del puerto 63486 obtenemos un byte cuyos 8 bits tienen
como significado el estado de cada una de las teclas de la semifila del
“1” al “5”.
</p>
<div class="table-responsive sectionedit5"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bits </th><th class="col1"> D7 </th><th class="col2"> D6 </th><th class="col3"> D5 </th><th class="col4"> D4 </th><th class="col5"> D3 </th><th class="col6"> D2 </th><th class="col7"> D1 </th><th class="col8"> D0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<th class="col0"> Teclas </th><td class="col1"> XX </td><td class="col2"> XX </td><td class="col3"> XX </td><td class="col4"> “5” </td><td class="col5"> “4” </td><td class="col6"> “3” </td><td class="col7"> “2” </td><td class="col8"> “1” </td>
	</tr>
</tbody></table></div>

<p>
 Los bits D7 a D5 no nos interesan en el caso del teclado (por ejemplo,
D6 tiene relación con la unidad de cinta), mientras que los bits de D5 a
 D0 son bits de teclas (0=pulsada, 1=no pulsada).
</p>

<p>
 Tenemos pues el teclado dividido en filas de teclas y disponemos de una
 serie de puertos para leer el estado de cada una de ellas:
</p>
<div class="table-responsive sectionedit6"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Puerto </th><th class="col1"> Teclas </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 65278d (FEFEh) </td><td class="col1"> de CAPS SHIFT a V </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 65022d (FDFEh) </td><td class="col1"> de A a G </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 64510d (FBFEh) </td><td class="col1"> de Q a T </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 63486d (F7FEh) </td><td class="col1"> de 1 a 5 (and JOYSTICK 1) </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 61438d (EFFEh) </td><td class="col1"> de 6 a 0 (and JOYSTICK 2) </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 57342d (DFFEh) </td><td class="col1"> de P a Y </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 49150d (BFFEh) </td><td class="col1"> de ENTER a H </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 32766d (7FFEh) </td><td class="col1"> de (space) a B </td>
	</tr>
</tbody></table></div>

<p>
A la hora de leer estos puertos, el bit menos significativo (D0) siempre
 hace referencia a la tecla más alejada del centro del teclado (“1” en
nuestro ejemplo), mientras que el más significativo de los 5 (D5) lo
hace a la tecla más cercana al centro del teclado.
</p>

<p>
En ensamblador también hay disponibles 2 instrucciones para leer el
contenido de un puerto de Entrada/Salida y para escribir un valor en un
puerto determinado, las instrucciones se llaman igual que en BASIC: IN y
 OUT:
</p>
<pre class="code z80"> <span class="co1">; Cargamos en BC el valor del puerto a leer</span>
 <span class="kw1">LD</span> <span class="kw2">BC</span>, F7FEh
&nbsp;
 <span class="co1">; Leemos en el registro A el valor del puerto</span>
 <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span></pre>

<p>
Hemos mostrado el ejemplo del teclado, aunque estamos todavía empezando y
 puede haber sido algo complicado de entender, por diferentes motivos:
</p>
<ul class="fix-media-list-overlap">
<li> El primero, explicar con un ejemplo
práctico qué son los puertos de E/S y cómo están conectados a nivel de
hardware con el microprocesador. Como habéis visto, del teclado salen
una serie de “hilos” o pistas de circuito impreso que van directamente
al Z80A (en el caso del Spectrum, a través de la ULA), mediante conexión
 a sus diferentes buses y puertos.
</li>
<li class="level2"> Mostrar cómo nosotros podemos, en
cualquier momento, leer y escribir en los puertos de E/S. Con esto
conseguimos comunicarnos con los periféricos externos. En este caso,
podemos leer del teclado (o escribir o leer del cassette, o en el
altavoz) con simples operaciones de lectura y escritura IN y OUT.
</li>
</ul>

<p>
El lector debería extraer una conclusión adicional del ejemplo del
teclado: la gran diferencia de proceso que hay entre programar en
ensamblador y programar en BASIC. Supongamos que nos interesa leer el
estado del teclado para saber si unas determinadas teclas están pulsadas
 o no. Para esto, en ensamblador (aunque esto también podemos hacerlo en
 BASIC) leemos directamente el estado del teclado con un par de simples
instrucciones (LD + IN).
</p>

<p>
 En BASIC, por contra, al usar INKEY$ estamos esperando la ejecución de
un código que, además de leer TODAS las filas del teclado (no sólo
aquellas de las teclas que nos interesen), realiza una conversión de
todos los bits pulsados o no pulsados mediante una tabla para al final
proporcionarnos el código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> de la tecla pulsada.
</p>

<p>
 Lo que son varias instrucciones simples en ASM, en BASIC se realiza
mediante cientos de instrucciones en ensamblador que nos acaban dando la
 última tecla pulsada. Es por eso que el intérprete BASIC es tan lento:
cada operación BASIC son decenas, cientos o miles de instrucciones en
ensamblador que ni vemos ni controlamos. Programando directamente en
ASM, el microprocesador hará EXCLUSIVAMENTE lo que nosotros le digamos
que haga. He aquí la “mágica” diferencia de velocidad entre ambos
lenguajes.
</p>

<p>
Podéis encontrar más información sobre los puertos de Entrada y Salida
en el capítulo 8 sección 32 del manual del +2A y +3, que tenéis
disponible online en World Of Spectrum.
</p>

<p>
<br>

</p>

</div>

<h2 id="memoria">Memoria</h2>
<div class="level2">

<p>
Al igual que en el caso de los puertos de entrada/salida, nuestro
microprocesador está también conectado a los diferentes chips de memoria
 (hablamos en plural porque, físicamente, hay más de uno). La conexión
se realiza siguiendo unas normas definidas por los ingenieros de
Sinclair, de tal forma que la memoria se mapea linealmente. ¿Qué quiere
decir esto? Que aunque tengamos varios chips de memoria, vemos la
memoria como una gran y única memoria de 64KB (en el caso del modelo de
48KB).
</p>

<p>
El Spectrum 48KB básico (48KB de RAM y 16KB de ROM) tiene disponibles
64KB de memoria, es decir, 65536 bytes a los cuales podemos acceder.
Podemos pensar en esta memoria como un gran baúl con 65536 cajones, uno
encima de otro. El primer cajón es el cajón 0 (posición de memoria 0),
el segundo el cajón 1 (posición de memoria 1), y así hasta el cajón
65535 (posición de memoria 65535).
</p>

<p>
Nuestro Spectrum no puede tener más de 65536 cajones porque el “bus de
direcciones” del microprocesador Z80 es de 16 bits, es decir, las líneas
 que conectan al microprocesador con la memoria sólo permiten 16
“conexiones”; lo que nos da la posibilidad de acceder a 2 elevado a 16
bytes de memoria, exactamente 65536 bytes.
</p>

<p>
<br>

<img src="img/memoria.gif" class="mediacenter" alt="Aspecto de nuestras 65536 celdillas de memoria"/>
<br>

</p>

<p>
Cada uno de estos cajones (más técnicamente, “celdillas de memoria” o
“posiciones de memoria”) puede contener un número de 8 bits, con un
valor, por tanto, entre 0 y 255. Esto es así porque el “bus de datos”
del microprocesador Z80 es de 8 bits, lo que implica que “sólo hay 8
conexiones” entre la salida de datos de la memoria y nuestro procesador.
</p>

<p>
El microprocesador Z80 puede acceder a cualquier posición de memoria
tanto para leer como para escribir. Internamente, cuando le pedimos al
microprocesador que meta en el registro A el contenido de la celdilla de
 memoria $1234, mediante una instrucción de ensamblador “<strong>LD A, ($1234)</strong>”  lo que hace el microprocesador internamente es:
</p>

<p>
(Nota: el operador () (paréntesis abierto y cerrado) en ensamblador significa acceso a memoria).
</p>

<p>
<br>

<br>

<strong>Ejecución de: LD A, ($1234)</strong>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> $1234 en binario es 00010010
00110100, de modo que el Z80 coge las 16 líneas que conectan al
microprocesador con la memoria y las pone a esos estados (0 = 0 voltios,
 1 = 5 voltios).
</li>
<li class="level2"> A continuación, el microprocesador
utiliza una conexión especial que le conecta con la memoria para
indicarle qué operación quiere realizar. Poniendo al valor apropiado la
línea de control que le comunica con la memoria, el Z80 informa al chip
de memoria de que quiere realizar una operación de lectura.
</li>
<li class="level2"> La memoria recibe la señal de “deseo
 leer un dato” por esta señal de control, y mira el bus de direcciones
que le conecta con el Spectrum. Mirando el estado de las 16 líneas
encuentra el “00010010 00110100” ($1234). Con eso, la memoria sabe a qué
 “casilla” o “cajón” quiere acceder el microprocesador.
</li>
<li class="level2"> La memoria lee el valor de la
celdilla de memoria $1234 (supongamos que contiene, por ejemplo $0F, que
 es 00001111 en binario) y cambia las 8 conexiones del Bus de Datos para
 que contengan 00001111 (4 “líneas” las pone a 0 voltios, y las otras 4 a
 5 voltios).
</li>
<li class="level2"> El Z80 consulta el bus de datos y ve el estado de las líneas, con lo que lee el “00001111” o 0Fh.
</li>
<li class="level2"> El Z80 coloca en el registro A el valor $0F.
</li>
</ul>

<p>
<br>

</p>

<p>
El procedimiento para escribir es similar, salvo que la línea de control
 entre el Z80 y la memoria en lugar de indicar “lectura” indica
“escritura”, y que es el Z80 quien pone en el bus de datos el valor que
quiere escribir en la celdilla indicada en el bus de direcciones:
</p>

<p>
<br>

<br>

<strong>Ejecución de: LD ($1234), A</strong>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Supongamos que A contiene el valor
15 ($0F): el Z80 coloca las líneas del bus de datos a los valores
00001111 (donde cada 0 es 0 Voltios y cada 1 son 5 Voltios).
</li>
<li class="level2"> El Z80 coloca las líneas del bus de direcciones a 00010010 00110100 ($1234).
</li>
<li class="level2"> A continuación, el microprocesador
pone las línea de control de Lectura y Escritura de memoria a tal valor
que la memoria sabe que el Z80 le pide una operación de escritura.
</li>
<li class="level2"> La memoria recibe la señal de “deseo
 escribir un dato”, y mira el bus de direcciones que le conecta con el
Spectrum. Obteniendo el estado de las 16 líneas encuentra el “00010010
00110100” ($1234). Con eso, la memoria sabe a qué “casilla” o “cajón”
quiere acceder el microprocesador para escribir.
</li>
<li class="level2"> La memoria lee el valor del bus de datos para saber qué dato tiene que escribir y obtiene el valor $0F.
</li>
<li class="level2"> La memoria escribe en su celdilla número $1234 el valor $0F.
</li>
</ul>

<p>
Estas son las 2 operaciones básicas que el Z80 puede realizar con la
memoria: leer una posición de memoria y escribir en una posición de
memoria. Nosotros no tenemos que preocuparnos de ninguna de las señales
hardware necesarias para realizar lecturas y escrituras, de eso se
encarga el microprocesador. Para nosotros, a nivel de ensamblador, nos
bastará con ejecutar “LD A, ($1234)” o “LD ($1234), A”, por ejemplo.
</p>

<p>
Las celdillas de memoria desde la nº 0 a la 16383 están ocupadas por un
chip que es la ROM del Spectrum. Este chip es de sólo lectura (ROM =
Read Only Memory), lo cual quiere decir que si intentamos escribir en
las celdillas desde la 0 a la 16383 no conseguiremos cambiar el valor
almacenado en ellas. ¿Por qué no se puede escribir aquí? Porque es la
ROM del Spectrum, es un chip que contiene el “sistema operativo” del
Spectrum, su intérprete BASIC, como veremos posteriormente.
</p>

<p>
<br>

<img src="img/romram.gif" class="mediacenter" alt="ROM y RAM"/>
<br>

</p>

<p>
Para trabajar (ejecutar programas, realizar operaciones y tareas)
podemos utilizar el resto de la memoria. Desde el cajón o celdilla
número 16384 hasta el 65535 (en los modelos de 48KB) podremos escribir y
 leer.
</p>

<p>
La memoria RAM (celdillas 16384 a 65536) es muy importante para el
Spectrum. Para empezar, en ella es donde se almacenan los datos y donde
se cargan los programas, y de ella es de donde lee el microprocesador
estos programas (como veremos posteriormente) para ejecutarlos
instrucción a instrucción. Cuando en nuestra anterior entrega del curso
pokeamos la rutina en código máquina en la dirección 40000, estabamos
escribiendo un programa en memoria RAM para después ejecutarlo.
</p>

<p>
Hay una parte de la memoria RAM que es especial. El trozo de 6912 bytes
que va desde la dirección 16384 hasta la 23295 es conocida como
VideoRAM. Esta porción de la memoria no se utiliza para almacenar
programas ni datos, sino que es una representación numérica de los
gráficos que aparecen en nuestro televisor. La ULA (un chip que hay
dentro de nuestro Spectrum) lee continuamente esta zona de memoria y
transforma los unos y ceros que en ella encuentra en puntos y colores en
 el televisor.
</p>

<p>
Visto de una manera simple (pero real): al escribir un valor numérico
(por ejemplo un 1) en alguna dirección de esta parte de la RAM, de forma
 inmediata aparece un punto en nuestro televisor, ya que la ULA está
continuamente “escaneando” la videoram (de forma independiente del Z80)
para reflejar en el televisor todos los valores numéricos que
introduzcamos en ella.
</p>

<p>
La videomemoria es memoria RAM normal y corriente (podemos tanto leer
como escribir en ella), sólo que los datos que contiene son leídos por
la ULA a un ritmo de 50 veces por segundo. La ULA convierte los datos de
 la videomemoria en la imagen que vemos en el televisor conectado a
nuestro Spectrum. La ULA es, pues, el chip encargado de representar en
el televisor el contenido de la videomemoria y nosotros, cuando queramos
 escribir o dibujar algo en pantalla, ya no utilizaremos funciones como
PLOT o DRAW de BASIC, sino que escribiremos directamente valores en esta
 zona de memoria.
</p>

<p>
Por ejemplo, el siguiente programa pinta 2 píxeles en el centro de la pantalla escribiendo en la videomemoria:
</p>
<pre class="code basic">10 REM Pintando 2 pixeles en pantalla mediante POKE
20 LET DIRECCION= 16384 + 2000
25 REM 129 = 10000001
30 POKE DIRECCION, 129
40 PAUSE 0</pre>

<p>
Si ejecutamos el programa, veremos 2 puntos en el centro de la pantalla.
 Estos 2 puntos aparecen al escribir el byte de valor 129 en la
dirección 18384. El número 129, en binario, es 10000001. Esos 2 unos son
 los que se convierten en 2 puntos cuando la ULA lee la videomemoria y
transforma los unos en colores de tinta y los ceros en colores de papel.
</p>

<p>
Lo que nos tiene que quedar claro al respecto de la memoria es lo siguiente:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> El microprocesador puede acceder a
la memoria tanto para leer como para escribir, y lo hará cuando nosotros
 se lo pidamos (para leer o escribir datos en memoria). También lo hará
para leer las instrucciones a ejecutar, como veremos posteriormente.
</li>
<li> La memoria se divide en ROM
(celdillas 0-16383) y RAM (celdillas desde 16384 hasta la totalidad de
memoria instalada), con los primeros 6912 bytes de la RAM mapeados como
VideoRAM.
</li>
<li> En la ROM no podemos escribir (pero
sí leer). Almacena el “código” de arranque del Spectrum, así como el
intérprete de BASIC. En ella existen rutinas que usa BASIC que podremos
aprovechar en nuestros programas en ensamblador.
</li>
<li> En la videoRAM sólo leeremos y escribiremos (en nuestro caso) cuando queramos dibujar cosas en pantalla (puntos y colores).
</li>
<li> En el resto de la RAM (a partir de
la dirección 23296) es donde realizaremos todo el trabajo: allí
situaremos nuestros programas, nuestras variables, datos, gráficos que
después copiaremos a la videoRAM, etc.
</li>
</ul>

<p>
<br>

</p>

<p>
<br>

</p>

</div>

<h2 id="el-puerto-de-expansion">El puerto de expansión</h2>
<div class="level2">

<p>
El puerto de expansión del Spectrum no será en principio tema de
discusión en este libro, ya que no lo utilizaremos en nuestros
programas. Para información del lector, basta con saber que algunos de
los pines del puerto de expansión del Spectrum están conectados
directamente a diferentes patillas del microprocesador. Es decir, cada
una de las líneas que podemos ver físicamente en el puerto de expansión
es una pista de circuito (como si fuera un cable) que va directamente a
alguna de las patillas del Z80.
</p>

<p>
Es por eso que mediante el puerto de expansión se puede implementar casi
 cualquier dispositivo hardware en el Spectrum sin tener que abrirlo y
manipularlo internamente: estamos conectando dipositivos directamente al
 microprocesador y tras hacerlo, podemos realizar programas que accedan a
 esos elementos recién conectados: podemos leer los joysticks (porque
los estamos conectando a puertos de Entrada/Salida mediante los buses de
 datos y direcciones), podemos leer cartuchos (porque “ocultamos” la
memoria del Spectrum y la reemplazamos con otra memoria que contiene el
juego ya cargado en ella, poniéndo esta memoria en el Bus de datos y
Direcciones), etc.
</p>

<p>
<br>

</p>

</div>

<h2 id="como-funciona-el-spectrum">Cómo funciona el Spectrum</h2>
<div class="level2">

<p>
Una vez hemos visto todas las partes funcionales, veamos cómo funciona el Spectrum a nivel de ciclo de instrucción y ejecución.
</p>

<p>
 Como ya hemos visto, los diferentes dispositivos externos (teclado,
altavoz, cassette, elementos conectados al puerto de expansión,
joysticks) se comunican con la CPU por medio de puertos de
Entrada/Salida (Puertos E/S o I/O Ports). Para acceder a ellos
simplemente leemos o escribimos en el puerto correspondiente mediante
las instrucciones IN y OUT del Z80. También existen instrucciones para
acceder a la memoria, tanto para lectura como para escritura.
</p>

<p>
 En realidad el Z80, visto de una forma simplificada, sólo puede hacer 3
 cosas: leer/escribir en la memoria, leer/escribir en los dispositivos
de Entrada/Salida y decodificar/ejecutar instrucciones. La parte de
lectura/decodificación/ejecución es el funcionamiento principal del
microprocesador, y es lo que trataremos a continuación.
</p>

<p>
<br>

</p>

</div>

<h2 id="ciclo-de-ejecucion-de-un-spectrum">Ciclo de ejecución de un Spectrum</h2>
<div class="level2">

<p>
Como ya hemos visto, la parte central del Spectrum es un microprocesador
 Z80 el cual ve la ROM y la RAM de forma continuada como la totalidad de
 su memoria. Recordemos que el Spectrum puede leer el contenido de
cualquiera de estas 65536 celdillas así como escribir en ellas (siempre
que no sean celdillas de la ROM).
</p>

<p>
Al encender el Spectrum éste se inicializa y muestra el BASIC en
pantalla. ¿Por qué ocurre esto? Cuando se inicia el Spectrum, el
microprocesador Z80 comienza a ejecutar instrucciones, una tras otra,
desde la dirección de memoria 0, donde está el principio de la ROM de
16K, es decir, el intérprete BASIC.
</p>

<p>
 Un microprocesador funciona a grandes rasgos de la siguiente forma:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Leer instrucción apuntada por el registro PC.
</li>
<li class="level2"> Incrementar PC para apuntar a la siguiente instrucción.
</li>
<li class="level2"> Ejecutar la instrucción recién leída.
</li>
<li class="level2"> Repetir continuadamente los 3 pasos anteriores.
</li>
</ul>

<p>
<br>

</p>

<p>
 Al encender un Spectrum (que perdió en su apagado toda alimentación
eléctrica) teóricamente todos los registros del microprocesador Z80
valen 0 (sin alimentación eléctrica, todos los bits de la CPU están a 0
Voltios, es decir, a 0 lógico), incluído el registro PC (Program Counter
 o Contador de Programa), que es el que apunta a la siguiente
instrucción que el Z80 debe leer y ejecutar.
</p>

<p>
 Al ser PC = 0000, el Spectrum comienza a ejecutar, instrucción tras
instrucción, el código que hay pregrabado en la ROM a partir de la
celdilla 0 de memoria.
</p>

<p>
 Visto en pseudocódigo, como si fuera un programa, un Z80 actúa así:
</p>
<pre class="code">    * Encendido de ordenador:
          o PC (el Contador de Programa) se pone a 0.
          o SP se pone a $FFFF.
    * Mientras No Se Apague el Ordenador:
      Leer de la memoria la siguiente instrucción, mediante
      lectura del contenido de la dirección apuntada por PC:
          o Opcode = (PC)
          o PC = PC + 1
          o Si la instrucción necesita algún operando, leerlo:
                + Operando1 = (PC)
                + PC = PC + 1
          o Si hay un segundo operando, leerlo:
                + Operando2 = (PC)
                + PC = PC + 1
          o Decodificar la instrucción (mirar en una tabla interna y ver
            qué microcódigo hay que ejecutar para la instrucción leída).
          o Ejecutar la instrucción
     Fin Mientras
    </pre>

<p>
 En realidad, según el texto “The Undocumented Z80 Documented”, de Sean Young,
tras un reset los registros quedan con los siguientes valores:
</p>
<pre class="code"> PC              = $0000
 AF, SP          = $FFFF
 Resto           = Valor indefinido
 Interrupciones
 (IM, IFF1 y 2)  = 0</pre>

<p>
Así pues, al encender el ordenador, PC vale 0. Al estar la ROM mapeada
en la posición de memoria 0 (mediante cableado hardware de los chips de
memoria en la placa del Spectrum), lo que pasa al encender el ordenador
es que ese contador de programa (PC) está apuntando al principio de la
ROM, y es por eso que se ejecuta la ROM paso a paso, instrucción a
instrucción, cada vez que lo encendemos, realizando desde el
característico borrado de pantalla del inicio del Spectrum hasta la
impresión del tradicional mensaje “© 1982 Sinclair Research Ltd”.
</p>

<p>
Después, la ejecución del código que hay en la ROM se mantiene en un
bucle que escanea el teclado y nos permite introducir órdenes de BASIC y
 ejecutarlas: el famoso intérprete BASIC.
</p>

<p>
Fuera de los primeros 16KB de memoria tenemos el resto de memoria
disponible, donde el intérprete BASIC almacenará las instrucciones BASIC
 que tecleemos o bien donde se cargará un programa desde los diferentes
dispositivos de entrada/salida (gestionados por el Z80) como la cinta o
disco, etc.
</p>

<p>
Así pues, nuestro Z80 en el momento del arranque lo que hace es comenzar
 a ejecutar una a una las instrucciones código máquina que hay a partir
de la dirección $0000 de la memoria, que se corresponde con la ROM.
</p>

<p>
 ¿Y qué contiene la ROM? Pues la ROM no es más que un programa realizado
 por los ingenieros de Sinclair. Ese programa contiene, entre otras
cosas, el intérprete BASIC. Los señores de Sinclair Research programaron
 un intérprete BASIC en lenguaje ensamblador de Z80, lo ensamblaron con
un programa ensamblador de Z80 y grabaron el código binario resultante
ensamblado en un CHIP ROM de 16KB. Por eso al encender nuestro Spectrum
aparece el intérprete de BASIC; el Sistema Operativo de nuestro ZX. Nada
 nos impediría realizar nuestro propio “sistema operativo” para Spectrum
 creando una ROM nueva (mirando siempre la compatibilidad con la ROM
vieja, de forma que contenga las mismas rutinas de ROM y variables en
memoria que utilizan muchos programas) y reemplazando el chip ROM del
Spectrum por nuestro propio chip de ROM.
</p>

<p>
<br>

</p>

</div>

<h2 id="opcodes-y-codigo-maquina">Opcodes y código máquina</h2>
<div class="level2">

<p>
Nuestro microprocesador Z80 no entiende los comandos en ensamblador que
hemos estado viendo en estos 2 primeros capítulos del curso de código
máquina; el Z80 sólo entiende números binarios, números de 8 bits de 0 a
 255 (o de $00 a $FF en hexadecimal).
</p>

<p>
De entre los registros del microprocesador hay uno llamado PC (Program
Counter o Contador de Programa), que como ya hemos visto, es el
“puntero” que apunta a la instrucción actual que se está ejecutando.
Cuando ejecutamos un programa, lo que hacemos es meterlo en memoria (por
 ejemplo, como cuando en la primera entrega del curso POKEábamos nuestra
 rutina a partir de la dirección 40.000) y después saltar al inicio del
mismo.
</p>

<p>
Supongamos por ejemplo que pokeamos el siguiente programa en la dirección 40000:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>
 <span class="kw1">INC</span> <span class="kw2">A</span>
 <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="sy0">$</span>FFh
 <span class="kw1">INC</span> <span class="kw2">B</span>
 <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="sy0">$</span>AABB
 <span class="kw1">RET</span></pre>

<p>
Si ensamblamos este programa obtendremos los siguientes números (técnicamente llamados “código máquina”):
</p>
<pre class="code"> 3e 00 3c 06 ff 04 11 bb aa c9</pre>

<p>
Al pokear en memoria estos valores, dejaremos el siguiente contenido en memoria:
</p>
<div class="table-responsive sectionedit12"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Dirección </th><th class="col1"> Valor hexadecimal </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0 leftalign"> 40000	</td><td class="col1"> 3e </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> 40001	</td><td class="col1"> 00 </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> 40002	</td><td class="col1"> 3c </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> 40003	</td><td class="col1"> 06 </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> 40004	</td><td class="col1"> ff </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> 40005	</td><td class="col1"> 04 </td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign"> 40006	</td><td class="col1"> 11 </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> 40007	</td><td class="col1"> bb </td>
	</tr>
	<tr class="row9">
		<td class="col0 leftalign"> 40008	</td><td class="col1"> aa </td>
	</tr>
	<tr class="row10">
		<td class="col0 leftalign"> 40009	</td><td class="col1"> c9 </td>
	</tr>
</tbody></table></div>

<p>
Para nosotros estos números no quieren decir nada, pero para el Spectrum tienen un total significado. Concretamente:
</p>
<div class="table-responsive sectionedit13"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Dirección </th><th class="col1"> Valor hexadecimal </th><th class="col2"> Significado </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0 leftalign"> 40000	</td><td class="col1"> 3e </td><td class="col2"> LD A, </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign"> 40001	</td><td class="col1"> 00 </td><td class="col2"> 00h </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign"> 40002	</td><td class="col1"> 3c </td><td class="col2"> INC A </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign"> 40003	</td><td class="col1"> 06 </td><td class="col2"> LD B, </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign"> 40004	</td><td class="col1"> ff </td><td class="col2"> FFh </td>
	</tr>
	<tr class="row6">
		<td class="col0 leftalign"> 40005	</td><td class="col1"> 04 </td><td class="col2"> INC B </td>
	</tr>
	<tr class="row7">
		<td class="col0 leftalign"> 40006	</td><td class="col1"> 11 </td><td class="col2"> LD DE, </td>
	</tr>
	<tr class="row8">
		<td class="col0 leftalign"> 40007	</td><td class="col1"> bb </td><td class="col2"> BBh </td>
	</tr>
	<tr class="row9">
		<td class="col0 leftalign"> 40008	</td><td class="col1"> aa </td><td class="col2"> AAh </td>
	</tr>
	<tr class="row10">
		<td class="col0 leftalign"> 40009	</td><td class="col1"> c9 </td><td class="col2"> RET </td>
	</tr>
</tbody></table></div>

<p>
A la hora de ejecutar el programa, nuestro RANDOMIZE USR 40000 lo que
hace en realidad es cambiar el valor del registro “PC” del
microprocesador. Hace PC igual a 40000. Así, una vez realizamos el salto
 a la dirección 40000, el microprocesador hace lo siguiente:
</p>
<pre class="code">    * Leer el byte contenido en la dirección de memoria "PC" (40000).
    * Incrementar PC (PC=PC+1).
    * El byte es "$3e", con lo cual el Spectrum sabe que
      tiene que meter en A un valor numérico.
    * El valor extra para "LD A," está a continuación en memoria,
      así que se lee la memoria de nuevo:
          o operando = [PC] = $00
          o Incrementar PC (PC=PC+1)
    * Ya se tiene el "código de instrucción completo", así que se
      ejecuta: "LD A, 00". (se ejecuta el microcódigo correspondiente
      dentro de la CPU).</pre>

<p>
Esto que hemos visto es el proceso de “Lectura de Instrucción (fetch)”,
“decodificación (decode)”, y “ejecución (execute)”. Pero recordemos que
este proceso se ejecuta una y otra vez, sin parar, de modo que el
procesador sigue con la siguiente instrucción (INC A):
</p>
<pre class="code">    * Leer el byte contenido en la dirección de memoria "PC" (40002).
    * Incrementar PC (PC=PC+1).
    * El byte es "$3c", con lo cual el Spectrum sabe que tiene que incrementar A.
    * No hacen falta operandos extra, INC A no requiere nada más.
    * Ya se tiene el "código de instrucción completo", así que se ejecuta: "INC A".</pre>

<p>
Y este ciclo se vuelve a repetir, una y otra vez, hasta que llegamos al RET:
</p>
<pre class="code">    * Leer el byte contenido en la dirección de memoria "PC" (40009).
    * Incrementar PC (PC=PC+1).
    * El byte es "$c9", con lo cual el Spectrum sabe que tiene que hacer un RET.
    * No hacen falta operandos extra, RET no requiere nada más.
    * Ya se tiene el "código de instrucción completo", así que se ejecuta: "RET".</pre>

<p>
Un par de detalles a tener en cuenta:
</p>
<ul class="fix-media-list-overlap">
<li> Como véis, el microprocesador no
entiende el lenguaje ensamblador, sólo la traducción de este a Lenguaje
Máquina (los números u opcodes que estamos viendo).
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> La primera parte leída de la
instrucción es el OPCODE (código de operación), y es lo que permite al
Spectrum, mediante una “tabla interna”, saber qué tarea exacta tiene que
 realizar. Si la instrucción necesita datos extra para leer de memoria,
se almacenan tras el opcode, y se conocen como “operandos”. Así, “LD A,
00” se corresponde con la instrucción “3E 00”, donde “3E” es el código
de operación (opcode) y “00” es el operando.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Cuando un operando es de 16 bits (2
bytes), primero encontramos el byte bajo y luego el byte alto. Así,
nuestro “LD DE, $AABB” no se codifica como “11 AA BB” sino como “11 BB
AA”. El opcode para “LD DE” es “11”, y “BB AA” los operandos (en este
caso, un valor numérico directo). Esta forma de almacenamiento se
denomina técnicamente “little endian”.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Para el Spectrum, no hay diferencia
entre instrucciones y datos. Un “$3C” puede ser un “INC A” o un valor
númerico “$3C”. ¿Cómo distingue el Spectrum uno de otro? Sencillo: todo
depende de si se encuentra al principio de un ciclo de decodificación o
no. Es decir, si cuando vamos a empezar a leer una instrucción leemos un
 “$3C”, es un INC A. Pero si lo leemos en el proceso de lectura de un
operando, su significado cambia. Pensad en por ejemplo en “LD A, $3C”,
que se codificaría como “3E 3C”, pero no ejecutaría un INC A porque la
lectura del “$3C” se realiza como operando para el “LD A,”.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Al no existir diferencia entre
instrucciones y datos, si cambiamos PC de forma que apunte a una zona de
 la memoria donde hay datos y no código, el Z80 tratará de interpretar
los números que va leyendo como si fueran opcodes (con resultados
imprecedibles, seguramente con el cuelgue del Spectrum o un reset).
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Por último, existen una serie de
opcodes compuestos (dejando de lado los operandos) que ocupan más de 1
byte. Esos opcodes suelen comenzar por CB, ED o FD, de forma que, por
ejemplo el opcode “CB 04” se corresponde con la operación “RLC L”. Si
sólo pudieramos utilizar un byte para representar el opcode, sólo
tendríamos disponibles 256 posibles instrucciones en el procesador. Para
 poder disponer de más instrucciones se utilizan códigos de instrucción
de más de un byte. Así, cuando nuestro procesador encuentra un CB, ED o
FD sabe que el próximo código que lea después tendrá un significado
diferente al que tendría sin el CB, ED o FD delante. Es por eso que
“$04” significa “INC B”, y “$CB $04” significa “RLC L” (una instrucción
diferente).
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="ensamblado-manual">Ensamblado manual</h2>
<div class="level2">

<p>
Al igual que el Spectrum consulta una tabla interna para saber a qué
instrucción corresponde cada valor numérico (cada opcode) nosotros
podemos consultar una tabla para ensamblar manualmente nuestros
programas en ensamblador y obtener los valores de código máquina con que
 se corresponden. Si no tenemos a mano un programa ensamblador que lo
haga por nosotros (que, al fin y al cabo, no es más que un traductor
“automático” con una tabla similar), podemos utilizar tablas de
ensamblado para traducir el programa manualmente. Cabe decir que es una
labor repetitiva y larga, y se recomienda encarecidamente la utilización
 de un programa ensamblador para ello.
</p>

<p>
Cuando lleguemos a la parte de definición del lenguaje veremos que
ensamblando manualmente resulta bastante costoso calcular las
direcciones de los saltos relativos y absolutos, cosa que el programa
ensamblador hace con bastante facilidad.
</p>

<p>
Aún así, quien quiera intentar ensamblar manualmente podrá hacerlo
incluso con la tabla de “Juego de caracteres” que tiene disponible en el
 manual del +2A/+3, capítulo 8, sección 28 (además de no ser la única
tabla de ensamblado manual que existe, ya que hay varias disponibles en
Internet).
</p>

<p>
<a href="opcodes.txt" class="urlextern" title="opcodes.txt">Tabla de opcodes</a>
</p>

<p>
<br>

</p>

</div>

<h2 id="tiempos-de-ejecucion">Tiempos de ejecución</h2>
<div class="level2">

<p>
Cada instrucción necesita un tiempo diferente para ejecutarse. No es lo
mismo un simple “INC A”, que requiere leer un único byte como opcode, no
 requiere parámetros, y sólo realiza un incremento en un registro, que
un complejo “LD A, ($1234)”, que requiere leer el opcode, a continuación
 leer 2 bytes para el operando “$1234”, después acceder a la memoria y
extraer el dato contenido en ($1234) para, finalmente, depositarlo en A.
</p>

<p>
Los tiempos de ejecución de cada instrucción son, pues, diferentes, y
para conocerlos tendremos que consultar cualquier tabla de tiempos,
medidos en t-states o t-estados. El t-estado o “ciclo del procesador”,
es la unidad de medida básica de tiempo. Podéis acceder a alguna de
estas tablas en los enlaces que veréis al final de este artículo.
</p>

<p>
<br>

</p>

</div>

<h2 id="el-software-de-spectrum">El software de Spectrum</h2>
<div class="level2">

<p>
A estas alturas ya debemos tener claro cómo funciona el Spectrum, con su
 microprocesador Z80 continuamente ejecutando el código apuntado por
“PC”, incrementando este y de nuevo repitiendo el ciclo.
</p>

<p>
Cuando encendemos nuestro Spectrum, PC vale 0000h y se ejecuta la ROM
que, como ya hemos comentado, no es más que un programa hecho por los
ingenieros que desarrollaron el Spectrum.
</p>

<p>
 El código ensamblador de este “programa” está disponible para su
consulta ya que usuarios de Spectrum realizaron un desensamblado (a
partir de los opcodes, obtener el código fuente original) y comentaron
todas las rutinas, variables del sistema y procedimientos que se
ejecutan en nuestro Spectrum nada más arrancarlo. El libro “The Complete
 Spectrum ROM Disassembly” (El desensamblado Completo de la ROM del
Spectrum) contiene este desensamblado, y podemos obtenerlo en Internet,
por si tenemos curiosidad en conocer las interioridades de la ROM del
Spectrum y cómo está programado el intérprete BASIC y las diferentes
funciones de la ROM del mismo (con el objetivo de poder “usarlas” en
nuestros programas en ensamblador).
</p>

<p>
Pero aparte de la ROM del Spectrum, ¿cómo llega a la memoria de nuestro
ordenador (o emulador) los programas que ejecutamos?. Veamos las
diferentes maneras:
</p>

<p>
<br>

</p>
<ol class="fix-media-list-overlap">
<li><div class="li"> Desde cinta: Nuestro LOAD “” provoca
 en BASIC la llamada a una rutina de la ROM que carga desde cinta el
código y los datos de los programas. Lo único que se hace es leer de la
cinta los opcodes y sus operandos, así como cualquier otro dato
(gráficos, sonidos) del programa, e introducirlos en memoria en una zona
 a la que luego saltaremos (cambiaremos PC a ella). Cuando grabamos a
cinta, lo que hacemos es leer el contenido de un trozo de memoria y
escribirlo en cinta (escribir los valores numéricos de los opcodes,
operandos y datos).<br>
</div>
</li>
<li><div class="li"> Desde disco: exactamente igual que en el caso de la cinta, pero el medio de almacenamiento es un disco de 3“ o de 3.5”.<br>
</div>
</li>
<li><div class="li"> Ficheros TAP y TZX: son ficheros de
ordenador que almacenan los datos exactamente igual que si fuera una
cinta real: almacenan opcodes, datos y operandos, que luego serán
cargados en memoria.<br>
</div>
</li>
<li><div class="li"> Ficheros .SP, .SNA y .Z80 (en
general, cualquier fichero de snapshot). No son más que volcados de la
memoria. Por ejemplo, un fichero .SP o .SNA contiene el contenido de las
 49152 celdillas de memoria desde 16384 hasta 65536. Para cargar ese
.SNA en un emulador, lo que realiza el emulador es un simple “POKEado”
del contenido del fichero en las celdillas de memoria. Así, un fichero
snapshot no es más que una “copia” de la memoria (de su contenido) que
volcamos a fichero.<br>
</div>
</li>
</ol>

<p>
<br>

</p>

<p>
 Cuando nosotros creemos un nuevo programa, lo haremos escribiendo el
programa en un fichero de texto con instrucciones en ensamblador. La
herramienta ensambladora “pasmo” convertirá este fichero con
instrucciones (fichero.asm) en una ristra de bytes en código máquina
(fichero.bin) con los opcodes y los datos de nuestro programa.
Obtendremos pues un fichero binario que podremos almacenar en cinta, en
tap, en tzx, etc.
</p>

<p>
 Este fichero binario (esta ristra de bytes) podrá ser cargado en la
memoria del Spectrum con cualquiera de los métodos que acabamos de ver y
 ejecutado saltando a la dirección de inicio donde haya sido cargado.
</p>

<p>
<br>

</p>

</div>

<h2 id="en-resumen">En resumen</h2>
<div class="level2">

<p>
Hemos visto cómo funciona internamente nuestro ordenador Spectrum y el
microprocesador Z80. A partir del próximo capítulo comenzaremos ya con
la sintaxis del lenguaje ensamblador y una descripción de las diferentes
 instrucciones disponibles. No obstante, creemos que los conceptos
introducidos ya en estos 2 primeros capítulos deben de haber llevado ya
al lector a un punto en el cual podrá realizar sus primeras pruebas en
ensamblador mediante la documentación a la cual nos referimos en los
enlaces. Basta con consultar el juego de instrucciones del Spectrum en
la página oficial del Z80 o de Zilog para poder realizar ya nuestros
primeros programas en ensamblador para nuestro querido Sinclair ZX
Spectrum.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/02_teclado.bas">Programa en BASIC que lee el teclado mediante acceso a puertos</a>
</li>
<li><a href="src/02_teclado.tap">Fichero tap del ejemplo teclado.bas</a>
</li>
<li><a href="src/02_pantalla.bas">Programa en BASIC que dibuja en pantalla mediante POKE]</a>
</li>
<li><a href="src/02_pantalla.tap">Fichero tap del ejemplo pantalla.bas</a>
</li>
<li><a href="src/02_opcodes.asm">Listado de opcodes para ensamblado manual</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt32.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt32.html">Puertos E/S</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt26.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt26.html">Usando CM</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt24.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt24.html">La Memoria</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt25.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt25.html">Variables del sistema</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt28.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt28.html">Set de caracteres</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="external/www.z80.info/index.html">Web del Z80</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/ti86.acz.org/z80_ref.htm" class="urlextern" title="external/ti86.acz.org/z80_ref.htm">Z80 Reference de TI86</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/index.html" class="urlextern" title="external/www.ticalc.org/pub/text/z80/index.html">Tablas de ensamblado y t-estados</a> (pulsar en <a href="external/www.ticalc.org/pub/text/z80/z80.txt">z80.txt</a>, <a href="external/www.ticalc.org/pub/text/z80/z80_reference.txt">z80_reference.txt</a>, <a href="external/www.ticalc.org/pub/text/z80/z80time.txt">z80time.txt</a>)</div>
</li>
<li class="level2"><div class="li"> <a href="external/freestuff.grok.co.uk/rom-dis/index.html" class="urlextern" title="external/freestuff.grok.co.uk/rom-dis/index.html">Complete Spectrum ROM disassembly project</a></div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="lenguaje-ensamblador-del-z80-i">Lenguaje Ensamblador del Z80 (I)</h1>
<div class="level1">

</div>

<h1 id="arquitectura-del-z80-e-instrucciones-basicas">Arquitectura del Z80 e Instrucciones básicas</h1>
<div class="level1">

<p>
<br>

</p>

<p>
 En este capítulo explicaremos la sintaxis utilizada en los programas en
 ensamblador. Para ello comenzaremos con una definición general de la
sintaxis para el ensamblador Pasmo, que será el “traductor” que usaremos
 entre el lenguaje ensamblador y el código máquina del Z80.
</p>

<p>
Posteriormente veremos en detalle los registros: qué registros hay
disponibles, cómo se agrupan, y el registro especial de Flags, enlazando
 el uso de estos registros con las instrucciones de carga, de
operaciones aritméticas, y de manejo de bits, que serán las que
trataremos hoy.
</p>

<p>
Esta entrega del curso es delicada y complicada: por un lado, tenemos
que explicar las normas y sintaxis del ensamblador cruzado PASMO antes
de que conozcamos la sintaxis del lenguaje ensamblador en sí, y por el
otro, no podremos utilizar PASMO hasta que conozcamos la sintaxis del
lenguaje.
</p>

<p>
Además, el lenguaje ensamblador tiene disponibles muchas instrucciones
diferentes, y nos resultaría imposible explicarlas todas en un mismo
capítulo, lo que nos fuerza a explicar las instrucciones del
microprocesador en varias entregas. Esto implica que hablaremos de PASMO
 comentando reglas, opciones de instrucciones y directivas que todavía
no conocemos.
</p>

<p>
Es por esto que recomendamos al lector que, tras releer anteriores
capítulos de este libro, se tome esta entrega de una manera especial,
leyéndola 2 veces. La “segunda pasada” sobre el texto permitirá enlazar
todos los conocimientos dispersos en el mismo, y que no pueden
explicarse de una manera lineal porque están totalmente
interrelacionados. Además, la parte relativa a la sintaxis de PASMO será
 una referencia obligada para posteriores capítulos (mientras
continuemos viendo diferentes instrucciones ASM y ejemplos).
</p>

<p>
<br>

</p>

</div>

<h2 id="sintaxis-del-lenguaje-asm-en-pasmo">Sintaxis del lenguaje ASM en PASMO</h2>
<div class="level2">

<p>
En anteriores capítulos ya hablamos de PASMO, el ensamblador cruzado que
 recomendamos para el desarrollo de programas para Spectrum. Este
ensamblador traduce nuestros ficheros de texto .asm con el código fuente
 de programa (en lenguaje ensamblador) a ficheros .bin (o .tap/.tzx) que
 contendrán el código máquina directamente ejecutable por el Spectrum.
</p>

<p>
Supondremos para el resto del capítulo que ya tenéis instalado PASMO (ya
 sea la versión Windows o la de UNIX/Linux) en vuestro sistema y que
sabéis utilizarlo de forma básica (bastará con saber realizar un simple
ensamblado de programa, como ya vimos en el primer capítulo), y que
podéis ejecutarlo dentro del directorio de trabajo que habéis elegido.
</p>

<p>
El ciclo de desarrollo con PASMO será el siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> Con un editor de texto, tecleamos nuestro programa en un fichero .ASM con la sintaxis que veremos a continuación.
</li>
<li class="level1 node"> Salimos del editor de texto y ensamblamos el programa:
<ul class="fix-media-list-overlap">
<li class="level2"> Si queremos generar un fichero .bin
de código objeto cuyo contenido POKEar en memoria (o cargar con LOAD “”
CODE) desde un cargador BASIC, lo ensamblamos con: “pasmo ejemplo1.asm
ejemplo1.bin”
</li>
<li class="level2"> Si queremos generar un fichero .tap
directamente ejecutable (de forma que sea pasmo quien añada el cargador
BASIC), lo ensamblamos con “pasmo --tapbas ejemplo1.asm ejemplo1.tap”
</li>
</ul>
</li>
</ul>

<p>
 Todo esto se mostró bastante detalladamente en su momento en el primer capítulo del curso.
</p>

<p>
 Con esto, ya sabemos ensamblar programas creados adecuadamente, de modo
 que la pregunta es: ¿cómo debo escribir mi programa para que PASMO
pueda ensamblarlo?
</p>

<p>
 Es sencillo: escribiremos nuestro programa en un fichero de texto con
extensión .asm. En este fichero de texto se ignorarán las líneas en
blanco y los comentarios, que en ASM de Z80 se introducen con el símbolo
 “;” (punto y coma), de forma que todo lo que el ensamblador encuentre a
 la derecha de un ; será ignorado (siempre que no forme parte de una
cadena). Ese fichero de texto será ensamblado por PASMO y convertido en
código binario.
</p>

<p>
Lo que vamos a ver a continuación son las normas que debe cumplir un
programa para poder ser ensamblado en PASMO. Es necesario explicar estas
 reglas para que el lector pueda consultarlas en el futuro, cuando esté
realizando sus propios programas. No te preocupes si no entiendes alguna
 de las reglas, cuando llegues al momento de implementar tus primeras
rutinas, las siguientes normas te serán muy útiles:<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>Normas para las instrucciones:</strong></div>
<ul class="fix-media-list-overlap">
<li class="level2"> Pondremos una sóla instrucción de ensamblador por línea.
</li>
<li class="level2"> Como existen diferencias entre los
“fin de línea” entre Linux y Windows, es recomendable que los programas
se ensamblen con PASMO en la misma plataforma de S.O. en que se han
escrito. Si PASMO intenta compilar en Windows un programa ASM escrito en
 un editor de texto de Linux (con retornos de carro de Linux) es posible
 que obtengamos errores de ensamblado (aunque no es seguro). Si os
ocurre al compilar los ejemplos que os proporcionamos (están escritos en
 Linux) y usáis Windows, lo mejor es abrir el fichero .ASM con notepad y
 grabarlo de nuevo (lo cual lo salvará con formato de retornos de carro
de Windows). El fichero “regrabado” con Notepad podrá ser ensamblado en
Windows sin problemas.
</li>
<li class="level2"> Además de una instrucción, en una
misma línea podremos añadir etiquetas (para referenciar a dicha línea,
algo que veremos posteriormente) y comentarios (con ';').
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>Normas para los valores numéricos:</strong></div>
<ul class="fix-media-list-overlap">
<li class="level2"> Todos los valores numéricos se considerarán, por defecto, escritos en decimal.
</li>
<li class="level2"> Para introducir valores números en
hexadecimal los precederemos del carácter “$”, y para escribir valores
numéricos en binario lo haremos mediante el carácter “%”.
</li>
<li class="level2"> Podremos también especificar la base
 del literal poniendoles como prefijo las cadena &amp;H ó 0x (para
hexadecimal) o &amp;O (para octal).
</li>
<li class="level2"> Podemos especificar también los
números mediante sufijos: Usando una “H” para hexadecimal, “D” para
decimal, “B” para binario u “O” para octal (tanto mayúsculas como
minúsculas).
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>Normas para cadenas de texto: </strong></div>
<ul class="fix-media-list-overlap">
<li class="level2"> Podemos separar las cadenas de texto mediante comillas simples o dobles.
</li>
<li class="level2"> El texto encerrado entre comillas
simples no recibe ninguna interpretación, excepto si se encuentran 2
comillas simples consecutivas, que sirven para introducir una comilla
simple en la cadena.
</li>
<li class="level2"> El texto encerrado entre comillas
dobles permite introducir caracteres especiales al estilo de C/C++ como
\n, \r o \t (nueva línea, retorno de carro, tabulador…).
</li>
<li class="level2"> El texto encerrado entre comillas
dobles también admite \xNN para introducir el carácter correspondiente a
 un número hexadecimal NN.
</li>
<li class="level2"><div class="li"> Una cadena de texto de longitud 1 (un carácter) puede usarse como una constante (valor <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> del carácter) en expresiones como, por ejemplo, 'C'+10h.</div>
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>Normas para los nombres de ficheros:</strong></div>
<ul class="fix-media-list-overlap">
<li class="level2"> Si vemos que nuestro programa se
hace muy largo y por lo tanto incómodo para editarlo, podemos partir el
fichero en varios ficheros e incluirlos mediante directivas INCLUDE
(para incluir ficheros ASM) o INCBIN (para incluir código máquina ya
compilado). Al especificar nombres de ficheros, deberán estar entre
dobles comillas o simples comillas.
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>Normas para los identificadores:</strong></div>
<ul class="fix-media-list-overlap">
<li class="level2"> Los identificadores son los nombres usados para etiquetas y también los símbolos definidos mediante EQU y DEFL.
</li>
<li class="level2"> Podemos utilizar cualquier cadena de texto, excepto los nombres de las palabras reservadas de ensamblador.
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>Normas para las etiquetas:</strong></div>
<ul class="fix-media-list-overlap">
<li class="level2"> Una etiqueta es un identificador de
texto que ponemos poner al principio de cualquier línea de nuestro
programa, por ejemplo: “bucle:”
</li>
<li class="level2"> Podemos añadir el tradicional sufijo
 “:” a las etiquetas, pero también es posible no incluirlo si queremos
compatibilidad con otros ensambladores que no lo soporten (por si
queremos ensamblar nuestro programa con otro ensamblador que no sea
pasmo).
</li>
<li class="level2"> Para PASMO, cualquier referencia a
una etiqueta a lo largo del programa se convierte en una referencia a la
 posición de memoria de la instrucción o dato siguiente a donde hemos
colocado la etiqueta. Podemos utilizar así etiquetas para hacer
referencia a nuestros gráficos, variables, datos, funciones, lugares a
donde saltar, etc.
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>Directivas:</strong></div>
<ul class="fix-media-list-overlap">
<li class="level2"> Tenemos a nuestra disposición una
serie de directivas para facilitarnos la programación, como DEFB o DB
para introducir datos en crudo en nuestro programa, ORG para indicar una
 dirección de inicio de ensamblado, END para finalizar el programa e
indicar una dirección de autoejecución, IF/ELSE/ENDIF en tiempo de
compilación, INCLUDE e INCBIN, MACRO y REPT.
</li>
<li class="level2"> La directiva END permite indicar un
parámetro numérico (END XXXX) que “pasmo --tapbas” toma para añadir al
listado BASIC de arranque el RANDOMIZE USR XXXX correspondiente. De esta
 forma, podemos hacer que nuestros programas arranquen en su posición
correcta sin que el usuario tenga que teclear el “RANDOMIZE USR DIRECCION_INICIO”.
</li>
</ul>
</li>
</ul>

<ul class="fix-media-list-overlap">
<li> Una de las directivas más
importantes es ORG, que indica la posición origen donde almacenar el
código que la sigue. Podemos utilizar diferentes directivas ORG en un
mismo programa. Los datos o el código que siguen a una directiva ORG son
 ensamblados a partir de la dirección que indica éste.
</li>
<li class="level2"><div class="li"> Iremos viendo el significado de las directivas conforme las vayamos usando, pero es aconsejable <a href="external/pasmodoc.html#directives" class="urlextern" title="external/pasmodoc.html#directives">consultar el manual de PASMO</a> para conocer más sobre ellas.</div>
</li>
</ul>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><strong><a href="external/pasmodoc.html#operators" class="urlextern" title="external/pasmodoc.html#operators">Operadores</a></strong>
<ul class="fix-media-list-overlap">
<li class="level2"> Podemos utilizar los operadores típicos +, -, *. /, así como otros operadores de desplazamiento de bits como » y «.
</li>
<li class="level2"> Tenemos disponibles operadores de comparación como EQ, NE, LT, LE, GT, GE o los clásicos =, !=, &lt;, &gt;, &lt;=, &gt;=.
</li>
<li class="level2"> Existen también operadores lógicos como AND, OR, NOT, o sus variantes &amp;, |, !.
</li>
<li class="level2"> Los operadores sólo tienen
aplicación en tiempo de ensamblado, es decir, no podemos multiplicar o
dividir en tiempo real en nuestro programa usando * o /. Estos
operadores están pensados para que podamos poner expresiones como
((32*10)+12), en lugar del valor numérico del resultado, por ejemplo.
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="aspecto-de-un-programa-en-ensamblador">Aspecto de un programa en ensamblador</h2>
<div class="level2">

<p>
Veamos un ejemplo de programa en ensamblador que muestra el uso de
algunas de estas normas, para que las podamos entender fácilmente
mediante los comentarios incluidos:
</p>
<pre class="code z80"><span class="co1">; Programa de ejemplo para mostrar el aspecto de</span>
<span class="co1">; un programa típico en ensamblador para PASMO.</span>
<span class="co1">; Copia una serie de bytes a la videomemoria con</span>
<span class="co1">; instrucciones simples (sin optimizar).</span>
ORG <span class="nu0">4</span><span class="re1">0000</span>
&nbsp;
valor     <span class="kw3">EQU</span>  <span class="re1">1</span>
destino   <span class="kw3">EQU</span>  <span class="re1">1</span><span class="nu0">8384</span>
&nbsp;
  <span class="co1">; Aqui empieza nuestro programa que copia los</span>
  <span class="co1">; 7 bytes desde la etiqueta "datos" hasta la</span>
  <span class="co1">; videomemoria ([16384] en adelante).</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, destino     <span class="co1">; HL = destino (VRAM)</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, datos       <span class="co1">; DE = origen de los datos</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">6</span>            <span class="co1">; numero de datos a copiar</span>
&nbsp;
bucle:               <span class="co1">; etiqueta que usaremos luego</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Leemos un dato de [DE]</span>
  <span class="kw1">ADD</span> <span class="kw2">A</span>, valor       <span class="co1">; Le sumamos 1 al dato leído</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Lo grabamos en el destino [HL]</span>
  <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Apuntamos al siguiente dato</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>             <span class="co1">; Apuntamos al siguiente destino</span>
&nbsp;
  <span class="kw1">DJNZ</span> bucle         <span class="co1">; Equivale a:</span>
                     <span class="co1">; B = B-1</span>
                     <span class="co1">; if (B&gt;0) goto Bucle</span>
  <span class="kw1">RET</span>
&nbsp;
datos DEFB <span class="re1">1</span><span class="nu0">27</span>, <span class="re1">%10101010</span>, <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">28</span>, <span class="sy0">$</span>FE, <span class="re1">%10000000</span>, FFh
&nbsp;
END</pre>

<p>
Algunos detalles a tener en cuenta:
</p>
<ul class="fix-media-list-overlap">
<li> Se utiliza una instrucción por línea.
</li>
<li> Los comentarios pueden ir en sus propias líneas, o dentro de líneas de instrucciones (tras ellas).
</li>
<li> Podemos definir “constantes” con EQU
 para hacer referencia a ellas luego en el código. Son constantes, no
variables, es decir, se definen en tiempo de ensamblado y no se cambian
con la ejecución del programa. Su uso está pensado para poder escribir
código más legible y que podamos cambiar los valores asociados
posteriormente de una forma sencilla (es más fácil cambiar el valor
asignado en el EQU, que cambiar un valor en todas sus apariciones en el
código).
</li>
<li> Podemos poner etiquetas (como
“bucle” y “datos” -con o sin dos puntos, son ignorados-) para
referenciar a una posición de memoria. Así, la etiqueta “bucle” del
programa anterior hace referencia a la posición de memoria donde se
ensamblaría la siguiente instrucción que aparece tras ella. Las
etiquetas se usan para poder saltar a ellas (en los bucles y
condiciones) mediante un nombre en lugar de tener que calcular nosotros
la dirección del salto a mano y poner direcciones de memoria. Es más
fácil de entender y programar un “JP bucle” que un “JP $40008”, por
ejemplo. En el caso de la etiqueta “datos”, nos permite referenciar la
posición en la que empiezan los datos que vamos a copiar.
</li>
<li> Los datos definidos con DEFB pueden
estar en cualquier formato numérico, como se ha mostrado en el ejemplo:
decimal, binario, hexadecimal tanto con prefijo “$” como con sufijo “h”,
 etc.
</li>
</ul>

<p>
Podéis ensamblar el ejemplo anterior mediante:
</p>
<pre class="code">pasmo --tapbas ejemplo.asm ejemplo.tap</pre>

<p>
Una vez cargado y ejecutado el TAP en el emulador de Spectrum, podréis
ejecutar el código máquina en BASIC con un “RANDOMIZE USR 40000”, y
deberéis ver una pantalla como la siguiente:
</p>

<p>
<br>

<img src="img/ejemplo1.gif" class="mediacenter" alt="Salida del ejemplo 1"/>
<br>

</p>

<p>
Los píxeles que aparecen en el centro de la pantalla (dirección de
memoria 18384) se corresponden con los valores numéricos que hemos
definido en “datos”, ya que los hemos copiado desde “datos” hasta la
videomemoria. No os preocupéis por ahora si no entendéis alguna de las
instrucciones utilizadas, las iremos viendo poco a poco y al final
tendremos una visión global y concreta de todas ellas.
</p>

<p>
 Si cambiáis el END del programa por END 40000, no tendréis la necesidad
 de ejecutar RANDOMIZE USR 40000 ya que pasmo lo introducirá en el
listado BASIC de “arranque”. El tap resultante contendrá un cargador que
 incluirá el RANDOMIZE USR 40000.
</p>

<p>
<br>

</p>

</div>

<h2 id="los-registros">Los registros</h2>
<div class="level2">

<p>
Como ya vimos en la anterior entrega, todo el “trabajo de campo” lo haremos con <em>los registros de la CPU</em>, que no son más que <em>variables de 8 y 16 bits integradas dentro del Z80</em> y que por tanto son muy rápidos para realizar operaciones con ellos.
</p>

<p>
El Z80 tiene una serie de registros de 8 bits con nombres específicos:
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>A</strong>: El Registro A
(de 8 bits) es el acumulador. Es un registro que se utiliza generalmente
 como destino de muchas operaciones aritméticas y de comparaciones y
testeos.</div>
</li>
<li class="level2"><div class="li"> <strong>B, C, D, E, H, L</strong>: Registros de propósito general, utilizables para gran cantidad de operaciones, almacenamiento de valores, etc.</div>
</li>
<li class="level2"><div class="li"> <strong>I</strong>: Registro de
interrupción, no lo utilizaremos en nuestros primeros programas. No
debemos modificar su valor, aunque en el futuro veremos su uso en las
interrupciones del Spectrum.</div>
</li>
<li class="level2"><div class="li"> <strong>R</strong>: Registro de
Refresco de memoria: lo utiliza internamente la CPU para saber cuándo
debe refrescar la RAM. Su valor cambia sólo conforme el Z80 va
ejecutando instrucciones, de modo que podemos utilizarlo (leerlo) para
obtener valores pseudo-aleatorios entre 0 y 127 (el Z80 no cambia el bit
 de mayor peso de R, sólo los bits del 0 al 6).</div>
</li>
</ul>

<p>
<br>

Además, podemos agrupar algunos de estos registros en pares de 16 bits para determinadas operaciones:
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>AF</strong>: Formado por el
registro A como byte más significativo (Byte alto) y por F como byte
menos significativo (Byte bajo). Si A vale $FF y F vale $00, AF valdrá
automáticamente “$FF00”.</div>
</li>
<li class="level2"><div class="li"> <strong>BC</strong>: Agrupación de
los registros B y C que se puede utilizar en bucles y para acceder a
puertos. También se utiliza como “repetidor” o “contador” en las
operaciones de acceso a memoria (LDIR, LDDR, etc.).</div>
</li>
<li class="level2"><div class="li"> <strong>DE, HL</strong>: Registros
de 16 bits formados por D y E por un lado y H y L por otro. Utilizaremos
 generalmente estos registros para leer y escribir en memoria en una
operación única, así como para las operaciones de acceso a memoria como
LDIR, LDDR, etc.</div>
</li>
</ul>

<p>
<br>

Aparte de estos registros, existen otra serie de registros de 16 bits:
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>IX, IY</strong>: Dos
registros de 16 bits pensados para acceder a memoria de forma indexada.
Gracias a estos registros podemos realizar operaciones como: “LD
(IX+desplazamiento), VALOR”. Este tipo de registros se suele utilizar
pues para hacer de índices dentro de tablas o vectores. El
desplazamiento es un valor numérico de 8 bits en complemento a 2, lo que
 nos permite un rango desde -128 a +127 (puede ser negativo para acceder
 a posiciones de memoria anteriores a IX).</div>
</li>
<li class="level2"><div class="li"> <strong>SP</strong>: Puntero de pila, como veremos en su momento apunta a la posición actual de la “cabeza” de la pila.</div>
</li>
<li class="level2"><div class="li"> <strong>PC</strong>: Program Counter
 o Contador de Programa. Como ya vimos en la anterior entrega, contiene
la dirección de la instrucción actual a ejecutar. No modificaremos PC
directamente moviendo valores a este registro, sino que lo haremos
mediante instrucciones de salto (JP, JR, CALL…).</div>
</li>
</ul>

<p>
<br>

 Por último, tenemos disponible un banco alternativo de registros, conocidos como <em>Shadow Registers</em> o <em>Registros Alternativos</em>, que se llaman igual que sus equivalentes principales pero con una comilla simple detrás: A', F', B', C', D'. E', H' y L'.
</p>

<p>
En cualquier momento podemos intercambiar el valor de los registros A,
B, C, D, E, F, H y L con el valor de los registros A', B', C', D', E',
F', H' y L' mediante la instrucción de ensamblador “<strong>EXX</strong>”.
 La utilidad de estos Shadow Registers es almacenar valores temporales y
 proporcionarnos más registros para operar: podremos intercambiar el
valor de los registros actuales con los temporales, realizar operaciones
 con los registros sin perder los valores originales (que al hacer el
EXX se quedarán en los registros Shadow), y después recuperar los
valores originales volviendo a ejecutar un EXX.
</p>

<p>
Ya conocemos los registros disponibles, veamos ahora ejemplos de operaciones típicas que podemos realizar con ellos:
</p>
<ul class="fix-media-list-overlap">
<li> Meter valores en registros (ya sean valores numéricos directos, de memoria, o de otros registros).
</li>
<li class="level2"> Incrementar o decrementar los valores de los registros.
</li>
<li class="level2"> Realizar operaciones (tanto aritméticas como lógicas) entre los registros.
</li>
<li class="level2"> Acceder a memoria para escribir o leer.
</li>
</ul>

<p>
Por ejemplo, las siguientes instrucciones en ensamblador serían válidas:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="sy0">$</span><span class="re1">00</span>       <span class="co1">; C vale 0</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="sy0">$</span><span class="re1">01</span>       <span class="co1">; B vale 1</span>
                  <span class="co1">; con esto, BC = $0100</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>         <span class="co1">; A ahora vale 1</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">234</span>    <span class="co1">; HL vale $1234 o 4660d</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>      <span class="co1">; A contiene el valor de (4660)</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="re1">1</span><span class="nu0">6384</span><span class="br0">)</span>   <span class="co1">; A contiene el valor de (16384)</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="re1">1</span><span class="nu0">6385</span><span class="br0">)</span>, <span class="kw2">A</span>   <span class="co1">; Escribimos en (16385) el valor de A</span>
  <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>        <span class="co1">; Suma: A = A + B</span>
  <span class="kw1">INC</span> <span class="kw2">B</span>           <span class="co1">; Incrementamos B (B = 1+1 =2)</span>
                  <span class="co1">; Ahora BC vale $0200</span>
  <span class="kw1">INC</span> <span class="kw2">BC</span>          <span class="co1">; Incrementamos BC</span>
                  <span class="co1">; (BC = $0200+1 = $0201)</span></pre>

<p>
 Dentro del ejemplo anterior queremos destacar el operador “()”, que
significa “el contenido de la memoria apuntado por”. Así, “LD A,
(16384)” no quiere decir “mete en A el valor 16384” (cosa que además no
se puede hacer porque A es un registro de 8 bits), sino “mete en A el
valor de 8 bits que contiene la celdilla de memoria 16384” (equivalente a
 utilizar en BASIC las funciones PEEK y POKE, como en LET A=PEEK 16384).
</p>

<p>
Cabe destacar un gran inconveniente del juego de instrucciones del Z80, y es que no es <em>ortogonal</em>.
 Se dice que el juego de instrucciones de un microprocesador es
ortogonal cuando puedes realizar todas las operaciones sobre todos los
registros, sin presentar excepciones. En el caso del Z80 no es así, ya
que hay determinadas operaciones que podremos realizar sobre unos
registros pero no sobre otros.
</p>

<p>
Así, si el Z80 fuera ortogonal, podríamos ejecutar cualquiera de estas operaciones:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">234</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>
  <span class="kw1">LD</span> <span class="kw2">SP</span>, <span class="kw2">BC</span>
  <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>
  <span class="kw1">EX</span> <span class="kw2">BC</span>, <span class="kw2">DE</span>
  <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>
  <span class="kw1">ADD</span> <span class="kw2">DE</span>, <span class="kw2">BC</span></pre>

<p>
Sin embargo, como el Z80 no tiene un juego de instrucciones (J.I. desde
este momento) ortogonal, hay instrucciones del ejemplo anterior que no
son válidas, es decir, que no tienen dentro de la CPU un microcódigo
para que el Z80 sepa qué hacer con ellas:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">SP</span>, <span class="kw2">BC</span>      <span class="co1">; NO: No se puede cargar el valor un registro en SP,</span>
                <span class="co1">; sólo se puede cargar un valor inmediato NN</span>
&nbsp;
 <span class="kw1">EX</span> <span class="kw2">BC</span>, <span class="kw2">DE</span>      <span class="co1">; NO: Existe EX DE, HL, pero no EX BC, DE</span>
&nbsp;
 <span class="kw1">ADD</span> <span class="kw2">DE</span>, <span class="kw2">BC</span>     <span class="co1">; NO: Sólo se puede usar HL como operando destino</span>
                <span class="co1">; en las sumas de 16 bytes con registros de propósito</span>
                <span class="co1">; general. Una alternativa sería:</span>
                <span class="co1">;</span>
                <span class="co1">; LD HL, 0        ; HL = 0</span>
                <span class="co1">; ADD HL, BC      ; HL = HL + BC</span>
                <span class="co1">; EX DE, HL       ; Intercambiamos el valor de HL y DE</span>
&nbsp;
 <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="kw2">DE</span>      <span class="co1">; NO:, pero se pueden tomar alternativas, como por ej:</span>
                <span class="co1">;</span>
                <span class="co1">; PUSH DE</span>
                <span class="co1">; POP BC</span>
&nbsp;
 <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>      <span class="co1">; NO: mismo caso anterior.</span>
&nbsp;
 <span class="kw1">LD</span> <span class="kw2">SP</span>, <span class="kw2">BC</span>      <span class="co1">; NO: no existe como instrucción.</span></pre>

<p>
La única solución para programar sin tratar de utilizar instrucciones no
 permitidas es la práctica: con ella acabaremos conociendo qué
operaciones podemos realizar y sobre qué registros se pueden aplicar, y
realizaremos nuestros programas con estas limitaciones en mente. Iremos
viendo las diferentes excepciones caso a caso, pero podemos encontrar
las nuestras propias gracias a los errores que nos dará el ensamblador
al intentar ensamblar un programa con una instrucción que no existe para
 el Z80.
</p>

<p>
No os preocupéis: es sólo una cuestión de práctica. Tras haber realizado
 varios programas en ensamblador ya conoceréis, prácticamente de
memoria, qué instrucciones son válidas para el microprocesador y cuáles
no.
</p>

<p>
<br>

</p>

</div>

<h2 id="el-registro-de-flags">El registro de flags</h2>
<div class="level2">

<p>
Hemos hablado del registro de 8 bits F como un registro especial. La particularidad de <em>F</em> es que <em>no es un registro de propósito general</em>
 donde podamos introducir valores a voluntad, sino que los diferentes
bits del registro F tienen un significado propio que cambia
automáticamente según el resultado de operaciones anteriores.
</p>

<p>
Por ejemplo, uno de los bits del registro F, el bit nº 6, es conocido
como “Zero Flag”, y nos indica si el resultado de la última operación
(para determinadas operaciones, como las aritméticas o las de
comparación) es cero o no es cero. Si el resultado de la anterior
operación resultó cero, este FLAG se pone a uno. Si no resultó cero, el
flag se pone a cero.
</p>

<p>
¿Para qué sirve pues un flag así? Para gran cantidad de tareas, por
ejemplo para bucles (repetir X veces una misma tarea poniendo el
registro BC al valor X, ejecutando el mismo código hasta que BC sea
cero), o para comparaciones (mayor que, menor que, igual que).
</p>

<p>
Veamos los diferentes registros de flags (bits del registro F) y su utilidad:
</p>

<p>
<br>

<img src="img/registrof.gif" class="mediacenter" alt="Los indicadores de flag del registro F"/>
<br>

</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Flag S (sign o signo)</strong>:
 Este flag se pone a uno si el resultado de la operación realizada en
complemento a dos es negativo (es una copia del bit más significativo
del resultado). Si por ejemplo realizamos una suma entre 2 números en
complemento a dos y el resultado es negativo, este bit se pondrá a uno.
Si el resultado es positivo, se pondrá a cero. Es útil para realizar
operaciones matemáticas entre múltiples registros: por ejemplo, si nos
hacemos una rutina de multiplicación o división de números que permita
números negativos, este bit nos puede ser útil en alguna parte de la
rutina.</div>
</li>
<li class="level2"><div class="li"> <strong>Flag Z (zero o cero)</strong>:
 Este flag se pone a uno si el resultado de la última operación que
afecte a los flags es cero. Por ejemplo, si realizamos una operación
matemática y el resultado es cero, se pondrá a uno. Este flag es uno de
los más útiles, ya que podemos utilizarlo para múltiples tareas. La
primera es para los bucles, ya que podremos programar código como:</div>
</li>
</ul>
<pre class="code z80">            <span class="co1">; Repetir algo 100 veces</span>
            <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">100</span>
    bucle:
            <span class="br0">(</span>...<span class="br0">)</span>        <span class="co1">; código</span>
&nbsp;
            <span class="kw1">DEC</span> <span class="kw2">B</span>        <span class="co1">; Decrementamos B (B=B-1)</span>
            <span class="kw1">JR</span> NZ, bucle
            <span class="co1">; Si el resultado de la operación anterior no es cero (NZ = Non Zero), </span>
            <span class="co1">; saltar a la etiqueta bucle y continuar. DEC B hará que el flag Z </span>
            <span class="co1">; se ponga a 1 cuando B llegue a cero, lo que afectará al JR NZ.</span>
            <span class="co1">; Como resultado, este trozo de código (...) se ejecutará 100 veces.</span></pre>

<p>
 Como veremos en su momento, existe una instrucción equivalente a DEC B +
 JR NZ que es más cómoda de utilizar y más rápida que estas 2
instrucciones juntas (DJNZ), pero se ha elegido el ejemplo que tenéis
arriba para que veáis cómo muchas operaciones (en este caso DEC) afectan
 a los flags, y la utilidad que estos tienen a la hora de programar.
</p>

<p>
Además de para bucles, también podemos utilizarlo para comparaciones.
Supongamos que queremos hacer en ensamblador una comparación de
igualdad, algo como:
</p>
<pre class="code">   IF C = B THEN GOTO 1000
   ELSE          GOTO 2000</pre>

<p>
 Si restamos C y B y el resultado es cero, es que ambos registros contienen el mismo valor:
</p>
<pre class="code z80">     <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>              <span class="co1">; A = C</span>
     <span class="co1">; Tenemos que hacer esto porque no existe</span>
     <span class="co1">; una instruccion SUB B, C . Sólo se puede</span>
     <span class="co1">; restar un registro al registro A.</span>
&nbsp;
     <span class="kw1">SUB</span> <span class="kw2">B</span>                <span class="co1">; A = A-B</span>
     <span class="kw1">JP</span> Z, Es_Igual       <span class="co1">; Si A=B la resta es cero y Z=1</span>
     <span class="kw1">JP</span> NZ, No_Es_Igual   <span class="co1">; Si A&lt;&gt;B la resta no es cero y Z=0</span>
     <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
    Es_Igual:
     <span class="br0">(</span>...<span class="br0">)</span>
    No_Es_Igual:
     <span class="br0">(</span>...<span class="br0">)</span></pre>

<p>
 Existe una instrucción específica para realizar comparaciones: CP, que
es similar a SUB pero que no altera el valor de A. Hablaremos de CP con
más detalle en su momento.
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Flag H (Half-carry o Acarreo-BCD)</strong>: Se pone a uno cuando en operaciones BCD existe un acarreo del bit 3 al bit 4.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Flag P/V (Parity/Overflow o Paridad/Desbordamiento)</strong>:
 En las operaciones que modifican el bit de paridad, este bit vale 1 si
el número de unos del resultado de la operación es par, y 0 si es impar.
 Si, por contra, el resultado de la operación realizada necesita más
bits para ser representado de los que nos provee el registro, tendremos
un desbordamiento, con este flag a 1. Este mismo bit sirve pues para 2
tareas, y nos indicará una u otra (paridad o desbordamiento) según sea
el tipo de operación que hayamos realizado. Por ejemplo, tras una suma,
su utilidad será la de indicar el desbordamiento. <br>
El flag de desbordamiento se activará cuando en determinadas operaciones
 pasemos de valores 11111111b a 00000000b, por “falta de bits” para
representar el resultado o viceversa . Por ejemplo, en el caso de INC y
DEC con registros de 8 bits, si pasamos de 0 a 255 o de 255 a 0.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Flag N (Substract o Resta)</strong>: Se pone a 1 si la última operación realizada fue una resta. Se utiliza en operaciones aritméticas.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Flag C (Carry o Acarreo)</strong>:
 Este flag se pone a uno si el resultado de la operación anterior no
cupo en el registro y necesita un bit extra para ser representado. Este
bit es ese bit extra. Veremos su uso cuando tratemos las operaciones
aritméticas, en esta misma entrega.</div>
</li>
</ul>

<p>
Así pues, resumiendo:
</p>
<ul class="fix-media-list-overlap">
<li> El registro F es un registro cuyo
valor no manejamos directamente, sino que cada uno de sus bits tiene un
valor especial y está a 1 o a 0 según ciertas condiciones de la última
operación realizada que afecte a dicho registro.
</li>
<li class="level2"> Por ejemplo, si realizamos una
operación y el resultado de la misma es cero, se pondrá a 1 el flag de
Zero (Z) del registro F, que no es más que su bit número 6.
</li>
<li class="level2"> No todas las operaciones afectan a
los flags, iremos viendo qué operaciones afectan a qué flags conforme
avancemos en el curso, en el momento en que se estudia cada instrucción.
</li>
<li class="level2"> Existen operaciones que se pueden
ejecutar con el estado de los flags como condición. Por ejemplo,
realizar un salto a una dirección de memoria si un determinado flag está
 activo, o si no lo está.
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="instrucciones-ld-instrucciones-de-carga">Instrucciones LD (instrucciones de carga)</h2>
<div class="level2">

<p>
Las operaciones que más utilizaremos en nuestros programas en
ensamblador serán sin duda las operaciones de carga o instrucciones <strong>LD</strong>. Estas operaciones sirven para:
</p>
<ul class="fix-media-list-overlap">
<li> Meter un valor en un registro.
</li>
<li class="level2"> Copiar el valor de un registro en otro registro.
</li>
<li class="level2"> Escribir en memoria (en una dirección determinada) un valor.
</li>
<li class="level2"> Escribir en memoria (en una dirección determinada) el contenido de un registro.
</li>
<li class="level2"> Asignarle a un registro el contenido de una dirección de memoria.
</li>
</ul>

<p>
La sintaxis de LD en lenguaje ensamblador es:
</p>
<pre class="code z80"> <span class="kw1">LD</span> DESTINO, ORIGEN</pre>

<p>
Así, gracias a las operaciones LD podemos:
</p>
<ul class="fix-media-list-overlap">
<li> Asignar a un registro un valor numérico directo de 8 o 16 bits.
</li>
</ul>
<pre class="code z80">        <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">10</span>         <span class="co1">; A = 10</span>
        <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">2</span><span class="re1">00</span>        <span class="co1">; B = 200</span>
        <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1</span><span class="nu0">2345</span>     <span class="co1">; BC = 12345</span></pre>
<ul class="fix-media-list-overlap">
<li> Copiar el contenido de un registro a otro registro:
</li>
</ul>
<pre class="code z80">        <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>          <span class="co1">; A = B</span>
        <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="kw2">DE</span>        <span class="co1">; BC = DE</span></pre>
<ul class="fix-media-list-overlap">
<li> Escribir en posiciones de memoria:
</li>
</ul>
<pre class="code z80">        <span class="kw1">LD</span> <span class="br0">(</span><span class="re1">1</span><span class="nu0">2345</span><span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; Memoria[12345] = valor en A</span>
        <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="re1">10</span>      <span class="co1">; Memoria[valor de HL] = 10</span></pre>
<ul class="fix-media-list-overlap">
<li> Leer el contenido de posiciones de memoria:
</li>
</ul>
<pre class="code z80">        <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="re1">1</span><span class="nu0">2345</span><span class="br0">)</span>    <span class="co1">; A = valor en Memoria[12345]</span>
        <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>       <span class="co1">; B = valor en Memoria[valor de HL]</span></pre>

<p>
 Nótese cómo el operador () nos permite acceder a memoria. En nuestros
ejemplos, LD A, (12345) no significa meter en A el valor 12345 (cosa
imposible al ser un registro de 16 bits) sino almacenar en el registro A
 el valor que hay almacenado en la celdilla número 12345 de la memoria
del Spectrum.
</p>

<p>
En un microprocesador con un juego de instrucciones ortogonal, se podría
 usar cualquier origen y cualquier destino sin distinción. En el caso
del Z80 no es así. El listado completo de operaciones válidas con LD es
el siguiente:
</p>

<p>
Leyenda:
</p>
<pre class="code"> N  = valor numérico directo de 8 bits (0-255)
 NN = valor numérico directo de 16 bits (0-65535)
 r  = registro de 8 bits (A, B, C, D, E, H, L)
 rr = registro de 16 bits (BC, DE, HL, SP)
 ri = registro índice (IX o IY).
 d  = desplazamiento respecto a un registro índice.</pre>

<p>
Listado:
</p>
<pre class="code z80"> <span class="co1">; Carga de valores en registros</span>
 <span class="kw1">LD</span> r, N
 <span class="kw1">LD</span> <span class="kw1">rr</span>, NN
 <span class="kw1">LD</span> ri, NN
&nbsp;
 <span class="co1">; Copia de un registro a otro</span>
 <span class="kw1">LD</span> r, r
 <span class="kw1">LD</span> <span class="kw1">rr</span>, <span class="kw1">rr</span>
&nbsp;
 <span class="co1">; Acceso a memoria</span>
 <span class="kw1">LD</span> r, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
 <span class="kw1">LD</span> <span class="br0">(</span>NN<span class="br0">)</span>, <span class="kw2">A</span>
 <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, N
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw1">rr</span><span class="br0">)</span>      <span class="co1">; (excepto rr=SP)</span>
 <span class="kw1">LD</span> <span class="br0">(</span><span class="kw1">rr</span><span class="br0">)</span>, <span class="kw2">A</span>      <span class="co1">; (excepto rr=SP)</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>NN<span class="br0">)</span>
 <span class="kw1">LD</span> <span class="kw1">rr</span>, <span class="br0">(</span>NN<span class="br0">)</span>
 <span class="kw1">LD</span> ri, <span class="br0">(</span>NN<span class="br0">)</span>
 <span class="kw1">LD</span> <span class="br0">(</span>NN<span class="br0">)</span>, <span class="kw1">rr</span>
 <span class="kw1">LD</span> <span class="br0">(</span>NN<span class="br0">)</span>, ri
&nbsp;
 <span class="co1">; Acceso indexado a memoria</span>
 <span class="kw1">LD</span> <span class="br0">(</span>ri<span class="sy0">+</span>N<span class="br0">)</span>, r
 <span class="kw1">LD</span> r, <span class="br0">(</span>ri<span class="sy0">+</span>N<span class="br0">)</span>
 <span class="kw1">LD</span> <span class="br0">(</span>ri<span class="sy0">+</span>N<span class="br0">)</span>, N</pre>

<p>
Además, tenemos una serie de casos “especiales”:
</p>
<pre class="code z80"> <span class="co1">; Manipulación del puntero de pila (SP)</span>
 <span class="kw1">LD</span> <span class="kw2">SP</span>, ri
 <span class="kw1">LD</span> <span class="kw2">SP</span>, <span class="kw2">HL</span>
&nbsp;
 <span class="co1">; Para manipular el registro I</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, I
 <span class="kw1">LD</span> I, <span class="kw2">A</span>
&nbsp;
 <span class="co1">; Para manipular el registro R</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, R
 <span class="kw1">LD</span> R, <span class="kw2">A</span></pre>

<p>
Veamos ejemplos válidos y cuál sería el resultado de su ejecución:
</p>
<pre class="code z80"> <span class="co1">; Carga de valores en registros</span>
 <span class="co1">; registro_destino = valor</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">100</span>          <span class="co1">; LD r, N</span>
 <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1</span><span class="nu0">2345</span>       <span class="co1">; LD rr, NN</span>
&nbsp;
 <span class="co1">; Copia de registros en registros</span>
 <span class="co1">; registro_destino = registro_origen</span>
 <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">C</span>            <span class="co1">; LD r, r</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; LD r, r</span>
 <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="kw2">DE</span>          <span class="co1">; LD rr, rr</span>
&nbsp;
 <span class="co1">; Acceso a memoria</span>
 <span class="co1">; (Posicion_memoria) = VALOR o bien</span>
 <span class="co1">;  Registro = VALOR en (Posicion de memoria)</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>         <span class="co1">; LD r, (rr)</span>
 <span class="kw1">LD</span> <span class="br0">(</span>BL<span class="br0">)</span>, <span class="kw2">B</span>         <span class="co1">; LD (rr), r</span>
 <span class="kw1">LD</span> <span class="br0">(</span><span class="re1">1</span><span class="nu0">2345</span><span class="br0">)</span>, <span class="kw2">A</span>      <span class="co1">; LD (NN), A</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>         <span class="co1">; LD r, (rr)</span>
 <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; LD (rr), r</span>
 <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">BC</span><span class="br0">)</span>, <span class="re1">1</span>234h     <span class="co1">; LD (BC), NN</span>
 <span class="kw1">LD</span> <span class="br0">(</span><span class="re1">1</span><span class="nu0">2345</span><span class="br0">)</span>, <span class="kw2">DE</span>     <span class="co1">; LD (NN), rr</span>
 <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="br0">(</span><span class="re1">1</span><span class="nu0">2345</span><span class="br0">)</span>     <span class="co1">; LD ri, (NN)</span>
 <span class="kw1">LD</span> <span class="br0">(</span><span class="nu0">34567</span><span class="br0">)</span>, <span class="kw2">IY</span>     <span class="co1">; LD (NN), ri</span>
&nbsp;
 <span class="co1">; Acceso indexado a memoria</span>
 <span class="co1">; (Posicion_memoria) = VALOR o VALOR = (Posicion_memoria)</span>
 <span class="co1">; Donde la posicion es IX+N o IY+N:</span>
 <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">10</span><span class="br0">)</span>, <span class="kw2">A</span>      <span class="co1">; LD (ri+N), r</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IY</span><span class="sy0">+</span><span class="re1">100</span><span class="br0">)</span>     <span class="co1">; LD r, (ri+N)</span>
 <span class="kw1">LD</span> <span class="br0">(</span>IX<span class="sy0">-</span><span class="nu0">3</span><span class="re1">0</span><span class="br0">)</span>, <span class="re1">100</span>    <span class="co1">; LD (ri+N), N</span></pre>

<p>
 Hagamos hincapié de nuevo en el mismo detalle: debido a que el juego de
 instrucciones del Z80 no es ortogonal, en ocasiones no podemos ejecutar
 ciertas operaciones que podrían sernos útiles con determinados
registros. En ese caso tendremos que buscar una solución mediante los
registros y operaciones válidas de que disponemos.
</p>

<p>
 Un detalle muy importante respecto a las instrucciones de carga: en el
caso de las operaciones LD, el registro F no ve afectado ninguno de sus
indicadores o flags en relación al resultado de la ejecución de las
mismas (salvo en el caso de “LD A, I” y “LD A, R”).
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   LD r, r           |- - - - - -|
   LD r, N           |- - - - - -|
   LD rr, rr         |- - - - - -|
   LD (rr), N        |- - - - - -|
   LD (rr), N        |- - - - - -|
   LD ri, (NN)       |- - - - - -|
   LD (NN), ri       |- - - - - -|
   LD (ri+d), N      |- - - - - -|
   LD (ri+d), r      |- - - - - -|
   LD r, (ri+d)      |- - - - - -|
   LD A, I           |* * 0 * 1 0|
   LD A, R           |* * 0 * 1 0|</pre>

<p>
Esto quiere decir que una operación como “LD A, 0”, por ejemplo, no activará el flag de Zero del registro F.
</p>

<p>
<br>

</p>

</div>

<h2 id="cpu-z80low-endian">CPU Z80: Low Endian</h2>
<div class="level2">

<p>
 Un detalle curioso sobre el Z80 es que a la hora de trabajar con datos
de 16 bits (por ejemplo, leer o escribir de memoria) conviene tener en
cuenta que nuestro Z80 es una CPU del tipo <em>LOW-ENDIAN</em>, es decir, que si almacenamos en la posición de memoria 5000h el valor “$1234”, el contenido de las celdillas de memoria sería:
</p>
<div class="table-responsive sectionedit9"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Posición </th><th class="col1"> Valor </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> $5000 </td><td class="col1"> $34 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> $5001 </td><td class="col1"> $12 </td>
	</tr>
</tbody></table></div>

<p>
 En otro tipo de procesadores del tipo <em>BIG-ENDIAN</em>, los bytes aparecerían escritos en memoria de la siguiente forma:
</p>
<div class="table-responsive sectionedit10"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Posición </th><th class="col1"> Valor </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> $0000 </td><td class="col1"> $12 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> $0001 </td><td class="col1"> $34 </td>
	</tr>
</tbody></table></div>

<p>
 Debemos tener en cuenta este dato a la hora de escribir valores de 16
bits en memoria y recuperarlos posteriormente mediante operaciones de
acceso a la memoria.
</p>

<p>
<br>

</p>

</div>

<h2 id="incrementos-y-decrementos">Incrementos y decrementos</h2>
<div class="level2">

<p>
Entre las operaciones disponibles, tenemos la posibilidad de incrementar (<strong>INC</strong>) y decrementar (<strong>DEC</strong>)
 en 1 unidad el contenido de determinados registros de 8 y 16 bits, así
como de posiciones de memoria apuntadas por HL o por IX/IY más un offset
 (desplazamiento de 8 bits).
</p>

<p>
Por ejemplo:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>      <span class="co1">; A = 0</span>
 <span class="kw1">INC</span> <span class="kw2">A</span>        <span class="co1">; A = A+1 = 1</span>
 <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>      <span class="co1">; B = A = 1</span>
 <span class="kw1">INC</span> <span class="kw2">B</span>        <span class="co1">; B = B+1 = 2</span>
 <span class="kw1">INC</span> <span class="kw2">B</span>        <span class="co1">; B = B+1 = 3</span>
 <span class="kw1">LD</span>  <span class="kw2">BC</span>, <span class="re1">0</span>
 <span class="kw1">INC</span> <span class="kw2">BC</span>       <span class="co1">; BC = 0001h</span>
 <span class="kw1">INC</span> <span class="kw2">B</span>        <span class="co1">; BC = 0101h (ya que B=B+1 y es la parte alta)</span>
 <span class="kw1">DEC</span> <span class="kw2">A</span>        <span class="co1">; A = A-1 = 0</span></pre>

<p>
Veamos las operaciones INC y DEC permitidas:
</p>
<pre class="code z80">   <span class="kw1">INC</span> r
   <span class="kw1">DEC</span> r
   <span class="kw1">INC</span> <span class="kw1">rr</span>
   <span class="kw1">DEC</span> <span class="kw1">rr</span></pre>

<p>
 Donde r puede ser A, B, C, D, E, H o L, y 'rr' puede ser BC, DE, HL,
SP, IX o IY. Esta instrucción incrementa o decrementa el valor contenido
 en el registro especificado.
</p>
<pre class="code z80">   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">DEC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span></pre>

<p>
 Incrementa o decrementa el byte que contiene la dirección de memoria apuntada por HL.
</p>
<pre class="code z80">   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span>N<span class="br0">)</span>
   <span class="kw1">DEC</span> <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span>N<span class="br0">)</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">IY</span><span class="sy0">+</span>N<span class="br0">)</span>
   <span class="kw1">DEC</span> <span class="br0">(</span><span class="kw2">IY</span><span class="sy0">+</span>N<span class="br0">)</span></pre>

<p>
 Incrementa o decrementa el byte que contiene la dirección de memoria
resultante de sumar el valor del registro IX o el registro IY con un
valor numérico de 8 bits en complemento a dos.
</p>

<p>
Por ejemplo, las siguientes instrucciones serían válidas:
</p>
<pre class="code z80"> <span class="kw1">INC</span> <span class="kw2">A</span>          <span class="co1">; A = A+1</span>
 <span class="kw1">DEC</span> <span class="kw2">B</span>          <span class="co1">; B = B-1</span>
 <span class="kw1">INC</span> <span class="kw2">DE</span>         <span class="co1">; DE = DE+1</span>
 <span class="kw1">DEC</span> <span class="kw2">IX</span>         <span class="co1">; IX = IX-1</span>
 <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>       <span class="co1">; (HL) = (HL)+1</span>
 <span class="kw1">INC</span> <span class="br0">(</span>IX<span class="sy0">-</span><span class="nu0">5</span><span class="br0">)</span>     <span class="co1">; (IX-5) = (IX-5)+1</span>
 <span class="kw1">DEC</span> <span class="br0">(</span><span class="kw2">IY</span><span class="sy0">+</span><span class="re1">100</span><span class="br0">)</span>   <span class="co1">; (IY+100) = (IY+100)+1</span></pre>

<p>
Unos apuntes sobre la afectación de los flags ante el uso de INC y DEC:
</p>
<ul class="fix-media-list-overlap">
<li> Si un registro de 8 bits vale 255 ($FF) y lo incrementamos, pasará a valer 0.
</li>
<li class="level2"> Si un registro de 16 bits vale 65535 ($FFFF) y lo incrementamos, pasará a valer 0.
</li>
<li class="level2"> Si un registro de 8 bits vale 0 y lo decrementamos, pasará a valer 255 ($FF).
</li>
<li class="level2"> Si un registro de 16 bits vale 0 ($0) y lo decrementamos, pasará a valer 65535 ($FF).
</li>
<li class="level2"> En estos desbordamientos no se
tomará en cuenta para nada el bit de Carry (acarreo) de los flags
(registro F), ni tampoco lo afectarán tras ejecutarse.
</li>
<li class="level2"> Las operaciones INC y DEC sobre
registros de 16 bits (BC, DE, HL, IX, IY, SP) no afectan a los flags.
Esto implica que no podemos usar como condición de flag zero para un
salto el resultado de instrucciones como “DEC BC”, por ejemplo.
</li>
<li class="level2"> Las operaciones INC y DEC sobre
registros de 8 bits y sobre la memoria no afectan al flag de acarreo,
pero sí que pueden afectar al flag de Zero (Z), al de Paridad/Overflow
(P/V), al de Signo (S) y al de Half-Carry (H).
</li>
</ul>

<p>
Lo siguiente que vamos a ver es una tabla de afectación de flags (que
encontraremos en muchas tablas de instrucciones del Z80, y a las que
conviene ir acostumbrandose). Esta tabla indica cómo afecta cada
instrucción a cada uno de los flags:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   INC r             |* * * V 0 -|
   INC [HL]          |* * * V 0 -|
   INC [ri+N]        |* * * V 0 -|
   INC rr            |- - - - - -|
   DEC r             |* * * V 1 -|
   DEC rr            |- - - - - -|</pre>

<p>
 Donde:
</p>
<pre class="code"> r = registro de 8 bits
 rr = registro de 16 bits (BC, DE, HL, IX, IY)
 ri = registro índice (IX, IY)
 N = desplazamiento de 8 bits (entre -128 y +127).</pre>

<p>
 Y respecto a los flags:
</p>
<pre class="code"> - = El flag NO se ve afectado por la operación.
 * = El flag se ve afectado por la operación acorde al resultado.
 0 = El flag se pone a cero.
 1 = El flag se pone a uno.
 V = El flag se comporta como un flag de Overflow acorde al resultado.
 ? = El flag toma un valor indeterminado.</pre>

<p>
<br>

</p>

</div>

<h2 id="operaciones-matematicas">Operaciones matematicas</h2>
<div class="level2">

<p>
 Las operaciones aritméticas básicas para nuestro Spectrum son la suma y
 la resta, tanto con acarreo como sin él. A partir de ellas deberemos
crearnos nuestras propias rutinas para multiplicar, dividir, etc.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit13" id="sumaadd-add">Suma: ADD (Add)</h3>
<div class="level3">

<p>
Nuestro microprocesador Z80 puede realizar sumas de 8 y 16 bits internamente. La instrucción utilizada para ello es “<strong>ADD</strong>” y el formato es:
</p>
<pre class="code z80"> <span class="kw1">ADD</span> DESTINO, ORIGEN</pre>

<p>
Las instrucciones disponibles para realizar sumas se reducen a:
</p>
<pre class="code z80">   <span class="kw1">ADD</span> <span class="kw2">A</span>, s
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, ss
   <span class="kw1">ADD</span> ri, <span class="kw1">rr</span></pre>

<p>
 Donde:
</p>
<pre class="code"> s:  Cualquier registro de 8 bits (A, B, C, D, E, H, L),
     cualquier valor inmediato de 8 bits (en el rango 0-255 o -128+127
     en complemento a dos), cualquier dirección de memoria apuntada por
     HL, y cualquier dirección de memoria apuntada por un registro
     índice con desplazamiento de 8 bits.
 ss: Cualquier registro de 16 bits de entre los siguientes: BC, DE, HL, SP.
 ri: Uno de los 2 registros índices (IX o IY).
 rr: Cualquier registro de 16 bits de entre los siguientes excepto el mismo
     registro índice origen: BC, DE, HL, IX, IY, SP.</pre>

<p>
Esto daría la posibilidad de ejecutar cualquiera de las siguientes instrucciones:
</p>
<pre class="code z80"> <span class="co1">; ADD A, s</span>
 <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>        <span class="co1">; A = A + B</span>
 <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="re1">100</span>      <span class="co1">; A = A + 100</span>
 <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="br0">[</span><span class="kw2">HL</span><span class="br0">]</span>     <span class="co1">; A = A + [HL]</span>
 <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="br0">[</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">10</span><span class="br0">]</span>  <span class="co1">; A = A + [IX+10]</span>
&nbsp;
 <span class="co1">; ADD HL, ss</span>
 <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>      <span class="co1">; HL = HL + BC</span>
 <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">SP</span>      <span class="co1">; HL = HL + SP</span>
&nbsp;
 <span class="co1">; ADD ri, rr</span>
 <span class="kw1">ADD</span> <span class="kw2">IX</span>, <span class="kw2">BC</span>      <span class="co1">; IX = IX + BC</span>
 <span class="kw1">ADD</span> <span class="kw2">IY</span>, <span class="kw2">DE</span>      <span class="co1">; IY = IY + DE</span>
 <span class="kw1">ADD</span> <span class="kw2">IY</span>, <span class="kw2">IX</span>      <span class="co1">; IY = IY + IX</span>
 <span class="kw1">ADD</span> <span class="kw2">IX</span>, <span class="kw2">IY</span>      <span class="co1">; IX = IX + IY</span></pre>

<p>
Por contra, estas instrucciones no serían válidas:
</p>
<pre class="code z80"> <span class="kw1">ADD</span> <span class="kw2">B</span>, <span class="kw2">C</span>      <span class="co1">; Sólo A puede ser destino</span>
 <span class="kw1">ADD</span> <span class="kw2">BC</span>, <span class="kw2">DE</span>    <span class="co1">; Sólo puede ser destino HL</span>
 <span class="kw1">ADD</span> <span class="kw2">IX</span>, <span class="kw2">IX</span>    <span class="co1">; No podemos sumar un registro índice a él mismo</span></pre>

<p>
La afectación de los flags ante las operaciones de sumas es la siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> Para “ADD A, s”, el registro N
(Substraction) se pone a 0 (lógicamente, ya que sólo se pone a uno
cuando se ha realizado una resta). El registro P/V se comporta como un
registro de Overflow e indica si ha habido overflow (desbordamiento) en
la operación. El resto de flags (Sign, Zero, Half-Carry y Carry) se
verán afectados de acuerdo al resultado de la operación de suma.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Para “ADD HL, ss” y “ADD ri, rr”, se
 pone a 0 el flag N, y sólo se verá afectado el flag de acarreo (C) de
acuerdo al resultado de la operación.
</li>
</ul>

<p>
O, en forma de tabla de afectación:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
 ADD A, s            |* * * V 0 *|
 ADD HL, ss          |- - ? - 0 *|
 ADD ri, rr          |- - ? - 0 *|</pre>

<p>
Las sumas realizadas por el Spectrum se hacen a nivel de bits, empezando
 por el bit de más a la derecha y yendo hacia la izquierda, según las
siguientes reglas:
</p>
<pre class="code"> 0 + 0 = 0
 0 + 1 = 1
 1 + 0 = 1
 1 + 1 = 10 (=0 con acarreo)</pre>

<p>
Al sumar el último bit, se actualizará el flag de acarreo si es necesario.
</p>

<p>
Por ejemplo:
</p>
<pre class="code">       *
   00000100
 + 00000101
  -----------
   00001001

  (* = acarreo de la suma del bit anterior, 1+1=10)</pre>

<p>
Si la suma del último bit (bit 7) requiere un bit extra, se utilizará el
 Carry Flag del registro F para almacenarlo. Supongamos que ejecutamos
el siguiente código:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">%10000000</span>
 <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">%10000000</span>
 <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span></pre>

<p>
El resultado de la ejecución de esta suma sería: A=128+128=256. Como 256
 (100000000b) tiene 9 bits, no podemos representar el resultado con los 8
 bits del registro A, de modo que el resultado de la suma sería
realmente: A = 00000000 y CarryFlag = 1.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit14" id="restasub-substract">Resta: SUB (Substract)</h3>
<div class="level3">

<p>
En el caso de las restas, sólo es posible realizar (de nuevo gracias a
la no ortogonalidad del J.I. del Z80) la operación “A=A-origen”, donde
“origen” puede ser cualquier registro de 8 bits, valor inmediato de 8
bits, contenido de la memoria apuntada por [HL], o contenido de la
memoria apuntada por un registro índice más un desplazamiento. El
formato de la instrucción <strong>SUB</strong> no requiere 2 operandos, ya que el registro destino sólo puede ser A:
</p>
<pre class="code z80">   <span class="kw1">SUB</span> ORIGEN</pre>

<p>
Concretamente:
</p>
<pre class="code z80">   <span class="kw1">SUB</span> r        <span class="co1">; A = A - r</span>
   <span class="kw1">SUB</span> N        <span class="co1">; A = A - N</span>
   <span class="kw1">SUB</span> <span class="br0">[</span><span class="kw2">HL</span><span class="br0">]</span>     <span class="co1">; A = A - [HL]</span>
   <span class="kw1">SUB</span> <span class="br0">[</span><span class="kw1">rr</span><span class="sy0">+</span><span class="kw2">d</span><span class="br0">]</span>   <span class="co1">; A = A - [rr+d]</span></pre>

<p>
Por ejemplo:
</p>
<pre class="code z80"> <span class="kw1">SUB</span> <span class="kw2">B</span>           <span class="co1">; A = A - B</span>
 <span class="kw1">SUB</span> <span class="re1">100</span>         <span class="co1">; A = A - 100</span>
 <span class="kw1">SUB</span> <span class="br0">[</span><span class="kw2">HL</span><span class="br0">]</span>        <span class="co1">; A = A - [HL]</span>
 <span class="kw1">SUB</span> <span class="br0">[</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">10</span><span class="br0">]</span>     <span class="co1">; A = A - [IX+10]</span></pre>

<p>
Es importante recordar que en una operación “SUB X”, la operación realizada es “A=A-X” y no “A=X-A”.
</p>

<p>
Por otra parte, con respecto a la afectación de flags, es la siguiente:
</p>
<pre class="code"> Flags:      S Z H P N C
 -----------------------
 Afectación: * * * V 1 *</pre>

<p>
Es decir, el flag de N (substraction) se pone a 1, para indicar que
hemos realizado una resta. El flag de P/V (Parity/Overflow) se convierte
 en indicar de Overflow y queda afectado por el resultado de la resta.
El resto de flags (Sign, Zero, Half-Carry y Carry) quedarán afectados de
 acuerdo al resultado de la misma (por ejemplo, si el resultado es Cero,
 se activará el Flag Z).
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit15" id="suma-con-acarreoadc-add-with-carry">Suma con acarreo: ADC (Add with carry)</h3>
<div class="level3">

<p>
Sumar con acarreo dos elementos (<strong>ADC</strong>) significa realizar la suma de uno con el otro y, posteriormente, sumarle el estado del flag de Carry. Es decir:
</p>
<pre class="code"> "ADC A, s"    equivale a    "A = A + s + CarryFlag"
 "ADC HL, ss"  equivale a    "HL = HL + ss + CarryFlag"</pre>

<p>
 (“s” y “ss” tienen el mismo significado que en ADD y SUB).
</p>

<p>
La tabla de afectación de flags sería la siguiente:
</p>
<pre class="code">                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
 ADC A,s            |* * * V 0 *|
 ADC HL,ss          |* * ? V 0 *|</pre>

<p>
La suma con acarreo se utiliza normalmente para sumar las partes altas
de elementos de 16 bits. Se suma la parte baja con ADD y luego la parte
alta con ADC para tener en cuenta el acarreo de la suma de la parte
baja.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit16" id="resta-con-acarreosbc-substract-with-carry">Resta con acarreo: SBC (Substract with carry)</h3>
<div class="level3">

<p>
Al igual que en el caso de la suma con acarreo, podemos realizar restas con acarreo (<strong>SBC</strong>), que no son más que realizar una resta de los 2 operandos, tras lo cual restamos además el valor del bit de Carry Flag:
</p>
<pre class="code"> "SBC A, s"    equivale a    "A = A - s - CarryFlag"
 "SBC HL, ss"  equivale a    "HL = HL - ss - CarryFlag"</pre>

<p>
La tabla de afectación de flags (en este caso con N=1, ya que es una resta):
</p>
<pre class="code">                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
 SBC A,s            |* * * V 1 *|
 SBC HL,ss          |* * ? V 1 *|</pre>

<p>
<br>

</p>

</div>

<h3 class="sectionedit17" id="complemento-a-dos">Complemento a dos</h3>
<div class="level3">

<p>
A lo largo del presente texto hemos hablado de números en complemento a
dos. Complemento a dos es una manera de representar números negativos en
 nuestros registros de 8 bits, utilizando para ello como signo el bit
más significativo (bit 7) del byte.
</p>

<p>
Si dicho bit está a 0, el número es positivo, y si está a 1 es negativo. Así:
</p>
<pre class="code"> 01111111    (+127)
 01111110    (+126)
 01111101    (+125)
 01111100    (+124)
 (...)
 00000100    (+4)
 00000011    (+3)
 00000010    (+2)
 00000001    (+1)
 00000000    (0)
 11111111    (-1)
 11111110    (-2)
 11111101    (-3)
 11111100    (-4)
 (...)
 10000011    (-125)
 10000010    (-126)
 10000001    (-127)
 10000000    (-128)</pre>

<p>
Podemos averiguar cuál es la versión negativa de cualquier número
positivo (y viceversa), invirtiendo el estado de los bits y sumando uno:
</p>
<pre class="code"> +17  = 00010001

 -17 =  11101110   (Invertimos unos y ceros)
     =        +1   (Sumamos 1)
     =  11101111   (-17 en complemento a dos)</pre>

<p>
Se eligió este sistema para representar los números negativos para que
las operaciones matemáticas estándar funcionaran directamente sobre los
números positivos y negativos. ¿Por qué no utilizamos directamente la
inversión de los bits para representar los números negativos y estamos
sumando además 1 para obtenerlos? Sencillo: si no sumáramos uno y
simplemente invirtiéramos los bits, tendríamos 2 ceros (00000000 y
11111111) y además las operaciones matemáticas no cuadrarían (por culpa
de los dos ceros). La gracia del complemento a dos es que las sumas y
restas binarias lógicas (ADD, ADC, SUB y SBC) funcionan:
</p>

<p>
 Sumemos -17 y 32:
</p>
<pre class="code">  -17 = 11101111
+ +32 = 00100000
 -----------------
      1 00001111</pre>

<p>
El resultado es 00001111, es decir, 15, ya que 32-17=15. El flag de
carry se pone a 1, pero lo podemos ignorar, porque el flag que nos
indica realmente el desbordamiento (como veremos a continuación) en
operaciones de complemento a dos es el flag de Overflow.
</p>

<p>
 Sumemos ahora +17 y -17:
</p>
<pre class="code">  +17 = 00010001
+ -17 = 11101111
 ----------------------
      1 00000000</pre>

<p>
Como podéis ver, al sumar +17 y -17 el resultado es 0. Si
representáramos los números negativos simplemente como la inversa de los
 positivos, esto no se podría hacer:
</p>
<pre class="code">  +17 = 00010001
+ -17 = 11101110    &lt;--- (solo bits invertidos)
 ----------------------
      1 11111111    &lt;--- Nos da todo unos, el "cero" alternativo.</pre>

<p>
En complemento a dos, las sumas y restas de números se pueden realizar a
 nivel lógico mediante las operaciones estándar del Z80. En realidad
para el Z80 no hay más que simples operaciones de unos y ceros, y somos
nosotros los que interpretamos la información de los operandos y del
resultado de una forma que nos permite representar números negativos.
</p>

<p>
En otras palabras: cuando vemos un uno en el bit más significativo de un
 resultado, somos nosotros los que tenemos que interpretar si ese bit
representa un signo negativo o no: si sabemos que estamos operando con
números 0-255, podemos tratarlo como un resultado positivo. Si estábamos
 operando con números en complemento a dos, podemos tratarlo como un
resultado en complemento a dos. Para el microprocesador, en cambio, no
hay más que unos y ceros.
</p>

<p>
Para acabar, veamos cuál es la diferencia entre el Flag de Carry (C) y
el de Overflow (V) a la hora de realizar sumas y restas. El primero (C)
se activará cuando se produzca un desbordamiento físico a la hora de
sumar o restar 2 números binarios (cuando necesitemos un bit extra para
representarlo). El segundo (V), se utilizará cuando se produzca
cualquier sobrepasamiento operando con 2 números en complemento a dos.
</p>

<p>
Como acabamos de ver, en complemento a dos el último bit (el bit 7) nos
indica el signo, y cuando operamos con 2 números binarios que nosotros
interpretamos como números en complemento a dos no nos basta con el bit
de Carry. Es el bit de Overflow el que nos dará información sobre el
desbordamiento a un nivel lógico.
</p>

<p>
 El bit de Carry se activará si pasamos de 255 a 0 o de 0 a 255
(comportándose como un bit de valor 2 elevado a 8, o 256), y el bit de
overflow lo hará si el resultado de una operación en complemento a dos
requiere más de 7 bits para ser representado.
</p>

<p>
Mediante ejemplos:
</p>

<p>
 255+1:
</p>
<pre class="code">   11111111
+  00000001
  -----------
 1 00000000

   C=1 (porque hace falta un bit extra)
   V=0</pre>

<p>
 127+1:
</p>
<pre class="code">   01111111
+  00000001
  -----------
   10000000

   C=0 (no es necesario un bit extra en el registro)
   V=1 (en complemento a dos, no podemos representar +128)</pre>

<p>
En el ejemplo anterior, V se activa porque no ha habido desbordamiento
físico (no es necesario un bit extra para representar la operación),
pero sí lógico: no podemos representar +128 con 7 bits+signo en
complemento a dos.
</p>

<p>
<br>

</p>

</div>

<h2 id="instrucciones-de-intercambio">Instrucciones de intercambio</h2>
<div class="level2">

<p>
Como ya se ha explicado, disponemos de un banco de registros
alternativos (los Shadow Registers), y podemos conmutar los valores
entre los registros estándar y los alternativos mediante unas
determinadas instrucciones del Z80.
</p>

<p>
El Z80 nos proporciona una serie de registros de propósito general (así
como un registro de flags), de nombres A, B, C, D, E, F, H y L. El micro
 dispone también de unos registros extra (set alternativo conocido como
Shadow Registers) de nombre A', B', C', D', E', F', H' y L', que
aprovecharemos en cualquier momento de nuestro programa. No obstante, no
 podremos hacer uso directo de estos registros en instrucciones en
ensamblador. No es posible, por ejemplo, ninguna de las siguientes
instrucciones:
</p>
<pre class="code"> LD B', $10
 INC A'
 LD HL', $1234
 LD A', ($1234)</pre>

<p>
La manera de utilizar estos registros alternativos es conmutar sus valores con los registros estándar mediante la instrucción “<strong>EXX</strong>”,
 cuyo resultado es el intercambio de B por B', C por C', D por D', E por
 E', H por H' y L por L'. Supongamos que tenemos los siguientes valores
en los registros:
</p>
<div class="table-responsive sectionedit19"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Registro </th><th class="col1"> Valor </th><th class="col2"> Registro </th><th class="col3"> Valor </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> B </td><td class="col1"> $A0 </td><td class="col2"> B' </td><td class="col3"> $00 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> C </td><td class="col1"> $55 </td><td class="col2"> C' </td><td class="col3"> $00 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> D </td><td class="col1"> $01 </td><td class="col2"> D' </td><td class="col3"> $00 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> E </td><td class="col1"> $FF </td><td class="col2"> E' </td><td class="col3"> $00 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> H </td><td class="col1"> $00 </td><td class="col2"> H' </td><td class="col3"> $00 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> L </td><td class="col1"> $31 </td><td class="col2"> L' </td><td class="col3"> $00 </td>
	</tr>
</tbody></table></div>

<p>
En el momento en que realicemos un EXX, los registros cambiarán de valor por la “conmutación” de bancos:
</p>
<div class="table-responsive sectionedit20"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Registro </th><th class="col1"> Valor </th><th class="col2"> Registro </th><th class="col3"> Valor </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> B </td><td class="col1"> $00 </td><td class="col2"> B' </td><td class="col3"> $A0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> C </td><td class="col1"> $00 </td><td class="col2"> C' </td><td class="col3"> $55 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> D </td><td class="col1"> $00 </td><td class="col2"> D' </td><td class="col3"> $01 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> E </td><td class="col1"> $00 </td><td class="col2"> E' </td><td class="col3"> $FF </td>
	</tr>
	<tr class="row5">
		<td class="col0"> H </td><td class="col1"> $00 </td><td class="col2"> H' </td><td class="col3"> $00 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> L </td><td class="col1"> $00 </td><td class="col2"> L' </td><td class="col3"> $31 </td>
	</tr>
</tbody></table></div>

<p>
Si realizamos de nuevo EXX, volveremos a dejar los valores de los
registros en sus “posiciones” originales. EXX (mnemónico ensamblador
derivado de EXchange), simplemente intercambia los valores entre ambos
bancos.
</p>

<p>
Aparte de la instrucción EXX, disponemos de una instrucción <strong>EX AF, AF'</strong> , que, como el lector imagina, intercambia los valores de los registros AF y AF'. Así, pasaríamos de:
</p>
<div class="table-responsive sectionedit21"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Registro </th><th class="col1"> Valor </th><th class="col2"> Registro </th><th class="col3"> Valor </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> A </td><td class="col1"> 01h </td><td class="col2"> A' </td><td class="col3"> 00h </td>
	</tr>
	<tr class="row2">
		<td class="col0"> F </td><td class="col1"> 10h </td><td class="col2"> F' </td><td class="col3"> 00h </td>
	</tr>
</tbody></table></div>

<p>
a:
</p>
<div class="table-responsive sectionedit22"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Registro </th><th class="col1"> Valor </th><th class="col2"> Registro </th><th class="col3"> Valor </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> A </td><td class="col1"> 00h </td><td class="col2"> A' </td><td class="col3"> 01h </td>
	</tr>
	<tr class="row2">
		<td class="col0"> F </td><td class="col1"> 00h </td><td class="col2"> F' </td><td class="col3"> 10h </td>
	</tr>
</tbody></table></div>

<p>
Realizando de nuevo un EX AF, AF' volveríamos a los valores originales en ambos registros.
</p>

<p>
De esta forma podemos disponer de un set de registros extra
Acumulador/Flags con los que trabajar. Por ejemplo, supongamos que
programamos una porción de código donde queremos hacer una serie de
cálculos entre registros y después dejar el resultado en una posición de
 memoria, pero no queremos perder los valores actuales de los registros
(ni tampoco hacer uso de la pila, que veremos en su momento). En ese
caso, podemos hacer:
</p>
<pre class="code z80"><span class="co1">; Una rutina a la que saltaremos gracias a la</span>
<span class="co1">; etiqueta que definimos aquí:</span>
MiRutina:
&nbsp;
    <span class="co1">; Cambiamos de banco de registros:</span>
    <span class="kw1">EXX</span>
    <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                       ; Intercambiamos AF con AF'</span>
&nbsp;
    <span class="co1">; Hacemos nuestras operaciones</span>
    <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span><span class="re1">1</span><span class="nu0">234</span><span class="br0">)</span>
    <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
    <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span><span class="re1">1</span><span class="nu0">235</span><span class="br0">)</span>
    <span class="kw1">INC</span> <span class="kw2">A</span>
    <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
    <span class="co1">; (...etc...)</span>
    <span class="co1">; (...aquí más operaciones...)</span>
&nbsp;
    <span class="co1">; Grabamos el resultado en memoria</span>
    <span class="kw1">LD</span> <span class="br0">(</span><span class="sy0">$</span><span class="re1">1</span><span class="nu0">236</span><span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
    <span class="co1">; Recuperamos los valores de los registros</span>
    <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                       ; Intercambiamos AF con AF'</span>
    <span class="kw1">EXX</span>
&nbsp;
    <span class="co1">; Volvemos al lugar de llamada de la rutina</span>
    <span class="kw1">RET</span></pre>

<p>
Además de EXX y EX AF, AF' tenemos disponibles 3 instrucciones de
intercambio más que no trabajan con los registros alternativos, sino
entre la memoria y registros, y la pila (o memoria en general) y los
registros HL, IX e IY.
</p>
<div class="table-responsive sectionedit23"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Instrucción </th><th class="col1"> Resultado </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> EX DE, HL </td><td class="col1"> Intercambiar los valores de DE y HL. </td>
	</tr>
	<tr class="row2">
		<td class="col0"> EX (SP), HL </td><td class="col1"> Intercambiar el valor de HL con el valor de 16 bits<br>
de la posición de memoria apuntada por el registro SP<br>
(por ejemplo, para intercambiar el valor de HL con el<br>
del último registro que hayamos introducido en la pila). </td>
	</tr>
	<tr class="row3">
		<td class="col0"> EX (SP), IX </td><td class="col1"> Igual que el anterior, pero con IX. </td>
	</tr>
	<tr class="row4">
		<td class="col0"> EX (SP), IY </td><td class="col1"> Igual que el anterior, pero con IY. </td>
	</tr>
</tbody></table></div>

<p>
La primera de estas instrucciones nos resultará muy útil en nuestros
programas en ensamblador, ya que nos permite intercambiar los valores de
 los registros DE y HL. Las 3 instrucciones restantes permiten
intercambiar el valor apuntado por SP (en memoria) por el valor de los
registros HL, IX o IY.
</p>

<p>
Como ya hemos comentado cuando hablamos del carácter Low-Endian de
nuestra CPU, al escribir en memoria (también en la pila) primero se
escribe el Byte Bajo y luego el Byte Alto. Posteriormente lo leeremos de
 la misma forma, de tal modo que si los bytes apuntados en la pila (en
memoria) son “$FF $00”, al hacer el EX (SP), HL, el registro HL valdrá
“$00FF”.
</p>

<p>
Nótese que aprovechando la pila (como veremos en su momento) también podemos intercambiar los valores de los registros mediante:
</p>
<pre class="code z80"> <span class="kw1">PUSH</span> <span class="kw2">BC</span>
 <span class="kw1">PUSH</span> <span class="kw2">DE</span>
 <span class="kw1">POP</span> <span class="kw2">BC</span>
 <span class="kw1">POP</span> <span class="kw2">DE</span></pre>

<p>
 El siguiente programa muestra el uso de esta técnica:
</p>
<pre class="code z80"> <span class="co1">; Ejemplo que muestra el intercambio de registros</span>
 <span class="co1">; mediante el uso de la pila (PUSH/POP).</span>
 ORG <span class="nu0">4</span><span class="re1">0000</span>
&nbsp;
 <span class="co1">; Cargamos en DE el valor 12345 y</span>
 <span class="co1">; realizamos un intercambio de valores</span>
 <span class="co1">; con BC, mediante la pila:</span>
 <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">2345</span>
 <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">0</span>
&nbsp;
 <span class="kw1">PUSH</span> <span class="kw2">DE</span>
 <span class="kw1">PUSH</span> <span class="kw2">BC</span>
 <span class="kw1">POP</span> <span class="kw2">DE</span>
 <span class="kw1">POP</span> <span class="kw2">BC</span>
&nbsp;
 <span class="co1">; Volvemos, ahora BC=DE y DE=BC</span>
 <span class="kw1">RET</span></pre>

<p>
Lo ensamblamos:
</p>
<pre class="code"> pasmo --tapbas cambio.asm cambio.tap</pre>

<p>
Tras esto lo cargamos en un emulador de Spectrum (como un fichero TAP),
nos vamos al BASIC y tecleamos “PRINT AT 10, 10; USR 40000”. En pantalla
 aparecerá el valor “12345”, ya que las rutinas llamadas desde BASIC
devuelven sus resultados en BC, y nosotros hemos hecho un intercambio
mediante la pila, entre DE y BC.
</p>

<p>
En su momento veremos cómo funciona la pila, por ahora basta con saber
que tenemos la posibilidad de intercambiar registros mediante el uso de
la misma. Podríamos haber optado por no explicar este pequeño truco
hasta haber hablado de la pila, pero nos parece más conveniente el hecho
 de tener toda la información sobre ensamblador agrupada de forma al
buscar información o referencias sobre instrucciones para intercambiar
valores de registros, pueda encontrarse toda junta. Como hemos comentado
 al principio de este capítulo, resulta muy complicado explicar un
lenguaje tan interrelacionado de forma que no se solapen diferentes
áreas, de modo que la comprensión total de muchos de los conceptos se
alcanzará con una segunda lectura del curso completo.
</p>

<p>
<br>

</p>

</div>

<h2 id="en-resumen">En resumen</h2>
<div class="level2">

<p>
 Hemos visto la sintaxis de los programas en ensamblador (o, al menos,
la sintaxis general de PASMO, el ensamblador que recomendamos), así como
 una descripción completa del juego de registros del Z80, incluyendo
entre ellos el registro de flags F.
</p>

<p>
Además, hemos comenzado a ver nuestras primeras instrucciones del
lenguaje ensamblador, en especial las instrucciones de carga, incremento
 y decremento, y aritméticas.
</p>

<p>
En el próximo capítulo continuaremos detallando las diferentes
instrucciones del Z80, ejemplos de uso y su efecto sobre los flags del
registro F.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/03_ejemplo.asm">Ejemplo de programa en ASM</a>
</li>
<li><a href="src/03_ejemplo.tap">Fichero tap del ejemplo ejemplo.asm</a>
</li>
<li><a href="src/03_cambio.asm">Programa en ASM que muestra el uso de la pila para el intercambio de registros</a>
</li>
<li><a href="src/03_cambio.tap">Fichero tap del ejemplo cambio.asm</a>
</li>
<li><a href="src/03_progcard.asm">Referencia del juego de instrucciones del Z80</a> y cómo su ejecución afecta a los flags.
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt28.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt28.html">Juego de caracteres</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="external/www.z80.info/index.html">Web del Z80</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/ti86.acz.org/z80_ref.htm" class="urlextern" title="external/ti86.acz.org/z80_ref.htm">Z80 Reference de TI86</a></div>
</li>
<li class="level2"><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/index.html" class="urlextern" title="external/www.ticalc.org/pub/text/z80/index.html">Tablas de ensamblado y t-estados</a> (pulsar en <a href="external/www.ticalc.org/pub/text/z80/z80.txt">z80.txt</a>, <a href="external/www.ticalc.org/pub/text/z80/z80_reference.txt">z80_reference.txt</a>, <a href="external/www.ticalc.org/pub/text/z80/z80time.txt">z80time.txt</a>)</div>
</li>
<li class="level2"><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/www.z80.info/lesson1.htm" class="urlextern" title="external/www.z80.info/lesson1.htm">Curso de ensamblador de z80.info</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">Pasmo</a></div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="lenguaje-ensamblador-del-z80-ii">Lenguaje Ensamblador del Z80 (II)</h1>
<div class="level1">

</div>

<h1 id="desplazamientos-de-memoria-manipulacion-de-bits-y-operaciones-logicas">Desplazamientos de memoria, manipulación de bits y operaciones lógicas</h1>
<div class="level1">

<p>
En el anterior capítulo comenzamos nuestra andadura en el lenguaje ensamblador del Z80 por medio de las instrucciones de carga (<strong>LD</strong>), operaciones aritméticas (<strong>ADD, ADC, SUB, SBC, INC, DEC</strong>) y de intercambio (<strong>EXX</strong> y <strong>EX</strong>).
 Mientras se introducían las diferentes instrucciones, mostramos la
manera de emplear los registros y cómo los resultados podían afectar a
los flags del registro F, mediante las “tablas de afectación de flags”.
</p>

<p>
Toda la teoría explicada en el anterior capítulo del curso nos permitirá
 avanzar ahora mucho más rápido, ya que con todos los conceptos
asimilados podemos ir realizando una rápida introducción a nuevas
instrucciones, bastando ahora con una simple descripción de cada una de
ellas. Las tablas de afectación de flags y comentarios sobre los
operandos permitidos (o prohibidos) para cada una de ellas completarán
la formación necesaria.
</p>

<p>
Para poder continuar con éste y posteriores capítulos del curso será
imprescindible haber comprendido y asimilado todos los conocimientos de
las entregas anteriores, de modo que si no es así, recomendamos al
lector que relea las entregas 1, 2 y 3, y que se asegure de comprender
todos los conceptos explicados.
</p>

<p>
En esta entrega trataremos las operaciones con bits (<strong>NEG, CPL, BIT, SET</strong> y <strong>RES</strong>), las operaciones lógicas (<strong>AND, OR</strong> y <strong>XOR</strong>) y las operaciones de desplazamiento de bits (<strong>RR, RL, RLC, RRC, SLA, SRA</strong> y <strong>SRL</strong>).
</p>

<p>
No obstante, antes de pasar a hablar de las operaciones con bits
finalizaremos con la descripción de las instrucciones de carga (en este
caso las repetitivas), y veremos 4 instrucciones muy sencillas: <strong>SCF, CCF, NOP</strong> y <strong>DAA</strong>.
</p>

<p>
<br>

</p>

</div>

<h2 id="instrucciones-de-desplazamiento-de-memoria">Instrucciones de desplazamiento de memoria</h2>
<div class="level2">

<p>
 Ya conocemos la existencia de las instrucciones de carga (LD), que nos
permitían mover valores entre 2 registros o entre la memoria y los
registros. Lo que vamos a ver a continuación es cómo podemos copiar un
byte de una posición de memoria a otra, con una sóla instrucción.
</p>

<p>
Las 2 instrucciones que vamos a describir: <strong>LDI</strong> y <strong>LDD</strong>, no admiten parámetros. Lo que hacen estas instrucciones es:
</p>

<p>
<strong>LDI (Load And Increment):</strong>
</p>
<ul class="fix-media-list-overlap">
<li> Leer el byte de la posición de memoria apuntada por el registro HL.
</li>
<li class="level2"> Escribir ese byte en la posición de memoria apuntada por el registro DE.
</li>
<li class="level2"> Incrementar DE en una unidad (DE=DE+1).
</li>
<li class="level2"> Incrementar HL en una unidad (HL=HL+1).
</li>
<li class="level2"> Decrementar BC en una unidad (BC=BC-1).
</li>
</ul>

<p>
<br>

<strong>LDD (Load And Decrement): </strong>
</p>
<ul class="fix-media-list-overlap">
<li> Leer el byte de la posición de memoria apuntada por el registro HL.
</li>
<li class="level2"> Escribir ese byte en la posición de memoria apuntada por el registro DE.
</li>
<li class="level2"> Decrementar DE en una unidad (DE=DE-1).
</li>
<li class="level2"> Decrementar HL en una unidad (HL=HL-1).
</li>
<li class="level2"> Decrementar BC en una unidad (BC=BC-1).
</li>
</ul>

<p>
En pseudocódigo:
</p>
<pre class="code">LDI:    Copiar [HL] en [DE]
        DE=DE+1
        HL=HL+1
        BC=BC-1

LDD:    Copiar [HL] en [DE]
        DE=DE-1
        HL=HL-1
        BC=BC-1</pre>

<p>
Estas instrucciones lo que nos permiten es copiar datos de una zona de
la memoria a otra. Por ejemplo, supongamos que queremos copiar el byte
contenido en 16384 a la posición de memoria 40000:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>
 <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">4</span><span class="re1">0000</span>
 <span class="kw1">LDI</span></pre>

<p>
¿Qué tiene de especial LDI con respecto a realizar la copia a mano con
operaciones LD? Pues que al incrementar HL y DE, lo que hace es apuntar a
 los siguientes elementos en memoria (HL=16385 y DE=40001), con lo cual
nos facilita la posibilidad de copiar múltiples datos (no sólo 1), con
varios LDI. Lo mismo ocurre con LDD, que al decrementar DE y HL los hace
 apuntar a los bytes anteriores de origen y destino.
</p>

<p>
Pero para facilitarnos aún más la tarea de copia (y no tener que
realizar bucles manualmente), el Z80 nos proporciona las instrucciones <strong>LDIR</strong> y <strong>LDDR</strong>, que funcionan igual que LDI y LDD pero copiando tantos bytes como valor contenga el registro BC. Es decir:
</p>
<pre class="code">LDIR = Repetir LDI hasta que BC valga 0
     = Repetir:
          Copiar [HL] en [DE]
          DE=DE+1
          HL=HL+1
          BC=BC-1
       Hasta que BC = 0

LDDR = Repetir LDD hasta que BC valga 0
     = Repetir:
          Copiar [HL] en [DE]
          DE=DE-1
          HL=HL-1
          BC=BC-1
       Hasta que BC = 0</pre>

<p>
Estas instrucciones son enormemente útiles porque nos permiten copiar
bloques de datos desde una zona de la memoria a otra. Por ejemplo,
podemos hacernos una copia del estado de la pantalla en una zona de
memoria mediante:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">5</span><span class="re1">0000</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">69</span><span class="re1">1</span><span class="nu0">2</span>
  <span class="kw1">LDIR</span></pre>

<p>
Con el anterior programa, copiamos los 6912 bytes que hay a partir de la
 dirección de memoria 16384 (la pantalla) y los almacenamos a partir de
la dirección 50000. De este modo, desde 50000 a 56912 tendremos una
copia del estado de la pantalla (podría servir, por ejemplo, para
modificar cosas en esta “pantalla virtual” y después copiarla de nuevo a
 la videoram, tomando HL=50000 y DE=16384).
</p>

<p>
Para demostrar esto, ensamblemos y ejecutemos el siguiente ejemplo:
</p>
<pre class="code z80"> <span class="co1">; Ejemplo de LDIR donde copiamos 6144 bytes de la ROM</span>
 <span class="co1">; a la videomemoria. Digamos que "veremos la ROM" :)</span>
 ORG <span class="nu0">4</span><span class="re1">0000</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">0</span>         <span class="co1">; Origen: la ROM</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6384</span>     <span class="co1">; Destino: la VideoRAM</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">6</span><span class="re1">1</span><span class="nu0">44</span>      <span class="co1">; toda la pantalla</span>
  <span class="kw1">LDIR</span>             <span class="co1">; copiar</span>
&nbsp;
 <span class="kw1">RET</span></pre>

<p>
 Este ejemplo copia el contenido de los primeros 6144 bytes de memoria
(el inicio de la ROM) sobre la videomemoria, haciendo aparecer píxeles
que se corresponden con los valores que hay en la rom (las instrucciones
 de arranque y el intérprete BASIC del Spectrum):
</p>

<p>
<br>

<img src="img/la_rom.gif" class="mediacenter" alt="Aspecto de la rom al copiarla a la VRAM"/>
<br>

</p>

<p>
 Al probar el equivalente BASIC del ejemplo anterior se puede comprobar la diferencia de velocidad existente:
</p>
<pre class="code basic"> 10 REM Copiamos la ROM en la VideoRAM
 20 FOR I=0 TO 6144 : POKE (16384+I), (PEEK I) : NEXT I
 30 PAUSE 0
 RUN</pre>

<p>
Concluímos pues que en todas estas instrucciones de copia de memoria o
transferencia, HL es el origen, DE el destino y BC el número de bytes a
transferir. Con LDI y LDD sólo copiaremos 1 byte (independientemente del
 valor de BC, aunque lo decrementará), y con LDIR y LDDR copiaremos
tantos bytes como valga BC, decrementando BC hasta que su valor llega a
cero. Los flags quedarán afectados, especialmente con LDI y LDD para
indicarnos mediante el registro P/V si BC ha llegado a cero.
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   LDI               |- - 0 * 0 -|
   LDD               |- - 0 * 0 -|
   LDDR              |- - 0 0 0 -|
   LDIR              |- - 0 0 0 -|</pre>

<p>
Recordemos el significado de los símbolos de la tabla de afectación de
flags (válido para todas las tablas de instrucciones que utilizaremos a
lo largo del curso):
</p>
<pre class="code"> - = El flag NO se ve afectado por la operación.
 * = El flag se ve afectado por la operación acorde al resultado.
 0 = El flag se pone a cero.
 1 = El flag se pone a uno.
 V = El flag se comporta como un flag de Overflow acorde al resultado.
 P = El flag se comporta como un flag de Paridad acorde al resultado.
 ? = El flag toma un valor indeterminado.</pre>

<p>
Una duda que puede asaltarle al lector es: “si tenemos LDIR para copiar
bloques, ¿para qué nos puede servir LDDR? ¿No es una instrucción
redundante, que podemos no necesitar nunca gracias a LDIR? La respuesta
es que LDDR es especialmente útil cuando hay que hacer copias de bloques
 de datos que se superponen.
</p>

<p>
Supongamos que tenemos que realizar una copia de 1000 bytes desde 25000 hasta 25100. Preparamos para ello el siguiente código:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">25</span><span class="re1">000</span>
 <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">25</span><span class="re1">100</span>
 <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1000</span>
 <span class="kw1">LDIR</span></pre>

<p>
Este código no funcionará como esperamos: ambas zonas se superponen, con lo cual si lo ejecutamos, ocurrirá lo siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> El byte en [25000] se copiará a [25100].
</li>
<li> El byte en [25001] se copiará a [25101].
</li>
<li> etc…
</li>
</ul>

<p>
¿Qué ocurrirá cuando LDIR llegue al byte número 25100 y lo intente
copiar a 25200? Sencillamente, que hemos perdido el contenido REAL del
byte número 25100, porque fue machacado al principio de la ejecución del
 LDIR por el byte contenido en [25000]. No estamos moviendo el bloque
correctamente, porque las zonas se superponen y cuando llegamos a la
zona destino, estamos copiando bytes que movimos desde el origen.
</p>

<p>
Para ello, lo correcto sería utilizar el siguiente código de “copia hacia atrás”:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">25999</span>
 <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">25</span><span class="re1">0</span><span class="nu0">99</span>
 <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1000</span>
 <span class="kw1">LDDR</span></pre>

<p>
Es decir, apuntamos HL y DE al final de los 2 bloques de copia, y
copiamos los bloques desde abajo, decrementando. De este modo nunca
sobreescribimos con un dato ninguna posición de memoria que vayamos a
copiar posteriormente.
</p>

<p>
En este ejemplo:
</p>
<ul class="fix-media-list-overlap">
<li> El byte en [26000] se copia en [26100].
</li>
<li> El byte en [25999] se copia en [26099].
</li>
<li> El byte en [25998] se copia en [26098].
</li>
<li> (…)
</li>
<li> El byte en [25001] se copia en [25101].
</li>
<li> El byte en [25000] se copia en [25100].
</li>
</ul>

<p>
Que es, efectivamente, lo que queríamos hacer, pero sin perder datos en
la copia: copiar 1000 bytes desde 25000 a 25100 (sólo que realizamos la
copia de abajo a arriba).
</p>

<p>
<br>

</p>

</div>

<h2 id="un-ejemplo-de-rutina-con-ldir">Un ejemplo de rutina con LDIR</h2>
<div class="level2">

<p>
Vamos a ver un ejemplo de rutina en ensamblador que utiliza LDIR con un
propósito concreto: vamos a cargar una pantalla de carga (por ejemplo,
para nuestros juegos) de forma que no aparezca poco a poco como lo haría
 con LOAD ”“ SCREEN$, sino que aparezca de golpe.
</p>

<p>
Para eso lo que haremos será lo siguiente:
</p>

<p>
Crearemos una rutina en ensamblador que copiará 6912 bytes desde la
dirección 50000 hasta la posición 16384 (la videoram). La rutina ya la
hemos visto:
</p>
<pre class="code z80"> ORG <span class="nu0">4</span><span class="re1">0000</span>
 <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">5</span><span class="re1">0000</span>     <span class="co1">; Origen: 50000</span>
 <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6384</span>     <span class="co1">; Destino: la VideoRAM</span>
 <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">69</span><span class="re1">1</span><span class="nu0">2</span>      <span class="co1">; toda la pantalla</span>
 <span class="kw1">LDIR</span>             <span class="co1">; copiar</span>
 <span class="kw1">RET</span></pre>

<p>
La ensamblamos con pasmo a formato binario (pasmo carga.asm carga.bin) y
 obtenemos el siguiente código máquina (que podremos ver con hexedit,
hexdump o cualquier otro editor/visor hexadecimal):
</p>
<pre class="code"> 33, 80, 195, 17, 0, 64, 1, 0, 27, 237, 176, 201</pre>

<p>
Nos crearemos un cargador BASIC que realice el trabajo de pokear nuestra rutina en 40000 y cargar la pantalla en 50000:
</p>
<pre class="code basic">10 REM Ejemplo de volcado de pantalla de carga
20 CLEAR 39999
30 DATA 33, 80, 195, 017, 0, 64, 1, 0, 27, 237, 176, 201
40 FOR I=0 TO 11 : READ OPCODE : POKE 40000+I, OPCODE : NEXT I
50 LOAD "" CODE 50000, 6912
60 RANDOMIZE USR 40000
70 PAUSE 0</pre>

<p>
 Grabamos este cargador en cinta (o tap/tzx), y a continuación, tras el
cargador, grabamos una pantalla de carga, que es cargada desde cinta en
la dirección de memoria 50000 con la sentencia BASIC LOAD ”“ CODE.
</p>

<p>
Ejecutamos el programa resultante en emulador o Spectrum, y veremos cómo
 la carga de la pantalla no puede verse en el monitor. Cuando está
termina su carga, la rutina ensamblador se ejecuta y se vuelca, de
golpe, a la videoram (estad atentos a la carga, porque el volcado es muy
 rápido).
</p>

<p>
<br>

<img src="img/carga.gif" class="mediacenter" alt="La pantalla de carga de ZXColumns, volcada a videoram"/>
<br>

</p>

<p>
<br>

</p>

</div>

<h2 id="algunas-instrucciones-especiales">Algunas instrucciones especiales</h2>
<div class="level2">

<p>
Antes de comenzar con las instrucciones de manipulación de registros y
datos a nivel de bits vamos a ver una serie de instrucciones difíciles
de encuadrar en futuros apartados y que pueden sernos de utilidad en
nuestros programas:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>SCF: Set Carry Flag</strong>
 : Esta instrucción (que no admite parámetros) pone a 1 el Carry Flag
del registro F. Puede sernos útil en determinadas operaciones
aritméticas.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>CCF: Complement Carry Flag</strong>
 : Esta instrucción (que tampoco admite parámetros) invierte el estado
del bit de Carry Flag: si está a 1 lo pone a 0, y viceversa. Puede
servirnos para poner a 0 el carry flag mediante la combinación de SCF +
CCF, aunque esta misma operación se puede realizar con un simple “AND
A”.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>NOP: No OPeration</strong> :
  Esta instrucción especial del microprocesador ocupa un byte en el
código (opcode $00) y no efectúa ninguna operación ni afecta a ningún
flag. En cambio, se toma 4 t-states (t-estados, o ciclos del procesador)
 para ejecutarse, debido al ciclo de fetch/decode/execute del
procesador. ¿Para qué puede servir una instrucción que no realiza
ninguna acción y que requiere tiempo del procesador (aunque sea muy
poco) para ejecutarse? Por un lado, podemos utilizarla en bucles de
retardos (varios NOPs ejecutados en un bucle que se repita varias veces)
 para poner retardos en nuestros programas o juegos. Por otro, como
ocupa un byte en memoria (en el código) y no realiza ninguna operación,
podemos utilizarla para rellenar zonas de nuestro código, y así alinear
código posterior en una determinada dirección que nos interese.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>DAA: Decimal Adjust Accumulator</strong>
 : Esta instrucción permite realizar ajustes en los resultados de
operaciones con números BCD (tras operaciones aritméticas). ¿Qué son los
 números en formato BCD? Es una manera de representar números en los
registros (o memoria) de forma que de los 8 bits de un byte se utilizan
los 4 bits del 0 al 3 para representar un número del 0 al 9 (4 bits =
desde 0000 hasta 1111), y los 4 bits del bit 4 al 7 para representar
otro número del 0 al 9. A los 2 números BCD juntos se les llama “Byte
BCD” o “números en formato BCD”. Un número BCD puede estar formado por
varios bytes BCD, siendo cada byte 2 cifras del mismo. Así, para
representar un número de 10 cifras en BCD sólo es necesario utilizar 5
bytes. Además, podemos utilizar un byte extra que indique la posición de
 la “coma decimal” para así poder trabajar con números decimales en
ensamblador. Si queremos realizar operaciones entre este tipo de números
 deberemos programarnos nosotros mismos las rutinas para realizarlas. <br>
<br>
A lo largo del curso no utilizaremos números en BCD y por lo tanto es
muy probable que no lleguemos a utilizar DAA, pero conviene saber que el
 Z80 nos brinda la oportunidad de utilizar números más grandes de 16
bits, operando con números en BCD. Para realizar juegos normalmente no
necesitaremos de estas instrucciones.</div>
</li>
</ul>

<p>
Todas estas instrucciones afectan a los flags de la siguiente manera:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   SCF               |- - 0 - 0 1|
   CCF               |- - ? - 0 *|
   NOP               |- - - - - -|
   DAA               |* * * P - *|</pre>

<p>
<br>

</p>

</div>

<h2 id="operaciones-con-bits">Operaciones con bits</h2>
<div class="level2">

<p>
El conjunto de instrucciones que vamos a ver hoy está pensado para
trabajar con los bits individuales de un registro: invertir los bits de
un registro, obtener el complemento a dos de un registro y poner a 0 o a
 1, o comprobar, un determinado bit de un registro.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit7" id="cpl-y-neg">CPL y NEG</h3>
<div class="level3">

<p>
<strong>CPL</strong> es una instrucción que se usa para obtener el
inverso en bits del registro A. No admite parámetros (el operando
destino es el registro A) y cuando la ejecutamos, se invierte el estado
de cada uno de los bits de A, de forma que los unos pasan a valer cero, y
 los ceros, uno.
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">%10000001</span>
 <span class="kw1">CPL</span>                 <span class="co1">; A = %01111110</span></pre>

<p>
La tabla de afectación de flags de CPL es:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   CPL               |- - 1 - 1 -|</pre>

<p>
Es decir, se deja a uno el flag de Resta (N) y el de HalfCarry (H). El resto de flags no se ven afectados.
</p>

<p>
 Existe una instrucción similar a CPL, pero que además de realizar la
inversión de unos y ceros suma 00000001 al resultado de la inversión del
 registro A. Esta instrucción es <strong>NEG</strong>. El resultado es que en A obtenemos el valor negativo del número en complemento a dos almacenado en este registro (A = -A).
</p>

<p>
Por ejemplo:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span>        <span class="co1">; A = +1</span>
 <span class="kw1">NEG</span>            <span class="co1">; A = -1 = %11111111</span></pre>

<p>
La tabla de afectación de flags de NEG es:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   NEG               |* * * V 1 *|</pre>

<p>
<br>

</p>

</div>

<h3 class="sectionedit8" id="set-res-y-bit">SET, RES y BIT</h3>
<div class="level3">

<p>
Las siguientes instrucciones que vamos a ver nos permitirán el manejo de
 cualquiera de los bits de un registro o posición de memoria: activar un
 bit (ponerlo a uno), desactivar un bit (ponerlo a cero), o comprobar su
 valor (averiguar si es cero o uno) afectando a los flags.
</p>

<p>
Comencemos con “<strong>SET</strong>”. Esta instrucción activa (pone a
valor 1) uno de los bits de un registro o dirección de memoria. El
formato de la instrucción es:
</p>
<pre class="code z80"> <span class="kw1">SET</span> <span class="kw1">bit</span>, DESTINO</pre>

<p>
donde Bit es un número entre 0 (el bit menos significativo o bit 0) y 7
(el de más valor o más significativo), y destino puede ser cualquier
registro de 8 bits (A, B, C, D, E, H y L), una dirección de memoria
apuntada por HL (es decir, el destino puede ser [HL]), o una dirección
de memoria indexada por [IX+N] o [IY+N]. Con esto, las siguientes
instrucciones serían válidas:
</p>
<pre class="code z80"> <span class="kw1">SET</span> <span class="nu0">5</span>, <span class="kw2">A</span>         <span class="co1">; Activar el bit 5 del registro A</span>
 <span class="kw1">SET</span> <span class="re1">0</span>, <span class="kw2">H</span>         <span class="co1">; Activar el bit 0 del registro H</span>
 <span class="kw1">SET</span> <span class="nu0">7</span>, <span class="br0">[</span><span class="kw2">HL</span><span class="br0">]</span>      <span class="co1">; Activar el bit 7 del dato contenido en</span>
                  <span class="co1">; la dirección de memoria apuntada por HL</span>
 <span class="kw1">SET</span> <span class="re1">1</span>, <span class="br0">[</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">10</span><span class="br0">]</span>   <span class="co1">; Activar el bit 1 del dato en [IX+10]</span></pre>

<p>
La instrucción opuesta a SET es <strong>RES</strong> (de reset), que
pone a cero el bit indicado del destino especificado. Su formato es
igual que el de SET, como podemos ver en los siguientes ejemplos:
</p>
<pre class="code z80"> <span class="kw1">RES</span> <span class="kw1">bit</span>, DESTINO
&nbsp;
 <span class="kw1">RES</span> <span class="re1">0</span>, <span class="kw2">H</span>         <span class="co1">; Desactivar el bit 0 del registro H</span>
 <span class="kw1">RES</span> <span class="nu0">7</span>, <span class="br0">[</span><span class="kw2">HL</span><span class="br0">]</span>      <span class="co1">; Desactivar el bit 7 del dato contenido en</span>
                  <span class="co1">; la dirección de memoria apuntada por HL</span>
 <span class="kw1">RES</span> <span class="re1">1</span>, <span class="br0">[</span>IX<span class="sy0">-</span><span class="nu0">5</span><span class="br0">]</span>    <span class="co1">; Desactivar el bit 0 del dato en [IX-5]</span></pre>

<p>
SET y RES no afectan a los flags, como podemos ver en su tabla de afectación de indicadores:
</p>
<pre class="code">                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
  SET b, s          |- - - - - -|
  RES b, s          |- - - - - -|</pre>

<p>
La última instrucción de manipulación de bits individuales que veremos en este apartado es <strong>BIT</strong>.
 Esta instrucción modifica el flag de cero (Z) y deja su valor en 0 ó 1
dependiendo del valor del bit que estamos probando. Si estamos probando,
 por ejemplo, el bit 5 del registro A, ocurrirá lo siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> Si el bit 5 del registro A es cero: el Flag Z se pone a 1.
</li>
<li class="level2"> Si el bit 5 del registro A es uno: el flag Z se pone a 0.
</li>
</ul>

<p>
En otras palabras, Z toma la inversa del valor del Bit que comprobamos:
esto es así porque Z no es una COPIA del bit que estamos testeando, sino
 el resultado de evaluar si dicho bit es cero o no, y una evaluación así
 pone a uno el flag Z sólo cuando lo que se evalúa es cero.
</p>

<p>
Su formato es:
</p>
<pre class="code z80"> <span class="kw1">BIT</span> <span class="kw1">bit</span>, DESTINO</pre>

<p>
El destino puede ser el mismo que en SET y RES: un registro, posición de
 memoria apuntado por HL o posición de memoria apuntada por un registro
índice más un desplazamiento.
</p>

<p>
Por ejemplo:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">8</span>       <span class="co1">; A = %00001000</span>
 <span class="kw1">BIT</span> <span class="nu0">7</span>, <span class="kw2">A</span>      <span class="co1">; El flag Z vale 1</span>
               <span class="co1">; porque el bit 7 es 0</span>
 <span class="kw1">BIT</span> <span class="nu0">3</span>, <span class="kw2">A</span>      <span class="co1">; El flag Z vale 0</span>
               <span class="co1">; porque el bit 3 no es 0</span>
               <span class="co1">; (es 1).</span></pre>

<p>
El lector se preguntará … ¿cuál es la utilidad de BIT? Bien, el hecho de
 que BIT modifique el Zero Flag de acuerdo al bit que queremos comprobar
 nos permitirá utilizar instrucciones condicionales para realizar muchas
 tareas. Por ejemplo, podemos comprobar el bit 0 de un registro (algo
que nos permitiría saber si es par o impar) y en caso de que se active
el flag de Zero (Si z=1, el bit 0 vale 0, luego es par), realizar un
salto a una determinada línea de programa.
</p>

<p>
Por ejemplo:
</p>
<pre class="code z80"> <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>      <span class="co1">; Que valor tiene el bit 0?</span>
               <span class="co1">; Ahora Z = NEG del bit 0 de A.</span>
 <span class="kw1">JP</span> Z es_par   <span class="co1">; Saltar si esta Z activado</span>
               <span class="co1">; (si Z=1 -&gt; salta a es_par)</span>
               <span class="co1">; ya que si Z=1, es porque el bit era 0</span></pre>

<p>
Esta instrucción es, como veremos en muchas ocasiones, muy útil, y como ya hemos dicho sí que altera el registro F:
</p>
<pre class="code">                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
  BIT b, s          |? * 1 ? 0 -|</pre>

<p>
<br>

</p>

</div>

<h2 id="rotacion-de-bits">Rotacion de bits</h2>
<div class="level2">

<p>
El siguiente set de instrucciones que veremos nos permitirá ROTAR
(ROTATE) los bits de un dato de 8 bits (por ejemplo, almacenado en un
registro o en memoria) hacia la izquierda o hacia la derecha.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit10" id="rlc-rrc-rl-y-rc">RLC, RRC, RL y RC</h3>
<div class="level3">

<p>
Para realizar esta tarea tenemos disponibles 2 instrucciones básicas: <strong>RLC</strong> y <strong>RRC</strong>.
 La primera de ellas, RLC, rota el registro o dato en un bit a la
izquierda (RLC = Rotate Left Circular), y la segunda lo hace a la
derecha.
</p>
<pre class="code"> Bit      7 6 5 4 3 2 1 0                 7 6 5 4 3 2 1 0
         ----------------- -&gt; RLC -&gt;     -----------------
 Valor    a b c d e f g h                 b c d e f g h a


 Bit      7 6 5 4 3 2 1 0                 7 6 5 4 3 2 1 0
         ----------------- -&gt; RRC -&gt;     -----------------
 Valor    a b c d e f g h                 h a b c d e f g</pre>

<p>
Así, RLC de 00000001 daría como resultado 00000010. Como la rotación es
circular, todos los bits se mueven una posición a la izquierda y el bit 7
 se copia en el bit 0. Asímismo, RRC de 00000001 daría como resultado
10000000, ya que el bit 0 al rotarse a la derecha (como todos los demás
bits) se copia donde estaba el bit 7. Cabe destacar que el Carry Flag se
 vé afectado, ya que el bit 7 en RLC y el 0 en RRC también se copiará
allí.
</p>

<p>
<br>

<img src="img/rlc_rrc.gif" class="mediacenter" alt="RLC y RRC"/>
<br>

</p>

<p>
Por ejemplo, supongamos el valor 10000001 almacenado en el registro B:
</p>

<p>
El resultado las 2 operaciones descritas sería:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">%10000001</span>   <span class="co1">; B = 10000001</span>
 <span class="kw1">RLC</span> <span class="kw2">B</span>             <span class="co1">; B = 00000011</span>
&nbsp;
 <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">%10000001</span>   <span class="co1">; B = 10000001</span>
 <span class="kw1">RRC</span> <span class="kw2">B</span>             <span class="co1">; B = 11000000</span></pre>

<p>
No sólo podemos rotar registros: en general el destino de la rotación
podrá ser un registro, el contenido de la dirección de memoria apuntada
por [HL], o bien el contenido de la memoria apuntada por un registro
índice más desplazamiento ([IX+N] o [IY+N]). Más adelante veremos la
tabla de afectación de flags de esta y otras instrucciones que veremos a
 continuación.
</p>

<p>
Además de RLC y RRC (rotación circular), tenemos disponibles 2
instrucciones más que nos permiten apoyarnos en el Carry Flag del
registro F como si fuera un bit más de nuestro registro, comportándose
como el noveno bit (de más valor) del registro: hablamos de las
instrucciones <strong>RL</strong> y <strong>RC</strong>:
</p>
<pre class="code"> Bit     C   7 6 5 4 3 2 1 0               C   7 6 5 4 3 2 1 0
        ---------------------- -&gt;  RL  -&gt;  ---------------------
 Valor   X   a b c d e f g h               a   b c d e f g h X


 Bit     C   7 6 5 4 3 2 1 0               C   7 6 5 4 3 2 1 0
        ---------------------- -&gt;  RR  -&gt;  ---------------------
 Valor   X   a b c d e f g h               h   X a b c d e f g</pre>

<p>
El CarryFlag hace de bit extra: por un lado se copia al Bit 0 o al Bit 7
 según estemos rotando a izquierda o a derecha, y por otra parte recibe
el valor del bit 7 del bit 0 (respectivamente para RL y RR).
</p>

<p>
<br>

<img src="img/rl_rr.gif" class="mediacenter" alt=" RL y RR "/>
<br>

</p>

<p>
Por ejemplo, supongamos el valor 10000001 almacenado en el registro B y que el carry flag estuviera a uno:
</p>

<p>
El resultado las 2 operaciones descritas sería:
</p>
<pre class="code z80"> <span class="kw1">SCF</span>              <span class="co1">; Set Carry Flag (hace C=1)</span>
 <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">%00000010</span>  <span class="co1">; B = 00000010</span>
 <span class="kw1">RL</span> <span class="kw2">B</span>             <span class="co1">; B = 00000101 y C=0 (del bit 7)</span>
&nbsp;
 <span class="kw1">SCF</span>              <span class="co1">; Set Carry Flag (hace C=1)</span>
 <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">%01000001</span>  <span class="co1">; B = 01000000</span>
 <span class="kw1">RR</span> <span class="kw2">B</span>             <span class="co1">; B = 10100000 y C=1 (del bit 0)</span></pre>

<p>
Así pues, RLC y RRC son circulares y no utilizan el Carry Flag, mientras
 que RR y RL sí que lo utilizan, como un bit extra. Utilizando RR/RL 9
veces o bien RLC/RRC 8 veces sobre un mismo registro obtenemos el valor
original antes de comenzar a rotar.
</p>

<p>
Veamos la tabla de afectación de flags de estas nuevas instrucciones:
</p>
<pre class="code">                        Flags
  Instrucción       |S Z H P N C|         Significado
 -----------------------------------------------------------------
  RLC s             |* * 0 P 0 *|         Rotate Left Circular
  RRC s             |* * 0 P 0 *|         Rotate Right Circular
  RL s              |* * 0 P 0 *|         Rotate Left (con Carry)
  RR s              |* * 0 P 0 *|         Rotate Right (con Carry)</pre>

<p>
El destino “s” puede ser cualquier registro de 8 bits, memoria apuntada
por HL o registros índice con desplazamiento. Como veis hay muchos flags
 afectados, y en esta ocasión el flag P/V ya no nos sirve para indicar
desbordamientos sino que su estado nos da la PARIDAD del resultado de la
 operación de rotación. Con el flag P a uno, tenemos paridad par (even),
 es decir, el número de bits a uno en el resultado es par. Si está a
cero significa que el número de bits a uno en el resultado es impar.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit11" id="rla-rra-rlca-y-rrca">RLA, RRA, RLCA y RRCA</h3>
<div class="level3">

<p>
Aunque pueda parecer sorprendente (ya que podemos utilizar las 4
operaciones anteriores con el registro A como operando), existen 4
instrucciones más dedicadas exclusivamente a trabajar con “A”: hablamos
de <strong>RLA, RRA, RLCA</strong> y <strong>RRCA</strong>. La
diferencia entre estas 4 instrucciones y su versión con un espacio en
medio (RL A, RR A, RLC A y RRC A) radica simplemente en que las nuevas 4
 instrucciones alteran los flags de una forma diferente:
</p>
<pre class="code">                        Flags
  Instrucción       |S Z H P N C|       Significado
 -----------------------------------------------------------------
  RLA               |- - 0 - 0 *|       Rotate Left Accumulator
  RRA               |- - 0 - 0 *|       Rotate Right Accumulator
  RLCA              |- - 0 - 0 *|       Rotate Left Circular Acc.
  RRCA              |- - 0 - 0 *|       Rotate Right Circular Acc.</pre>

<p>
Como veis, están pensadas para alterar MENOS flags que sus homónimas de
propósito general (algo que nos puede interesar en alguna ocasión).
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit12" id="rld-y-rrd">RLD y RRD</h3>
<div class="level3">

<p>
Y para acabar con las instrucciones de rotación, tenemos <strong>RLD</strong> y <strong>RRD</strong>, que realiza una rotación entre A y el contenido de la memoria apuntada por HL.
</p>

<p>
Concretamente, RRD lo que hace es:
</p>
<ul class="fix-media-list-overlap">
<li> Leer el dato contenido en la dirección de memoria apuntada por HL.
</li>
<li class="level2"> Coger los 4 bits más significativos (bit 4-7) de ese valor.
</li>
<li class="level2"> Rotar A hacia la izquierda 4 veces (copiando los bits 0-3 en las posiciones 4-7).
</li>
<li class="level2"> Copiar los 4 bits extraídos de la memoria en los 4 bits menos significativos de A.
</li>
</ul>

<p>
Resumiendo, supongamos los siguientes valores de A y [HL]:
</p>
<pre class="code"> Registro A:   Bit 7 6 5 4 3 2 1 0
               --------------------
                   a b c d e f g h

 [HL]:         Bit 7 6 5 4 3 2 1 0
               --------------------
                   s t u v w x y z</pre>

<p>
<strong>Resultado de RRD:</strong>
</p>
<pre class="code"> Registro A:   Bit 7 6 5 4 3 2 1 0
               --------------------
                   e f g h s t u v</pre>

<p>
<strong>Resultado de RLD:</strong>
</p>
<pre class="code"> Registro A:   Bit 7 6 5 4 3 2 1 0
               --------------------
                   s t u v e f g h</pre>

<p>
En pseudocódigo C:
</p>
<pre class="code"> RRD:  A = ( A&lt;&lt;4 )    | ([HL]&gt;&gt;4)
 RLD:  A = ( [HL]&lt;&lt;4 ) | (A &amp; 0x0F)</pre>

<p>
La afectación de flags sería:
</p>
<pre class="code">                        Flags
  Instrucción       |S Z H P N C|         Significado
 -----------------------------------------------------------------
  RLD               |* * 0 P 0 -|         Rotate Left 4 bits
  RRD               |* * 0 P 0 -|         Rotate Right 4 bits</pre>

<p>
Aunque ahora todo este conjunto de instrucciones pueda parecernos
carente de utilidad, lo que hace el microprocesador Z80 es proveernos de
 toda una serie de pequeñas herramientas (como estas de manipulación,
chequeo y rotación de bits) para que con ellas podamos resolver
cualquier problema, mediante la combinación de las mismas. Os aseguramos
 que en más de una rutina tendréis que usar instrucciones de rotación o
desplazamiento.
</p>

<p>
<br>

</p>

</div>

<h2 id="desplazamiento-de-bits">Desplazamiento de bits</h2>
<div class="level2">

<p>
El siguiente set de instrucciones que veremos nos permitirá DESPLAZAR
(SHIFT) los bits de un dato de 8 bits (por ejemplo, almacenado en un
registro o en memoria) hacia la izquierda o hacia la derecha. Desplazar
es parecido a rotar, sólo que el desplazamiento no es circular; es
decir, los bits que salen por un lado no entran por otro, sino que
entran ceros en el caso de desplazar a la izquierda, o copias del bit 7
en el caso de desplazar a la derecha:
</p>
<pre class="code"> 00010001 DESPLAZADO A LA IZQUIERDA es 00100010
 (movemos todos los bits hacia la izquierda y el bit 0
  entra como 0. El bit 7 se copia al Carry)

 00001001 DESPLAZADO A LA DERECHA es 00000100
 (el 0 del bit 7 del resultado entra nuevo, el 1 del
  bit 0 origen se pierde, el cuarto se desplaza)</pre>

<p>
Las instrucciones de desplazamiento a izquierda y derecha en Z80 se llaman <strong>SLA (Shift Left Arithmetic)</strong> y <strong>SRA (Shift Right Arithmetic)</strong>, y su formato es:
</p>
<pre class="code z80"> <span class="kw1">SRA</span> operando
 <span class="kw1">SLA</span> operando</pre>

<p>
Donde operando puede ser el mismo tipo de operando que en las
instrucciones de rotación: un registro de 8 bits, [HL] o [IX/IY+N]. Lo
que realizan estas operaciones sobre el dato operando es:
</p>
<pre class="code"> Bit 7 6 5 4 3 2 1 0                C    7 6 5 4 3 2 1 0
    ----------------- -&gt; SLA -&gt;  ------------------------
     a b c d e f g h                a    b c d e f g h 0</pre>

<p>
Literalmente:
</p>
<ul class="fix-media-list-overlap">
<li> Rotar los bits a la izquierda («).
</li>
<li class="level2"> El bit “a” (bit 7) se copia al Carry Flag.
</li>
<li class="level2"> Por la derecha entra un cero.
</li>
</ul>
<pre class="code"> Bit 7 6 5 4 3 2 1 0                C    7 6 5 4 3 2 1 0
    ----------------- -&gt; SRA -&gt;  ------------------------
     a b c d e f g h                h    a a b c d e f g</pre>

<p>
Literalmente:
</p>
<ul class="fix-media-list-overlap">
<li> Rotar los bits a la derecha (»).
</li>
<li class="level2"> El bit “h” (bit 0) se copia al Carry Flag.
</li>
<li class="level2"> En la izquierda (bit 7) se mantiene su valor anterior.
</li>
</ul>

<p>
Nótese pues que SLA y SRA nos permiten trabajar también con números
negativos. En el caso de SLA se utiliza el carry flag para almacenar el
estado del bit 7 tras la rotación (con lo cual podemos conservar el
signo si sabemos dónde buscarlo). En el caso de SRA, porque el bit 7
además de desplazarse hacia la derecha se mantiene en su posición
(manteniendo el signo).
</p>

<p>
El hecho de desplazar un número binario una posición a izquierda o derecha tiene una curiosa propiedad: <strong>el número resultante es el original multiplicado o dividido por 2</strong>.
</p>

<p>
Pensemos un poco en nuestro sistema decimal: si tenemos un determinado
número y desplazamos todos los dígitos una posición a la izquierda y
añadimos un cero, lo que está sucediendo es que multiplicamos el valor
del número por la base (10):
</p>
<pre class="code"> 1 5  -&gt; Desplazar y añadir cero  -&gt;  1 5 0
 (equivale a multiplicar por la base, es decir, por 10)</pre>

<p>
Si desplazamos el número a la derecha, por contra, estamos dividiendo por la base:
</p>
<pre class="code"> 1 5 2 -&gt; Desplazar y añadir cero -&gt; 0 1 5
 (equivale a dividir por la base, es decir, por 10).</pre>

<p>
 En binario ocurre lo mismo: al desplazar un byte a la izquierda estamos
 multiplicando por 2 (por la base), y al hacerlo a la derecha estamos
dividiendo por 2 (siempre divisiones enteras). Veamos unos ejemplos:
</p>
<pre class="code"> 33 = 00100001
          &lt;&lt; 1   (&lt;&lt; significa desplazamiento de bits a izquierda)
    ------------
      01000010 = 66 (33*2)


 14 = 00001110
          &gt;&gt; 1   (&gt;&gt; significa desplazamiento de bits a derecha)
    ------------
      00000111 = 7 (14/2)</pre>

<p>
Cada vez que realizamos un desplazamiento estamos multiplicando o dividiendo el resultado por dos, de forma que:
</p>
<div class="table-responsive sectionedit14"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Dirección Desplaz. </th><th class="col1"> Núm. desplazamientos </th><th class="col2"> Operación (con <strong>SLA</strong>) </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Izquierda («) </td><td class="col1"> 1 </td><td class="col2"> N = N*2 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> Izquierda («) </td><td class="col1"> 2 </td><td class="col2"> N = (N*2)*2 = N*4 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> Izquierda («) </td><td class="col1"> 3 </td><td class="col2"> N = ((N*2)*2)*2 = N*8 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> Izquierda («) </td><td class="col1"> 4 </td><td class="col2"> N = (…) N*16 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> Izquierda («) </td><td class="col1"> 5 </td><td class="col2"> N = (…) N*32 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> Izquierda («) </td><td class="col1"> 6 </td><td class="col2"> N = (…) N*64 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> Izquierda («) </td><td class="col1"> 7 </td><td class="col2"> N = (…) N*128 </td>
	</tr>
</tbody></table></div>
<div class="table-responsive sectionedit15"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Dirección Desplaz. </th><th class="col1"> Núm. desplazamientos </th><th class="col2"> Operación (con <strong>SRA</strong>) </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Derecha (») </td><td class="col1"> 1 </td><td class="col2"> N = N/2 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> Derecha (») </td><td class="col1"> 2 </td><td class="col2"> N = (N/2)/2 = N/4 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> Derecha (») </td><td class="col1"> 3 </td><td class="col2"> N = ((N/2)/2)/2 = N/8 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> Derecha (») </td><td class="col1"> 4 </td><td class="col2"> N = (…) N/16 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> Derecha (») </td><td class="col1"> 5 </td><td class="col2"> N = (…) N/32 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> Derecha (») </td><td class="col1"> 6 </td><td class="col2"> N = (…) N/64 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> Derecha (») </td><td class="col1"> 7 </td><td class="col2"> N = (…) N/128 </td>
	</tr>
</tbody></table></div>

<p>
Así, desplazar una vez a la izquierda equivale a multiplicar por 2.
Desplazar 2 veces, por 4. Desplazar 3 veces, por 8, etc. En resumen,
desplazar un registro N veces a la izquierda equivale a multiplicarlo
por 2 elevado a N. Lo mismo ocurre con el desplazamiento a derecha y la
división.
</p>

<p>
De este modo, acabamos de descubrir una manera muy sencilla y efectiva
(y rápida, muy rápida para el microprocesador) de efectuar
multiplicaciones y divisiones por 2, 4, 8, 16, 32, 64 y 128.
</p>

<p>
Existe una pequeña variante de SRA llamada <strong>SRL</strong> que realiza la misma acción que SRA pero que, a diferencia de esta, lo que hace es <em>introducir un cero a la izquierda</em> (en lugar de copiar el bit de signo). La diferencia es que SRA es un desplazamiento aritmético (tiene en cuenta el signo) y <em>SRL es un desplazamiento lógico</em> (simplemente desplaza los bits):
</p>
<pre class="code"> Bit 7 6 5 4 3 2 1 0                C    7 6 5 4 3 2 1 0
    ----------------- -&gt; SRL -&gt;  ------------------------
     a b c d e f g h                h    0 a b c d e f g</pre>

<p>
Literalmente:
</p>
<ul class="fix-media-list-overlap">
<li> Rotar los bits a la derecha (»).
</li>
<li class="level2"> El bit “h” (bit 0) se copia al Carry Flag.
</li>
<li class="level2"> Por la izquierda entra un cero.
</li>
</ul>

<p>
<img src="img/sla_sra_srl.gif" class="mediacenter" alt="SLA, SRA y SLR"/>
</p>

<p>
 Veamos nuestra ya conocida tabla de afectación de flags:
</p>
<pre class="code">                        Flags
  Instrucción       |S Z H P N C|        Significado
 -----------------------------------------------------------------
  SLA s             |* * 0 P 0 *|        Shift Left Arithmetic (s=s*2)
  SRA s             |* * 0 P 0 *|        Shift Right Arithmetic (s=s/2)
  SRL s             |* * 0 P 0 *|        Shift Right Logical (s=s&gt;&gt;1)</pre>

<p>
 Cabe destacar que gracias al Carry flag podremos realizar operaciones
de desplazamiento que desborden los 8 bits de que dispone un registro.
Por ejemplo, supongamos que queremos realizar una multiplicación por 152
 por 2. El resultado del desplazamiento sería:
</p>
<pre class="code"> 152 = 10011000
           &lt;&lt; 1 (*2)
     ------------
       00110000 = 48</pre>

<p>
¿Por qué nuestro registro acaba con un valor 48? Porque el resultado es
mayor que 255, el valor máximo que podemos representar con 8 bits. Para
representar el resultado (304), necesitaríamos un bit extra (9 bits) que
 nos daría acceso a representar números en el rango de 0 a 511. Ese bit
extra es el carry flag, ya que en realidad:
</p>
<pre class="code"> 152 =     10011000
               &lt;&lt; 1 (*2)
     ---------------------
      1    00110000 = 304
     (C)</pre>

<p>
Además, gracias a la combinación de instrucciones de rotación y
desplazamiento podemos realizar operaciones con registros de 16 bits.
Por ejemplo, supongamos que queremos multiplicar por 2 el valor positivo
 que tenemos en el registro DE:
</p>
<pre class="code z80">  <span class="kw1">SLA</span> <span class="kw2">E</span>
  <span class="kw1">RL</span>  <span class="kw2">D</span></pre>

<p>
Lo que hacemos con “SLA E” es desplazar el byte más bajo del registro de
 16 bits DE hacia la izquierda, dejando el bit 7 de “E” en el Carry
Flag, y después realizar una rotación de “D” hacia la izquierda
introduciendo el carry flag de la operación anterior en el bit 0 de “D”.
</p>
<pre class="code"> Registro DE original:

               D                       E
 DE:   ---------------------   ---------------------
 Bit  15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00      Carry
     -------------------------------------------------     -----
       a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p        ?</pre>

<p>
Primero con SLA E rotamos la parte baja, metiendo el bit “i” en el Carry Flag:
</p>
<pre class="code"> SLA E:

               D                       E
 DE:   ---------------------   ---------------------
 Bit  15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00      Carry
     -------------------------------------------------     -----
       a  b  c  d  e  f  g  h  j  k  l  m  n  o  p  0        i
</pre>

<p>
Ahora con RL D rotamos D introduciendo el bit “i” en su bit 0:
</p>
<pre class="code"> RL D:

               D                       E
 DE:   ---------------------   ---------------------
 Bit  15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00      Carry
     -------------------------------------------------     -----
       b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  0        a</pre>

<p>
Podemos repetir la operación para multiplicar por 4, 8, 16, etc. dicho par de registros.
</p>

<p>
De igual forma, podemos realizar rotaciones de 16 bits a la derecha,
haciendo el proceso inverso y comenzando primero con el byte alto:
</p>
<pre class="code z80"> <span class="kw1">SRL</span> <span class="kw2">D</span>
 <span class="kw1">RR</span> <span class="kw2">E</span></pre>

<p>
Las operaciones de este tipo sobre registros de 16 bits son muy
importantes para realizar otro tipo de operaciones de más amplitud como
multiplicaciones y divisiones.
</p>

<p>
Y, para finalizar, veamos cómo el operando destino de 16 bits puede ser
un par de bytes de memoria, como en el siguiente código de ejemplo:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="re1">1</span><span class="nu0">6384</span>
 <span class="kw1">SLA</span> <span class="br0">(</span><span class="kw2">IX</span><span class="br0">)</span>
 <span class="kw1">RL</span> <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re0">01H</span><span class="br0">)</span></pre>

<p>
Recordad para este ejemplo que en memoria se almacena primero el byte
menos significativo de la palabra de 16 bits, y en la siguiente posición
 de memoria el más significativo.
</p>

<p>
<br>

</p>

</div>

<h2 id="operaciones-logicasand-or-y-xor">Operaciones logicas: AND, OR y XOR</h2>
<div class="level2">

<p>
Para acabar con el artículo de hoy vamos a ver 3 operaciones a nivel de bits: <strong>AND, OR</strong> y <strong>XOR</strong>. Estas 3 operaciones lógicas se realizan entre 2 bits, dando un tercer bit como resultado:
</p>
<div class="table-responsive sectionedit17"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bit 1 </th><th class="col1"> Bit 2 </th><th class="col2"> Resultado AND </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 1 </td><td class="col1"> 1 </td><td class="col2"> 1 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> 0 </td><td class="col2"> 0 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 0 </td><td class="col1"> 1 </td><td class="col2"> 0 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 0 </td><td class="col1"> 0 </td><td class="col2"> 0 </td>
	</tr>
</tbody></table></div>
<div class="table-responsive sectionedit18"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bit 1 </th><th class="col1"> Bit 2 </th><th class="col2"> Resultado OR </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 1 </td><td class="col1"> 1 </td><td class="col2"> 1 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> 0 </td><td class="col2"> 1 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 0 </td><td class="col1"> 1 </td><td class="col2"> 1 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 0 </td><td class="col1"> 0 </td><td class="col2"> 0 </td>
	</tr>
</tbody></table></div>
<div class="table-responsive sectionedit19"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bit 1 </th><th class="col1"> Bit 2 </th><th class="col2"> Resultado XOR </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 1 </td><td class="col1"> 1 </td><td class="col2"> 0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> 0 </td><td class="col2"> 1 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 0 </td><td class="col1"> 1 </td><td class="col2"> 1 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 0 </td><td class="col1"> 0 </td><td class="col2"> 0 </td>
	</tr>
</tbody></table></div>

<p>
Podría decirse que:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>AND es la multiplicación lógica</strong>:
 si cualquiera de los 2 bits es cero, el resultado es cero (0*0=0,
0*1=0, 1*0=0); dicho resultado sólo será uno cuando ambos bits sean 1
(1*1=1).</div>
</li>
<li class="level2"><div class="li"> <strong>OR es la suma lógica</strong>:
 si alguno de los bits es uno, el resultado es uno (1+1=1, 0+1=1,
1+0=1). Sólo obtendremos un 0 al hacer un OR entre 2 bits cuando ambos
son cero.</div>
</li>
<li class="level2"><div class="li"> <strong>XOR es una operación de “O EXCLUSIVO”</strong>
 (exclusive OR) donde el resultado es cero cuando los 2 bits operandos
son iguales, y uno cuando los 2 bits operandos son diferentes.</div>
</li>
</ul>

<p>
Ejemplos:
</p>
<pre class="code"> 10010101 AND 0000111  = 00000101

 00000101 OR  1100000  = 11000101

 11000011 XOR 10011001 = 01011010</pre>

<p>
A la hora de realizar estas operaciones lógicas en nuestro Z80
disponemos de 3 instrucciones cuyos nombres son, como podéis imaginar,
AND, OR y XOR. Las tres tienen el mismo formato:
</p>
<pre class="code z80"> <span class="kw1">AND</span> ORIGEN
 <span class="kw1">OR</span>  ORIGEN
 <span class="kw1">XOR</span> ORIGEN</pre>

<p>
Donde ORIGEN puede ser cualquier registro de 8 bits, valor inmediato de 8
 bits, contenido de la memoria apuntada por [HL], o contenido de la
memoria apuntada por un registro índice más un desplazamiento. El
formato de la instrucción no requiere 2 operandos, ya que el registro
destino sólo puede ser A.
</p>

<p>
 La operación CPL, que vimos al principio de este capítulo, también se
considera una operación lógica, equivalente a NOT (0→1 y 1→0).
</p>

<p>
Pero continuemos con AND, OR y XOR. Veamos algunos ejemplos de instrucciones válidas:
</p>
<pre class="code z80"> <span class="kw1">AND</span> <span class="kw2">B</span>
 <span class="kw1">OR</span> <span class="kw2">C</span>
 <span class="kw1">OR</span> <span class="br0">[</span><span class="kw2">HL</span><span class="br0">]</span>
 <span class="kw1">XOR</span> <span class="br0">[</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">10</span><span class="br0">]</span>
 <span class="kw1">AND</span> <span class="nu0">45</span></pre>

<p>
La operación realizada por estas instrucciones sería:
</p>
<pre class="code"> AND ORIGEN -&gt; A = A &amp; ORIGEN
 OR  ORIGEN -&gt; A = A | ORIGEN
 XOR ORIGEN -&gt; A = A ^ ORIGEN

 (Donde &amp; = AND, | = OR y ^ = XOR)</pre>

<p>
Recordemos que AND, OR y XOR son operaciones lógicas de un sólo bit, de
modo que al trabajar con registros (o memoria, o valores inmediatos), en
 realidad estamos realizando 8 operaciones AND, OR o XOR, entre los
diferentes bits de los operandos. Por ejemplo, al hacer un AND entre los
 registros A y B con “AND B” (A=A&amp;B), realizamos las siguientes
operaciones:
</p>
<pre class="code"> Registro A:   Bit  7  6  5  4  3  2  1  0
               ----------------------------
                   A7 A6 A5 A4 A3 A2 A1 A0

 Registro B:   Bit  7  6  5  4  3  2  1  0
               ----------------------------
                   B7 B6 B5 B4 B3 B2 B1 B0

 Resultado:

 A7 = A7 AND B7
 A6 = A6 AND B6
 A5 = A5 AND B5
 A4 = A4 AND B4
 A3 = A3 AND B3
 A2 = A2 AND B2
 A1 = A1 AND B1
 A0 = A0 AND B0</pre>

<p>
 Es decir, se hace una operación AND entre el bit 7 de A y el bit 7 de
B, y se almacena el resultado en el bit 7 de A, y lo mismo para los bits
 restantes.
</p>

<p>
¿Para qué pueden servirnos estas 3 operaciones lógicas? Tenga el lector
por seguro que a lo largo de nuestros programas tendremos que usarlas, y
 mucho, porque son operaciones muy importantes a la hora de manipular
registros. Por ejemplo, supongamos que queremos eliminar los 4 bits más
altos de un registro, dejándolos a cero, y dejar sin alterar el estado
de los 4 bits menos significativos.
</p>

<p>
Podríamos hacer:
</p>
<pre class="code z80"> <span class="kw1">RES</span> <span class="nu0">7</span>, <span class="kw2">A</span>
 <span class="kw1">RES</span> <span class="nu0">6</span>, <span class="kw2">A</span>
 <span class="kw1">RES</span> <span class="nu0">5</span>, <span class="kw2">A</span>
 <span class="kw1">RES</span> <span class="nu0">4</span>, <span class="kw2">A</span></pre>

<p>
Pero sería mucho más sencillo:
</p>
<pre class="code z80"> <span class="kw1">AND</span> <span class="re1">%00001111</span></pre>

<p>
O sea, realizar la operación:
</p>
<pre class="code"> A = A AND 00001111b</pre>

<p>
Veamos un ejemplo del porqué:
</p>
<pre class="code"> Sea A = 10101011
 valor = 00001111
       ------------ &lt;-- Operación AND
         00001011</pre>

<p>
 Como AND es la operación lógica de la multiplicación, al hacer un AND
de A con 00001111, todos aquellos bits que son cero en 00001111 quedarán
 a cero en el resultado, y todos aquellos bits que son uno en 00001111
no modificarán el estado de los bits de A.
</p>

<p>
De la misma forma, por ejemplo, OR nos permite fusionar 2 cuartetos de bits:
</p>
<pre class="code"> Sea A = 10100000
 Sea B = 00001111
       ------------ &lt;-- Operación OR
         10101111</pre>

<p>
 La afectación de flags de las 3 instrucciones es idéntica:
</p>
<pre class="code">                        Flags
  Instrucción       |S Z H P N C|
 ----------------------------------
  AND s             |* * * P 0 0|
  OR s              |* * * P 0 0|
  XOR s             |* * * P 0 0|</pre>

<p>
 Una curiosidad: XOR A es equivalente a “LD A, 0”. Dejamos como
ejercicio al lector comprobar por qué mediante algún ejemplo práctico
con diferentes valores de A.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/04_copiarom.bas">Ejemplo de programa en BASIC que copia la ROM en la VRAM</a>
</li>
<li class="level2"><a href="src/04_copiarom.tap">Fichero tap del ejemplo copiarom.bas</a>
</li>
<li class="level2"><a href="src/04_carga.zip">Rutina de volcado de pantalla en ASM (asm+bin+bas)</a>
</li>
<li class="level2"><a href="src/04_ejemplo.asm">Ejemplo ASM de carga de pantalla con volcado</a>
</li>
<li class="level2"><a href="src/04_ejemplo.tap">Fichero tap del ejemplo anterior</a>
</li>
<li class="level2"><a href="src/04_sumaresta.asm">Ejemplos de suma y resta en BCD</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt28.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt28.html">Juego de caracteres</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="external/www.z80.info/index.html">Web del Z80</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/ti86.acz.org/z80_ref.htm" class="urlextern" title="external/ti86.acz.org/z80_ref.htm">Z80 Reference de TI86</a></div>
</li>
<li class="level2"><div class="li"> <a href="http://icarus.ticalc.org/articles/z80_faq.html" class="urlextern" title="http://icarus.ticalc.org/articles/z80_faq.html">FAQ de Icarus Productions</a></div>
</li>
<li class="level2"><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/index.html" class="urlextern" title="external/www.ticalc.org/pub/text/z80/index.html">Tablas de ensamblado y t-estados (pulsar en z80.txt, z80_reference.txt, z80time.txt)</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/www.z80.info/lesson1.htm" class="urlextern" title="external/www.z80.info/lesson1.htm">Curso de ensamblador de z80.info</a></div>
</li>
<li class="level2"><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">Pasmo</a></div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="lenguaje-ensamblador-del-z80-iii">Lenguaje Ensamblador del Z80 (III)</h1>
<div class="level1">

</div>

<h1 id="instrucciones-condicionales">Instrucciones condicionales</h1>
<div class="level1">

<p>
 Una vez hemos visto la mayoría de instrucciones aritméticas y lógicas, es el
momento de utilizarlas como condicionales para realizar cambios en el flujo
lineal de nuestro programa. En esta entrega aprenderemos a usar etiquetas y
saltos mediante instrucciones condicionales (<strong>CP</strong>, <strong>JR + condición</strong>, <strong>JP + condición</strong>,
etc.), lo que nos permitirá implementar en ensamblador las típicas instrucciones
IF/THEN/ELSE y los GOTO de BASIC.
</p>

<p>
<br>

</p>

</div>

<h2 id="las-etiquetas-en-los-programas-asm">Las etiquetas en los programas ASM</h2>
<div class="level2">

<p>
 Las <strong>etiquetas</strong> son unas útiles directivas de los ensambladores que nos
permitirán <em>hacer referencia a posiciones concretas de memoria</em> por medio de nombres,
en lugar de tener que utilizar valores numéricos.
</p>

<p>
 Veamos un ejemplo de etiqueta en un programa ensamblador:
</p>
<pre class="code z80">        ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
        <span class="kw1">NOP</span>
        <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">10</span>
bucle:
        <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">2</span><span class="re1">0</span>
        <span class="kw1">NOP</span>
        <span class="br0">(</span>...<span class="br0">)</span>
        <span class="kw1">JP</span> bucle
        <span class="kw1">RET</span></pre>

<p>
 Este es el código binario que genera el listado anterior al ser ensamblado:
</p>
<pre class="code"> 00 06 0a 3e 14 00 (...) c3 53 c3 c9</pre>

<p>
 Concretamente:
</p>
<div class="table-responsive sectionedit4"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> DIRECCION </th><th class="col1"> OPCODE </th><th class="col2"> INSTRUCCION </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 50000 </td><td class="col1"> 00 </td><td class="col2"> NOP </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 50001 </td><td class="col1"> 06 0a </td><td class="col2"> LD B, 10 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 50003 </td><td class="col1"> 3e 14 </td><td class="col2"> LD A, 20 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 50004 </td><td class="col1"> 00 </td><td class="col2"> NOP </td>
	</tr>
	<tr class="row5">
		<td class="col0"> … </td><td class="col1"> … </td><td class="col2"> … </td>
	</tr>
	<tr class="row6">
		<td class="col0"> … </td><td class="col1"> c3 53 c3 </td><td class="col2"> JP $C353   (53000) </td>
	</tr>
	<tr class="row7">
		<td class="col0"> …+1 </td><td class="col1"> c9 </td><td class="col2"> RET </td>
	</tr>
</tbody></table></div>

<p>
Si mostramos las direcciones de memoria en que se ensambla cada instrucción,
veremos:
</p>
<pre class="code">50000   NOP              ; (opcode = 1 byte)
50001   LD B, 10         ; (opcode = 2 bytes)
50003   LD A, 20         ; (opcode = 2 bytes)
50005   NOP              ; (opcode = 1 byte)
50005   (más código)
50006   (más código)
.....
50020   JP bucle
50023   RET</pre>

<p>
 ¿Dónde está en ese listado de instrucciones nuestra etiqueta
“bucle”? Sencillo: no está. <em>No es ninguna instrucción</em>, sino, para el
ensamblador, una referencia a la celdilla de memoria 50003, donde está
la instrucción que sigue a la etiqueta.
</p>

<p>
 En nuestro ejemplo anterior, le decimos al programa
ensamblador mediante ORG 50000 que nuestro código, una vez ensamblado, debe quedar
situado a partir de la dirección 50000, con lo cual cuando calcule las
direcciones de las etiquetas deberá hacerlo en relación a esta dirección
de origen. Así, en nuestro ejemplo anterior la instrucción NOP, que se
ensambla con el opcode $00, será “pokeada” (por nuestro cargador BASIC)
en la dirección 50000. La instrucción LD B, 10, cuyo opcode tiene 2 bytes,
será “pokeada” en 50001 y 50002, y así con todas las instrucciones del
programa.
</p>

<p>
 Cuando el ensamblador se encuentra la etiqueta “bucle:” después
del “LD B, 10”, ¿cómo la ensambla? Supuestamente le corresponde la
posición 50003, pero recordemos que esto no es una instrucción, sino
una etiqueta: no tiene ningún significado para el microprocesador,
sólo para el programa ensamblador. Por eso, cuando el ensamblador
encuentra la etiqueta “bucle:”, asocia internamente esta etiqueta (el
texto “bucle”) a la dirección 50003, que es la dirección donde hemos
puesto la etiqueta.
</p>

<p>
 Si la etiqueta fuera una instrucción, se ensamblaría en la dirección
50003, pero como no lo es, el programa ensamblador simplemente la
agrega a una tabla interna de referencias, donde lo que anota es:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> La etiqueta “bucle” apunta a la dirección 50003
</li>
</ul>

<p>
<br>

</p>

<p>
 Lo que realmente ensamblará en la dirección 50003 (y en la 50004) es la instrucción
siguiente: “LD A, 20”.
</p>

<p>
 Pero, entonces, ¿para qué nos <em>sirve</em> la etiqueta? Sencillo: <em>para poder hacer
referencia en cualquier momento a esa posición de memoria</em> (del programa, en
este caso), mediante una cadena fácil de recordar en lugar de mediante un
número. Es más sencillo recordar “bucle” que recordar “50003”, y si nuestro
programa es largo y tenemos muchos saltos, funciones o variables, acabaremos
utilizando decenas y centenares de números para saltos, con lo que el programa
sería inmanejable.
</p>

<p>
 El siguiente programa es equivalente al anterior, pero sin usar etiquetas:
</p>
<pre class="code z80"> ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
 <span class="kw1">NOP</span>
 <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">10</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">2</span><span class="re1">0</span>
 <span class="kw1">NOP</span>
 <span class="br0">(</span>...<span class="br0">)</span>
 <span class="kw1">JP</span> <span class="nu0">5</span><span class="re1">000</span><span class="nu0">3</span>
 <span class="kw1">RET</span></pre>

<p>
 En este caso, “JP 50003” no permite distinguir rápidamente a qué
instrucción vamos a saltar, mientras que la etiqueta “bucle” que
utilizamos en el anterior ejemplo marcaba de forma indiscutible el
destino del salto.
</p>

<p>
 Las etiquetas son muy útiles no sólo por motivos de legibilidad del
código. Imaginemos que una vez acabado
nuestro programa sin etiquetas (utilizando sólo direcciones numéricas),
con muchos
saltos (JP, CALL, JR, DJNZ…) a diferentes partes del mismo, tenemos que
modificarlo para corregir alguna parte del mismo. Al añadir o quitar
instrucciones del programa, estamos variando
las posiciones donde se ensambla todo el programa. Si por ejemplo,
añadiéramos un NOP extra al principio del mismo, ya no habría que saltar
 a
50003 sino a 50004:
</p>
<pre class="code z80"> ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
 <span class="kw1">NOP</span>
 <span class="kw1">NOP</span>        <span class="co1">; Un NOP extra</span>
 <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">10</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">2</span><span class="re1">0</span>
 <span class="kw1">NOP</span>
 <span class="br0">(</span>...<span class="br0">)</span>
 <span class="kw1">JP</span> <span class="nu0">5</span><span class="re1">000</span><span class="nu0">4</span>   <span class="co1">; La dirección de salto cambia</span>
 <span class="kw1">RET</span></pre>

<p>
 Para que nuestro programa funcione, tendríamos que cambiar TODAS las
direcciones numéricas de salto del programa, a mano (recalculandolas
todas).
Las etiquetas evitan esto, ya que es el programa ensamblador quien,
en tiempo de ensamblado, cuando está convirtiendo el programa a código
objeto, cambia todas las referencias a la etiqueta por el valor
numérico correcto (por la posición donde aparece la etiqueta). Un “JP
bucle” siempre saltaría a la dirección correcta (la de la posición de la
 etiqueta) aunque cambiemos la cantidad de instrucciones del programa.
</p>

<p>
 Como veremos posteriormente, la instrucción JP realiza un salto de
ejecución de código a una posición de memoria dada. Literalmente, un
JP XX hace el registro PC = XX, de forma que alteramos el orden de
ejecución del programa. Las etiquetas nos permiten establecer posiciones
donde saltar en nuestro programa para utilizarlas luego fácilmente:
</p>
<pre class="code z80"> ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
<span class="co1">; Al salir de esta rutina, A=tecla pulsada</span>
RutinaLeerTeclado:
   <span class="br0">(</span>instrucciones<span class="br0">)</span>    <span class="co1">; Aquí código</span>
   <span class="kw1">RET</span>
&nbsp;
<span class="co1">; Saltar (JP) a esta rutina con:</span>
<span class="co1">;  HL = Sprite a dibujar</span>
<span class="co1">;  DE = Direccion en pantalla donde dibujar</span>
RutinaDibujarSprite:
   <span class="br0">(</span>...<span class="br0">)</span>
 bucle<span class="re1">1</span>:
     <span class="br0">(</span>instrucciones<span class="br0">)</span>
 bucle2:
     <span class="br0">(</span>instrucciones<span class="br0">)</span>
 pintar:
     <span class="br0">(</span>instrucciones<span class="br0">)</span>
     <span class="kw1">JP</span> bucle<span class="re1">1</span>
   <span class="br0">(</span>...<span class="br0">)</span>
 salir:
   <span class="kw1">RET</span>
&nbsp;
 <span class="br0">(</span>etc...<span class="br0">)</span></pre>

<p>
 Así, podremos especificar múltiples etiquetas para hacer referencia
a todas las posiciones que necesitemos dentro de nuestro programa.
</p>

<p>
 Lo que nos tiene que quedar claro de este apartado son dos conceptos:
cuando el ensamblador encuentra la definición de una etiqueta, guarda
en una tabla interna la dirección de ensamblado de la siguiente
instrucción a dicha etiqueta. Después, cada vez que hay una aparición
de esa etiqueta en el código, sustituye la etiqueta por dicha
dirección de memoria. Además, podemos utilizar la etiqueta incluso
aunque la definamos después (más adelante) del código, ya que el
ensamblador hace varias pasadas en la compilación: no es necesario
primero definir la etiqueta y después hacer referencia a ella, podemos
hacerlo también a la inversa.
</p>

<p>
 Es decir, es válido tanto:
</p>
<pre class="code z80">etiqueta:
    <span class="co1">;;; (más código)</span>
    <span class="kw1">JP</span> etiqueta</pre>

<p>
 Como:
</p>
<pre class="code z80">    <span class="kw1">JP</span> etiqueta
    <span class="co1">;;; (más código)</span>
etiqueta:</pre>

<p>
 Como vamos a ver, también podemos utilizar etiquetas para referenciar a
 bloques de datos, cadenas de texto, gráficos y en general cualquier
tipo de dato en crudo que queramos insertar dentro de nuestro programa.
</p>

<p>
<br>

</p>

</div>

<h2 id="definir-datos-y-referenciarlos-con-etiquetas">Definir datos y referenciarlos con etiquetas</h2>
<div class="level2">

<p>
<br>

 Podemos insertar en cualquier posición de la
memoria y de nuestro programa datos en formato numérico o de texto con directivas como <strong>DB (DEFB), DW (DEFW)</strong> o <strong>DS (DEFS)</strong>, y hacer referencia a ellos mediante etiquetas.
</p>

<p>
Por ejemplo:
</p>
<pre class="code z80"> <span class="co1">; Principio del programa</span>
 ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
   <span class="co1">; Primero vamos a copiar los datos a la videomemoria.</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, datos
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6384</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">10</span>
   <span class="kw1">LDIR</span>
&nbsp;
   <span class="co1">; Ahora vamos a sumar 1 a cada carácter:</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">27</span>
bucle:
   <span class="kw1">LD</span> <span class="kw2">HL</span>, texto
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
   <span class="kw1">DJNZ</span> bucle
   <span class="kw1">RET</span>
&nbsp;
datos DB <span class="re1">0</span>, <span class="sy0">$</span>FF, <span class="sy0">$</span>FF, <span class="re1">0</span>, <span class="sy0">$</span>FF, <span class="re1">1</span><span class="nu0">2</span>, <span class="re1">0</span>, <span class="re1">0</span>, <span class="re1">0</span>, <span class="re1">10</span>, <span class="nu0">255</span>
texto DB <span class="st0">"Esto es una cadena de texto"</span>
&nbsp;
   <span class="co1">; Fin del programa</span>
   END</pre>

<p>
<br>

<img src="img/db.gif" class="mediacenter" alt="Resultado de RANDOMIZE USR 50000 en nuestro programa"/>
<br>

</p>

<p>
 Como puede verse, con DB hemos “insertado” datos directamente
dentro de nuestro programa. Estos datos se cargarán en memoria
(pokeados) también como parte del programa, y podremos acceder a ellos
posteriormente. Los datos, en nuestro programa, están situados en
la memoria, justo después de las instrucciones ensambladas (tras el
último RET). Podemos verlo si ensamblamos el programa:
</p>
<pre class="code">$ pasmo --bin db.asm db.bin

$ hexdump -C db.bin
00000000  21 66 c3 11 00 40 01 0a  00 ed b0 06 1b 21 71 c3  |!f...@.......!q.|
00000010  7e 3c 77 10 f8 c9 00 ff  ff 00 ff 0c 00 00 00 0a  |~&lt;w.............|
00000020  ff 45 73 74 6f 20 65 73  20 75 6e 61 20 63 61 64  |.Esto es una cad|
00000030  65 6e 61 20 64 65 20 74  65 78 74 6f              |ena de texto|
0000003c</pre>

<p>
 Si os fijáis, podemos ver el RET (201, o $C9) justo antes del bloque
de datos FF, FF, 0, FF. Concretamente, la etiqueta “datos” en el programa
hará referencia (al pokear el programa a partir de 50000), a la posición
de memoria 50022, que contendrá el 00 inicial de nuestros datos DB.
</p>

<p>
 Cuando en el programa hacemos “LD HL, datos”, el ensamblador transforma
esa instrucción en realidad en “LD HL, 50022” (fijaos en el principio del
programa: 21 66 C3, que corresponde a LD HL, C366, que es 50022). Gracias
a esto podemos manipular los datos (que están en memoria) y leerlos y
cambiarlos, utilizando un “nombre” como referencia a la celdilla de memoria
de inicio de los mismos.
</p>

<p>
 Lo mismo ocurre con el texto que se ha definido entre dobles comillas.
A partir de la dirección definida por “texto” se colocan todos los bytes
que forman la cadena “Esto es una cadena de texto”. Cada byte en memoria
es una letra de la cadena, en formato <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> (La “E” es $45, la “s” es $73“,
etc.).
</p>

<p>
 Con <strong>DB</strong> (o <strong>DEFB</strong>, que es un equivalente por compatibilidad con otros ensambladores)
podremos definir:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Cadenas de texto (todos los mensajes de texto de nuestros programas/juegos).
</li>
<li> Datos numéricos con los que trabajar (bytes, words, caracteres…).
</li>
<li> Tablas precalculadas para optimizar. Por ejemplo, podemos tener un listado como el siguiente:
</li>
</ul>

<p>
<br>

</p>
<pre class="code z80"> numeros_primos  DB  <span class="re1">1</span>, <span class="nu0">3</span>, <span class="nu0">5</span>, <span class="nu0">7</span>, <span class="re1">11</span>, <span class="re1">1</span><span class="nu0">3</span>, <span class="br0">(</span>etc...<span class="br0">)</span></pre>
<ul class="fix-media-list-overlap">
<li> Variables en memoria para trabajar en nuestro programa:
</li>
</ul>
<pre class="code z80">   vidas  DB   <span class="nu0">3</span>
   x      DB   <span class="re1">0</span>
   y      DB   <span class="re1">0</span>
   ancho  DB  <span class="re1">1</span><span class="nu0">6</span>
   alto   DB  <span class="re1">1</span><span class="nu0">6</span>
   <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>vidas<span class="br0">)</span>
   <span class="br0">(</span>...<span class="br0">)</span>
muerte:
   <span class="kw1">DEC</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>vidas<span class="br0">)</span>, <span class="kw2">A</span></pre>
<ul class="fix-media-list-overlap">
<li> Datos gráficos de nuestros sprites (creados con utilidades como SevenuP o ZXPaintBrush, por ejemplo):
</li>
</ul>
<pre class="code z80"> Enemigo:
    DB <span class="re1">1</span><span class="nu0">2</span>, <span class="re1">1</span><span class="nu0">3</span>, <span class="nu0">25</span>, <span class="re1">1</span><span class="nu0">23</span>, <span class="nu0">2</span><span class="re1">10</span> <span class="br0">(</span>etc...<span class="br0">)</span></pre>

<p>
 Ahora bien, es muy importante tener clara una consideración: los datos que introducimos
con DB (o DW, o cualquier otra directiva de inclusión) no se ensamblan, pero se
insertan dentro del código resultante tal cual. Y el Z80 no puede
distinguir un 201 introducido con DB de un opcode 201 (RET), con lo cual tenemos
que asegurarnos de que dicho código no se ejecute, como en el siguiente programa:
</p>
<pre class="code z80"> ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
<span class="co1">; Cuidado, al situar los datos aquí, cuando saltemos a 50000</span>
<span class="co1">; con RANDOMIZE USR 50000, ejecutaremos estos datos como si</span>
<span class="co1">; fueran opcodes.</span>
datos DB <span class="re1">00</span>, <span class="nu0">2</span><span class="re1">01</span>, <span class="re1">100</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="nu0">255</span>, <span class="re1">11</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
  <span class="br0">(</span>más instrucciones<span class="br0">)</span>
  <span class="kw1">RET</span>
&nbsp;
 Lo correcto serí<span class="kw2">a</span>:
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="co1">; Ahora el salto a 50000 ejecutará el LD B, A, no los</span>
  <span class="co1">; datos que habíamos introducido antes.</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
  <span class="br0">(</span>más instrucciones<span class="br0">)</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">; Aquí nunca serán ejecutados, el RET está antes.</span>
datos DB <span class="re1">00</span>, <span class="nu0">2</span><span class="re1">01</span>, <span class="re1">100</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="nu0">255</span>, <span class="re1">11</span></pre>

<p>
 <em>Los microprocesadores como el Z80 no saben distinguir entre datos
e instrucciones</em>, y es por eso que tenemos que tener cuidado de no
ejecutar datos como si fueran códigos de instrucción del Z80. De
hecho, si hacemos un RANDOMIZE USR XX (siendo XX cualquier valor de
la memoria fuera de la ROM), lo más probable es que ejecutemos datos como si fueran
instrucciones y el Spectrum se cuelgue, ya que los datos no son parte de un
programa, y la ejecución resultante de interpretar esos datos no
tendría ningún sentido.
</p>

<p>
<br>

</p>

</div>

<h2 id="saltos-absolutos-incondicionalesjp">Saltos absolutos incondicionales: JP</h2>
<div class="level2">

<p>
 Ya sabemos definir etiquetas en nuestros programas y referenciarlas. Ahora la pregunta
es: ¿para qué sirven estas etiquetas? Aparte de referencias para
usarlas como variables o datos, su principal uso será saltar a ellas con las
<em>instrucciones de salto</em>.
</p>

<p>
 Para empezar vamos a ver 2 instrucciones de salto incondicionales, es decir, cuando
lleguemos a una de esas 2 instrucciones, se modificará el registro PC para cambiar
la ejecución del programa. De esta forma podremos realizar bucles,
saltos a rutinas o funciones, etc.
</p>

<p>
 Empecemos con <strong>JP</strong> (abreviatura de <strong>JumP</strong>):
</p>
<pre class="code z80">      <span class="co1">; Ejemplo de un programa con un bucle infinito</span>
      ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
      <span class="kw1">XOR</span> <span class="kw2">A</span>               <span class="co1">; A = 0</span>
bucle:
      <span class="kw1">INC</span> <span class="kw2">A</span>               <span class="co1">; A = A + 1</span>
      <span class="kw1">LD</span> <span class="br0">(</span><span class="re1">1</span><span class="nu0">6384</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Escribir valor de A en (16384)</span>
      <span class="kw1">JP</span> bucle
&nbsp;
      <span class="kw1">RET</span>                 <span class="co1">; Esto nunca se ejecutará</span>
&nbsp;
      END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 ¿Qué hace el ejemplo anterior? Ensamblémoslo con “pasmo --tapbas bucle.asm bucle.tap”
y carguémoslo en BASIC.
</p>

<p>
 Nada más entrar en 50000, se ejecuta un “INC A”. Después se hace un “LD (16384), A”, es
decir, escribimos en la celdilla (16384) de la memoria el valor que contiene A. Esta
celdilla se corresponde con los primeros 8 píxeles de la pantalla, con lo cual estaremos
cambiando el contenido de la misma.
</p>

<p>
 Tras esta escritura, encontramos un “JP bucle”, que lo que hace es cambiar el valor
de PC y hacerlo, de nuevo, PC=50000. El código se
volverá a repetir, y de nuevo al llegar a JP volveremos a saltar a la dirección
definida por la etiqueta “bucle”. Es un bucle infinito, realizado gracias a este
salto incondicional (podemos reiniciar el Spectrum para retomar el control). Estaremos
repitiendo una y otra vez la misma porción de código, que cambia el contenido de
los 8 primeros píxeles de pantalla poniendo en ellos el valor de A (que varía desde 0
a 255 continuadamente).
</p>

<p>
 <em>Utilizaremos pues JP para cambiar el rumbo del programa</em> y cambiar PC para ejecutar otras
porciones de código (anteriores o posteriores a la posición actual) del mismo. JP realiza pues
lo que se conoce como “SALTO INCONDICIONAL ABSOLUTO”, es decir, saltar a una
posición absoluta de memoria (una celdilla de 0 a 65535), mediante la asignación
de dicho valor al registro PC.
</p>

<p>
 Existen 3 maneras de usar JP:
</p>

<p>
<br>

a.- <strong>JP NN</strong>:
</p>

<p>
 Saltar a la dirección NN.
 Literalmente: PC = NN
</p>

<p>
<br>

<br>

b.- <strong>JP (HL)</strong>
</p>

<p>
 Saltar a la dirección contenida en el registro HL (ojo, no
 a la dirección apuntada por el registro HL, sino directamente
 a su valor).
 Literalmente: PC = HL
</p>

<p>
<br>

<br>

c.- <strong>JP (registro_indice)</strong>
</p>

<p>
 Saltar a la dirección contenida en IX o IY.
 Literalmente: PC = IX o PC = IY
</p>

<p>
<br>

 Ninguna de estas instrucciones afecta a los flags:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
 JP NN               |- - - - - -|
 JP (HL)             |- - - - - -|
 JP (IX)             |- - - - - -|
 JP (IY)             |- - - - - -|</pre>

<p>
 Recordemos que nuestra CPU almacena primero en memoria los bytes bajos
de
los números de 16 bits, por lo que a la hora de ensamblar un salto como
“JP 50000” (JP $C350), dicha instrucción será traducida como:
</p>
<pre class="code"> C3 50 C3</pre>

<p>
 que quiere decir:
</p>
<pre class="code"> JP 50 C3  -&gt;  JP $C350  -&gt;  JP 50000</pre>

<p>
 Como podéis ver, aparte del código de instrucción (C3) almacenamos un
valor numérico, absoluto, de la posición a la que saltar. Es pues una
instrucción de 3 bytes.
</p>

<p>
 Literalmente, <strong>JP NN</strong> se traduce por <strong>PC=NN</strong> .
</p>

<p>
<br>

</p>

</div>

<h2 id="saltos-relativos-incondicionalesjr">Saltos relativos incondicionales: JR</h2>
<div class="level2">

<p>
 Además de JP, tenemos otra instrucción para realizar saltos incondicionales: <strong>JR</strong>.
JR trabaja exactamente igual que JP: realiza un salto (cambiando el valor del
registro PC), pero lo hace de forma diferente.
</p>

<p>
 <strong>JR</strong> son las siglas de “<strong>Jump Relative</strong>”, y es que esta instrucción
en lugar de realizar un salto absoluto (a una posición de memoria
0-65535), lo hace <em>de forma relativa</em>, es decir, a una posición de
memoria alrededor de la posición actual (una vez decodificada la
instrucción JR).
</p>

<p>
 El argumento de JR no es pues un valor numérico
de 16 bits (0-65535) sino un valor de 8 bits en complemento a dos
que nos permite saltar desde la posición actual (referenciada en el
ensamblador como “$”) hasta 127 bytes hacia adelante y 127 bytes hacia
atrás:
</p>

<p>
 Ejemplos de instrucciones JR:
</p>
<pre class="code"> JR $+25      ; Saltar adelante 25 bytes: PC = PC+25
 JR $-100     ; Saltar atrás 100 bytes:   PC = PC-100</pre>

<p>
 Nosotros, gracias a las etiquetas, podemos olvidarnos de calcular
posiciones y hacer referencia de una forma más sencilla a posiciones
en nuestro programa:
</p>

<p>
 Veamos el mismo ejemplo anterior de JP, con JR:
</p>
<pre class="code z80">      <span class="co1">; Ejemplo de un programa con un bucle infinito</span>
      ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
bucle:
      <span class="kw1">INC</span> <span class="kw2">A</span>
      <span class="kw1">LD</span> <span class="br0">(</span><span class="re1">1</span><span class="nu0">6384</span><span class="br0">)</span>, <span class="kw2">A</span>
      <span class="kw1">JR</span> bucle
&nbsp;
      <span class="kw1">RET</span> <span class="co1">; Esto nunca se ejecutará</span></pre>

<p>
 Como puede verse, el ejemplo es exactamente igual que en el caso
anterior. No tenemos que utilizar el carácter $ (posición actual de
ensamblado) porque al hacer uso de etiquetas es el ensamblador quien
se encarga de traducir la etiqueta a un desplazamiento de 8 bits y
ensamblarlo.
</p>

<p>
 ¿Qué diferencia tiene JP con JR? Pues bien: para empezar en lugar de
ocupar 3 bytes (JP + la dirección de 16 bits), ocupa sólo 2 (JR +
el desplazamiento de 8 bits) con lo cual se decodifica y ejecuta más
rápido.
</p>

<p>
 Además, como la dirección del salto no es absoluta, sino relativa,
y de 8 bits en complemento a dos, no podemos saltar a cualquier
punto del programa, sino que sólo podremos saltar a código que esté
cerca de la línea actual: como máximo 127 bytes por encima o por debajo de la posición actual en memoria.
</p>

<p>
 Si tratamos de ensamblar un salto a una etiqueta que está más allá del
alcance de un salto relativo, obtendremos un error como el siguiente:
</p>
<pre class="code">ERROR: Relative jump out of range</pre>

<p>
 En ese caso, tendremos que cambiar la instrucción “JR etiqueta” por un
“JP etiqueta”, de forma que el ensamblador utilice un salto absoluto que
 le permita llegar a la posición de memoria que queremos saltar y que
está más alejada de que la capacidad de salto de JR.
</p>

<p>
 ¿Cuál es la utilidad o ventaja de los saltos relativos aparte de ocupar 2 bytes en lugar de 3? Pues que los saltos realizados
en rutinas que usen JR y no JP son todos relativos a la posición actual,
con lo cual la rutina es REUBICABLE. Es decir, si cambiamos nuestra
rutina de 50000 a 60000 (por ejemplo), funcionará, porque los saltos
son relativos a “$”. En una rutina programada con JP, si la pokeamos
en 60000 en lugar de en 50000, cuando hagamos saltos (JP 50003, por
ejemplo), saltaremos a lugares donde no está el código (ahora está en
60003) y el programa no hará lo que esperamos. En resumen: JR permite
programar rutinas reubicables y JP no.
</p>

<p>
(Nota: se dice que una rutina es reubicable cuando estando programada
a partir de una determinada dirección de memoria, podemos copiar la
rutina a otra dirección y sus saltos funcionarán correctamente
por no ser absolutos).
</p>

<p>
 ¿Recordáis en los cursos y rutinas de Microhobby cuando se decía
”<em>Esta rutina es reubicable</em>“? Pues quería decir exactamente eso, que
podías copiar la rutina en cualquier lugar de la memoria y llamarla,
dado que el autor de la misma había utilizado sólo saltos relativos
y no absolutos, por lo que daría igual la posición de memoria en que la POKEaramos.
</p>

<p>
 En nuestro caso, al usar un programa ensamblador en lugar de
simplemente disponer de las rutinas en código máquina (ya ensambladas)
que nos mostraba microhobby, no se nos plantearán esos problemas,
dado que nosotros podemos usar etiquetas y copiar cualquier porción
del código a dónde queramos de nuestro programa. Aquellas rutinas
etiquetadas como “reubicables” o “no reubicables” estaban ensambladas
manualmente y utilizaban direcciones de memoria numéricas o saltos
absolutos.
</p>

<p>
 Nuestro ensamblador (Pasmo, z80asm, etc) nos permite utilizar
etiquetas, que serán reemplazadas por sus direcciones de memoria
durante el proceso de ensamblado. Nosotros podemos modificar las
posibles de nuestras rutinas en el código, y dejar que el ensamblador
las “reubique” por nosotros, ya que al ensamblará cambiará todas
las referencias a las etiquetas que usamos.
</p>

<p>
 Esta facilidad de trabajo contrasta con las dificultades que tenían
los programadores de la época que no disponían de ensambladores
profesionales. Imaginad la cantidad de usuarios que ensamblaban
sus programas a mano, usando saltos relativos y absolutos (y como
veremos, llamadas a subrutinas), que en lugar de sencillos nombres
(JP A_mayor_que_B) utilizaban directamente direcciones en memoria.
</p>

<p>
 E imaginad el trabajo que suponía mantener un listado en papel todas
los direcciones de saltos, subrutinas y variables, referenciados por direcciones de
memoria y no por nombres, y tener que cambiar muchos de ellos cada
vez que tenían que arreglar un fallo en una subrutina y cambiaban los
destinos de los saltos por crecer el código que había entre ellos.
</p>

<p>
 Dejando ese tema aparte, la tabla de afectación de flags de JR es
la misma que para JP: nula.
</p>
<pre class="code">
                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
  JR d               |- - - - - -|

 (Donde "d" es un desplazamiento de 8 bits)</pre>

<p>
 Literalmente, JR d se traduce por PC=PC+d.
</p>

<p>
<br>

</p>

</div>

<h2 id="saltos-condicionales-con-los-flags">Saltos condicionales con los flags</h2>
<div class="level2">

<p>
 Ya hemos visto la forma de realizar saltos incondicionales. A continuación
veremos cómo realizar los saltos (ya sean absolutos con JP o relativos
con JR) <em>de acuerdo a unas determinadas condiciones</em>.
</p>

<p>
 Las instrucciones condicionales disponibles trabajan con el estado
de los flags del registro F, y son:
</p>

<p>
<br>

 <strong>JP NZ, direccion</strong> : Salta si el indicador de cero (Z) está a cero (resultado no cero).<br>

 <strong>JP Z, direccion</strong>  : Salta si el indicador de cero (Z) está a uno (resultado cero).<br>

 <strong>JP NC, direccion</strong> : Salta si el indicador de carry (C) está a cero.<br>

 <strong>JP C, direccion</strong>  : Salta si el indicador de carry (C) está a uno.<br>

 <strong>JP PO, direccion</strong> : Salta si el indicador de paridad/desbordamiento (P/O) está a cero.<br>

 <strong>JP PE, direccion</strong> : Salta si el indicador de paridad/desbordamiento (P/O) está a uno.<br>

 <strong>JP P, direccion</strong>  : Salta si el indicador de signo S está a cero (resultado positivo).<br>

 <strong>JP M, direccion</strong>  : Salta si el indicador de signo S está a uno (resultado negativo).<br>

<br>

 <strong>JR NZ, relativo</strong> : Salta si el indicador de cero (Z) está a cero (resultado no cero).<br>

 <strong>JR Z,  relativo</strong> : Salta si el indicador de cero (Z) está a uno (resultado cero).<br>

 <strong>JR NC, relativo</strong> : Salta si el indicador de carry (C) está a cero.<br>

 <strong>JR C,  relativo</strong> : Salta si el indicador de carry (C) está a uno.<br>

<br>

</p>

<p>
 Donde “dirección” es un valor absoluto 0-65535, y “relativo” es un desplazamiento
de 8 bits con signo -127 a +127.
</p>

<p>
 (Nota: en el listado de instrucciones, positivo o negativo se refiere
a considerando el resultado de la operación anterior en complemento a
dos).
</p>

<p>
 Así, supongamos el siguiente programa:
</p>
<pre class="code z80">   <span class="kw1">JP</span> Z, destino
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">10</span>
destino:
   <span class="kw1">NOP</span></pre>

<p>
 (donde “destino” es una etiqueta definida en algún lugar de nuestro programa,
aunque también habríamos podido especificar directamente una dirección como
por ejemplo 50004).
</p>

<p>
 Cuando el procesador lee el “JP Z, destino”, lo que hace es lo siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> Si el flag Z está activado (a uno),
saltamos a “destino” (con lo cual no se ejecuta el “LD A, 10”),
ejecutándose el código a partir del “NOP”.
</li>
<li> Si no está activo (a cero) no se realiza ningún salto, con lo que se ejecutaría el “LD A, 10”, y seguiría después con el “NOP”.
</li>
</ul>

<p>
 En BASIC, “<strong>JP Z, destino</strong>” sería algo como:
</p>
<pre class="code basic"> IF FLAG_ZERO = 1 THEN GOTO destino</pre>

<p>
 Y “<strong>JP NZ, destino</strong>” sería:
</p>
<pre class="code basic"> IF FLAG_ZERO = 0 THEN GOTO destino</pre>

<p>
 Con estas instrucciones podemos realizar saltos condicionales en función del
estado de los flags o indicadores del registro F: podemos saltar si el resultado
de una operación es cero, si no es cero, si hubo acarreo, si no lo hubo…
</p>

<p>
 Y el lector se preguntará: ¿y tiene utilidad realizar saltos en
función de los flags? Pues la respuesta es: bien usados, lo tiene
para todo tipo de tareas:
</p>
<pre class="code z80">  <span class="co1">; Repetir 100 veces la instruccion NOP</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">100</span>
bucle:
  <span class="kw1">NOP</span>
&nbsp;
  <span class="kw1">DEC</span> <span class="kw2">A</span>          <span class="co1">; Decrementamos A.</span>
                 <span class="co1">; Cuando A sea cero, Z se pondrá a 1</span>
  <span class="kw1">JR</span> NZ, bucle   <span class="co1">; Mientras Z=0, repetir el bucle</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">2</span><span class="re1">00</span>      <span class="co1">; Aquí llegaremos cuando Z sea 1 (A valga 0)</span>
  <span class="co1">; resto del programa</span></pre>

<p>
 Es decir: cargamos en A el valor 100, y tras ejecutar la instrucción “NOP”, hacemos
un “DEC A” que decrementa su valor (a 99). Como el resultado de “DEC A”
es 99 y no cero, el flag de Z (de cero) se queda a 0, (recordemos que
sólo se pone a uno cuando la última operación resultó ser cero).
</p>

<p>
 Y como el flag Z es cero (NON ZERO = no activado el flag zero) la
instrucción “JR NZ, bucle” realiza un salto a la etiqueta “bucle”.
Allí se ejecuta el NOP y de nuevo el “DEC A”, dejando ahora A en 98.
</p>

<p>
 Tras repetirse 100 veces el proceso, llegará un momento en que A valga
cero tras el “DEC A”. En ese momento se activará el flag de ZERO con lo
que la instrucción “JR NZ, bucle” no realizará el salto y continuará
con el “LD A, 200”.
</p>

<p>
 Veamos otro ejemplo más gráfico: vamos a implementar en ASM una
comparación de igualdad:
</p>
<pre class="code basic"> IF A=B THEN GOTO iguales ELSE GOTO distintos</pre>

<p>
 En ensamblador:
</p>
<pre class="code z80">   <span class="kw1">SUB</span> <span class="kw2">B</span>              <span class="co1">; A = A-B</span>
   <span class="kw1">JR</span> Z, iguales      <span class="co1">; Si Z=1 saltar a iguales </span>
   <span class="kw1">JR</span> NZ, distintos   <span class="co1">; Si Z=0 saltar a distintos </span>
&nbsp;
iguales:
   <span class="co1">;;; (código)</span>
   <span class="kw1">JR</span> seguir
&nbsp;
distintos:
   <span class="co1">;;; (código)</span>
   <span class="kw1">JR</span> seguir
&nbsp;
seguir:</pre>

<p>
 (Nota: se podría haber usado JP en vez de JR)
</p>

<p>
 Para comparar A con B los restamos (A=A-B). Si el resultado de la resta
es cero, es porque A era igual a B. Si no es cero, es que eran distintos.
Y utilizando el flag de Zero con JP Z y JP NZ podemos detectar esa
diferencia.
</p>

<p>
 Pronto veremos más a fondo otras instrucciones de comparación, pero este
ejemplo debe bastar para demostrar la importancia de los flags y de su
uso en instrucciones de salto condicionales. Bien utilizadas podemos
alterar el flujo del programa a voluntad. Es cierto que no es tan
inmediato ni cómodo como los &gt;, &lt;, = y &lt;&gt; de BASIC, pero el resultado
es el mismo, y es fácil acostumbrarse a este tipo de comparaciones
mediante el estado de los flags.
</p>

<p>
 Para finalizar, un detalle sobre <strong>DEC+JR</strong>: La combinación <strong>DEC B / JR NZ</strong>
se puede sustituir (es más eficiente, y más sencillo) por el comando
<strong>DJNZ</strong>, que literalmente significa “Decrementa B y si no es cero, salta
a &lt;direccion&gt;”.
</p>

<p>
<br>

 <strong>DJNZ direccion</strong>
</p>

<p>
 Equivale a decrementar B y a la dirección indicada en caso de que B no valga cero tras el decremento.
</p>

<p>
 Esta instrucción se usa habitualmente en bucles (usando B como iterador
del mismo) y, al igual que JP y JR, no afecta al estado de los flags:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
  |JP COND, NN       |- - - - - -|
  |JR COND, d        |- - - - - -|
  |DJNZ d            |- - - - - -|</pre>

<p>
 El argumento de salto de DJNZ es de 1 byte, por lo que para saltos
relativos de más de 127 bytes hacia atrás o hacia adelante (-127 a
+127), DJNZ se tiene que sustituir por la siguiente combinación de
instrucciones:
</p>
<pre class="code z80">  <span class="kw1">DEC</span> <span class="kw2">B</span>                      <span class="co1">; Decrementar B, afecta a los flags</span>
  <span class="kw1">JP</span> NZ, direccion           <span class="co1">; Salto absoluto: permite cualquier distancia</span></pre>

<p>
 DJNZ trabaja con el registro B como contador de repeticiones, lo que
implica que podemos realizar de 0 a 255 iteraciones. En caso de
necesitar realizar hasta 65535 iteraciones tendremos que utilizar un
registro de 16 bits como BC de la siguiente forma:
</p>
<pre class="code z80">   <span class="kw1">DEC</span> <span class="kw2">BC</span>                    <span class="co1">; Decrementamos BC -&gt; no afecta a los flags</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                   <span class="co1">; Cargamos B en A</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>                      <span class="co1">; Hacemos OR a de A y C (de B y C)</span>
   <span class="kw1">JR</span> NZ, direccion          <span class="co1">; Si (B OR C) no es cero, BC != 0, saltar</span></pre>

<p>
<br>

</p>

</div>

<h2 id="instruccion-de-comparacion-cp">Instruccion de comparacion CP</h2>
<div class="level2">

<p>
<br>

</p>

</div>

<h3 class="sectionedit10" id="comparaciones-de-8-bits">Comparaciones de 8 bits</h3>
<div class="level3">

<p>
 Para realizar comparaciones (especialmente de igualdad, mayor que y menor que)
utilizaremos la instrucción <strong>CP</strong>. Su formato es:
</p>
<pre class="code z80"> <span class="kw1">CP</span> origen</pre>

<p>
 Donde “origen” puede ser A, F, B, C, D, E, H, L, un valor numérico de 8 bits
directo, (HL), (IX+d) o (IY+d).
</p>

<p>
 Al realizar una instrucción “<strong>CP origen</strong>”, el microprocesador ejecuta la
operación “<strong>A-origen</strong>”, <em>pero no almacena el resultado en ningún sitio.</em>
Lo que sí que hace es <em>alterar el estado de los flags</em> de acuerdo al
resultado de la operación.
</p>

<p>
 Recordemos el ejemplo de comparación anterior donde realizábamos una
resta, perdiendo por tanto el valor de A:
</p>
<pre class="code z80">   <span class="kw1">SUB</span> <span class="kw2">B</span>                  <span class="co1">; A = A-B</span>
   <span class="kw1">JR</span> Z, iguales          <span class="co1">; Si Z=1 saltar a iguales</span>
   <span class="kw1">JR</span> NZ, distintos       <span class="co1">; Si Z=0 saltar a distintos</span></pre>

<p>
 Gracias a CP, podemos hacer la misma operación pero sin perder el valor
de A (por la resta):
</p>
<pre class="code z80">   <span class="kw1">CP</span> <span class="kw2">B</span>                   <span class="co1">; Flags = estado(A-B)</span>
   <span class="kw1">JR</span> Z, iguales          <span class="co1">; Si Z=1 saltar a iguales</span>
   <span class="kw1">JR</span> NZ, distintos       <span class="co1">; Si Z=0 saltar a distintos</span></pre>

<p>
¿Qué nos permite esto? Aprovechando todos los flags del registro F
(flag de acarreo, flag de zero, etc), realizar comparaciones como
las siguientes:
</p>
<pre class="code z80">  <span class="co1">; Comparación entre A Y B (=, &gt; y &lt;)</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">5</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">3</span>
&nbsp;
  <span class="kw1">CP</span> <span class="kw2">B</span>                            <span class="co1">; Flags = estado(A-B)</span>
  <span class="kw1">JP</span> Z, A_Igual_que_B             <span class="co1">; IF(a-b)=0 THEN a=b</span>
  <span class="kw1">JP</span> NC, A_Mayor_o_igual_que_B    <span class="co1">; IF(a-b)&gt;0 THEN a&gt;=b</span>
  <span class="kw1">JP</span> <span class="kw2">C</span>, A_Menor_que_B             <span class="co1">; IF(a-b)&lt;0 THEN a&lt;b</span>
&nbsp;
A_Mayor_que_B:
  <span class="co1">;;; (instrucciones)</span>
  <span class="kw1">JP</span> fin
&nbsp;
A_Menor_que_B:
  <span class="co1">;;; (instrucciones)</span>
  <span class="kw1">JP</span> fin
&nbsp;
A_Igual_que_B:
  <span class="co1">;;; (instrucciones)</span>
&nbsp;
fin:
  <span class="co1">;;; (continúa el programa)</span></pre>

<p>
 Vamos a ilustrar la anterior porción de código con un ejemplo que nos permitirá,
además, descubrir una forma muy singular de hacer debugging en vuestras pruebas
aprendiendo ensamblador. Vamos a sacar información por pantalla de forma que
podamos ver en qué parte del programa estamos. Este mismo “sistema” podéis
emplearlo (hasta que veamos cómo sacar texto o gráficos concretos por pantalla)
para “depurar” vuestros programas y hacer pruebas.
</p>

<p>
 Consiste en escribir un valor en la memoria, justo en la zona de la pantalla,
para así distinguir las partes de nuestro programa por las que pasamos. Así,
escribiremos 255 (8 pixeles activos) en una línea de la parte superior de la
pantalla izquierda (16960), en el centro de la misma (19056), o en la parte
inferior derecha (21470):
</p>
<pre class="code z80"> <span class="co1">; Principio del programa</span>
 ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="co1">; Comparacion entre A Y B (=, &gt; y &lt;)</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">7</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">5</span>
&nbsp;
  <span class="kw1">CP</span> <span class="kw2">B</span>                    <span class="co1">; Flags = estado(A-B)</span>
  <span class="kw1">JP</span> Z, A_Igual_que_B     <span class="co1">; IF(a-b)=0 THEN a=b</span>
  <span class="kw1">JP</span> NC, A_Mayor_que_B    <span class="co1">; IF(a-b)&gt;0 THEN a&gt;b</span>
  <span class="kw1">JP</span> <span class="kw2">C</span>, A_Menor_que_B     <span class="co1">; IF(a-b)&lt;0 THEN a&lt;b</span>
&nbsp;
A_Mayor_que_B:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="re1">1</span><span class="nu0">696</span><span class="re1">0</span><span class="br0">)</span>, <span class="kw2">A</span>           <span class="co1">; 8 pixels en la parte sup-izq</span>
  <span class="kw1">JP</span> fin
&nbsp;
A_Menor_que_B:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="re1">1</span><span class="nu0">9</span><span class="re1">0</span><span class="nu0">56</span><span class="br0">)</span>, <span class="kw2">A</span>           <span class="co1">; centro de la pantalla</span>
  <span class="kw1">JP</span> fin
&nbsp;
A_Igual_que_B:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="nu0">2</span><span class="re1">1</span><span class="nu0">47</span><span class="re1">0</span><span class="br0">)</span>, <span class="kw2">A</span>           <span class="co1">; parte inferior derecha</span>
&nbsp;
fin:
  <span class="kw1">JP</span> fin                  <span class="co1">; bucle infinito, para que podamos ver </span>
                          <span class="co1">; el resultado de la ejecucion</span>
&nbsp;
  END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 Lo ensamblamos con: <em>pasmo --tapbas compara.asm compara.tap</em>, y lo cargamos en
el Spectrum o emulador. La sentencia END 50000 nos ahorra el teclear “RANDOMIZE
USR 50000” ya que pasmo lo introducirá en el cargador BASIC por nosotros.
Jugando con los valores de A y B del listado deberemos ver cómo
cambia el lugar al que saltamos (representado por el lugar de la pantalla en
que vemos dibujada nuestra pequeña línea de 8 píxeles).
</p>

<p>
<br>

<img src="img/compara.png" class="mediacenter" alt="Salida del programa anterior con A=5 y B=7"/>
<br>

</p>

<p>
 Finalmente, destacar que nada nos impide el hacer comparaciones multiples o anidadas:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">5</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">3</span>
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="nu0">6</span>
&nbsp;
  <span class="kw1">CP</span> <span class="kw2">B</span>                  <span class="co1">; IF A==B</span>
  <span class="kw1">JR</span> Z, A_Igual_a_B     <span class="co1">; THEN goto A_Igual_a_B</span>
  <span class="kw1">CP</span> <span class="kw2">C</span>                  <span class="co1">; IF A==C</span>
  <span class="kw1">JR</span> Z, A_Igual_a_C     <span class="co1">; THEN goto A_Igual_a_C</span>
  <span class="kw1">JP</span> Fin                <span class="co1">; si no, salimos</span>
A_Igual_a_B:
  <span class="co1">;;; (...)</span>
  <span class="kw1">JR</span> Fin
&nbsp;
A_Igual_a_C:
  <span class="co1">;;; (...)</span>
&nbsp;
Fin:
  <span class="br0">(</span>resto del programa<span class="br0">)</span></pre>

<p>
 La instrucción CP afecta a todos los flags:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
 |CP s               |* * * V 1 *|</pre>

<p>
 El flag “N” se pone a uno porque, aunque se ignore el resultado, la
operación efectuada es una resta.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit11" id="comparaciones-de-16-bits">Comparaciones de 16 bits</h3>
<div class="level3">

<p>
 Aunque la instrucción CP sólo permite comparar un valor de 8 bits con
el valor contenido en el registro A, podemos realizar 2 comparaciones CP
 para verificar si un valor de 16 bits es menor, igual o mayor que otro.
</p>

<p>
 Si lo que queremos comparar es un registro con otro, podemos hacerlo
mediante un CP de su parte alta y su parte baja. Por ejemplo, para
comparar HL con DE:
</p>
<pre class="code z80">  <span class="co1">;;; Comparacion 16 bits de HL y DE</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
  <span class="kw1">CP</span> <span class="kw2">D</span>
  <span class="kw1">JR</span> NZ, no_iguales
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
  <span class="kw1">CP</span> <span class="kw2">E</span>
  <span class="kw1">JR</span> NZ, no_iguales
iguales:
  <span class="co1">;;; (...)</span>
&nbsp;
no_iguales:
  <span class="co1">;;; (...)</span></pre>

<p>
 Para comparar si el valor de un registro es igual a un valor numérico
inmediato (introducido directamente en el código de programa),
utilizaríamos el siguiente código:
</p>
<pre class="code z80">   <span class="co1">;;; Comparacion 16 bits de HL y VALOR_NUMERICO (inmediato)</span>
   <span class="co1">;;; VALOR_NUMERICO puede ser cualquier valor de 0 a 65535</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
  <span class="kw1">CP</span> VALOR_NUMERICO <span class="sy0">/</span> <span class="nu0">256</span>         <span class="co1">; Parte alta (VALOR/256)</span>
  <span class="kw1">JR</span> NZ, no_iguales
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
  <span class="kw1">CP</span> VALOR_NUMERICO <span class="sy0">%</span> <span class="nu0">256</span>         <span class="co1">; Parte baja (Resto de VALOR/256)</span>
  <span class="kw1">JR</span> NZ, no_iguales
iguales:
  <span class="co1">;;; (...)</span>
&nbsp;
no_iguales:
  <span class="co1">;;; (...)</span></pre>

<p>
<br>

</p>

</div>

<h2 id="consideraciones-de-las-condiciones">Consideraciones de las condiciones</h2>
<div class="level2">

<p>
 A la hora de utilizar instrucciones condicionales hay que tener en
cuenta que no todas las instrucciones afectan a los flags. Por ejemplo,
la instrucción “DEC BC” no pondrá el flag Z a uno cuando BC sea cero.
Si intentamos montar un bucle mediante DEC BC + JR NZ, nunca saldremos
del mismo, ya que DEC BC no afecta al flag de zero.
</p>
<pre class="code z80">    <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1000</span>        <span class="co1">; BC = 1000</span>
bucle:
    <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
    <span class="kw1">DEC</span> <span class="kw2">BC</span>             <span class="co1">; BC = BC-1 (pero NO ALTERA el Carry Flag)</span>
    <span class="kw1">JR</span> NZ, bucle       <span class="co1">; Nunca se pondrá a uno el ZF, siempre salta</span></pre>

<p>
 Para evitar estas situaciones necesitamos conocer la afectación de
los flags ante cada instrucción, que podéis consultar en todas las
tablas que os hemos proporcionado.
</p>

<p>
 Podemos realizar algo similar al ejemplo anterior aprovechándonos
(de nuevo) de los flags y de los resultados de las operaciones lógicas
(y sus efectos sobre el registro F). Como ya vimos al tratar la
instrucción DJNZ, podemos comprobar si un registro de 16 bits vale 0
realizando un OR entre la parte alta y la parte baja del mismo. Esto sí
afectará a los flags y permitirá realizar el salto condicional:
</p>
<pre class="code z80">    <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1000</span>        <span class="co1">; BC = 1000</span>
&nbsp;
bucle:
    <span class="br0">(</span>...<span class="br0">)</span>
    <span class="kw1">DEC</span> <span class="kw2">BC</span>             <span class="co1">; Decrementamos BC. No afecta a F.</span>
    <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; A = B</span>
    <span class="kw1">OR</span> <span class="kw2">C</span>               <span class="co1">; A = A OR C </span>
                       <span class="co1">; Esto sí que afecta a los flags.</span>
                       <span class="co1">; Si B==C y ambos son cero, el resultado</span>
                       <span class="co1">; del OR será cero y el ZF se pondrá a 1.</span>
    <span class="kw1">JR</span> NZ, bucle       <span class="co1">; ahora sí que funcionará el salto si BC=0</span></pre>

<p>
 Más detalles sobre los saltos condicionales: esta vez respecto al
signo. Las condiciones P y M (JP P, JP M) nos permitirán
realizar saltos según el estado del bit de signo. Resultará
especialmente útil después de operaciones aritméticas.
</p>

<p>
 Los saltos por Paridad/Overflow (JP PO, JP PE) permitirán realizar
saltos en función de la paridad cuando la última operación realizada
modifique ese bit de F según la paridad del resultado. La misma
condición nos servirá para desbordamientos si la última operación
que afecta a flags realizada modifica este bit con respecto a dicha
condición.
</p>

<p>
 ¿Qué quiere decir esto? Que si, por ejemplo, realizamos una suma o
resta, JP PO y JP PE responderán en función de si ha habido un
desbordamiento o no y no en función de la paridad, porque las
sumas y restas actualizan dicho flag según los desbordamientos,
no según la paridad.
</p>

<p>
<br>

</p>

</div>

<h2 id="la-importancia-de-la-probabilidad-de-salto">La importancia de la probabilidad de salto</h2>
<div class="level2">

<p>
 Ante una instrucción condicional, el microprocesador tendrá 2 opciones,
según los valores que comparemos y el tipo de comparación que hagamos
(si es cero, si no es cero, si es mayor o menor, etc.). Al final, sólo
habrá 2 caminos posibles: saltar a una dirección de destino, o no saltar
y continuar en la dirección de memoria siguiente al salto condicional.
</p>

<p>
 Aunque pueda parecer una pérdida de tiempo, en rutinas críticas <em>es muy
interesante el pararse a pensar cuál puede ser el caso con más probabilidades
de ejecución</em>, ya que el tiempo empleado en la opción ”<em>CONDICION CIERTA, POR
LO QUE SE PRODUCE EL SALTO</em>“ es mayor que el empleado en ”<em>CONDICION FALSA,
NO SALTO Y SIGO</em>“.
</p>

<p>
 Por ejemplo, ante un “JP Z, direccion”, el microprocesador tardará 10 ciclos
de reloj en ejecutar un salto si la condición se cumple, y sólo 1 si no se
cumple (ya que entonces no tiene que realizar salto alguno).
</p>

<p>
 Supongamos que tenemos una rutina crítica donde la velocidad es
importante. Vamos a utilizar, como ejemplo, la siguiente rutina que
devuelve 1 si el parámetro que le pasamos es mayor que 250 y devuelve 0
si es menor:
</p>
<pre class="code z80"><span class="co1">; Comparar A con 250:</span>
<span class="co1">;</span>
<span class="co1">; Devuelve A = 0 si A &lt; 250</span>
<span class="co1">;          A = 1 si A &gt; 250</span>
&nbsp;
Valor_Mayor_Que_25<span class="re1">0</span>:
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">25</span><span class="re1">0</span>                      <span class="co1">; Comparamos A con 250</span>
   <span class="kw1">JP</span> <span class="kw2">C</span>, A_menor_que_25<span class="re1">0</span>       <span class="co1">; Si es menor, saltamos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span>                     <span class="co1">; si es mayor, devolvemos 1</span>
   <span class="kw1">RET</span>
&nbsp;
A_menor_que_25<span class="re1">0</span>:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>
   <span class="kw1">RET</span></pre>

<p>
 En el ejemplo anterior se produce el salto si A es menor que 250 (10
t-estados) y no se produce si A es mayor que 250 (1 t-estado).
</p>

<p>
 Supongamos que llamamos a esta rutina con 1000 valores diferentes. En
ese caso, existen más probabilidades de que el valor esté entre 0 y 250 a
 que esté entre 250 y 255, por lo que sería más óptimo que el salto que
hay dentro de la rutina se haga no cuando A sea menor que 250 sino
cuando A sea mayor, de forma que se produzcan menos saltos.
</p>

<p>
 Lo normal es que, ante datos aleatorios, haya más probabilidad de encontrar
datos del segundo caso (0-250) que del primero (250-255), simplemente por el
hecho de que del primer caso hay 250 probabilides de 255, mientras que del segundo hay 5
probabilidades de 255.
</p>

<p>
 En tal caso, la rutina debería organizarse de
forma que la comparación realice el salto cuando encuentre un dato mayor
de 250, dado que ese supuesto se dará menos veces. Si lo hicieramos a la
inversa, se saltaría más veces y la rutina tardaría más en realizar el mismo
trabajo.
</p>
<pre class="code z80"><span class="co1">; Comparar A con 250:</span>
<span class="co1">;</span>
<span class="co1">; Devuelve A = 0 si A &lt; 250</span>
<span class="co1">;          A = 1 si A &gt; 250</span>
&nbsp;
Valor_Mayor_Que_25<span class="re1">0</span>:
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">25</span><span class="re1">0</span>                      <span class="co1">; Comparamos A con 250</span>
   <span class="kw1">JP</span> NC, A_mayor_que_25<span class="re1">0</span>      <span class="co1">; Si es mayor, saltamos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>                     <span class="co1">; si es menor, devolvemos 1</span>
   <span class="kw1">RET</span>
&nbsp;
A_mayor_que_25<span class="re1">0</span>:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span>
   <span class="kw1">RET</span></pre>

<p>
 Eso hace que haya más posibilidades de no saltar que de saltar, es
decir, de emplear un ciclo de procesador y no 10 para la mayoría de las
ejecuciones.
</p>

<p>
<br>

</p>

</div>

<h2 id="instrucciones-de-comparacion-repetitivas">Instrucciones de comparacion repetitivas</h2>
<div class="level2">

<p>
 Para acabar con las instrucciones de comparación vamos a ver las
instrucciones de comparación repetitivas. Son parecidas a CP, pero
trabajan (igual que LDI, LDIR, LDD y LDDR) con HL y BC para realizar
las comparaciones con la memoria: son <strong>CPI, CPD, CPIR</strong> y <strong>CPDR</strong>.
</p>

<p>
 Comencemos con <strong>CPI (ComPare and Increment)</strong>:
</p>

<p>
<br>

<br>

<strong>CPI:</strong>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Al registro A se le resta el byte contenido en la posición de memoria apuntada por HL.
</li>
<li> El resultado de la resta no se almacena en ningún sitio.
</li>
<li class="level1 node"> Los flags resultan afectados por la comparación:
<ul class="fix-media-list-overlap">
<li class="level2"> Si A==(HL), se pone a 1 el flag de Zero (si no es igual se pone a 0).
</li>
<li class="level2"> Si BC==0000, se pone a 0 el flag Parity/Overflow (a 1 en caso contrario).
</li>
</ul>
</li>
<li> Se incrementa HL.
</li>
<li> Se decrementa BC.
</li>
</ul>

<p>
 Técnicamente (con un pequeño matiz que veremos ahora), CPI equivale a:
</p>
<pre class="code"> CPI =     CP [HL]
           INC HL
           DEC BC</pre>

<p>
<br>

<strong>CPD:</strong>
<br>

 Su instrucción “hermana” <strong>CPD (ComPare and Decrement)</strong> funciona de idéntica
forma, pero decrementando HL:
</p>
<pre class="code"> CPD =     CP [HL]
           DEC HL
           DEC BC</pre>

<p>
 Y el pequeño matiz: así como CP [HL] afecta al indicador C de Carry, <em>CPI y CPD</em>,
aunque realizan esa operación intermedia, <em>no lo afectan</em>.
</p>

<p>
 Las instrucciones <strong>CPIR</strong> y <strong>CPDR</strong> son equivalentes a CPI y CPD, pero ejecutándose
múltiples veces: hasta que BC sea cero o bien se encuentre en la posición de
memoria apuntada por HL un valor numérico igual al que contiene el registro A.
Literalmente, <em>es una instrucción de búsqueda</em>: buscamos hacia adelante (CPIR) o
hacia atrás (CPDR), desde una posición de memoria inicial (HL), un valor (A),
entre dicha posición inicial (HL) y una posición final (HL+BC o HL-BC para
CPIR y CPDR).
</p>

<p>
<br>

<br>

<strong>CPIR:</strong>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Al registro A se le resta el byte contenido en la posición de memoria apuntada por HL.
</li>
<li> El resultado de la resta no se almacena en ningún sitio.
</li>
<li class="level1 node"> Los flags resultan afectados por la comparación:
<ul class="fix-media-list-overlap">
<li class="level2"> Si A==(HL), se pone a 1 el flag de Zero (si no es igual se pone a 0).
</li>
<li class="level2"> Si BC==0000, se pone a 0 el flag Parity/Overflow (a 1 en caso contrario).
</li>
</ul>
</li>
<li> Se incrementa HL.
</li>
<li> Se decrementa BC.
</li>
<li> Si BC===0 o A=(HL), se finaliza la instrucción. Si no, repetimos el proceso.
</li>
</ul>

<p>
<br>

<br>

<strong>CPDR:</strong>
<br>

 CPDR es, como podéis imaginar, el equivalente a CPIR pero decrementando HL,
para buscar hacia atrás en la memoria.
</p>

<p>
 Como ya hemos comentado, muchos flags se ven afectados:
</p>
<pre class="code">                        Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
 |CPI                |* * * * 1 -|
 |CPD                |* * * * 1 -|
 |CPIR               |* * * * 1 -|
 |CPDR               |* * * * 1 -|</pre>

<p>
 Un ejemplo de uso de un CP repetitivo es realizar búsquedas de
un determinado valor en memoria. Supongamos que deseamos buscar
la primera aparición del valor “123” en la memoria a partir de la
dirección 20000, y hasta la dirección 30000, es decir, encontrar la
dirección de la primera celdilla de memoria entre 20000 y 30000 que
contenga el valor 123.
</p>

<p>
 Podemos hacerlo mediante el siguiente ejemplo con CPIR:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">2</span><span class="re1">0000</span>      <span class="co1">; Origen de la busqueda</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">10000</span>      <span class="co1">; Número de bytes a buscar (20000-30000)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">23</span>         <span class="co1">; Valor a buscar</span>
   <span class="kw1">CPIR</span></pre>

<p>
 Este código realizará lo siguiente:
</p>
<pre class="code">  HL = 20000
  BC = 10000
  A  = 123

CPIR =
Repetir:
  Leer el contenido de (HL)
  Si A==(HL) -&gt; Fin_de_CPIR
  Si BC==0   -&gt; Fin_de_CPIR
  HL = HL+1
  BC = BC-1
Fin_de_CPIR:</pre>

<p>
 Con esto, si la celdilla 15000 contiene el valor “123”, la instrucción
CPIR del ejemplo anterior acabará su ejecución, dejando en HL el valor
15001 (tendremos que decrementar HL para obtener la posición exacta).
Dejará además el flag “P/O” (paridad/desbordamiento) y el flag Z a uno. En
BC tendremos restado el número de iteraciones del “bucle” realizadas.
</p>

<p>
 Si no se encuentra ninguna aparición de “123”, BC llegará a valer cero,
porque el “bucle CPI” se ejecutará 10000 veces. El flag P/O estará a cero,
al igual que Z, indicando que se finalizó el CPIR y no se encontró nada.
</p>

<p>
 Nótese que si en vez de utilizar CPIR hubiéramos utilizado CPDR, podríamos
haber buscado hacia atrás, desde 20000 a 10000, decrementando HL. Incluso haciendo
HL=0 y usando CPDR, podemos encontrar la última aparición del valor de A
en la memoria (ya que 0000 - 1 = $FFFF, es decir: 0-1=65535 en nuestros
16 bits).
</p>

<p>
<br>

</p>

</div>

<h2 id="un-ejemplo-con-cpir">Un ejemplo con CPIR</h2>
<div class="level2">

<p>
 Veamos un ejemplo práctico con CPIR. El código que veremos a continuación
realiza una búsqueda de un determinado carácter <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> en una cadena de texto:
</p>
<pre class="code z80"> <span class="co1">; Principio del programa</span>
 ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, texto     <span class="co1">; Inicio de la busqueda</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">'X'</span>        <span class="co1">; Carácter (byte) a buscar</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">100</span>       <span class="co1">; Número de bytes donde buscar</span>
   <span class="kw1">CPIR</span>             <span class="co1">; Realizamos la búsqueda</span>
&nbsp;
   <span class="kw1">JP</span> NZ, No_Hay    <span class="co1">; Si no encontramos el caracter buscado</span>
                    <span class="co1">; el flag de Z estará a cero.</span>
&nbsp;
                    <span class="co1">; Si seguimos por aquí es que se encontró</span>
   <span class="kw1">DEC</span> <span class="kw2">HL</span>           <span class="co1">; Decrementamos HL para apuntar al byte</span>
                    <span class="co1">; encontrado en memoria.</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">BC</span>, texto
   <span class="kw1">SCF</span>
   <span class="kw1">CCF</span>              <span class="co1">; Ponemos el carry flag a 0 (SCF+CCF)</span>
   <span class="kw1">SBC</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>       <span class="co1">; HL = HL - BC </span>
                    <span class="co1">;    = (posicion encontrada) - (inicio cadena)</span>
                    <span class="co1">;    = posición de 'X' dentro de la cadena.</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">H</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">L</span>          <span class="co1">; BC = HL</span>
&nbsp;
   <span class="kw1">RET</span>              <span class="co1">; Volvemos a basic con el resultado en BC</span>
&nbsp;
No_Hay:
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>FFFF
   <span class="kw1">RET</span>
&nbsp;
texto DB <span class="st0">"Esto es una X cadena de texto."</span>
&nbsp;
  <span class="co1">; Fin del programa</span>
  END </pre>

<p>
 Lo compilamos con ”<em>pasmo --tapbas buscatxt.asm buscatxt.tap</em>“, lo
cargamos en el emulador y tras un RUN ejecutamos nuestra rutina como
“PRINT AT 10,10 ; USR 50000”. En pantalla aparecerá el valor 12:
</p>

<p>
<img src="img/buscatxt.gif" class="mediacenter" alt="Salida del programa buscatxt.asm"/>
</p>

<p>
 ¿Qué significa este “12”? Es la posición del carácter 'X' dentro de
la cadena de texto. La hemos obtenido de la siguiente forma:
</p>
<ul class="fix-media-list-overlap">
<li> Hacemos HL = posición de memoria donde empieza la cadena.
</li>
<li> Hacemos A = 'X'.
</li>
<li> Ejecutamos un CPIR
</li>
<li> En HL obtendremos la posición
absoluta + 1 donde se encuentra el carácter 'X' encontrado (o FFFFh si
no se encuentra). Exactamente 50041.
</li>
<li> Decrementamos HL para que apunte a la 'X' (50040).
</li>
<li> Realizamos la resta de Posicion('X')
 - PrincipioCadena para obtener la posición del carácter dentro de la
cadena. De esta forma, si la 'E' de la cadena está en 50028, y la X
encontrada en 50040, eso quiere decir que la 'X' está dentro del array
en la posición 50040-50028 = 12.
</li>
<li> Volvemos al BASIC con el resultado en BC. El PRINT USR 50000 imprimirá dicho valor de retorno.
</li>
</ul>

<p>
 Nótese que el bloque desde “SCF” hasta “LD C, L” tiene como objetivo
ser el equivalente a “HL = HL - BC”, y se tiene que hacer de esta forma
porque no existe “SUB HL, BC” ni “LD BC, HL”:
</p>
<pre class="code">SUB HL, BC =  SCF
              CCF              ; Ponemos el carry flag a 0 (SCF+CCF)
              SBC HL, BC       ; HL = HL - BC

LD BC, HL  =  LD B, H
              LD C, L          ; BC = HL</pre>

<p>
 (Podemos dar las gracias por estas extrañas operaciones a la no ortogonalidad del juego de instrucciones del Z80).
</p>

<p>
<br>

</p>

</div>

<h2 id="en-resumen">En resumen</h2>
<div class="level2">

<p>
 En este capítulo hemos aprendido a utilizar todas las funciones
condicionales y de salto de que nos provee el Z80. En el próximo
trataremos la PILA (Stack) del Spectrum, gracias a la cual podremos
implementar en ensamblador el equivalente a
GOSUB/RETURN de BASIC, es decir, subrutinas.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/05_db.asm">La directiva DB utilizada en un ejemplo.</a>
</li>
<li><a href="src/05_db.tap">Fichero tap del ejemplo db.asm.</a>
</li>
<li><a href="src/05_bucle.asm">Ejemplo de bucle infinito con JP.</a>
</li>
<li><a href="src/05_bucle.tap">Fichero tap del ejemplo bucle.asm.</a>
</li>
<li><a href="src/05_buscatxt.asm">Búsqueda de cadenas de texto con CPIR.</a>
</li>
<li><a href="src/05_buscatxt.tap">Fichero tap del ejemplo buscatxt.asm.</a>
</li>
<li><a href="src/05_compara.asm">Comparación &lt;, &gt;, =</a>
</li>
<li><a href="src/05_compara.tap">Tap del ejemplo anterior</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt28.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt28.html">Set de caracteres</a></div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a></div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li><div class="li"> <a href="external/ti86.acz.org/z80_ref.htm" class="urlextern" title="external/ti86.acz.org/z80_ref.htm">Z80 Reference de TI86</a>  </div>
</li>
<li><div class="li"> <a href="http://icarus.ticalc.org/articles/z80_faq.html" class="urlextern" title="http://icarus.ticalc.org/articles/z80_faq.html">FAQ de Icarus Productions</a> </div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a></div>
</li>
<li><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/index.html" class="urlextern" title="external/www.ticalc.org/pub/text/z80/index.html">Tablas de ensamblado y t-estados</a> (pulsar en z80.txt, z80_reference.txt, z80time.txt).</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/lesson1.htm" class="urlextern" title="external/www.z80.info/lesson1.htm">Curso de ASM de z80.info</a></div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a></div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="lenguaje-ensamblador-del-z80-iv">Lenguaje Ensamblador del Z80 (IV)</h1>
<div class="level1">

</div>

<h1 id="la-pila-y-las-llamadas-a-subrutinas">La pila y las llamadas a subrutinas</h1>
<div class="level1">

<p>
<br>

</p>

</div>

<h2 id="la-pila-del-spectrum">La pila del Spectrum</h2>
<div class="level2">

<p>
 Este capítulo se centra en una de las estructuras más importantes del microprocesador Z80: <strong>la pila</strong> (o <strong>Stack</strong> en inglés).
</p>

<p>
 La pila <em>es una porción de memoria donde se pueden almacenar valores de 16 bits</em>, apilados uno a continuación del siguiente.
</p>

<p>
 Su nombre viene del hecho que los datos se almacenan unos “encima” de los otros, como, por ejemplo, en una pila de platos.
</p>

<p>
 Cuando almacenamos un nuevo plato en una pila, lo dejamos en la parte
superior de la misma, sobre el plato anterior. Cuando queremos coger un
plato, cogemos el plato de arriba, el situado en la parte superior de la
 pila.
</p>

<p>
 Es lo que se conoce como una estructura de datos “<em>tipo LIFO</em>” (“<em>Last In, First Out</em>”):
 el último que entró es el primero que sale. En nuestro ejemplo de los
platos, efectivamente cuando retiramos un plato extraemos el que está
arriba del todo, por lo que el primero en salir (First Out) es el último
 que habíamos dejado (Last In).
</p>

<p>
 En una pila de ordenador (como en nuestra pila de datos) sólo podemos
trabajar
con el dato que está arriba del todo de la pila: no podemos extraer uno
de los platos intermedios. Sólo podemos apilar un dato nuevo y desapilar
 el dato apilado arriba del todo
de la pila.
</p>

<p>
 La pila del Spectrum no es de platos sino de valores numéricos de 16
bits. Introducimos valores y sacamos valores mediante 2 instrucciones
concretas: <strong>PUSH &lt;valor&gt;</strong> y <strong>POP &lt;valor&gt;</strong>,
 donde
normalmente &lt;valor&gt; será un registro (metemos en la pila el valor
que contiene un registro de 16 bits, o bien leemos de la pila un valor y
 lo asignamos a un registro de 16 bits).
</p>

<p>
 Por ejemplo, podemos guardar el valor que contiene un registro
en la pila si tenemos que hacer operaciones con ese registro
para así luego recuperarlo tras realizar una determinada tarea:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1000</span>
 <span class="kw1">PUSH</span> <span class="kw2">BC</span>         <span class="co1">; Guardamos el contenido de BC en la pila</span>
&nbsp;
 <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">2</span><span class="re1">000</span>
 <span class="br0">(</span>...<span class="br0">)</span>           <span class="co1">; Operamos con BC </span>
&nbsp;
 <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">0</span>
 <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>      <span class="co1">; y ya podemos guardar el resultado de la operación</span>
                 <span class="co1">; (recordemos que no existe "LD HL, BC", de modo que</span>
                 <span class="co1">; lo almacenamos como HL = 0+BC</span>
&nbsp;
 <span class="kw1">POP</span> <span class="kw2">BC</span>          <span class="co1">; Hemos terminado de trabajar con BC, ahora</span>
                 <span class="co1">; recuperamos el valor que tenia BC (1000).</span></pre>

<p>
 La instrucción “PUSH BC” introduce en memoria, en lo alto de la pila,
el valor contenido en BC (1000), que recuperamos posteriormente con el
“POP BC”.
</p>

<p>
 La realidad es que <em>el Spectrum no tiene una zona de memoria especial o aislada de la RAM dedicada a la pila. En su lugar se utiliza la misma RAM</em> del Spectrum (0-65535).
</p>

<p>
 El Z80 tiene un registro conocido como <strong>SP (Stack Pointer)</strong>, o puntero de pila, que es un registro de 16 bits que contiene una dirección de memoria. Esa dirección de memoria es “<em>la cabeza de la pila</em>”: apunta al próximo lugar donde almacenaremos un dato.
</p>

<p>
 La peculiaridad de la pila del Spectrum es que <em>crece hacia abajo</em>, en lugar de hacia arriba. Veamos un ejemplo práctico:
</p>

<p>
<br>

<img src="img/pila_z80.png" class="mediacenter" alt="Cómo crece y decrece la pila del Z80"/>
<br>

</p>

<p>
 Veámoslo con un ejemplo:
</p>

<p>
 Supongamos que SP (puntero de pila) apunta a 65535 (la última posición
de la memoria) y que tenemos los siguientes valores en BC y DE:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span><span class="re1">00</span>FF
 <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="sy0">$</span>AABB
 <span class="kw1">LD</span> <span class="kw2">SP</span>, <span class="nu0">65535</span>     <span class="co1">; Puntero de pila al final de la memoria</span></pre>

<p>
 Si ahora hacemos:
</p>
<pre class="code z80"> <span class="kw1">PUSH</span> <span class="kw2">BC</span>          <span class="co1">; Apilamos el registro BC</span></pre>

<p>
 Lo que estaremos haciendo es:
</p>
<pre class="code"> SP = SP - 2 = 65533
 (SP) = BC = $00FF</pre>

<p>
 Con lo que el contenido de la memoria sería:
</p>
<pre class="code">      Celdilla    Contenido
     -----------------------
       65534         $FF
SP -&gt;  65533         $00</pre>

<p>
 Si a continuación hacemos otro PUSH:
</p>
<pre class="code z80"> <span class="kw1">PUSH</span> <span class="kw2">DE</span>          <span class="co1">; Apilamos el registro DE</span></pre>

<p>
 Lo que estaremos haciendo es:
</p>
<pre class="code"> SP = SP - 2 = 65531
 (SP) = DE = $AABB</pre>

<p>
 Con lo que el contenido de las celdillas de memoria sería:
</p>
<pre class="code">      Celdilla    Contenido
     -----------------------
       65534         $FF
       65533         $00
       65532         $AA
SP -&gt;  65531         $BB</pre>

<p>
 Si ahora hacemos un POP:
</p>
<pre class="code z80"> <span class="kw1">POP</span> <span class="kw2">DE</span></pre>

<p>
 Lo que hacemos es:
</p>
<pre class="code"> DE = (SP) = $AABB
 SP = SP + 2 = 65533</pre>

<p>
 Y la memoria queda, de nuevo, como:
</p>
<pre class="code">      Celdilla    Contenido
     -----------------------
       65534         $FF
SP -&gt;  65533         $00</pre>

<p>
 Como podemos ver, <em>PUSH apila valores</em>, haciendo decrecer el valor de SP,
mientras que <em>POP recupera valores</em>, haciendo crecer (en 2 bytes, 16 bits)
el valor de SP.
</p>

<p>
<br>

</p>

</div>

<h2 id="push-y-pop">PUSH y POP</h2>
<div class="level2">

<p>
 Así pues, podemos hacer <strong>PUSH</strong> y <strong>POP</strong> de los siguientes registros:
</p>
<ul class="fix-media-list-overlap">
<li> PUSH:  AF, BC, DE, HL, IX, IY
</li>
<li> POP :  AF, BC, DE, HL, IX, IY
</li>
</ul>

<p>
 Lo que hacen PUSH y POP, tal y como funciona la pila, es:
</p>
<pre class="code"> PUSH xx :
   SP   = SP-2
   (SP) = xx

 POP xx :
   xx   = (SP)
   SP   = SP+2</pre>

<p>
 Nótese cómo la pila se decrementa ANTES de poner los datos en ella,
y se incrementa DESPUES de sacar datos de la misma. Esto mantiene
siempre SP apuntando al TOS (<em>Top Of Stack</em>).
</p>
<pre class="code">                        Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
 POP xx              |- - - - - -|
 PUSH xx             |- - - - - -|</pre>

<p>
 Nótese que también podemos apilar y desapilar AF. De hecho, es una forma
de manipular los bits del registro F (hacer PUSH BC con un valor determinado,
por ejemplo, y hacer un POP AF).
</p>

<p>
<br>

</p>

</div>

<h2 id="utilidad-de-la-pila-del-spectrum">Utilidad de la pila del Spectrum</h2>
<div class="level2">

<p>
 La pila resulta muy útil para gran cantidad de tareas en programas en
ensamblador. Veamos algunos ejemplos:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Intercambiar valores de registros mediante PUSH y POP. Por ejemplo, para intercambiar el valor de BC y de DE:
</li>
</ul>
<pre class="code z80"> <span class="kw1">PUSH</span> <span class="kw2">BC</span>       <span class="co1">; Apilamos BC</span>
 <span class="kw1">PUSH</span> <span class="kw2">DE</span>       <span class="co1">; Apilamos DE</span>
 <span class="kw1">POP</span> <span class="kw2">BC</span>        <span class="co1">; Desapilamos BC </span>
               <span class="co1">; ahora BC=(valor apilado en PUSH DE)</span>
 <span class="kw1">POP</span> <span class="kw2">DE</span>        <span class="co1">; Desapilamos DE</span>
               <span class="co1">; ahora DE=(valor apilado en PUSH BC)</span></pre>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> Para manipular el registro F: La instrucción <strong>POP AF</strong> es la principal forma de manipular el registro F directamente (haciendo PUSH de otro registro y POP de AF).</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Almacenaje de datos mientras
ejecutamos porciones de código: Supongamos que tenemos un registro cuyo
valor queremos mantener, pero que tenemos que ejecutar una porción de
código que lo modifica. Gracias a la pila podemos hacer lo siguiente:
</li>
</ul>

<p>
<br>

</p>
<pre class="code z80"> <span class="kw1">PUSH</span> <span class="kw2">BC</span>       <span class="co1">; Guardamos el valor de BC</span>
&nbsp;
 <span class="br0">(</span><span class="kw2">c</span>ódigo<span class="br0">)</span>      <span class="co1">; Hacemos operaciones</span>
&nbsp;
 <span class="kw1">POP</span> <span class="kw2">BC</span>        <span class="co1">; Recuperamos el valor que teníamos en BC</span></pre>

<p>
 Esto incluye, por ejemplo, el almacenaje del valor de BC en los bucles cuando necesitamos operador con B, C o BC:
</p>
<pre class="code z80">    <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>
    <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">100</span>
bucle:
    <span class="kw1">PUSH</span> <span class="kw2">BC</span>         <span class="co1">; Guardamos BC</span>
    <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span>
    <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
    <span class="kw1">POP</span> <span class="kw2">BC</span>          <span class="co1">; Recuperamos BC</span>
    <span class="kw1">DJNZ</span> bucle  </pre>

<p>
 En este sentido, también podremos anidar 2 o más bucles que usen el
registro B o BC con PUSH y POPs entre ellos. Supongamos un bucle BASIC
del tipo:
</p>
<pre class="code basic">  FOR I=0 TO 20:
    FOR J=0 TO 100:
       CODIGO
    NEXT J
  NEXT I</pre>

<p>
 En ensamblador podríamos hacer:
</p>
<pre class="code z80">    <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">2</span><span class="re1">0</span>                <span class="co1">; repetimos bucle externo 20 veces</span>
&nbsp;
bucle_externo:
    <span class="kw1">PUSH</span> <span class="kw2">BC</span>                 <span class="co1">; Nos guardamos el valor de BC</span>
    <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">100</span>               <span class="co1">; Iteraciones del bucle interno</span>
bucle_interno:
    <span class="br0">(</span>... <span class="kw2">c</span>ódigo ...<span class="br0">)</span>
    <span class="kw1">DJNZ</span> bucle_interno      <span class="co1">; FOR J=0 TO 100</span>
    <span class="kw1">POP</span> <span class="kw2">BC</span>                  <span class="co1">; Recuperamos el valor de B</span>
&nbsp;
    <span class="kw1">DJNZ</span> bucle_externo      <span class="co1">; FOR I=0 TO 20</span></pre>

<p>
 Hay que tener en cuenta que PUSH y POP implican escribir en memoria (en
 la dirección apuntada por SP), por que siempre serán más lentas que
guardarse el valor actual de B en otro registro:
</p>
<pre class="code z80">    <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">2</span><span class="re1">0</span>                <span class="co1">; repetimos bucle externo 20 veces</span>
&nbsp;
bucle_externo:
    <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">B</span>                 <span class="co1">; Nos guardamos el valor de B</span>
&nbsp;
    <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">100</span>               <span class="co1">; Iteraciones del bucle interno</span>
bucle_interno:
    <span class="br0">(</span>... <span class="kw2">c</span>ódigo ...<span class="br0">)</span>        <span class="co1">; En este codigo no podemos usar D</span>
    <span class="kw1">DJNZ</span> bucle_interno      <span class="co1">; FOR J=0 TO 100</span>
&nbsp;
    <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">D</span>                 <span class="co1">; Recuperamos el valor de B</span>
    <span class="kw1">DJNZ</span> bucle_externo      <span class="co1">; FOR I=0 TO 20</span></pre>

<p>
 No obstante, en múltiples casos nos quedaremos sin registros libres
donde guardar datos, por lo que la pila es una gran opción. No hay que
obsesionarse con no usar la pila porque implique escribir en memoria. A
menos que estemos hablando de una rutina muy muy crítica, que se ejecute
 muchas veces por cada fotograma de nuestro juego, PUSH y POP serán las
mejores opciones para preservar valores, con un coste de 11 t-estados
para el PUSH y 10 t-estados para el POP de los registros de propósito
general y de 15 y 14 t-estados cuando trabajamos con IX e IY.
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Almacenaje de datos de entrada y
salida en subrutinas: Podemos pasar parámetros a nuestras rutinas
apilándolos en el stack, de forma que nada más entrar en la rutina
leamos de la pila esos parámetros.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Extendiendo un poco más el punto
anterior, cuando realicemos funciones en ensamblador embebidas dentro de
 otros lenguajes (por ejemplo, dentro de programas en C con Z88DK),
podremos recoger dentro de nuestro bloque en ensamblador los parámetros
pasados con llamadas de funciones C.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Como veremos en el próximo apartado,
 la pila es la clave de las subrutinas (CALL/RET) en el Spectrum
(equivalente al GOSUB/RETURN de BASIC).
</li>
</ul>

<p>
<br>

</p>

<p>
 Recordad también que tenéis instrucciones de intercambio (EX) que permiten manipular el contenido de la pila. Hablamos de:
</p>
<pre class="code z80"> <span class="kw1">EX</span> <span class="br0">(</span><span class="kw2">SP</span><span class="br0">)</span>, <span class="kw2">HL</span>
 <span class="kw1">EX</span> <span class="br0">(</span><span class="kw2">SP</span><span class="br0">)</span>, <span class="kw2">IX</span>
 <span class="kw1">EX</span> <span class="br0">(</span><span class="kw2">SP</span><span class="br0">)</span>, <span class="kw2">IY</span></pre>

<p>
<br>

</p>

</div>

<h2 id="los-peligros-de-la-pila">Los peligros de la pila</h2>
<div class="level2">

<p>
 Pero como todo arma, las pilas también tienen un doble filo. Mal
utilizada puede dar lugar a enormes desastres en nuestros programas.
</p>

<p>
Veamos algunos de los más habituales:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Dado que la pila decrece en memoria,
 tenemos que tener cuidado con el valor de SP y la posición más alta de
memoria donde hayamos almacenado datos o rutinas. Si ponemos un gráfico o
 una rutina cerca del valor inicial de SP, y realizamos muchas
operaciones de PUSH, podemos sobreescribir nuestros datos con los
valores que estamos apilando.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Hacer más PUSH que POP o más POP que
 PUSH. Recordemos que la pila tiene que ser consistente. Si hacemos un
push, debemos recordar hacer el pop correspondiente (a menos que haya
una razón para ello), y viceversa. Como veremos a continuación, la pila
es utilizada tanto para pasar parámetros a funciones como para volver de
 ellas, si introducimos un valor en ella con PUSH dentro de una función y
 no lo sacamos antes de hacer el RET, nuestro programa continuará su
ejecución en algún lugar de la memoria que no era al que debía volver.
Es más, si nuestro programa debe volver a BASIC correctamente tras su
ejecución, entonces es obligatorio que hagamos tantos PUSH como POP para
 que el punto final de retorno del programa al BASIC esté en la
siguiente posición de la pila cuando nuestro programa acabe.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Ampliando la regla anterior, hay que tener cuidado con los bucles a la hora de hacer PUSH y POP.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Finalmente, no hay que asumir que SP
 tiene un valor correcto para nosotros. Tal vez tenemos planeado usar
una zona de la memoria para guardar datos o subrutinas y el uso de PUSH y
 POP pueda sobreescribir estos datos. Si sabemos dónde no puede hacer
daño SP y sus escrituras en memoria, basta con inicializar la pila al
principio de nuestro programa a una zona de memoria libre (por ejemplo,
“LD SP, 49999”, o cualquier otra dirección que sepamos que no vamos a
usar). Esto no es obligatorio y muchas veces el valor por defecto de SP
será válido, siempre que no usemos zonas de la memoria que creemos
libres como “almacenes temporales”. Si usamos “variables” creadas en
tiempo de ensamblado (definidas como DB o DW en el ensamblador) no
deberíamos tener problemas, al menos con programas pequeños.
</li>
</ul>

<p>
 Veamos algunos ejemplos de “errores” con la pila. Empecemos con el típico PUSH del cual se nos olvida hacer POP:
</p>
<pre class="code z80">  <span class="co1">; Este programa se colgará (probablemente, depende de BC)</span>
  <span class="co1">; pero en cualquier caso, no seguirá su ejecución normal.</span>
  <span class="kw1">PUSH</span> <span class="kw2">BC</span>
  <span class="kw1">PUSH</span> <span class="kw2">DE</span>
&nbsp;
  <span class="br0">(</span><span class="kw2">c</span>ódigo<span class="br0">)</span>
&nbsp;
  <span class="kw1">POP</span> <span class="kw2">DE</span>
  <span class="kw1">RET</span>          <span class="co1">; En lugar de volver a la dirección de memoria</span>
               <span class="co1">; a la que teníamos que volver, volveremos a</span>
               <span class="co1">; la dirección apuntada por el valor de BC, que</span>
               <span class="co1">; no hemos recogido de la pila.</span></pre>

<p>
 También hay que tener cuidado con los bucles:
</p>
<pre class="code z80">bucle:
    <span class="kw1">PUSH</span> <span class="kw2">BC</span>         <span class="co1">; Nos queremos guardar BC</span>
    <span class="br0">(</span><span class="kw2">c</span>ódigo que usa <span class="kw2">B</span><span class="br0">)</span>
&nbsp;
    <span class="kw1">JR</span> flag, bucle
    <span class="kw1">POP</span> <span class="kw2">BC</span></pre>

<p>
 En ese código hacemos múltiples PUSHes pero un sólo POP. Probablemente,
en realidad, queremos hacer lo siguiente:
</p>
<pre class="code z80">bucle:
    <span class="kw1">PUSH</span> <span class="kw2">BC</span>         <span class="co1">; Nos queremos guardar BC</span>
    <span class="br0">(</span><span class="kw2">c</span>ódigo<span class="br0">)</span>
&nbsp;
    <span class="kw1">POP</span> <span class="kw2">BC</span>
    <span class="kw1">JR</span> flag, bucle</pre>

<p>
 O bien:
</p>
<pre class="code z80">    <span class="kw1">PUSH</span> <span class="kw2">BC</span>         <span class="co1">; Nos queremos guardar BC</span>
bucle:
    <span class="br0">(</span><span class="kw2">c</span>ódigo<span class="br0">)</span>
&nbsp;
    <span class="kw1">JR</span> flag, bucle
    <span class="kw1">POP</span> <span class="kw2">BC</span></pre>

<p>
 Y una curiosidad al respecto de la pila y la sentencia CLEAR de
BASIC: en el fondo, lo que realiza la función CLEAR es cambiar el valor
de la variable del sistema RAMTOP, lo que implica cambiar el valor de
SP. Así, con <strong>CLEAR XXXX</strong>, <em>ponemos la pila colgando de la dirección de
memoria XXXX</em>, asegurándonos de que BASIC no pueda hacer crecer la pila
de forma que sobreescriba código máquina que hayamos cargado nosotros en
memoria. Si, por ejemplo, vamos a cargar todo nuestro código a partir
de la dirección 50000, en nuestro cargador BASIC haremos un CLEAR 49999, de forma
que BASIC no podrá tocar ninguna dirección de memoria por encima de
este valor.
</p>

<p>
<br>

</p>

</div>

<h2 id="la-ubicacion-de-la-pila-en-el-spectrum">La ubicación de la pila en el Spectrum</h2>
<div class="level2">

<p>
 Al cambiar la ubicación de la pila en el Spectrum mediante la
modificación del registro SP debemos tener una consideración especial:
no debemos ubicar el stack en la zona de memoria de 16KB entre 16384 y
32767.
</p>

<p>
 Comenzando en la dirección de memoria 16384 está el área de
videomemoria del Spectrum, donde se almacena en forma de datos numéricos
 el estado de los píxeles y colores de la pantalla. La ULA utiliza esta
información para redibujar en la pantalla el contenido de esta
videomemoria, a razón de 50 veces por segundo.
</p>

<p>
 El haz de electrones del monitor se mueve de forma constante
recorriendo la pantalla y la ULA, sincronizada con él, lee regularmente
el contenido de la videomemoria para construir la señal de vídeo que
debe representar dicho haz.
</p>

<p>
 Cuando la ULA necesita leer un dato de la videoram bloquea
temporalmente el acceso del Z80 al chip de memoria que contiene los
datos de vídeo, ya que el dibujado de la pantalla tiene prioridad (el
haz de electrones del monitor no se puede detener y se le debe
proporcionar la información de imagen conforme la necesita). Cuando
tanto la ULA como nuestro programa necesitan acceder a la memoria
simultaneamente, es la ULA quien accede y el Z80 quien espera a que la
ULA acabe. Esto es lo que se conoce como “contented memory” o “memoria
contenida”.
</p>

<p>
 Esto implica que las lecturas y escrituras de nuestro programa
(ejecutado por el Z80) en la página de memoria de 16KB que va desde
16384 a 32767 se ven interrumpidas de forma constante por la ULA (aunque
 de forma transparente para nuestro programa), por lo que ubicar la pila
 en esta zona puede suponer una gran ralentización con respecto a
ubicarla más arriba de la dirección 32768. Recuerda que cada operación
PUSH y POP es, físicamente, un acceso de escritura y lectura a memoria, y
 las rutinas de nuestro programa harán, seguro, gran uso de ellas,
además de los CALLs y RETs (PUSH PC + JP DIR / POP PC).
</p>

<p>
 Por ahora, y hasta que veamos más información respecto a la ULA y la
memoria contenida, basta con saber que debemos evitar el colocar la pila
 en el bloque de 16KB que comienza en la dirección 16384.
</p>

<p>
<br>

</p>

</div>

<h2 id="subrutinascall-y-ret">Subrutinas: CALL y RET</h2>
<div class="level2">

<p>
 Ya de por sí el lenguaje ensamblador es un lenguaje de listados “largos”
y enrevesados, y donde teníamos 10 líneas en BASIC podemos tener 100 ó 1000
en ensamblador.
</p>

<p>
 Lo normal para hacer el programa más legible es <em>utilizar bloques de código
que hagan unas funciones concretas</em> y a los cuales podamos llamar a lo largo
de nuestro programa. Esos bloques de código son las <strong>funciones</strong> o <strong>subrutinas</strong>.
</p>

<p>
 Las subrutinas son bloques de código máquina a las cuales saltamos, hacen
su tarea asignada, y devuelven el control al punto en que fueron llamadas.
A veces, esperan recibir los registros con una serie de valores y devuelven
registros con los valores resultantes.
</p>

<p>
 Para saltar a subrutinas utilizamos la instrucción <strong>CALL</strong>, y estas deben de terminar en un <strong>RET</strong>.
</p>

<p>
 El lector podría preguntar, ¿por qué no utilizar las instrucciones de
salto JP y JR vistas hasta ahora? La respuesta es: debido a la necesidad
 de una dirección de retorno.
</p>

<p>
 Veamos un ejemplo ilustrativo de la importancia de CALL/RET realizando
una subrutina que se utilice JP para su llamada. Supongamos la siguiente
 “subrutina” sin RET:
</p>
<pre class="code z80"><span class="co1">; SUMA_A_10</span>
<span class="co1">;</span>
<span class="co1">; SUMA 10 a A y devuelve el resultado en B</span>
<span class="co1">;</span>
<span class="co1">; Nota: Modifica el valor de A</span>
&nbsp;
SUMA_A_<span class="re1">10</span>:
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="re1">10</span>         <span class="co1">; A = A + 10</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>           <span class="co1">; B = A</span></pre>

<p>
 Nuestra función/subrutina de ejemplo espera obtener en A un valor, y devuelve
el resultado de su ejecución en B. Antes de llamar a esta rutina, nosotros
deberemos poner en A el valor sobre el que actuar, y posteriormente interpretar
el resultado (sabiendo que lo tenemos en B).
</p>

<p>
 Pero, ¿cómo llamamos a las subrutinas y volvemos de ellas? Comencemos probando con “JP”:
</p>
<pre class="code z80">    <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">35</span>
    <span class="kw1">JP</span> SUMA_A_<span class="re1">10</span>
volver<span class="re1">1</span>:
&nbsp;
   <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
<span class="co1">; SUMA_A_10</span>
<span class="co1">; SUMA 10 a A y devuelve el resultado en B</span>
<span class="co1">; Nota: Modifica el valor de A</span>
SUMA_A_<span class="re1">10</span>:
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="re1">10</span>         <span class="co1">; A = A + 10</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>           <span class="co1">; B = A</span>
   <span class="kw1">JP</span> volver<span class="re1">1</span>        <span class="co1">; Volvemos de la subrutina</span></pre>

<p>
 En este caso, cargaríamos A con el valor 35, saltaríamos a la subrutina,
sumaríamos 10 a A (pasando a valer 45), haríamos B = 45, y volveríamos al
lugar posterior al punto de llamada.
</p>

<p>
 Pero … ¿qué pasaría si quisieramos volver a llamar a la subrutina desde
otro punto de nuestro programa? Que sería inviable, porque nuestra subrutina
acaba con un “JP volver1” que no devolvería la ejecución al punto desde donde
la hemos llamado, sino a “volver1”.
</p>
<pre class="code z80">    <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">35</span>
    <span class="kw1">JP</span> SUMA_A_<span class="re1">10</span>
volver<span class="re1">1</span>:
&nbsp;
    <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">5</span><span class="re1">0</span>
    <span class="kw1">JP</span> SUMA_A_<span class="re1">10</span>
                     <span class="co1">; Nunca llegariamos a volver aqui</span>
   <span class="br0">(</span>...<span class="br0">)</span>
SUMA_A_<span class="re1">10</span>:
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="re1">10</span>         <span class="co1">; A = A + 10</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>           <span class="co1">; B = A</span>
   <span class="kw1">JP</span> volver<span class="re1">1</span>        <span class="co1">; Volvemos de la subrutina</span></pre>

<p>
 Para evitar ese enorme problema es para lo que se usa <strong>CALL</strong> y <strong>RET</strong>.
</p>

<p>
<br>

</p>

</div>

<h2 id="uso-de-call-y-ret">Uso de CALL y RET</h2>
<div class="level2">

<p>
 <strong>CALL</strong> es, en esencia, similar a JP, salvo porque antes de realizar el salto,
introduce en la pila (PUSH) el valor del registro PC (Program Counter, o
contador de programa), el cual (una vez leída y decodificada la instrucción CALL) apunta
a la instrucción que sigue al CALL.
</p>

<p>
 ¿Y para qué sirve eso? Para que lo aprovechemos dentro de nuestra subrutina
con <strong>RET</strong>. RET lee de la pila la dirección que introdujo CALL y salta a ella.
Así, cuando acaba nuestra función, el RET devuelve la ejecución a la instrucción
siguiente al CALL que hizo la llamada.
</p>

<p>
 Son, por tanto, el equivalente ensamblador de GO SUB y RETURN en BASIC (o
más bien se debería decir que GO SUB y RETURN son la implantación en BASIC
de estas instrucciones del microprocesador).
</p>
<pre class="code"> CALL NN equivale a:
    PUSH PC
    JP NN

 RET equivale a:
    POP PC</pre>

<p>
 Veamos la aplicación de CALL y RET con nuestro ejemplo anterior:
</p>
<pre class="code z80">    <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">35</span>
    <span class="kw1">CALL</span> SUMA_A_<span class="re1">10</span>
&nbsp;
    <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">5</span><span class="re1">0</span>
    <span class="kw1">CALL</span> SUMA_A_<span class="re1">10</span>
&nbsp;
    <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">B</span>
&nbsp;
   <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
SUMA_A_<span class="re1">10</span>:
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="re1">10</span>         <span class="co1">; A = A + 10</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>           <span class="co1">; B = A</span>
   <span class="kw1">RET</span>               <span class="co1">; Volvemos de la subrutina</span></pre>

<p>
 En esta ocasión, cuando ejecutamos el primer CALL, se introduce en la pila
el valor de PC, que se corresponde exáctamente con la dirección de memoria
donde estaría ensamblada la siguiente instrucción (LD A, 50). El CALL cambia
el valor de PC al de la dirección de “SUMA_A_10”, y se continúa la ejecución
dentro de la subrutina.
</p>

<p>
 Al acabar la subrutina encontramos el RET, quien extrae de la pila el valor
de PC anteriormente introducido, con lo que en el siguiente ciclo de
instrucción del microprocesador, el Z80 leerá, decodificará y ejecutará
la instrucción “LD A, 50”, siguiendo el flujo del programa linealmente desde ahí.
Con la segunda llamada a CALL ocurriría lo mismo, pero esta vez lo que se
introduce en la pila es la dirección de memoria en la que está ensamblada
la instrucción “LD C, B”. Esto asegura el retorno de nuestra subrutina al
punto adecuado.
</p>

<p>
 Al hablar de la pila os contamos lo importante que era mantener la misma
cantidad de PUSH que de POPs en nuestro código. Ahora entenderéis por qué:
si dentro de una subrutina hacéis un PUSH que no elimináis después con un
POP, cuando lleguéis al RET éste obtendrá de la pila un valor que no será
el introducido por CALL, y saltará allí. Por ejemplo:
</p>
<pre class="code z80">  <span class="kw1">CALL</span> SUMA_A_<span class="re1">10</span>
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">B</span>              <span class="co1">; Esta dirección se introduce en la pila con CALL</span>
&nbsp;
SUMA_A_<span class="re1">10</span>:
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="sy0">$</span><span class="re1">0000</span>
  <span class="kw1">PUSH</span> <span class="kw2">DE</span>
  <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="re1">10</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">a</span>
  <span class="kw1">RET</span>                  <span class="co1">; RET no sacará de la pila lo introducido por CALL</span>
                       <span class="co1">; sino "0000", el valor que hemos pulsado nosotros.</span></pre>

<p>
 Aquí RET sacará de la pila 0000h, en lugar de la dirección que introdujo
CALL, y saltará al inicio del a ROM, produciendo un bonito reset.
</p>

<p>
 Ni CALL ni RET afectan a la tabla de flags del registro F.
</p>
<pre class="code">                        Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
 CALL NN             |- - - - - -|
 RET                 |- - - - - -|</pre>

<p>
<br>

</p>

</div>

<h2 id="saltos-y-retornos-condicionales">Saltos y retornos condicionales</h2>
<div class="level2">

<p>
 Una de las peculiaridades de CALL y RET es que tienen instrucciones condicionales
con respecto al estado de los flags, igual que “JP cc” o “JR cc”, de forma que
podemos condicionar el SALTO (CALL) o el retorno (RET) al estado de un determinado
flag.
</p>

<p>
 Para eso, utilizamos las siguientes instrucciones:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>CALL flag, NN</strong> :  Salta sólo si FLAG está activo.</div>
</li>
<li><div class="li"> <strong>RET flag</strong> : Vuelve sólo si FLAG está activo.</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 Por ejemplo, supongamos que una de nuestras subrutinas tiene que comprobar
que uno de los parámetros que le pasamos, BC, no sea 0.
</p>
<pre class="code z80"><span class="co1">; Copia_Pantalla:</span>
<span class="co1">;</span>
<span class="co1">; Entrada:</span>
<span class="co1">;             HL = direccion origen</span>
<span class="co1">;             DE = direccion destino</span>
<span class="co1">;             BC = bytes a copiar</span>
<span class="co1">;</span>
Copia_Pantalla:
&nbsp;
   <span class="co1">; lo primero, comprobamos que BC no sea cero:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>                           <span class="co1">; Hacemos un OR de B sobre C</span>
                                  <span class="co1">; Si BC es cero, activará el flag Z</span>
   <span class="kw1">RET</span> Z                          <span class="co1">; Si BC es cero, volvemos sin hacer nada</span>
&nbsp;
   <span class="br0">(</span>más <span class="kw2">c</span>ódigo<span class="br0">)</span>
   <span class="co1">; Aquí seguiremos si BC no es cero, el </span>
   <span class="co1">; RET no se habrá ejecutado.</span></pre>

<p>
 Del mismo modo, el uso de CALL condicionado al estado de flags
(CALL Z, CALL NZ, CALL M, CALL P, etc) nos permitirá llamar o no a
 funciones según el estado de un flag.
</p>

<p>
 Al igual que CALL y RET, sus versiones condicionales no afectan al estado
de los flags.
</p>
<pre class="code">                        Flags
   Instrucción       |S Z H P N C|         Pseudocodigo
 -----------------------------------------------------------
 CALL cc, NN         |- - - - - -|        IF cc CALL NN
 RET cc              |- - - - - -|        IF cc RET</pre>

<p>
<br>

</p>

</div>

<h2 id="pasando-parametros-a-rutinas">Pasando parametros a rutinas</h2>
<div class="level2">

<p>
 Ahora que ya sabemos crear rutinas y utilizarlas, vamos a ver los 3
métodos que hay para pasar y devolver parámetros a las funciones.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit12" id="metodo-1uso-de-registros">Método 1: Uso de registros</h3>
<div class="level3">

<p>
 Este método consiste en modificar unos registros concretos antes
de hacer el CALL a nuestra subrutina, sabiendo que dicha subrutina
espera esos registros con los valores sobre los que actuar. Asímismo,
nuestra rutina puede modificar alguno de los registros con el objetivo
de devolvernos un valor.
</p>

<p>
 Por ejemplo:
</p>
<pre class="code z80"><span class="co1">;--------------------------------------------------------------</span>
<span class="co1">; MULTIPLI: Multiplica DE*BC</span>
<span class="co1">;       Entrada:        DE: Multiplicando,  </span>
<span class="co1">;                       BC: Multiplicador</span>
<span class="co1">;       Salida:         HL: Resultado.</span>
<span class="co1">;--------------------------------------------------------------</span>
MULTIPLICA:
        <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">0</span>
MULTI<span class="re1">01</span>:
        <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">DE</span>
        <span class="kw1">DEC</span> <span class="kw2">BC</span>
        <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
        <span class="kw1">OR</span> <span class="kw2">C</span>
        <span class="kw1">JR</span> NZ, MULTI<span class="re1">01</span>
        <span class="kw1">RET</span></pre>

<p>
 Antes de hacer la llamada a MULTIPLICA, tendremos que cargar en DE y en BC
los valores que queremos multiplicar, de modo que si estos valores están
en otros registros o en memoria, tendremos que moverlos a DE y BC.
</p>

<p>
 Además, sabemos que la salida nos será devuelta en HL, con lo que si dicho
registro contiene algún valor importante, deberemos preservarlo previamente.
</p>

<p>
 Con este tipo de funciones resulta importantísimo realizarse cabeceras de
comentarios explicativos, que indiquen:
</p>

<p>
a.- Qué función realiza la subrutina.<br>

b.- Qué registros espera como entrada.<br>

c.- Qué registros devuelve como salida.<br>

d.- Qué registros modifica además de los de entrada y salida.<br>

</p>

<p>
 Con este tipo de paso de parámetros tenemos el mayor ahorro y la mayor
velocidad: no se accede a la pila y no se accede a la memoria, pero por
contra tenemos que tenerlo todo controlado. Tendremos que saber en cada
momento qué parámetros de entrada y de salida utiliza (de ahí la importancia
del comentario explicativo, al que acudiremos más de una vez cuando no
recordemos en qué registros teníamos que pasarle los datos de entrada), y
asegurarnos de que ninguno de los registros “extra” que modifica están en
uso antes de llamar a la función, puesto que se verán alterados.
</p>

<p>
 Si no queremos que la función modifique muchos registros además de los
de entrada y salida, siempre podemos poner una serie de PUSH y POP en
su inicio y final, al estilo:
</p>
<pre class="code z80">MiFuncion:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>      <span class="co1">; Nos guardamos sus valores</span>
&nbsp;
   <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>       <span class="co1">; Recuperamos sus valores</span>
   <span class="kw1">RET</span></pre>

<p>
 En funciones que no sean críticas en velocidad, es una buena opción porque
no tendremos que preocuparnos por el estado de nuestros registros durante
la ejecución de la subrutina: al volver de ella tendrán sus valores originales
(excepto aquellos de entrada y salida que consideremos necesarios).
</p>

<p>
 No nos olvidemos de que en algunos casos podemos usar el juego de registros
alternativos (EX AF, AF', EXX) para evitar algún PUSH o POP.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit13" id="metodo-2uso-de-localidades-de-memoria">Método 2: Uso de localidades de memoria</h3>
<div class="level3">

<p>
 Aunque no es una opción especialmente rápida, el uso de variables o
posiciones de memoria para pasar y recoger parámetros de funciones es
bastante efectivo y sencillo. Nos ahorra el uso de muchos registros, y
hace que podamos usar dentro de las funciones prácticamente todos los
registros. Se hace especialmente útil usando el juego de registros
alternativos.
</p>

<p>
 Por ejemplo:
</p>
<pre class="code z80">      <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">10</span>
      <span class="kw1">LD</span> <span class="br0">(</span>x<span class="br0">)</span>, <span class="kw2">A</span>
      <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">2</span><span class="re1">0</span>
      <span class="kw1">LD</span> <span class="br0">(</span>y<span class="br0">)</span>, <span class="kw2">A</span>
      <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">4</span><span class="re1">0</span>
      <span class="kw1">LD</span> <span class="br0">(</span>size<span class="br0">)</span>, <span class="kw2">BC</span>      <span class="co1">; Parametros de entrada a la funcion</span>
      <span class="kw1">CALL</span> MiFuncion
      <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
MiFuncion:
      <span class="kw1">EXX</span>                <span class="co1">; Preservamos TODOS los registros</span>
&nbsp;
      <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>x<span class="br0">)</span>
      <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
      <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>y<span class="br0">)</span>
      <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>size<span class="br0">)</span>      <span class="co1">; Leemos los parametros</span>
&nbsp;
      <span class="br0">(</span>Codigo<span class="br0">)</span>
&nbsp;
      <span class="kw1">LD</span> <span class="br0">(</span>salida<span class="br0">)</span>, <span class="kw2">a</span>     <span class="co1">; Devolvemos un valor</span>
      <span class="kw1">EXX</span>
      <span class="kw1">RET</span>
&nbsp;
x      DB  <span class="re1">0</span>
y      DB  <span class="re1">0</span>
size   DW  <span class="re1">0</span>
salida DB  <span class="re1">0</span></pre>

<p>
 Este es un ejemplo exagerado donde todos los parámetros se pasan en variables,
pero lo normal es usar un método mixto entre este y el anterior, pasando cosas
en registros excepto si nos quedamos sin ellos (por que una función requiere
muchos parámetros, por ejemplo), de forma que algunas cosas las pasamos con
variables de memoria.
</p>

<p>
 La ventaja del paso de parámetros por memoria es que podemos utilizar
las rutinas desde BASIC, POKEando los parámetros en memoria y llamando a
 la rutina con RANDOMIZE USR DIRECCION.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit14" id="metodo-3uso-de-la-pila-metodo-c">Método 3: Uso de la pila (método C)</h3>
<div class="level3">

<p>
 El tercer método es el sistema que utilizan los lenguajes de alto nivel
para pasar parámetros a las funciones: el apilamiento de los mismos. Este
sistema no se suele utilizar en ensamblador, pero vamos a comentarlo
de forma que os permita integrar funciones en ASM dentro de programas
escritos en C, como los compilables con el ensamblador Z88DK.
</p>

<p>
 En C (y en otros lenguajes de programación) los parámetros se insertan
en la pila en el orden en que son leídos. La subrutina debe utilizar el
registro SP (una copia) para acceder a los valores apilados en orden
inverso. Estos valores son siempre de 16 bits aunque las variables
pasadas sean de 8 bits (en este caso ignoraremos el byte que no
contiene datos, el segundo).
</p>

<p>
 Veamos unos ejemplos:
</p>
<pre class="code">//-----------------------------------------------------------------
// Sea parte de nuestro programa en C:

  int jugador_x, jugador_y;

  jugador_x = 10;
  jugador_y = 200;
  Funcion( jugador_x, jugador_y );
  (...)


//-----------------------------------------------------------------
int Funcion( int x, int y )
{

#asm
   LD HL,2
   ADD HL,SP           ; Ahora SP apunta al ultimo parametro metido
                       ; en la pila por el compilador (valor de Y)

   LD C, (HL)
   INC HL
   LD B, (HL)
   INC HL              ; Ahora BC = y

   LD E, (HL)
   INC HL
   LD D, (HL)
   INC HL              ; Ahora, DE = x

   ;;; (ahora hacemos lo que queramos en asm)

#endasm
}</pre>

<p>
 No tenemos que preocuparnos por hacer PUSH y POP de los registros para
preservar su valor dado que Z88DK lo hace automáticamente antes y después
de cada #asm y #endasm.
</p>

<p>
 El problema es que conforme crece el número de parámetros apilados, es posible
que tengamos que hacer malabarismos para almacenarlos, dado que no podemos
usar HL (es nuestro puntero a la pila en las lecturas). Veamos el siguiente
ejemplo con 3 parámetros, donde tenemos que usar PUSH para guardar el valor
de DE y EX DE, HL para acabar asociando el valor final a HL:
</p>
<pre class="code">//-----------------------------------------------------------------
int Funcion( int x, int y, int z )
{

#asm
   LD HL,2
   ADD HL,SP           ; Ahora SP apunta al ultimo parametro metido
                       ; en la pila por el compilador (z)
   LD C, (HL)
   INC HL
   LD B, (HL)
   INC HL              ; Ahora BC = z

   LD E, (HL)
   INC HL
   LD D, (HL)
   INC HL              ; Ahora, DE = y

   PUSH DE             ; Guardamos DE

   LD E, (HL)
   INC HL
   LD D, (HL)
   INC HL              ; Usamos DE para leer el valor de x

   EX DE, HL           ; Ahora cambiamos x a HL
   POP DE              ; Y recuperamos el valor de y en DE

   ;;; (ahora hacemos lo que queramos en asm)

#endasm
}</pre>

<p>
 La manera de leer bytes (variables de tipo char) pulsados en C es de la misma forma
que leemos una palabra de 16 bits, pero ignorando la parte alta. En
realidad, como la pila es de 16 bits, el compilador convierte el
dato de 8 bits en uno de 16 (rellenando con ceros) y mete en la pila este valor:
</p>
<pre class="code">//-----------------------------------------------------------------
int Funcion( char x, char y )
{

#asm
   LD HL,2
   ADD HL,SP           ; Ahora SP apunta al ultimo parametro metido
                       ; en la pila por el compilador (z)

   LD A, (HL)          ; Aquí tenemos nuestro dato de 8 bits (y)
   LD B, A
   INC HL
   INC HL              ; La parte alta del byte no nos interesa

   LD A, (HL)          ; Aquí tenemos nuestro dato de 8 bits (x)
   LD C, A
   INC HL
   INC HL              ; La parte alta del byte no nos interesa

   ;;; (ahora hacemos lo que queramos en asm)

#endasm
}</pre>

<p>
 En ocasiones, es posible que incluso tengamos que utilizar variables
auxiliares de memoria para guardar datos:
</p>
<pre class="code">//-----------------------------------------------------------------
int Funcion( int x, int y, char z )
{

#asm
   LD HL,2
   ADD HL,SP           ; Ahora SP apunta al ultimo parametro metido
                       ; en la pila por el compilador (z)

   LD C, (HL)
   INC HL
   LD B, (HL)
   INC HL              ; Ahora BC = y
   LD (valor_y), BC    ; nos lo guardamos, BC libre de nuevo

   LD C, (HL)
   INC HL
   LD B, (HL)
   INC HL
   LD (valor_x), BC    ; Nos lo guardamos, BC libre de nuevo

   LD A, (HL)
   LD (valor_z), A     ; Nos guardamos el byte
   INC HL
   INC HL              ; La parte alta del byte no nos interesa

   ;;; (ahora hacemos lo que queramos en asm)

   RET

valor_x   DW  0
valor_y   DW  0
valor_z   DB  0

#endasm
}</pre>

<p>
 Por contra, para devolver valores no se utiliza la pila (dado que
no podemos tocarla), sino que se utiliza un determinado registro.
En el caso de Z88DK, se utiliza el registro HL. Si la función es
de tipo INT o CHAR en cuanto a devolución, el valor que dejemos
en HL será el que se asignará en una llamada de este tipo:
</p>
<pre class="code c"> valor <span class="sy0">=</span> MiFuncion_ASM<span class="br0">(</span> x<span class="sy0">,</span> y<span class="sy0">,</span> z<span class="br0">)</span><span class="sy0">;</span></pre>

<p>
 Hemos considerado importante explicar este tipo de paso de parámetros
y devolución de valores porque nos permite integrar nuestro código
ASM en programas en C.
</p>

<p>
<br>

</p>

</div>

<h2 id="integracion-de-asm-en-z88dk">Integracion de ASM en Z88DK</h2>
<div class="level2">

<p>
 Para aprovechar esta introducción de “uso de ASM en Z88DK”, veamos
el código de alguna función en C que use ASM internamente y que
muestre, entre otras cosas, la lectura de parámetros de la pila,
el acceso a variables del código C, el uso de etiquetas, o la
devolución de valores.
</p>
<pre class="code">//
// Devuelve la direccion de memoria del atributo de un caracter
// de pantalla, de coordenadas (x,y). Usando la dirección que
// devuelve esta función (en HL, devuelto en la llamada), podemos
// leer o cambiar los atributos de dicho carácter.
//
// Llamada:   valor =  Get_LOWRES_Attrib_Address( 1, 3 );
//
int Get_LOWRES_Attrib_Address( char x, char y )
{
#asm

   LD HL, 2
   ADD HL, SP                 ; Leemos x e y de la pila
   LD  D, (HL)  ; d = y
   INC HL                     ; Primero "y" y luego "x".
   INC HL                     ; Como son "char", ignoramos parte alta.
   LD  E, (HL)  ; e = x

   LD H, 0
   LD L, D
   ADD HL, HL                 ; HL = HL*2
   ADD HL, HL                 ; HL = HL*4
   ADD HL, HL                 ; HL = HL*8
   ADD HL, HL                 ; HL = HL*16
   ADD HL, HL                 ; HL = HL*32
   LD D, 0
   ADD HL, DE                 ; Ahora HL = (32*y)+x
   LD BC, 16384+6144          ; Ahora BC = offset attrib (0,0)
   ADD HL, BC                 ; Sumamos y devolvemos en HL

#endasm
}

//
// Set Border
// Ejemplo de modificación del borde, muestra cómo leer variables
// globales de C en ASM, añadiendo "_" delante.
//

unsigned char bordeactual;

void BORDER( unsigned char value )
{
#asm
   LD HL, 2
   ADD HL, SP
   LD A, (HL)
   LD C, 254
   OUT (C), A
   LD (_bordeactual), A

   RLCA                   ; Adaptamos el borde para guardarlo
   RLCA                   ; en la variable del sistema BORDCR
   RLCA                   ; Color borde -&gt; a zona de PAPER
   LD HL, 23624           ; lo almacenamos en BORDCR para que
   LD (HL), A             ; lo usen las rutinas de la ROM.
#endasm
}


//
// Realización de un fundido de la pantalla hacia negro
// Con esta función se muestra el uso de etiquetas. Nótese
// como en lugar de escribirse como ":", se escriben sin
// ellos y con un punto "." delante.
//
void FadeScreen( void )
{

#asm
   LD B, 9                      ; Repetiremos el bucle 9 veces

.fadescreen_loop1
   LD HL, 16384+6144            ; Apuntamos HL a la zona de atributos
   LD DE, 768                   ; Iteraciones bucle

   HALT
   HALT                         ; Ralentizamos el efecto

.fadescreen_loop2
   LD A, (HL)                   ; Cogemos el atributo
   AND 127                      ; Eliminamos el bit de flash
   LD C, A

   AND 7                        ; Extraemos la tinta (AND 00000111b)
   JR Z, fadescreen_ink_zero    ; Si la tinta ya es cero, no hacemos nada

   DEC A                        ; Si no es cero, decrementamos su valor

.fadescreen_ink_zero

   EX AF, AF                    ; Nos hacemos una copia de la tinta en A
   LD A, C                      ; Recuperamos el atributo
   SRA A
   SRA A                        ; Pasamos los bits de paper a 0-2
   SRA A                        ; con 3 instrucciones de desplazamiento &gt;&gt;

   AND 7                        ; Eliminamos el resto de bits
   JR Z, fadescreen_paper_zero  ; Si ya es cero, no lo decrementamos

   DEC A                        ; Lo decrementamos

.fadescreen_paper_zero
   SLA A
   SLA A                        ; Volvemos a color paper en bits 3-5
   SLA A                        ; Con 3 instrucciones de desplazamiento &lt;&lt;

   LD C, A                      ; Guardamos el papel decrementado en A
   EX AF, AF                    ; Recuperamos A
   OR C                         ; A = A OR C  =  PAPEL OR TINTA

   LD (HL), A                   ; Almacenamos el atributo modificado
   INC HL                       ; Avanzamos puntero de memoria

   DEC DE
   LD A, D
   OR E
   JP NZ, fadescreen_loop2      ; Hasta que DE == 0

   DJNZ fadescreen_loop1        ; Repeticion 9 veces

#endasm
}</pre>

<p>
 Si tenéis curiosidad por ver el funcionamiento de esta rutina de Fade (fundido),
podéis verla integramente en ASM en el fichero fade.asm. Un detalle a tener en cuenta,
en Z88DK se soporta “EX AF, AF”, mientras que pasmo requiere poner la
comilla del shadow-register: “EX AF, AF'”.
</p>

<p>
<br>

<img src="img/fade.png" class="mediacenter" alt="Captura durante el fade de la pantalla"/>
<br>

</p>

<p>
 En la anterior captura podéis ver el aspecto de uno de los pasos del fundido.
</p>

<p>
<br>

</p>

</div>

<h2 id="la-importancia-de-usar-subrutinas">La importancia de usar subrutinas</h2>
<div class="level2">

<p>
 Usar subrutinas es mucho más importante de lo que parece a simple
vista:<em> nos permite organizar el programa en unidades o módulos
funcionales</em> que cumplen una serie de funciones específicas, lo que
hace mucha más sencilla su depuración y optimización.
</p>

<p>
 Si en el menú de nuestro juego estamos dibujando una serie de
sprites móviles, y también lo hacemos a lo largo del juego, resulta
absurdo “construir” 2 bloques de código, uno para mover los sprites
del menú y otro para los del juego. Haciendo esto, si encontramos
un error en una de las 2 rutinas, o realizamos una mejora, deberemos
corregirlo en ambas.
</p>

<p>
 Por contra, si creamos una subrutina, digamos, DrawSprite, que podamos
llamar con los parámetros adecuados en ambos puntos del programa, cualquier
cambio, mejora o corrección que realicemos en DrawSprite afectará a
todas las llamadas que le hagamos. También reducimos así el tamaño de
nuestro programa (y con él el tiempo de carga del mismo), las posibilidades
de fallo, y la longitud del listado (haciéndolo más legible y manejable).
</p>

<p>
 Aunque no sea el objetivo de esta serie de artículos, antes de sentarse a
teclear, un buen programador debería coger un par de folios de papel y
hacer un pequeño análisis de lo que pretende crear. Este proceso, la
fase de diseño, define qué debe de hacer el programa y, sobre todo,
una división lógica de cuáles son las principales partes del mismo.
Un sencillo esquema en papel, un diagrama de flujo, identificar las
diferentes partes del programa, etc.
</p>

<p>
 El proceso empieza con un esbozo muy general del programa, que será
coincidente con la gran mayoría de los juegos: inicialización de
variables, menú (que te puede llevar bien a las opciones o bien al
juego en sí), y dentro del juego, lectura de teclado/joystick,
trazado de la pantalla, lógica del juego, etc.
</p>

<p>
 Después, se teclea un programa vacío que siga esos pasos, pero que no
haga nada; un bucle principal que tenga un aspecto parecido a:
</p>
<pre class="code z80">BuclePrincipal:
     <span class="kw1">CALL</span> Leer_Teclado
     <span class="kw1">CALL</span> Logica_Juego
     <span class="kw1">CALL</span> Comprobar_Estado
     <span class="kw1">jp</span> Bucle_Principal
&nbsp;
Leer_Teclado:
     <span class="kw1">RET</span>
&nbsp;
Logica_Juego:
     <span class="kw1">RET</span>
&nbsp;
Comprobar_Estado:
     <span class="kw1">RET</span></pre>

<p>
 Tras esto, ya tenemos el “esqueleto del programa”. Y ahora hay que rellenar
ese esqueleto, y la mejor forma de hacerlo es aprovechar esa “modularidad” que
hemos obtenido con ese diseño en papel.
</p>

<p>
 Por ejemplo, supongamos que nuestro juego tiene que poder dibujar
sprites y pantallas hechas a bases de bloques que se repiten (tiles).
Gracias a nuestro diseño, sabemos que necesitamos una rutina que
imprima un sprite, una rutina que dibuje un tile y una rutina que
dibuje una pantalla llena de tiles.
</p>

<p>
 Pues bien, creamos un programa en ASM nuevo, desde cero, y en él
creamos una función DrawSprite que acepte como parámetros la dirección
origen de los datos del Sprite, y las posiciones X e Y donde dibujarlo,
y la realizamos. En este nuevo programa, pequeño, sencillo de leer,
realizamos todo tipo de pruebas:
</p>
<pre class="code z80">   ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
   <span class="co1">; Probamos de diferentes formas nuestra rutina</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">10</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">1</span><span class="nu0">5</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, sprite
   <span class="kw1">CALL</span> DrawSprite
   <span class="kw1">RET</span>
&nbsp;
<span class="co1">; Rutina DrawSprite</span>
<span class="co1">; Acepta como parametros ... y devuelve ...</span>
DrawSprite:
   <span class="br0">(</span>aquí el <span class="kw2">c</span>ódigo<span class="br0">)</span>
   <span class="kw1">RET</span>
&nbsp;
sprite DB <span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">255</span>,<span class="re1">1</span><span class="nu0">23</span>,<span class="re1">1</span><span class="nu0">2</span><span class="re1">1</span>,<span class="re1">1</span><span class="nu0">23</span>,<span class="nu0">34</span>, <span class="br0">(</span>etc...<span class="br0">)</span>
&nbsp;
   END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 Gracias a esto, podremos probar nuestra nueva rutina y trabajar con
ella limpiamente y en un fichero de programa pequeño. Cuando la tenemos
lista, basta con copiarla a nuestro programa “principal” y ya sabemos
que la tenemos disponible para su uso con CALL.
</p>

<p>
 Así, vamos creando diferentes rutinas en un entorno controlado y
testeable, y las vamos incorporando a nuestro programa. Si hay algún bug
en una rutina y tenemos que reproducirlo, podemos hacerlo en nuestros
pequeños programas de prueba, evitando el típico problema de tener que
llegar a un determinado punto de nuestro programa para chequear una
rutina, o modificar su bucle principal para hacerlo.
</p>

<p>
 Además, el definir de antemano qué tipo de subrutinas necesitamos y
qué parámetros deben aceptar o devolver permite trabajar en equipo. Si
sabes que necesitarás una rutina que dibuje un sprite, o que lea el
teclado y devuelva la tecla pulsada, puedes decir los registros de
entrada y los valores de salida que necesitas, y que la realice una
segunda persona y te envíe la rutina lista para usar.
</p>

<p>
 En ocasiones una excesiva desgranación del programa en módulos más
pequeños puede dar lugar a una penalización en el rendimiento, aunque
no siempre es así. Por ejemplo, supongamos que tenemos que dibujar
un mapeado de 10×10 bloques de 8×8 pixeles cada uno. Si hacemos una
función de que dibuja un bloque de 8×8, podemos llamarla en un bucle
para dibujar nuestros 10×10 bloques.
</p>

<p>
 Hay gente que, en lugar de esto, preferirá realizar una función
específica que dibuje los 10×10 bloques dentro de una misma función.
Esto es así porque de este modo te evitas 100 CALLs (10×10) y sus
correspondientes RETs, lo cual puede ser importante en una rutina
gráfica que se ejecute X veces por segundo. Por supuesto, en muchos
casos tendrán razón, en ciertas ocasiones hay que hacer rutinas
concretas para tareas concretas, aún cuando puedan repetir parte
de otro código que hayamos escrito anteriormente, con el objetivo
de evitar llamadas, des/apilamientos u operaciones innecesarias en
una función crítica.
</p>

<p>
 Pero si, por ejemplo, nosotros sólo dibujamos la pantalla una vez
cuando nuestro personaje sale por el borde, y no volvemos a dibujar
otra hasta que sale por otro borde (típico caso de juegos sin scroll
que muestran pantallas completas de una sóla vez), vale la pena el
usar funciones modulares dado que unos milisegundos más de ejecución
en el trazado de la pantalla no afectarán al desarrollo del juego.
</p>

<p>
 Al final hay que llegar a un compromiso entre modularidad y optimización,
en algunos casos nos interesará desgranar mucho el código, y en otros
nos interesará hacer funciones específicas. Y esa decisión no deja de
ser, al fin y al cabo, diseño del programa.
</p>

<p>
 En cualquier caso, el diseño nos asegura que podremos implementar
nuestro programa en cualquier lenguaje y en cualquier momento. Podremos
retomar nuestros “papeles de diseño” 3 meses después y, pese a no
recordar en qué parte del programa estábamos, volver a su desarrollo
sin excesivas dificultades.
</p>

<p>
 Una de las cosas más complicadas de hacer un juego es el pensar por
dónde empezar. Todo este proceso nos permite empezar el programa por la parte
del mismo que realmente importa. Todos hemos empezado alguna vez a
realizar nuestro juego por el menú, perdiendo muchas horas de trabajo
para descubrir que teníamos un menú, pero no teníamos un juego, y que
ya estábamos cansados del desarrollo sin apenas haber empezado.
</p>

<p>
 Veamos un ejemplo: suponiendo que realizamos, por ejemplo, un juego
de puzzles tipo Tetris, lo ideal sería empezar definiendo dónde se
almacenan los datos del area de juego, hacer una función que convierta
esos datos en imágenes en pantalla, y realizar un bucle que permita ver
caer la pieza. Después, se agrega control por teclado para la pieza y
se pone la lógica del juego (realización de líneas al tocar suelo, etc).
</p>

<p>
 Tras esto, ya tenemos el esqueleto funcional del juego y podemos añadir
opciones, menúes y demás. Tendremos algo tangible, funcional, donde podemos
hacer cambios que implican un inmediato resultado en pantalla, y no habremos
malgastado muchas horas con un simple menú.
</p>

<p>
 Por otra parte, el diseñar correctamente nuestro programa y desgranarlo
en piezas reutilizables redundará en nuestro beneficio no sólo actual (con
respecto al programa que estamos escribiendo) sino futuro, ya que podremos
crearnos nuestras propias “bibliotecas” de funciones que reutilizar en
futuros programas.
</p>

<p>
 Aquella rutina de dibujado de Sprites, de zoom de pantalla o de compresión
de datos que tanto nos costó programar, bien aislada en una subrutina y
con sus parámetros de entrada y salida bien definidos puede ser utilizada
directamente en nuestros próximos programas simplemente copiando y pegando el código correspondiente.
</p>

<p>
 Más aún, podemos organizar funciones con finalidades comunes en ficheros
individuales. Tendremos así nuestro fichero / biblioteca con funciones
gráficas, de sonido, de teclado/joystick, etc. El ensamblador PASMO nos
permite incluir un fichero en cualquier parte de nuestro código con la
directiva “INCLUDE”.
</p>

<p>
 Así, nuestro programa en ASM podría comenzar (o acabar) por algo como:
</p>
<pre class="code z80">INCLUDE <span class="st0">"graficos.asm"</span>
INCLUDE <span class="st0">"sonido.asm"</span>
INCLUDE <span class="st0">"teclado.asm"</span>
INCLUDE <span class="st0">"datos.asm"</span></pre>

<p>
 También podemos utilizar este sistema para los programas de prueba y
testeo de las funciones que vamos realizando para el programa principal.
 Así, podemos verificar con un sencillo programa que incluya algunos
.asm del juego si la rutina que acabamos de crear funciona
correctamente.
</p>

<p>
 La organización del código en bibliotecas de funciones contribuye a
reducir fallos en la codificación, hacer más corto el “listado general
del programa”, y, sobre todo, reduce el tiempo de desarrollo.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/06_reset.asm">Ejemplo de reset por el mal uso de la pila</a>
</li>
<li><a href="src/06_reset.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/06_call_nz.asm">Experimentando con CALL NZ</a>
</li>
<li><a href="src/06_call_nz.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/06_fade.asm">Sencillo fundido de pantalla</a>
</li>
<li><a href="src/06_fade.tap">Tap del ejemplo anterior</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt28.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt28.html">Set de caracteres</a></div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a></div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li><div class="li"> <a href="external/ti86.acz.org/z80_ref.htm" class="urlextern" title="external/ti86.acz.org/z80_ref.htm">Z80 Reference de TI86</a>  </div>
</li>
<li><div class="li"> <a href="http://icarus.ticalc.org/articles/z80_faq.html" class="urlextern" title="http://icarus.ticalc.org/articles/z80_faq.html">FAQ de Icarus Productions</a> </div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a></div>
</li>
<li><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/index.html" class="urlextern" title="external/www.ticalc.org/pub/text/z80/index.html">Tablas de ensamblado y t-estados</a> (pulsar en z80.txt, z80_reference.txt, z80time.txt).</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/lesson1.htm" class="urlextern" title="external/www.z80.info/lesson1.htm">Curso de ASM de z80.info</a></div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a></div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content ">
<h1 id="lenguaje-ensamblador-del-z80-v">Lenguaje Ensamblador del Z80 (V)</h1>
<div class="level1">

<p>
<br>

</p>

</div>

<h2 id="puertos-de-es-y-tabla-de-opcodes">Puertos de E/S y Tabla de Opcodes</h2>
<div class="level2">

<p>
 En este capítulo se introducirán las instrucciones <strong>IN</strong> y <strong>OUT</strong> para la exploración
de los puertos del microprocesador, mostrando cómo el acceso a dichos puertos nos
permitirá la gestión de los diferentes dispositivos conectados al microprocesador
(teclado, altavoz, controladora de disco, etc…).
</p>

<p>
 Finalmente, para acabar con la descripción del juego de instrucciones del Z80
veremos algunos ejemplos de <em>opcodes no documentados</em>, y una <em>tabla-resumen</em> con
la mayoría de instrucciones, así como sus tiempos de ejecución y tamaños.
</p>

<p>
<br>

</p>

</div>

<h2 id="los-puertos-es">Los puertos E/S</h2>
<div class="level2">

<p>
 Como ya vimos en su momento, el microprocesador Z80 se conecta
mediante los puertos de entrada/salida de la CPU a los periféricos
externos (teclado, cassette y altavoz de audio), pudiendo leer el
estado de los mismos (leer del teclado, leer del cassette) y escribir
en ellos (escribir en el altavoz para reproducir sonido, escribir en
el cassette) por medio de estas conexiones conocidas como “<em>I/O Ports</em>”.
</p>

<p>
<img src="img/esquema_zx.gif" class="mediacenter" alt="Esquema del hardware de un ZX Spectrum"/>
</p>

<p>
Aunque para nosotros el teclado o el altavoz puedan ser parte del
ordenador, para el Z80, el microprocesador en sí mismo, son tan
externos a él como el monitor o el joystick. Nuestro microprocesador
accede a todos estos elementos externos mediante una serie de patillas
(buses de datos y direcciones) que son conectadas eléctricamente a
todos los elementos externos con los que queremos que interactúe. La
memoria, el teclado, el altavoz, o los mismos pines del bus trasero
del Spectrum, se conectan al Z80 y éste nos permite su acceso a través
de dichas líneas, o de los puertos de entrada/salida (I/O).
</p>

<p>
<br>

</p>

</div>

<h2 id="in-y-out">IN y OUT</h2>
<div class="level2">

<p>
 Ya conocemos la existencia y significado de los puertos y su conexión
con el microprocesador. Sólo resta saber: ¿cómo accedemos a un puerto
tanto para leer como para escribir desde nuestros programas en
ensamblador?
</p>

<p>
 La respuesta la tienen los comandos <strong>IN</strong> y <strong>OUT</strong> del Z80.
</p>

<p>
 Comenzaremos con <strong>IN</strong>, que nos permite leer el valor de un puerto ya
sea directamente, o cargado sobre el registro BC:
</p>

<p>
<br>

<strong>IN registro, (C)</strong> <br>

Leemos el puerto “BC” y ponemos su contenido en el registro especificado.
En realidad, pese a que teóricamente el Spectrum sólo tiene acceso a puertos
E/S de 8 bits (0-255), para acceder a los puertos, IN r, (C) pone todo el valor
de BC en el bus de direcciones.
</p>

<p>
<strong>IN A, (puerto)</strong> <br>

 Leemos el puerto “A*256 + Puerto” y ponemos su contenido en A. En esta
ocasión, el Spectrum pone en el bus de direcciones el valor del registro
de 16 bits formado por A y (puerto) (en lugar de BC).
<br>

<br>

</p>

<p>
 Por ejemplo, estas 2 lecturas de puerto (usando los 2 formatos de la
instrucción IN vistos anteriormente) son equivalentes:
</p>
<pre class="code z80"> <span class="co1">; Forma 1</span>
 <span class="kw1">LD</span> <span class="kw2">BC</span>, FFFEh
 <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>       <span class="co1">; A = Lectura de puerto FFFEh</span>
&nbsp;
 <span class="co1">; Forma 2</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, FFh
 <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span>FEh<span class="br0">)</span>     <span class="co1">; A = Lectura de puerto FFFEh</span></pre>

<p>
 Aunque la instrucción de la “Forma 1” hable del puerto C, en realidad
el puerto es un valor de 16 bits y se carga en el registro BC.
</p>

<p>
 De la misma forma, podemos escribir un valor en un puerto con sus equivalentes “OUT”:
</p>

<p>
<br>

<strong>OUT (puerto), A </strong> <br>

Escribimos en “puerto” (valor de 8 bits) el valor de A.
</p>

<p>
<strong>OUT (C), registro</strong> <br>

Escribimos en el puerto “C” el valor contenido en “registro” (aunque se pone el
valor de BC en el bus de direcciones).
<br>

<br>

</p>

<p>
 Curiosamente, como se explica en el excelente documento “<em>The
Undocumented Z80 Documented</em>” (que habla de las funcionalidades y
opcodes no documentados del Z80), los puertos del Spectrum son
oficialmente de 8 bits (0-255) aunque realmente se pone o bien BC o
bien (A*256)+PUERTO en el bus de direcciones, por lo que en el fondo
se pueden acceder a todos los 65536 puertos disponibles.
</p>

<p>
 La forma en que estas instrucciones afectan a los flags es la siguiente:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   IN A, (n)         |- - - - - -|
   IN r, (C)         |* * * P 0 -|
   OUT (C), r        |- - - - - -|
   OUT (n), A        |- - - - - -|</pre>

<p>
 Aunque entre los 2 formatos OUT no debería haber ninguna diferencia
funcional, cabe destacar que “OUT (N), A” es 1 t-estado o ciclo de reloj
 más rápida que “OUT (C), A”, tardando 11 y 12 t-estados
respectivamente.
</p>

<p>
<br>

</p>

</div>

<h2 id="instrucciones-de-puerto-repetitivas-e-incrementales">Instrucciones de puerto repetitivas e incrementales</h2>
<div class="level2">

<p>
 Al igual que LD carga un valor de un origen a un destino, y tiene sus correspondientes
instrucciones incrementales (LDI “carga e incrementa”, LDD “carga y decrementa”) o
repetitivas (LDIR “carga, incrementa y repite BC veces”, LDDR “carga, decrementa, y
repite BC veces”), IN y OUT tienen sus equivalentes incrementales y repetidores.
</p>

<p>
 Así:
</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>IND</strong> : </div>
<ul class="fix-media-list-overlap">
<li class="level2"> Leemos en la dirección de memoria apuntada por HL ([HL]) el valor contenido en el puerto C.
</li>
<li class="level2"> Decrementamos HL.
</li>
<li class="level2"> Decrementamos B
</li>
</ul>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>INI</strong> : </div>
<ul class="fix-media-list-overlap">
<li class="level2"> Leemos en la dirección de memoria apuntada por HL ([HL]) el valor contenido en el puerto C.
</li>
<li class="level2"> Incrementamos HL.
</li>
<li class="level2"> Decrementamos B
</li>
</ul>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>OUTD</strong> : </div>
<ul class="fix-media-list-overlap">
<li class="level2"> Escribimos en el puerto C el valor de la dirección de memoria apuntada por HL ([HL])
</li>
<li class="level2"> Decrementamos HL.
</li>
<li class="level2"> Decrementamos B
</li>
</ul>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>OUTI</strong> : </div>
<ul class="fix-media-list-overlap">
<li class="level2"> Escribimos en el puerto C el valor de la dirección de memoria apuntada por HL ([HL])
</li>
<li class="level2"> Incrementamos HL.
</li>
<li class="level2"> Decrementamos B
</li>
</ul>
</li>
</ul>

<p>
 Y sus versiones repetitivas <strong>INDR, INIR, OTDR</strong> y <strong>OTIR</strong>, que realizan la misma
función que sus hermanas incrementales, repitiéndolo hasta que BC sea cero.
</p>

<p>
 Las afectaciones de flags de estas funciones son las siguientes:
</p>

<p>
Flags:
</p>
<pre class="code">                         Flags
   Instrucción       |S Z H P N C|
 ----------------------------------
   INI               |? * ? ? 1 ?|
   IND               |? * ? ? 1 ?|
   OUTI              |? * ? ? 1 ?|
   OUTD              |? * ? ? 1 ?|
   INDR              |? 1 ? ? 1 ?|
   INIR              |? 1 ? ? 1 ?|
   OTDR              |? 1 ? ? 1 ?|
   OTIR              |? 1 ? ? 1 ?|</pre>

<p>
Nota: Pese a que la documentación oficial dice que estas instrucciones no
afectan al Carry Flag, las pruebas hechas a posteriori y recopiladas en
la información disponible sobre Opcodes No Documentados del Z80 sugieren que
sí que son modificados.
</p>

<p>
<br>

</p>

</div>

<h2 id="algunos-puertos-es-comunes">Algunos puertos E/S comunes</h2>
<div class="level2">

<p>
 Para terminar con el tema de los puertos de Entrada y Salida, vamos a hacer
referencia a algunos puertos disponibles en el Sinclair Spectrum (algunos de
ellos sólo en ciertos modelos).
</p>

<p>
 Como veremos en capítulo dedicado al teclado, existe una serie de puertos
E/S que acceden directamente a la lectura del estado de las diferentes teclas
de nuestro Spectrum. Leyendo del puerto adecuado, y chequeando en la respuesta
obtenida el bit concreto asociado a la tecla que queremos consultar podremos
conocer si una determinada tecla está pulsada (0) o no pulsada (1), como
podemos ver en el siguiente ejemplo:
</p>
<pre class="code z80">  <span class="co1">; Lectura de la tecla "P" en un bucle</span>
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
bucle:
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>DFFE         <span class="co1">; Semifila "P" a "Y"</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>            <span class="co1">; Leemos el puerto</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>             <span class="co1">; Testeamos el bit 0</span>
  <span class="kw1">JR</span> Z, salir          <span class="co1">; Si esta a 0 (pulsado) salir.</span>
  <span class="kw1">JR</span> bucle             <span class="co1">; Si no (a 1, no pulsado) repetimos</span>
&nbsp;
salir:
  <span class="kw1">RET</span></pre>

<p>
 El anterior ejemplo lee constantemente el puerto $DFFE a la espera de
que el bit 0 de la respuesta obtenida de dicha lectura sea 0, lo que quiere
decir que la tecla “p” ha sido pulsada.
</p>

<p>
 Aunque los veremos en su momento en profundidad, estos son los puertos
asociados a las diferentes filas de teclas:
</p>
<div class="table-responsive sectionedit7"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Puerto </th><th class="col1"> Bits: </th><th class="col2"> D4 </th><th class="col3"> D3 </th><th class="col4"> D2 </th><th class="col5"> D1 </th><th class="col6"> D0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 65278d (FEFEh) </td><td class="col1"> Teclas: </td><td class="col2"> “V” </td><td class="col3"> “C” </td><td class="col4"> “X” </td><td class="col5"> “Z” </td><td class="col6"> CAPS </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 65022d (FDFEh) </td><td class="col1"> Teclas: </td><td class="col2"> “G” </td><td class="col3"> “F” </td><td class="col4"> “D” </td><td class="col5"> “S” </td><td class="col6"> “A” </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 64510d (FBFEh) </td><td class="col1"> Teclas: </td><td class="col2"> “T” </td><td class="col3"> “R” </td><td class="col4"> “E” </td><td class="col5"> “W” </td><td class="col6"> “Q” </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 63486d (F7FEh) </td><td class="col1"> Teclas: </td><td class="col2"> “5” </td><td class="col3"> “4” </td><td class="col4"> “3” </td><td class="col5"> “2” </td><td class="col6"> “1” </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 61438d (EFFEh) </td><td class="col1"> Teclas: </td><td class="col2"> “0” </td><td class="col3"> “9” </td><td class="col4"> “8” </td><td class="col5"> “7” </td><td class="col6"> “6” </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 57342d (DFFEh) </td><td class="col1"> Teclas: </td><td class="col2"> “Y” </td><td class="col3"> “U” </td><td class="col4"> “I” </td><td class="col5"> “O” </td><td class="col6"> “P” </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 49150d (BFFEh) </td><td class="col1"> Teclas: </td><td class="col2"> “H” </td><td class="col3"> “J” </td><td class="col4"> “K” </td><td class="col5"> “L” </td><td class="col6"> ENTER </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 32766d (7FFEh) </td><td class="col1"> Teclas: </td><td class="col2"> “B” </td><td class="col3"> “N” </td><td class="col4"> “M” </td><td class="col5"> SYMB </td><td class="col6"> SPACE </td>
	</tr>
</tbody></table></div>

<p>
 El bit 6 de los puertos que hemos visto para el teclado tiene un valor
aleatorio, excepto cuando se pulsa PLAY en el cassette, y es a través
de dicho bit de donde podremos obtener los datos a cargar.
</p>

<p>
 La escritura en el puerto 00FEh permite <em>acceder al altavoz</em> (bit 4)
y a la señal de audio para grabar a cinta (bit 3). Los bits 0, 1 y 2
controlan <em>el color del borde</em>, como podemos ver en el siguiente ejemplo:
</p>
<pre class="code z80">  <span class="co1">; Cambio del color del borde al pulsar espacio</span>
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">6</span>              <span class="co1">; 6 iteraciones, color inicial borde</span>
&nbsp;
bucle:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>7F            <span class="co1">; Semifila B a ESPACIO</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>          <span class="co1">; Leemos el puerto</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>             <span class="co1">; Testeamos el bit 0 (ESPACIO)</span>
  <span class="kw1">JR</span> NZ, bucle         <span class="co1">; Si esta a 1 (no pulsado), esperar</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>              <span class="co1">; A = B</span>
  <span class="kw1">OUT</span> <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Cambiamos el color del borde</span>
&nbsp;
suelta_tecla:          <span class="co1">; Ahora esperamos a que se suelte la tecla</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>7F            <span class="co1">; Semifila B a ESPACIO</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>          <span class="co1">; Leemos el puerto</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>             <span class="co1">; Testeamos el bit 0</span>
  <span class="kw1">JR</span> Z, suelta_tecla   <span class="co1">; Saltamos hasta que se suelte</span>
&nbsp;
  <span class="kw1">djnz</span> bucle           <span class="co1">; Repetimos "B" veces</span>
&nbsp;
salir:
  <span class="kw1">RET</span>
&nbsp;
  END <span class="nu0">5</span><span class="re1">0000</span>            <span class="co1">; Ejecucion en 50000</span></pre>

<p>
<br>

<img src="img/borde.png" class="mediacenter" alt="Ejecución del programa de cambio de borde"/>
<br>

</p>

<p>
 El puerto 7FFDh gestiona la <em>paginación en los modos de 128K</em>,
permitiendo cambiar el modelo de páginas de memoria (algo que
no vamos a ver en este capítulo).
</p>

<p>
 Los puertos BFFDh y FFFDh gestionan el <em>chip de sonido</em> en aquellos
modelos que dispongan de él, así como el RS232/MIDI y el interfaz
AUX.
</p>

<p>
 Finalmente, el puerto 0FFDh gestiona <em>el puerto paralelo de impresora</em>,
y los puertos 2FFDh y 3FFDh permiten gestionar la controladora de disco en
aquellos modelos de Spectrum que dispongan de ella.
</p>

<p>
 Podéis encontrar más información sobre los puertos de Entrada y
Salida en el <em>capítulo 8 sección 23 del manual del +2A y +3</em>, disponible
online en World Of Spectrum.
</p>

<p>
<br>

</p>

</div>

<h2 id="tabla-de-instrucciones-ciclos-y-tamanos">Tabla de instrucciones, ciclos y tamaños</h2>
<div class="level2">

<p>
 A continuación se incluye una tabla donde se hace referencia a las instrucciones
del microprocesador Z80 (campo Mnemonic), los ciclos de reloj que tarda en ejecutarse
(campo Clck), el tamaño en bytes de la instrucción codificada (Siz), la afectación
de Flags (SZHPNC), el opcode y su descripción en cuanto a ejecución.
</p>

<p>
 La tabla forma parte de un documento llamado “<strong>The Complete Z80 OP-Code Reference</strong>”,
de <em>Devin Gardner</em>.
</p>

<p>
<br>

</p>
<pre class="code">--------------+----+---+------+------------+---------------------+-----------------------
|Mnemonic     |Clck|Siz|SZHPNC|  OP-Code   |    Description      |        Notes         |
--------------+----+---+------+------------+---------------------+-----------------------
|ADC A,r      | 4  | 1 |***V0*|88+rb       |Add with Carry       |A=A+s+CY              |
|ADC A,N      | 7  | 2 |      |CE XX       |                     |                      |
|ADC A,(HL)   | 7  | 1 |      |8E          |                     |                      |
|ADC A,(IX+N) | 19 | 3 |      |DD 8E XX    |                     |                      |
|ADC A,(IY+N) | 19 | 3 |      |FD 8E XX    |                     |                      |
|ADC HL,BC    | 15 | 2 |**?V0*|ED 4A       |Add with Carry       |HL=HL+ss+CY           |
|ADC HL,DE    | 15 | 2 |      |ED 5A       |                     |                      |
|ADC HL,HL    | 15 | 2 |      |ED 6A       |                     |                      |
|ADC HL,SP    | 15 | 2 |      |ED 7A       |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|ADD A,r      | 4  | 1 |***V0*|80+rb       |Add (8-bit)          |A=A+s                 |
|ADD A,N      | 7  | 2 |      |C6 XX       |                     |                      |
|ADD A,(HL)   | 7  | 1 |      |86          |                     |                      |
|ADD A,(IX+N) | 19 | 3 |      |DD 86 XX    |                     |                      |
|ADD A,(IY+N) | 19 | 3 |      |FD 86 XX    |                     |                      |
|ADD HL,BC    | 11 | 1 |--?-0*|09          |Add (16-bit)         |HL=HL+ss              |
|ADD HL,DE    | 11 | 1 |      |19          |                     |                      |
|ADD HL,HL    | 11 | 1 |      |29          |                     |                      |
|ADD HL,SP    | 11 | 1 |      |39          |                     |                      |
|ADD IX,BC    | 15 | 2 |--?-0*|DD 09       |Add (IX register)    |IX=IX+pp              |
|ADD IX,DE    | 15 | 2 |      |DD 19       |                     |                      |
|ADD IX,IX    | 15 | 2 |      |DD 29       |                     |                      |
|ADD IX,SP    | 15 | 2 |      |DD 39       |                     |                      |
|ADD IY,BC    | 15 | 2 |--?-0*|FD 09       |Add (IY register)    |IY=IY+rr              |
|ADD IY,DE    | 15 | 2 |      |FD 19       |                     |                      |
|ADD IY,IY    | 15 | 2 |      |FD 29       |                     |                      |
|ADD IY,SP    | 15 | 2 |      |FD 39       |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|AND r        | 4  | 1 |***P00|A0+rb       |Logical AND          |A=A&amp;s                 |
|AND N        | 7  | 2 |      |E6 XX       |                     |                      |
|AND (HL)     | 7  | 1 |      |A6          |                     |                      |
|AND (IX+N)   | 19 | 3 |      |DD A6 XX    |                     |                      |
|AND (IY+N)   | 19 | 3 |      |FD A6 XX    |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|BIT b,r      | 8  | 2 |?*1?0-|CB 40+8*b+rb|Test Bit             |m&amp;{2^b}               |
|BIT b,(HL)   | 12 | 2 |      |CB 46+8*b   |                     |                      |
|BIT b,(IX+N) | 20 | 4 |      |DD CB XX 46+8*b                   |                      |
|BIT b,(IY+N) | 20 | 4 |      |FD CB XX 46+8*b                   |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|CALL NN      | 17 | 3 |------|CD XX XX    |Unconditional Call   |-(SP)=PC,PC=nn        |
|CALL C,NN    |17/1| 3 |------|DC XX XX    |Conditional Call     |If Carry = 1          |
|CALL NC,NN   |17/1| 3 |      |D4 XX XX    |                     |If carry = 0          |
|CALL M,NN    |17/1| 3 |      |FC XX XX    |                     |If Sign = 1 (negative)|
|CALL P,NN    |17/1| 3 |      |F4 XX XX    |                     |If Sign = 0 (positive)|
|CALL Z,NN    |17/1| 3 |      |CC XX XX    |                     |If Zero = 1 (ans.=0)  |
|CALL NZ,NN   |17/1| 3 |      |C4 XX XX    |                     |If Zero = 0 (non-zero)|
|CALL PE,NN   |17/1| 3 |      |EC XX XX    |                     |If Parity = 1 (even)  |
|CALL PO,NN   |17/1| 3 |      |E4 XX XX    |                     |If Parity = 0 (odd)   |
+-------------+----+---+------+------------+---------------------+----------------------+
|CCF          | 4  | 1 |--?-0*|3F          |Complement Carry Flag|CY=~CY                |
+-------------+----+---+------+------------+---------------------+----------------------+
|CP r         | 4  | 1 |***V1*|B8+rb       |Compare              |Compare A-s           |
|CP N         | 7  | 2 |      |FE XX       |                     |                      |
|CP (HL)      | 7  | 1 |      |BE          |                     |                      |
|CP (IX+N)    | 19 | 3 |      |DD BE XX    |                     |                      |
|CP (IY+N)    | 19 | 3 |      |FD BE XX    |                     |                      |
|CPD          | 16 | 2 |****1-|ED A9       |Compare and Decrement|A-(HL),HL=HL-1,BC=BC-1|
|CPDR         |21/1| 2 |****1-|ED B9       |Compare, Dec., Repeat|CPD till A=(HL)or BC=0|
|CPI          | 16 | 2 |****1-|ED A1       |Compare and Increment|A-(HL),HL=HL+1,BC=BC-1|
|CPIR         |21/1| 2 |****1-|ED B1       |Compare, Inc., Repeat|CPI till A=(HL)or BC=0|
+-------------+----+---+------+------------+---------------------+----------------------+
|CPL          | 4  | 1 |--1-1-|2F          |Complement           |A=~A                  |
+-------------+----+---+------+------------+---------------------+----------------------+
|DAA          | 4  | 1 |***P-*|27          |Decimal Adjust Acc.  |A=BCD format  (dec.)  |
+-------------+----+---+------+------------+---------------------+----------------------+
|DEC A        | 4  | 1 |***V1-|3D          |Decrement (8-bit)    |s=s-1                 |
|DEC B        | 4  | 1 |      |05          |                     |                      |
|DEC C        | 4  | 1 |      |0D          |                     |                      |
|DEC D        | 4  | 1 |      |15          |                     |                      |
|DEC E        | 4  | 1 |      |1D          |                     |                      |
|DEC H        | 4  | 1 |      |25          |                     |                      |
|DEC L        | 4  | 2 |      |2D          |                     |                      |
|DEC (HL)     | 11 | 1 |      |35          |                     |                      |
|DEC (IX+N)   | 23 | 3 |      |DD 35 XX    |                     |                      |
|DEC (IY+N)   | 23 | 3 |      |FD 35 XX    |                     |                      |
|DEC BC       | 6  | 1 |------|0B          |Decrement (16-bit)   |ss=ss-1               |
|DEC DE       | 6  | 1 |      |1B          |                     |                      |
|DEC HL       | 6  | 1 |      |2B          |                     |                      |
|DEC SP       | 6  | 1 |      |3B          |                     |                      |
|DEC IX       | 10 | 2 |------|DD 2B       |Decrement            |xx=xx-1               |
|DEC IY       | 10 | 2 |      |FD 2B       |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|DI           | 4  | 1 |------|F3          |Disable Interrupts   |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|DJNZ $+2     |13/8| 1 |------|10          |Dec., Jump Non-Zero  |B=B-1 till B=0        |
+-------------+----+---+------+------------+---------------------+----------------------+
|EI           | 4  | 1 |------|FB          |Enable Interrupts    |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|EX (SP),HL   | 19 | 1 |------|E3          |Exchange             |(SP)&lt;-&gt;HL             |
|EX (SP),IX   | 23 | 2 |------|DD E3       |                     |(SP)&lt;-&gt;xx             |
|EX (SP),IY   | 23 | 2 |      |FD E3       |                     |                      |
|EX AF,AF'    | 4  | 1 |------|08          |                     |AF&lt;-&gt;AF'              |
|EX DE,HL     | 4  | 1 |------|EB          |                     |DE&lt;-&gt;HL               |
|EXX          | 4  | 1 |------|D9          |Exchange             |qq&lt;-&gt;qq'   (except AF)|
+-------------+----+---+------+------------+---------------------+----------------------+
|HALT         | 4  | 1 |------|76          |Halt                 |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|IM 0         | 8  | 2 |------|ED 46       |Interrupt Mode       |             (n=0,1,2)|
|IM 1         | 8  | 2 |      |ED 56       |                     |                      |
|IM 2         | 8  | 2 |      |ED 5E       |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|IN A,(N)     | 11 | 2 |------|DB XX       |Input                |A=(n)                 |
|IN (C)       | 12 | 2 |***P0-|ED 70       |Input*               |         (Unsupported)|
|IN A,(C)     | 12 | 2 |***P0-|ED 78       |Input                |r=(C)                 |
|IN B,(C)     | 12 | 2 |      |ED 40       |                     |                      |
|IN C,(C)     | 12 | 2 |      |ED 48       |                     |                      |
|IN D,(C)     | 12 | 2 |      |ED 50       |                     |                      |
|IN E,(C)     | 12 | 2 |      |ED 58       |                     |                      |
|IN H,(C)     | 12 | 2 |      |ED 60       |                     |                      |
|IN L,(C)     | 12 | 2 |      |ED 68       |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|INC A        | 4  | 1 |***V0-|3C          |Increment (8-bit)    |r=r+1                 |
|INC B        | 4  | 1 |      |04          |                     |                      |
|INC C        | 4  | 1 |      |0C          |                     |                      |
|INC D        | 4  | 1 |      |14          |                     |                      |
|INC E        | 4  | 1 |      |1C          |                     |                      |
|INC H        | 4  | 1 |      |24          |                     |                      |
|INC L        | 4  | 1 |      |2C          |                     |                      |
|INC BC       | 6  | 1 |------|03          |Increment (16-bit)   |ss=ss+1               |
|INC DE       | 6  | 1 |      |13          |                     |                      |
|INC HL       | 6  | 1 |      |23          |                     |                      |
|INC SP       | 6  | 1 |      |33          |                     |                      |
|INC IX       | 10 | 2 |------|DD 23       |Increment            |xx=xx+1               |
|INC IY       | 10 | 2 |      |FD 23       |                     |                      |
|INC (HL)     | 11 | 1 |***V0-|34          |Increment (indirect) |(HL)=(HL)+1           |
|INC (IX+N)   | 23 | 3 |***V0-|DD 34 XX    |Increment            |(xx+d)=(xx+d)+1       |
|INC (IY+N)   | 23 | 3 |      |FD 34 XX    |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|IND          | 16 | 2 |?*??1-|ED AA       |Input and Decrement  |(HL)=(C),HL=HL-1,B=B-1|
|INDR         |21/1| 2 |?1??1-|ED BA       |Input, Dec., Repeat  |IND till B=0          |
|INI          | 16 | 2 |?*??1-|ED A2       |Input and Increment  |(HL)=(C),HL=HL+1,B=B-1|
|INIR         |21/1| 2 |?1??1-|ED B2       |Input, Inc., Repeat  |INI till B=0          |
+-------------+----+---+------+------------+---------------------+----------------------+
|JP $NN       | 10 | 3 |------|C3 XX XX    |Unconditional Jump   |PC=nn                 |
|JP (HL)      | 4  | 1 |------|E9          |Unconditional Jump   |PC=(HL)               |
|JP (IX)      | 8  | 2 |------|DD E9       |Unconditional Jump   |PC=(xx)               |
|JP (IY)      | 8  | 2 |      |FD E9       |                     |                      |
|JP C,$NN     |10/1| 3 |------|DA XX XX    |Conditional Jump     |If Carry = 1          |
|JP NC,$NN    |10/1| 3 |      |D2 XX XX    |                     |If Carry = 0          |
|JP M,$NN     |10/1| 3 |      |FA XX XX    |                     |If Sign = 1 (negative)|
|JP P,$NN     |10/1| 3 |      |F2 XX XX    |                     |If Sign = 0 (positive)|
|JP Z,$NN     |10/1| 3 |      |CA XX XX    |                     |If Zero = 1 (ans.= 0) |
|JP NZ,$NN    |10/1| 3 |      |C2 XX XX    |                     |If Zero = 0 (non-zero)|
|JP PE,$NN    |10/1| 3 |      |EA XX XX    |                     |If Parity = 1 (even)  |
|JP PO,$NN    |10/1| 3 |      |E2 XX XX    |                     |If Parity = 0 (odd)   |
+-------------+----+---+------+------------+---------------------+----------------------+
|JR $N+2      | 12 | 2 |------|18 XX       |Relative Jump        |PC=PC+e               |
|JR C,$N+2    |12/7| 2 |------|38 XX       |Cond. Relative Jump  |If cc JR(cc=C,NC,NZ,Z)|
|JR NC,$N+2   |12/7| 2 |      |30 XX       |                     |                      |
|JR Z,$N+2    |12/7| 2 |      |28 XX       |                     |                      |
|JR NZ,$N+2   |12/7| 2 |      |20 XX       |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|LD I,A       | 9  | 2 |------|ED 47       |Load*                |dst=src               |
|LD R,A       | 9  | 2 |      |ED 4F       |                     |                      |
|LD A,I       | 9  | 2 |**0*0-|ED 57       |Load*                |dst=src               |
|LD A,R       | 9  | 2 |      |ED 5F       |                     |                      |
|LD A,r       | 4  | 1 |------|78+rb       |Load (8-bit)         |dst=src               |
|LD A,N       | 7  | 2 |      |3E XX       |                     |                      |
|LD A,(BC)    | 7  | 1 |      |0A          |                     |                      |
|LD A,(DE)    | 7  | 1 |      |1A          |                     |                      |
|LD A,(HL)    | 7  | 1 |      |7E          |                     |                      |
|LD A,(IX+N)  | 19 | 3 |      |DD 7E XX    |                     |                      |
|LD A,(IY+N)  | 19 | 3 |      |FD 7E XX    |                     |                      |
|LD A,(NN)    | 13 | 3 |      |3A XX XX    |                     |                      |
|LD B,r       | 4  | 1 |      |40+rb       |                     |                      |
|LD B,N       | 7  | 2 |      |06 XX       |                     |                      |
|LD B,(HL)    | 7  | 1 |      |46          |                     |                      |
|LD B,(IX+N)  | 19 | 3 |      |DD 46 XX    |                     |                      |
|LD B,(IY+N)  | 19 | 3 |      |FD 46 XX    |                     |                      |
|LD C,r       | 4  | 1 |      |48+rb       |                     |                      |
|LD C,N       | 7  | 2 |      |0E XX       |                     |                      |
|LD C,(HL)    | 7  | 1 |      |4E          |                     |                      |
|LD C,(IX+N)  | 19 | 3 |      |DD 4E XX    |                     |                      |
|LD C,(IY+N)  | 19 | 3 |      |FD 4E XX    |                     |                      |
|LD D,r       | 4  | 1 |      |50+rb       |                     |                      |
|LD D,N       | 7  | 2 |      |16 XX       |                     |                      |
|LD D,(HL)    | 7  | 1 |      |56          |                     |                      |
|LD D,(IX+N)  | 19 | 3 |      |DD 56 XX    |                     |                      |
|LD D,(IY+N)  | 19 | 3 |      |FD 56 XX    |                     |                      |
|LD E,r       | 4  | 1 |      |58+rb       |                     |                      |
|LD E,N       | 7  | 2 |      |1E XX       |                     |                      |
|LD E,(HL)    | 7  | 1 |      |5E          |                     |                      |
|LD E,(IX+N)  | 19 | 3 |      |DD 5E XX    |                     |                      |
|LD E,(IY+N)  | 19 | 3 |      |FD 5E XX    |                     |                      |
|LD H,r       | 4  | 1 |      |60+rb       |                     |                      |
|LD H,N       | 7  | 2 |      |26 XX       |                     |                      |
|LD H,(HL)    | 7  | 1 |      |66          |                     |                      |
|LD H,(IX+N)  | 19 | 3 |      |DD 66 XX    |                     |                      |
|LD H,(IY+N)  | 19 | 3 |      |FD 66 XX    |                     |                      |
|LD L,r       | 4  | 1 |      |68+rb       |                     |                      |
|LD L,N       | 7  | 2 |      |2E XX       |                     |                      |
|LD L,(HL)    | 7  | 1 |      |6E          |                     |                      |
|LD L,(IX+N)  | 19 | 3 |      |DD 6E XX    |                     |                      |
|LD L,(IY+N)  | 19 | 3 |      |FD 6E XX    |                     |                      |
|LD BC,(NN)   | 20 | 4 |------|ED 4B XX XX |Load (16-bit)        |dst=src               |
|LD BC,NN     | 10 | 3 |      |01 XX XX    |                     |                      |
|LD DE,(NN)   | 20 | 4 |      |ED 5B XX XX |                     |                      |
|LD DE,NN     | 10 | 3 |      |11 XX XX    |                     |                      |
|LD HL,(NN)   | 20 | 3 |      |2A XX XX    |                     |                      |
|LD HL,NN     | 10 | 3 |      |21 XX XX    |                     |                      |
|LD SP,(NN)   | 20 | 4 |      |ED 7B XX XX |                     |                      |
|LD SP,HL     | 6  | 1 |      |F9          |                     |                      |
|LD SP,IX     | 10 | 2 |      |DD F9       |                     |                      |
|LD SP,IY     | 10 | 2 |      |FD F9       |                     |                      |
|LD SP,NN     | 10 | 3 |      |31 XX XX    |                     |                      |
|LD IX,(NN)   | 20 | 4 |      |DD 2A XX XX |                     |                      |
|LD IX,NN     | 14 | 4 |      |DD 21 XX XX |                     |                      |
|LD IY,(NN)   | 20 | 4 |      |FD 2A XX XX |                     |                      |
|LD IY,NN     | 14 | 4 |      |FD 21 XX XX |                     |                      |
|LD (HL),r    | 7  | 1 |------|70+rb       |Load (Indirect)      |dst=src               |
|LD (HL),N    | 10 | 2 |      |36 XX       |                     |                      |
|LD (BC),A    | 7  | 1 |      |02          |                     |                      |
|LD (DE),A    | 7  | 1 |      |12          |                     |                      |
|LD (NN),A    | 13 | 3 |      |32 XX XX    |                     |                      |
|LD (NN),BC   | 20 | 4 |      |ED 43 XX XX |                     |                      |
|LD (NN),DE   | 20 | 4 |      |ED 53 XX XX |                     |                      |
|LD (NN),HL   | 16 | 3 |      |22 XX XX    |                     |                      |
|LD (NN),IX   | 20 | 4 |      |DD 22 XX XX |                     |                      |
|LD (NN),IY   | 20 | 4 |      |FD 22 XX XX |                     |                      |
|LD (NN),SP   | 20 | 4 |      |ED 73 XX XX |                     |                      |
|LD (IX+N),r  | 19 | 3 |      |DD 70+rb XX |                     |                      |
|LD (IX+N),N  | 19 | 4 |      |DD 36 XX XX |                     |                      |
|LD (IY+N),r  | 19 | 3 |      |FD 70+rb XX |                     |                      |
|LD (IY+N),N  | 19 | 4 |      |FD 36 XX XX |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|LDD          | 16 | 2 |--0*0-|ED A8       |Load and Decrement   |(DE)=(HL),HL=HL-1,#   |
|LDDR         |21/1| 2 |--000-|ED B8       |Load, Dec., Repeat   |LDD till BC=0         |
|LDI          | 16 | 2 |--0*0-|ED A0       |Load and Increment   |(DE)=(HL),HL=HL+1,#   |
|LDIR         |21/1| 2 |--000-|ED B0       |Load, Inc., Repeat   |LDI till BC=0         |
+-------------+----+---+------+------------+---------------------+----------------------+
|NEG          | 8  | 2 |***V1*|ED 44       |Negate               |A=-A                  |
+-------------+----+---+------+------------+---------------------+----------------------+
|NOP          | 4  | 1 |------|00          |No Operation         |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|OR r         | 4  | 1 |***P00|B0+rb       |Logical inclusive OR |A=Avs                 |
|OR N         | 7  | 2 |      |F6 XX       |                     |                      |
|OR (HL)      | 7  | 1 |      |B6          |                     |                      |
|OR (IX+N)    | 19 | 3 |      |DD B6 XX    |                     |                      |
|OR (IY+N)    | 19 | 3 |      |FD B6 XX    |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|OUT (N),A    | 11 | 2 |------|D3 XX       |Output               |(n)=A                 |
|OUT (C),0    | 12 | 2 |------|ED 71       |Output*              |         (Unsupported)|
|OUT (C),A    | 12 | 2 |------|ED 79       |Output               |(C)=r                 |
|OUT (C),B    | 12 | 2 |      |ED 41       |                     |                      |
|OUT (C),C    | 12 | 2 |      |ED 49       |                     |                      |
|OUT (C),D    | 12 | 2 |      |ED 51       |                     |                      |
|OUT (C),E    | 12 | 2 |      |ED 59       |                     |                      |
|OUT (C),H    | 12 | 2 |      |ED 61       |                     |                      |
|OUT (C),L    | 12 | 2 |      |ED 69       |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|OUTD         | 16 | 2 |?*??1-|ED AB       |Output and Decrement |(C)=(HL),HL=HL-1,B=B-1|
|OTDR         |21/1| 2 |?1??1-|ED BB       |Output, Dec., Repeat |OUTD till B=0         |
|OUTI         | 16 | 2 |?*??1-|ED A3       |Output and Increment |(C)=(HL),HL=HL+1,B=B-1|
|OTIR         |21/1| 2 |?1??1-|ED B3       |Output, Inc., Repeat |OUTI till B=0         |
+-------------+----+---+------+------------+---------------------+----------------------+
|POP AF       | 10 | 1 |------|F1          |Pop                  |qq=(SP)+              |
|POP BC       | 10 | 1 |      |C1          |                     |                      |
|POP DE       | 10 | 1 |      |D1          |                     |                      |
|POP HL       | 10 | 1 |      |E1          |                     |                      |
|POP IX       | 14 | 2 |------|DD E1       |Pop                  |xx=(SP)+              |
|POP IY       | 14 | 2 |      |FD E1       |                     |                      |
|PUSH AF      | 11 | 1 |------|F5          |Push                 |-(SP)=qq              |
|PUSH BC      | 11 | 1 |      |C5          |                     |                      |
|PUSH DE      | 11 | 1 |      |D5          |                     |                      |
|PUSH HL      | 11 | 1 |      |E5          |                     |                      |
|PUSH IX      | 15 | 2 |------|DD E5       |Push                 |-(SP)=xx              |
|PUSH IY      | 15 | 2 |      |FD E5       |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|RES b,r      | 8  | 2 |------|CB 80+8*b+rb|Reset bit            |m=m&amp;{~2^b}            |
|RES b,(HL)   | 15 | 2 |------|CB 86+8*b   |                     |                      |
|RES b,(IX+N) | 23 | 4 |------|DD CB XX 86+8*b                   |                      |
|RES b,(IY+N) | 23 | 4 |------|FD CB XX 86+8*b                   |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|RET          | 10 | 1 |------|C9          |Return               |PC=(SP)+              |
|RET C        |11/5| 1 |------|D8          |Conditional Return   |If Carry = 1          |
|RET NC       |11/5| 1 |      |D0          |                     |If Carry = 0          |
|RET M        |11/5| 1 |      |F8          |                     |If Sign = 1 (negative)|
|RET P        |11/5| 1 |      |F0          |                     |If Sign = 0 (positive)|
|RET Z        |11/5| 1 |      |C8          |                     |If Zero = 1 (ans.=0)  |
|RET NZ       |11/5| 1 |      |C0          |                     |If Zero = 0 (non-zero)|
|RET PE       |11/5| 1 |      |E8          |                     |If Parity = 1 (even)  |
|RET PO       |11/5| 1 |      |E0          |                     |If Parity = 0 (odd)   |
+-------------+----+---+------+------------+---------------------+----------------------+
|RETI         | 14 | 2 |------|ED 4D       |Return from Interrupt|PC=(SP)+              |
|RETN         | 14 | 2 |------|ED 45       |Return from NMI      |PC=(SP)+              |
+-------------+----+---+------+------------+---------------------+----------------------+
|RLA          | 4  | 1 |--0-0*|17          |Rotate Left Acc.     |A={CY,A}&lt;-            |
|RL r         | 8  | 2 |**0P0*|CB 10+rb    |Rotate Left          |m={CY,m}&lt;-            |
|RL (HL)      | 15 | 2 |      |CB 16       |                     |                      |
|RL (IX+N)    | 23 | 4 |      |DD CB XX 16 |                     |                      |
|RL (IY+N)    | 23 | 4 |      |FD CB XX 16 |                     |                      |
|RLCA         | 4  | 1 |--0-0*|07          |Rotate Left Cir. Acc.|A=A&lt;-                 |
|RLC r        | 8  | 2 |**0P0*|CB 00+rb    |Rotate Left Circular |m=m&lt;-                 |
|RLC (HL)     | 15 | 2 |      |CB 06       |                     |                      |
|RLC (IX+N)   | 23 | 4 |      |DD CB XX 06 |                     |                      |
|RLC (IY+N)   | 23 | 4 |      |FD CB XX 06 |                     |                      |
|RLD          | 18 | 2 |**0P0-|ED 6F       |Rotate Left 4 bits   |{A,(HL)}={A,(HL)}&lt;- ##|
|RRA          | 4  | 1 |--0-0*|1F          |Rotate Right Acc.    |A=-&gt;{CY,A}            |
|RR r         | 8  | 2 |**0P0*|CB 18+rb    |Rotate Right         |m=-&gt;{CY,m}            |
|RR (HL)      | 15 | 2 |      |CB 1E       |                     |                      |
|RR (IX+N)    | 23 | 4 |      |DD CB XX 1E |                     |                      |
|RR (IY+N)    | 23 | 4 |      |FD CB XX 1E |                     |                      |
|RRCA         | 4  | 1 |--0-0*|0F          |Rotate Right Cir.Acc.|A=-&gt;A                 |
|RRC r        | 8  | 2 |**0P0*|CB 08+rb    |Rotate Right Circular|m=-&gt;m                 |
|RRC (HL)     | 15 | 2 |      |CB 0E       |                     |                      |
|RRC (IX+N)   | 23 | 4 |      |DD CB XX 0E |                     |                      |
|RRC (IY+N)   | 23 | 4 |      |FD CB XX 0E |                     |                      |
|RRD          | 18 | 2 |**0P0-|ED 67       |Rotate Right 4 bits  |{A,(HL)}=-&gt;{A,(HL)} ##|
+-------------+----+---+------+------------+---------------------+----------------------+
|RST 0        | 11 | 1 |------|C7          |Restart              | (p=0H,8H,10H,...,38H)|
|RST 08H      | 11 | 1 |      |CF          |                     |                      |
|RST 10H      | 11 | 1 |      |D7          |                     |                      |
|RST 18H      | 11 | 1 |      |DF          |                     |                      |
|RST 20H      | 11 | 1 |      |E7          |                     |                      |
|RST 28H      | 11 | 1 |      |EF          |                     |                      |
|RST 30H      | 11 | 1 |      |F7          |                     |                      |
|RST 38H      | 11 | 1 |      |FF          |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|SBC r        | 4  | 1 |***V1*|98+rb       |Subtract with Carry  |A=A-s-CY              |
|SBC A,N      | 7  | 2 |      |DE XX       |                     |                      |
|SBC (HL)     | 7  | 1 |      |9E          |                     |                      |
|SBC A,(IX+N) | 19 | 3 |      |DD 9E XX    |                     |                      |
|SBC A,(IY+N) | 19 | 3 |      |FD 9E XX    |                     |                      |
|SBC HL,BC    | 15 | 2 |**?V1*|ED 42       |Subtract with Carry  |HL=HL-ss-CY           |
|SBC HL,DE    | 15 | 2 |      |ED 52       |                     |                      |
|SBC HL,HL    | 15 | 2 |      |ED 62       |                     |                      |
|SBC HL,SP    | 15 | 2 |      |ED 72       |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|SCF          | 4  | 1 |--0-01|37          |Set Carry Flag       |CY=1                  |
+-------------+----+---+------+------------+---------------------+----------------------+
|SET b,r      | 8  | 2 |------|CB C0+8*b+rb|Set bit              |m=mv{2^b}             |
|SET b,(HL)   | 15 | 2 |      |CB C6+8*b   |                     |                      |
|SET b,(IX+N) | 23 | 4 |      |DD CB XX C6+8*b                   |                      |
|SET b,(IY+N) | 23 | 4 |      |FD CB XX C6+8*b                   |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|SLA r        | 8  | 2 |**0P0*|CB 20+rb    |Shift Left Arithmetic|m=m*2                 |
|SLA (HL)     | 15 | 2 |      |CB 26       |                     |                      |
|SLA (IX+N)   | 23 | 4 |      |DD CB XX 26 |                     |                      |
|SLA (IY+N)   | 23 | 4 |      |FD CB XX 26 |                     |                      |
|SRA r        | 8  | 2 |**0P0*|CB 28+rb    |Shift Right Arith.   |m=m/2                 |
|SRA (HL)     | 15 | 2 |      |CB 2E       |                     |                      |
|SRA (IX+N)   | 23 | 4 |      |DD CB XX 2E |                     |                      |
|SRA (IY+N)   | 23 | 4 |      |FD CB XX 2E |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|SLL r        | 8  | 2 |**0P0*|CB 30+rb    |Shift Left Logical*  |m={0,m,CY}&lt;-          |
|SLL (HL)     | 15 | 2 |      |CB 36       |                     |  (SLL instructions   |
|SLL (IX+N)   | 23 | 4 |      |DD CB XX 36 |                     |     are Unsupported) |
|SLL (IY+N)   | 23 | 4 |      |FD CB XX 36 |                     |                      |
|SRL r        | 8  | 2 |**0P0*|CB 38+rb    |Shift Right Logical  |m=-&gt;{0,m,CY}          |
|SRL (HL)     | 15 | 2 |      |CB 3E       |                     |                      |
|SRL (IX+N)   | 23 | 4 |      |DD CB XX 3E |                     |                      |
|SRL (IY+N)   | 23 | 4 |      |FD CB XX 3E |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|SUB r        | 4  | 1 |***V1*|90+rb       |Subtract             |A=A-s                 |
|SUB N        | 7  | 2 |      |D6 XX       |                     |                      |
|SUB (HL)     | 7  | 1 |      |96          |                     |                      |
|SUB (IX+N)   | 19 | 3 |      |DD 96 XX    |                     |                      |
|SUB (IY+N)   | 19 | 3 |      |FD 96 XX    |                     |                      |
+-------------+----+---+------+------------+---------------------+----------------------+
|XOR r        | 4  | 1 |***P00|A8+rb       |Logical Exclusive OR |A=Axs                 |
|XOR N        | 7  | 2 |      |EE XX       |                     |                      |
|XOR (HL)     | 7  | 1 |      |AE          |                     |                      |
|XOR (IX+N)   | 19 | 3 |      |DD AE XX    |                     |                      |
|XOR (IY+N)   | 19 | 3 |      |FD AE XX    |                     |                      |
--------------+----+---+------+------------+---------------------+-----------------------

 Leyenda:

+---------------+---------------------------------------------+
| n             |Immediate addressing                         |
| nn            |Immediate extended addressing                |
| e             |Relative addressing (PC=PC+2+offset)         |
| (nn)          |Extended addressing                          |
| (xx+d)        |Indexed addressing                           |
| r             |Register addressing                          |
| (rr)          |Register indirect addressing                 |
|               |Implied addressing                           |
| b             |Bit addressing                               |
| p             |Modified page zero addressing (see RST)      |
| *             |Undocumented opcode                          |
+---------------+---------------------------------------------+
| A  B  C  D  E |Registers (8-bit)                            |
| AF BC DE HL   |Register pairs (16-bit)                      |
| F             |Flag register (8-bit)                        |
| I             |Interrupt page address register (8-bit)      |
| IX IY         |Index registers (16-bit)                     |
| PC            |Program Counter register (16-bit)            |
| R             |Memory Refresh register                      |
| SP            |Stack Pointer register (16-bit)              |
+---------------+---------------------------------------------+
| b             |One bit (0 to 7)                             |
| cc            |Condition (C,M,NC,NZ,P,PE,PO,Z)              |
| d             |One-byte expression (-128 to +127)           |
| dst           |Destination s, ss, (BC), (DE), (HL), (nn)    |
| e             |One-byte expression (-126 to +129)           |
| m             |Any register r, (HL) or (xx+d)               |
| n             |One-byte expression (0 to 255)               |
| nn            |Two-byte expression (0 to 65535)             |
| pp            |Register pair BC, DE, IX or SP               |
| qq            |Register pair AF, BC, DE or HL               |
| qq'           |Alternative register pair AF, BC, DE or HL   |
| r             |Register A, B, C, D, E, H or L               |
| rr            |Register pair BC, DE, IY or SP               |
| s             |Any register r, value n, (HL) or (xx+d)      |
| src           |Source s, ss, (BC), (DE), (HL), nn, (nn)     |
| ss            |Register pair BC, DE, HL or SP               |
| xx            |Index register IX or IY                      |
| +  -  *  /  ^ |Add/subtract/multiply/divide/exponent        |
| &amp;  ~  v  x    |Logical AND/NOT/inclusive OR/exclusive OR    |
| &lt;-  -&gt;        |Rotate left/right                            |
| ( )           |Indirect addressing                          |
| ( )+  -( )    |Indirect addressing auto-increment/decrement |
| { }           |Combination of operands                      |
| #             |Also BC=BC-1,DE=DE-1                         |
| ##            |Only lower 4 bits of accumulator A used      |
+---------------+---------------------------------------------+</pre>

<p>
 Unos apuntes sobre esta tabla:
</p>

<p>
1.- En instrucciones como “ADC A, r” podemos ver una defición del OPCODE como “88+rb”.
En este caso, el opcode final se obtendría sumando a “88h” un valor de 0 a 7 según
el registro al que nos referimos:
</p>
<div class="table-responsive sectionedit9"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Registro </th><th class="col1"> Valor RB </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> A </td><td class="col1"> 7 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> B </td><td class="col1"> 0 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> C </td><td class="col1"> 1 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> D </td><td class="col1"> 2 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> E </td><td class="col1"> 3 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> H </td><td class="col1"> 4 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> L </td><td class="col1"> 5 </td>
	</tr>
	<tr class="row8">
		<td class="col0"> (HL) </td><td class="col1"> 6 </td>
	</tr>
</tbody></table></div>

<p>
 Por ejemplo, “ADC A, B” se codificaría en memoria como “88+0=88”.
</p>

<p>
2.- En los saltos hay 2 tiempos de ejecución diferentes (por ejemplo, 10/1). En este
caso el valor más alto (10) son los t-estados o ciclos que toma la instrucción cuando
el salto se realiza, y el más bajo (1) es lo que tarda la instrucción cuando no se
salta al destino. Como véis, a la hora de programar una rutina que tenga saltos o
bifurcaciones, es interesante programarla de forma que el caso más común, el que se
produzca la mayoría de las veces, no produzca un salto.
</p>

<p>
3.- La descripción de las afectaciones de flags son las siguientes:
</p>
<pre class="code">--------+-------+----------------------------------------------
| F     | -*01? |Flag unaffected/affected/reset/set/unknown   |
| S     | S     |Sign flag (Bit 7)                            |
| Z     |  Z    |Zero flag (Bit 6)                            |
| HC    |   H   |Half Carry flag (Bit 4)                      |
| P/V   |    P  |Parity/Overflow flag (Bit 2, V=overflow)     |
| N     |     N |Add/Subtract flag (Bit 1)                    |
| CY    |      C|Carry flag (Bit 0)                           |
+---------------+---------------------------------------------+</pre>

<p>
<br>

</p>

</div>

<h2 id="instrucciones-no-documentadas-del-z80">Instrucciones no documentadas del Z80</h2>
<div class="level2">

<p>
 En Internet podemos encontrar gran cantidad de documentación acerca del Z80
y su juego de instrucciones, incluyendo las especificaciones oficiales del
microprocesador Z80 de Zilog.
</p>

<p>
 No obstante, existen una serie de instrucciones u opcodes que el microprocesador
puede ejecutar y que no están detallados en la documentación oficial de Zilog.
Con respecto a esto, tenemos la suerte de disponer de algo que los programadores
de la época del Spectrum no tenían: una descripción detallada de las instrucciones
no documentadas del Z80. Aunque la mayoría son instrucciones repetidas de sus
versiones documentadas, hay algunas instrucciones curiosas y a las que tal vez
le podamos sacar alguna utilidad.
</p>

<p>
 ¿Por qué existen estos opcodes y no fueron documentados? Supongo que algunos de
ellos no fueron considerados como “merecedores de utilidad alguna” y los ingenieros
de Zilog no los documentaron, o tal vez sean simplemente un resultado no previsto
de la ejecución del Z80 porque los diseñadores no pensaron que al microprocesador
pudieran llegarle dichos códigos. El caso es que para el microprocesador existen
“todos” los opcodes, otra cosa es qué haga al leerlos y decodificarlos. En este
caso algunos de ellos realizan funciones válidas mientras que otros son el equivalente
a ejecutar 2 instrucciones NOP, por ejemplo.
</p>

<p>
 ¿Cuál es la utilidad de estas instrucciones para los programadores? Para ser
sinceros, como programadores con un ensamblador o un ensamblador cruzado, poca.
Si haces tus programas desde cero con un programa ensamblador, éste se encargará
de la conversión de instrucciones estándar a opcodes, aunque no viene mal conocer
la existencia de estas instrucciones. Para los programadores de emuladores y de
desensambladores, el conocimiento de estos opcodes es vital.
</p>

<p>
 El juego Sabre Wulf, por ejemplo, utiliza una de estas instrucciones en la determinación
del camino de uno de los enemigos en pantalla (la instrucción SLL, que veremos a
continuación), hasta el punto en que los primeros emuladores de Spectrum emulaban
mal este juego hasta que incluyeron dicha instrucción en la emulación.
</p>

<p>
 Los “<em>undocumented opcodes</em>” son esencialmente opcodes con prefijos CB, ED, DD o FD
que hacen unas determinadas operaciones y que no están incluídos en la “lista oficial”
que hemos visto hasta ahora. Todos los ejemplos que veremos a continuación están
extraídos del documento “The Undocumented Z80 Documented”, de Sean Young.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit11" id="prefijo-cb">Prefijo CB</h3>
<div class="level3">

<p>
 Por ejemplo, los opcodes CB 30, CB 31, CB 32, CB 33, CB 34, CB 35, CB 36 y CB 37
definen una nueva instrucción: <strong>SLL</strong>.
</p>
<div class="table-responsive sectionedit12"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> OPCODE </th><th class="col1"> INSTRUCCION </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> CB 30 </td><td class="col1"> SLL B </td>
	</tr>
	<tr class="row2">
		<td class="col0"> CB 31 </td><td class="col1"> SLL C </td>
	</tr>
	<tr class="row3">
		<td class="col0"> CB 32 </td><td class="col1"> SLL D </td>
	</tr>
	<tr class="row4">
		<td class="col0"> CB 33 </td><td class="col1"> SLL E </td>
	</tr>
	<tr class="row5">
		<td class="col0"> CB 34 </td><td class="col1"> SLL H </td>
	</tr>
	<tr class="row6">
		<td class="col0"> CB 35 </td><td class="col1"> SLL L </td>
	</tr>
	<tr class="row7">
		<td class="col0"> CB 36 </td><td class="col1"> SLL (HL) </td>
	</tr>
	<tr class="row8">
		<td class="col0"> CB 37 </td><td class="col1"> SLL A </td>
	</tr>
</tbody></table></div>

<p>
 <strong>SLL (Shift Logical Left)</strong> funciona exactamente igual que SLA salvo porque pone a
1 el bit 0 (mientras que SLA lo ponía a 0).
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit13" id="prefijos-dd-y-fd">Prefijos DD y FD</h3>
<div class="level3">

<p>
 En general, una instrucción precedida por el opcode DD se ejecuta igual que sin él
excepto por las siguientes reglas:
</p>
<ul class="fix-media-list-overlap">
<li> Si la instrucción usaba el registro HL, éste se sustituye por IX (excepto en las instrucciones EX DE, HL y EXX).
</li>
<li> Cualquier uso de (HL) se reemplaza por (IX+d), excepto JP (HL).
</li>
<li> Cualquier acceso a H se reemplaza por IXh (byte alto de IX), excepto en el uso de (IX+d).
</li>
<li> Cualquier acceso a L se reemplaza por IXl (byte alto de IX), excepto en el uso de (IX+d).
</li>
</ul>

<p>
 Por ejemplo:
</p>
<div class="table-responsive sectionedit14"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Sin el prefijo DD </th><th class="col1"> Con el Prefijo DD </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> LD HL, 0 </td><td class="col1"> LD IX, 0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> LD H, A </td><td class="col1"> LD IXh, A </td>
	</tr>
	<tr class="row3">
		<td class="col0"> LD H, (HL) </td><td class="col1"> LD H, (IX+d) </td>
	</tr>
</tbody></table></div>

<p>
El caso de FD es exactamente igual que el de DD, pero usando el registro IY en lugar del IX.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit15" id="prefijo-ed">Prefijo ED</h3>
<div class="level3">

<p>
 Hay una gran cantidad de instrucciones ED XX indocumentadas. Muchos de ellos realizan
la misma función que sus equivalentes sin ED delante, mientras que otros simplemente
son leídos y decodificados, resultando, a niveles prácticos, equivalentes a 2 instrucciones
NOP. Veamos algunos de ellos:
</p>
<div class="table-responsive sectionedit16"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> OPCODE </th><th class="col1"> INSTRUCCION </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> ED 4C </td><td class="col1"> NEG </td>
	</tr>
	<tr class="row2">
		<td class="col0"> ED 4E </td><td class="col1"> IM 0 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> ED 44 </td><td class="col1"> NEG </td>
	</tr>
	<tr class="row4">
		<td class="col0"> ED 45 </td><td class="col1"> RETN </td>
	</tr>
	<tr class="row5">
		<td class="col0"> ED 5C </td><td class="col1"> NEG </td>
	</tr>
	<tr class="row6">
		<td class="col0"> ED 5D </td><td class="col1"> RETN </td>
	</tr>
	<tr class="row7">
		<td class="col0"> ED 64 </td><td class="col1"> NEG </td>
	</tr>
	<tr class="row8">
		<td class="col0"> ED 65 </td><td class="col1"> RETN </td>
	</tr>
	<tr class="row9">
		<td class="col0"> ED 66 </td><td class="col1"> IM 0 </td>
	</tr>
	<tr class="row10">
		<td class="col0"> ED 6C </td><td class="col1"> NEG </td>
	</tr>
	<tr class="row11">
		<td class="col0"> ED 6D </td><td class="col1"> RETN </td>
	</tr>
	<tr class="row12">
		<td class="col0"> ED 6E </td><td class="col1"> IM 0 </td>
	</tr>
	<tr class="row13">
		<td class="col0"> ED 70 </td><td class="col1"> IN (C) / IN F,(C) </td>
	</tr>
	<tr class="row14">
		<td class="col0"> ED 71 </td><td class="col1"> OUT (C),0 </td>
	</tr>
	<tr class="row15">
		<td class="col0"> ED 74 </td><td class="col1"> NEG </td>
	</tr>
	<tr class="row16">
		<td class="col0"> ED 75 </td><td class="col1"> RETN </td>
	</tr>
	<tr class="row17">
		<td class="col0"> ED 76 </td><td class="col1"> IM1 </td>
	</tr>
	<tr class="row18">
		<td class="col0"> ED 77 </td><td class="col1"> NOP </td>
	</tr>
	<tr class="row19">
		<td class="col0"> ED 7C </td><td class="col1"> NEG </td>
	</tr>
	<tr class="row20">
		<td class="col0"> ED 7D </td><td class="col1"> RETN </td>
	</tr>
	<tr class="row21">
		<td class="col0"> ED 7E </td><td class="col1"> IM2 </td>
	</tr>
	<tr class="row22">
		<td class="col0"> ED 7F </td><td class="col1"> NOP </td>
	</tr>
</tbody></table></div>

<p>
 Aparte de los duplicados de NOP, NEG, IM0, etc, podemos ver un par de instrucciones
curiosas y que nos pueden ser de utilidad. Por ejemplo:
</p>
<pre class="code">ED 70       IN (C)</pre>

<p>
 Esta instrucción lee el puerto C, pero no almacena el resultado de la lectura en
ningún lugar. No obstante, altera los flags del registro F como corresponde al
resultado leído. Puede ser interesante si sólo nos interesa, por ejemplo, si el
valor leído es cero o no (flag Z), y no queremos perder un registro para almacenar
el resultado.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit17" id="prefijos-ddcb-y-fdcb">Prefijos DDCB y FDCB</h3>
<div class="level3">

<p>
 Las instrucciones DDCB y FDCB no documentadas almacenan el resultado de la
operación de la instrucción equivalente sin prefijo (si existe dicho resultado)
en uno de los registros de propósito general: B, C, D, E, H, L, ninguno o A,
según los 3 bits más bajos del último byte del opcode (000=B, 001=C, 010=D, etc).
</p>

<p>
 Así, supongamos el siguiente opcode sí documentado:
</p>
<pre class="code"> DD CB 01 06         RLC (IX+01h)</pre>

<p>
 Si hacemos los 3 últimos bits de dicho opcode 010 (010), el resultado de la
operación se copia al registro D (010 = D en nuestra definición anterior), con
lo que realmente, en lugar de “RLC (IX+01h)” se ejecuta:
</p>
<pre class="code z80"> <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re0">01h</span><span class="br0">)</span>
 <span class="kw1">RLC</span> <span class="kw2">D</span>
 <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re0">01h</span><span class="br0">)</span>, <span class="kw2">D</span></pre>

<p>
 La notación que sugiere <em>Sean Young</em> para estos opcodes es: “RLC (IX+01h), D”.
</p>

<p>
 Con el prefijo FDCB ocurre igual que con DDCB, salvo que se usa el registro IY
en lugar de IX.
</p>

<p>
<br>

</p>

</div>

<h2 id="de-la-teoria-a-la-practica">De la teoría a la práctica</h2>
<div class="level2">

<p>
 Con este capítulo hemos cubierto el 99% de las instrucciones soportadas
por el microprocesador Z80. Con la excepción de los <em>Modos de Interrupciones</em>
del Z80 y sus aplicaciones, ya tenemos a nuestra disposición las piezas
básicas para formar cualquier programa o rutina en ensamblador.
</p>

<p>
 No obstante, todavía quedan por delante muchas horas de programación
para dominar este lenguaje, así como diferentes técnicas, trucos,
rutinas y mapas de memoria que nos permitan dibujar nuestros gráficos,
realizar rutinas complejas, utilizar el sistema de interrupciones del
microprocesador para realizar controles de temporización de nuestros
programas, o reproducir sonido.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/07_borde.asm">Cambiando el borde (ASM)</a>
</li>
<li><a href="src/07_borde.tap">Cambiando el borde (TAP)</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt23.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt23.html">Puerto E/S</a></div>
</li>
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt28.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt28.html">Set de caracteres</a></div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a></div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li><div class="li"> <a href="external/ti86.acz.org/z80_ref.htm" class="urlextern" title="external/ti86.acz.org/z80_ref.htm">Z80 Reference de TI86</a>  </div>
</li>
<li><div class="li"> <a href="http://icarus.ticalc.org/articles/z80_faq.html" class="urlextern" title="http://icarus.ticalc.org/articles/z80_faq.html">FAQ de Icarus Productions</a> </div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a></div>
</li>
<li><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/index.html" class="urlextern" title="external/www.ticalc.org/pub/text/z80/index.html">Tablas de ensamblado y t-estados</a> (pulsar en z80.txt, z80_reference.txt, z80time.txt).</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/lesson1.htm" class="urlextern" title="external/www.z80.info/lesson1.htm">Curso de ASM de z80.info</a></div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a></div>
</li>
<li><div class="li"> <a href="http://www.myquest.nl/z80undocumented/z80-documented.pdf" class="urlextern" title="http://www.myquest.nl/z80undocumented/z80-documented.pdf">Instrucciones no documentadas</a> (1)</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/zip/z80-documented.pdf" class="urlextern" title="external/www.z80.info/zip/z80-documented.pdf">Instrucciones no documentadas</a> (2)</div>
</li>
<li><a href="src/zx-ports-full-table.pdf">ZX Spectrum Guide to the ZX Spectrum ports</a>
</li>
<li><a href="src/velesoft-zxporty-cz.pdf">ZX SPECTRUM - PORTS TABLE (Velesoft)</a>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content ">
<h1 id="save-y-loadalmacenamiento-en-cinta">Save y Load: almacenamiento en cinta</h1>
<div class="level1">

<p>
 ¿En qué formato se almacenan los datos en una cinta de cassette para
que el Spectrum pueda después cargar desde ellas pantallas de
presentación, los personajes de un juego o el código ejecutable de un
programa?
</p>

<p>
 En este capítulo mostraremos cómo se graban y estructuran los datos en
las cintas, y qué hace el Spectrum para acceder a ellos mediante las
rutinas de que nos provee la ROM. Como aplicación  práctica, se incluirá
 código de carga y grabación de pantallas junto a un ejemplo completo
que hará uso de las mismas.
</p>

<p>
<br>

</p>

</div>

<h2 id="formato-de-los-datos-en-cinta">Formato de los datos en cinta</h2>
<div class="level2">

<p>
 Supongamos que, desde BASIC, salvamos un bloque de datos en cinta con
el comando SAVE. Lo primero que nos interesa conocer es el <strong>formato</strong> o <strong>estructura de los datos</strong> almacenados en la cinta, es decir, ¿qué se guarda realmente en la cinta (en formato de audio) cuando hacemos un SAVE?
</p>

<p>
 Un SAVE produce 2 bloques de datos en la cinta:
</p>

<p>
<br>

</p>
<ol class="fix-media-list-overlap">
<li> Un bloque de 19 bytes de tamaño
fijo, conocido como cabecera. Este bloque es cargado muy rápidamente,
debido a su pequeño tamaño. Si pensáis en los cientos ó miles de LOADs
desde cinta que habréis hecho en vuestro Spectrum, recordaréis, nada más
 pulsar PLAY, la aparición del tono guía (líneas del borde rojas y cyan)
 seguido de un brevísimo momento de carga de datos (líneas del borde
azules y amarillas). Es en ese momento en el que aparece en pantalla la
información relativa al juego/programa que estamos cargando.
</li>
<li> Un bloque de longitud variable que contiene los datos concretos y reales a cargar.
</li>
</ol>

<p>
<br>

</p>

<p>
 Ambos bloques son en realidad “datos” con el siguiente formato:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Un byte inicial, que como veremos se llama Flag Byte.
</li>
<li> Los datos en sí mismos: 17 bytes para cabeceras, o la longitud concreta de los datos para los bloques de datos.
</li>
<li> Un byte de checksum o CRC.
</li>
</ul>

<p>
<br>

</p>

<p>
 Profundicemos un poco más en estos 2 bloques de datos:
</p>

<p>
 Cada bloque se inicia con una serie de pulsos de 2168 t-stados cada
uno, que constituyen el tono guía. La cantidad de pulsos (la duración)
de este tono guía es de 8063 pulsos para los bloques de cabecera, y 3223
 pulsos para los bloques de datos. Es por eso que la duración del tono
guía (el famoso pitido inicial de la carga) es mayor para la carga de la
 cabecera que para el de los datos en sí mismos. Es decir, el tono guía
está presente tanto para los bloques de cabecera como para los de datos,
 salvo que su duración es menor en los bloques de datos.
</p>

<p>
 Un t-stado (t-state) es 1 ciclo de reloj, y equivale a  1 / 3.500.000 segundos.
</p>

<p>
<br>

<img src="img/tono_guia.png" class="mediacenter" alt=" Aspecto del tono guía "/>
<br>

</p>

<p>
 Tras el tono guía de la cabecera viene la cabecera en sí misma (que no
dejan de ser datos). Su carga, como ya hemos dicho, tarda un tiempo muy
corto en realizarse, ya que son sólo 19 bytes a ser leídos desde el
cassette.
</p>

<p>
<br>

<img src="img/header.png" class="mediacenter" alt=" Una vez cargada la cabecera "/>
<br>

</p>

<p>
 En la imagen anterior podemos ver el aspecto de la pantalla una vez
terminado el tono guía y cargada la cabecera. Esta cabecera, mediante
sus 19 bytes, le indican al Spectrum la naturaleza de los datos a cargar
 en el bloque de datos que sigue a la misma, con el siguiente formato:
</p>
<div class="table-responsive sectionedit3"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Byte </th><th class="col1"> Longitud </th><th class="col2"> Descripción </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> 1 </td><td class="col2"> Byte Flag ($00 ó $FF) </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> 1 </td><td class="col2"> Tipo de bloque (0-3)</td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> 10 </td><td class="col2"> Nombre de fichero (rellenado con espacios en blanco) </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 12 </td><td class="col1"> 2 </td><td class="col2"> Longitud del bloque de datos a cargar </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 14 </td><td class="col1"> 2 </td><td class="col2"> Parámetro 1 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 16 </td><td class="col1"> 2 </td><td class="col2"> Parámetro 2 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 18 </td><td class="col1"> 1 </td><td class="col2"> Checksum / Suma de comprobación </td>
	</tr>
</tbody></table></div>

<p>
 Pasemos a describir los diferentes campos de la cabecera:
</p>

<p>
 El byte de flag (Byte 0) y el de Checksum (byte 18) no forman parte
exactamente de la cabecera, sino del bloque cargado en sí mismo (también
 están presente cuando cargamos datos y no cabeceras), pero se han
incluído dentro de la tabla para hacerla de lectura más sencilla. Puede
decirse que el byte-flag es el byte prefijo de todo bloque de datos
(considerando una cabecera de 17 bytes como un bloque de datos) y el
checksum es el byte sufijo de ese mismo bloque. Concretamente, el valor
de Byte-Flag es de $00 para bloques de cabecera y $FF para bloques de
datos.
</p>

<p>
 El byte de tipo de bloque indica qué datos se van a cargar a continuación, según los siguientes valores:
</p>
<div class="table-responsive sectionedit4"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Valor </th><th class="col1"> Significado </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> Programa </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> Array de números </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> Array de caracteres </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> CODE (datos a cargar en memoria)</td>
	</tr>
</tbody></table></div>

<p>
 En el caso de bloques de tipo CODE, el byte “Parámetro 1” define la
dirección de inicio del bloque de código cuando se hizo el SAVE, y el
parámetro 2 contiene el valor 32768.
</p>

<p>
 Para bloques de tipo PROGRAM, el Parámetro 1 contiene el valor de la
línea BASIC de autostart (o un número mayor de 32768 si no se dio un
parámetro LINE al hacer el SAVE), y el Parámetro 2 contiene el inicio
del área de variables relativa al inicio del programa.
</p>

<p>
 Un detalle: una pantalla de datos (SCREEN$) se define en esta cabecera
como un bloque de tipo CODE de 6912 bytes a cargar sobre la dirección
16384.
</p>

<p>
 Tras la cabecera (tono guía + bloque datos) viene el bloque de datos en
 sí mismo, que vuelve a componerse de un tono guía, el Flag Byte, los
datos
</p>

<p>
<br>

 <img src="img/bloque_datos.png" class="mediacenter" alt=" Aspecto de la carga del bloque de datos en sí mismo "/>
<br>

</p>

<p>
 Ahora bien … ¿cómo es posible que se almacenen como audio datos
digitales? ¿Cómo entiende el Spectrum si los datos que está cargando son
 unos o ceros y los agrupa en bloques de bytes que podemos interpretar
de forma lógica?
</p>

<p>
 Como ya hemos comentado al hablar del tono guía, la clave está en la
temporización precisa a la hora de leer datos desde la cinta. Aparte de
tonos guía y pulsos de sincronización … ¿qué es un cero en la cinta?
¿qué es un uno? ¿Cómo se almacena (y lee) un byte de 8 bits? ¿Y cómo se
almacena (y lee) un conjunto de bytes?
</p>
<ul class="fix-media-list-overlap">
<li> Un cero (bit=0) se codifica en cinta como 2 pulsos de una duración de 855 t-stados cada uno.
</li>
<li> Un uno (bit=1) se codifica en cinta como 2 pulsos de una duración de 1710 t-stados cada uno.
</li>
<li> Para almacenar los 8 bits de un
byte, se almacenan bit a bit de mayor a menor peso (primero el bit 7,
luego el 6, el 5, el 4, el 3, el 2, el 1 y finalmente el LSB o bit 0).
</li>
<li> Cuando se almacena más de un byte (un bloque) se guardan primero los datos del primer byte del bloque, luego el segundo, etc.
</li>
</ul>

<p>
 Los pulsos son ondas con un aspecto como el siguiente (aspecto de un tono guía en TAPER):
</p>

<p>
<br>

<img src="img/pilot.png" class="mediacenter" alt=" Aspecto de un tono guía (TAPER) "/>
<br>

</p>

<p>
 Es decir, si tenemos que almacenar en cinta los siguientes bytes:
</p>
<pre class="code">abcdefgh ijklmnop</pre>

<p>
 Se almacenarían en cinta en este orden:
</p>
<pre class="code">a b c d e f g h i j k l m n o p</pre>

<p>
 Así pues, la rutina de la ROM del Spectrum se encarga (tanto al grabar
como al leer) de codificar pulsos de diferentes duraciones para
almacenar los ceros y unos de forma consecutiva. Nosotros aprovecharemos
 (como veremos a continuación) dicha rutina para cargar o salvar bloques
 de datos a nuestro antojo sin tener que programar esas temporizaciones y
 lecturas/escrituras a la cinta. Para nosotros será tan sencillo como
cargar los valores adecuados en ciertos registros y realizar un CALL. No
 obstante, para los más curiosos, al final de este capítulo tenéis un
enlace a las rutinas de la ROM adecuadamente comentadas de “The Complete
 Spectrum ROM Disassembly”, por el Ian Logan y Frank O'Hara (publicado
en 1983).
</p>

<p>
 El nivel más bajo al que necesitamos llegar es el siguiente:
</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"> Cada bloque tiene la siguiente estructura física:
<ul class="fix-media-list-overlap">
<li class="level3"> Un tono guía de 8063 (cabeceras) ó 3223 pulsos (datos) de 2168 t-stados cada uno.
</li>
<li class="level3"> Un pulso de sincronización de 667 t-stados.
</li>
<li class="level3"> Un segundo pulso de sincronización de 735 t-stados.
</li>
<li class="level3"> El bloque de datos en sí mismo, bit a bit (0 = 2 pulsos de 855 t-stados, 1 = 2 pulsos de 1710 t-stados).
</li>
</ul>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li class="level1 node"> Cada bloque tiene la siguiente estructura lógica (formato de los datos DENTRO de un bloque):
<ul class="fix-media-list-overlap">
<li class="level3"> Flag byte, con un valor de $00 para bloques de cabecera o $FF para bloques de datos.
</li>
<li class="level3"> Los datos en sí mismos: 17 bytes para cabeceras, o la longitud concreta de los datos para los bloques de datos.
</li>
<li class="level3"> Un byte de checksum, calculado de forma que haciendo un XOR de todos los bytes juntos, incluyendo el flag Byte, produzca $00.
</li>
</ul>
</li>
</ul>

<p>
 Resumiendo:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Los datos salvados en cinta constan
de tono guía, seguido de un bloque de datos de 19 bytes denominado
cabecera, seguido de un tono guía de menor duración que el inicial (por
ser de datos), seguido de los datos en sí mismos.
</li>
<li> Esa cabecera proporciona información
 sobre el nombre, duración y ciertos parámetros relativos a los datos en
 sí mismos (el segundo bloque cargado).
</li>
<li> Los datos se leen de cinta
secuencialmente, del primer al último byte del bloque de datos, y
almacenado cada byte desde el bit 7 al 0 secuencialmente.
</li>
<li> Los 1s y los 0s se almacenan en cinta como pulsos de duraciones concretas.
</li>
<li> Las rutinas de la ROM nos permiten
leer y escribir en cinta bloques de datos, realizando ellas la
temporización adecuada para convertir nuestros “datos en memoria” en
“pulsos” o viceversa sin complicación por nuestra parte.
</li>
<li> Sólo necesitaríamos escribir una
rutina propia de carga (que detecte pulsos, temporice, etc) si
quisiéramos programar nuestra propia carga, por ejemplo para cargar a
diferente velocidad que el Spectrum (ultracargas), que cargue de
dispositivos externos (puerto de joystick, algún pin concreto del bus de
 expansión, etc.) o para ejecutar código mientras cargamos el programa
(minijuegos durante la carga, contadores de carga, etc). Para el resto
de casos, bastará con usar mediante CALL las rutinas de la ROM.
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="ejemplo-de-volcado-de-un-save">Ejemplo de volcado de un SAVE</h2>
<div class="level2">

<p>
 En la <abbr title="" data-original-title="Frequently Asked Questions">FAQ</abbr>
 de comp.sys.sinclair y WorldOfSpectrum tenemos un ejemplo muy
interesante que muestra el formato lógico de los datos grabados con un
SAVE en cinta. Supongamos el siguiente comando BASIC:
</p>
<pre class="code">SAVE "ROM" CODE 0,2</pre>

<p>
 Este comando BASIC salvaría (SAVE), un total de 2 bytes (2) de datos
(CODE), empezando en 0 (0) a cinta. En resumen, salvaría el contenido de
 la dirección de memoria 0x0000 y 0x0001 en cinta. Esto produciría los
siguientes datos en cinta:
</p>
<pre class="code">00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1 ff f3 af a3</pre>

<p>
 Comencemos mostrando qué representa cada dato poco a poco:
</p>
<div class="table-responsive sectionedit6"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> cabecera </th><th class="col1"> bloque de datos </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1 </td><td class="col1"> ff f3 af a3 </td>
	</tr>
</tbody></table></div>

<p>
 Desgranando más la información:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit7"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Byte Flag </th><th class="col1"> datos cabecera </th><th class="col2"> checksum </th><th class="col3"> byte flag </th><th class="col4"> datos ROM </th><th class="col5"> checksum </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 00 </td><td class="col1"> 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 </td><td class="col2"> f1 </td><td class="col3"> ff </td><td class="col4"> f3 af </td><td class="col5"> a3 </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Concretamente, los datos de la cabecera (ignorando el Byte Flag y el Checksum):
</p>
<div class="table-responsive sectionedit8"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Tipo de bloque </th><th class="col1"> Nombre de fichero </th><th class="col2"> Longitud bloque </th><th class="col3"> Parámetro 1 </th><th class="col4"> Parametro 2 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 03 </td><td class="col1"> 52 4f 4d 20 20 20 20 20 20 20 </td><td class="col2"> 02 00 </td><td class="col3"> 00 00 </td><td class="col4"> 00 80 </td>
	</tr>
</tbody></table></div>

<p>
 Como véis el nombre “ROM” (52 4F 4D) se completa con espacios en blanco
 hasta los 10 caracteres. Además podemos ver la longitud del bloque que
se salvó (02 bytes).
</p>

<p>
 Después de estos datos tenemos el checksum (F1) y el bloque de datos en sí mismo:
</p>
<div class="table-responsive sectionedit9"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Byte Flag </th><th class="col1"> Datos grabados </th><th class="col2"> Checksum </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> ff </td><td class="col1"> f3 af </td><td class="col2"> a3 </td>
	</tr>
</tbody></table></div>

<p>
 En este caso el byte flag es 0xFF (bloque de tipo “datos”), al cual
siguen los 2 bytes tomados de la ROM y grabados a cinta (0x0000 y
0x0001) y el checksum (0xA3).
</p>

<p>
<br>

</p>

</div>

<h2 id="rutinas-de-carga-de-la-rom">Rutinas de carga de la ROM</h2>
<div class="level2">

<p>
 Ya sabemos cómo se almacenan los datos en cinta, así que nuestra
próxima misión es conocer cómo cargarlos o grabarlos de una manera
sencilla. Para hacer esto usaremos las funciones de la ROM del Spectrum
para carga y grabación de datos a cinta: hablamos de 2 subrutinas (de
LOAD y SAVE) a las que podremos llamar con unos parámetros concretos.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit11" id="rutina-de-load-de-la-rom">Rutina de LOAD de la ROM</h3>
<div class="level3">

<p>
 La rutina de LOAD comienza en la dirección $0556 (0556h ó 1366d) y requiere los siguientes parámetros:
</p>
<div class="table-responsive sectionedit12"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Registro </th><th class="col1"> Valor </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> IX </td><td class="col1"> Dirección inicio de memoria donde almacenar los datos que se van a cargar. </td>
	</tr>
	<tr class="row2">
		<td class="col0"> DE </td><td class="col1"> Longitud del bloque de datos a cargar. </td>
	</tr>
	<tr class="row3">
		<td class="col0"> A </td><td class="col1"> Flag Byte, normalmente 0x00 para cargar cabeceras o 0xFF (255) para cargar datos. </td>
	</tr>
	<tr class="row4">
		<td class="col0"> CF (CarryFlag) </td><td class="col1"> 1=LOAD, 0=VERIFY </td>
	</tr>
</tbody></table></div>

<p>
 La rutina devuelve el CF = 0 si ocurre alguno de los siguientes errores:
</p>
<ul class="fix-media-list-overlap">
<li> “R-Tape Loading Error” (bien por timeout o bien por byte de paridad incorrecto)
</li>
<li> Flag Byte incorrecto.
</li>
<li> “D BREAK - CONT repeats” (se pulsó la tecla BREAK).
</li>
</ul>

<p>
 Recuerda que puedes activar el CARRY FLAG con la instruccion “SCF” (Set Carry Flag) y ponerlo a cero con un simple “AND A”.
</p>

<p>
 Veamos 2 ejemplos, el primero cargaría una pantalla gráfica sobre la
videomemoria (el equivalente de un LOAD “” SCREEN$) siempre y cuando la
pantalla se haya grabado sin cabecera:
</p>
<pre class="code z80">   <span class="kw1">SCF</span>                <span class="co1">; Set Carry Flag -&gt; CF=1 -&gt; LOAD</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>          <span class="co1">; A = 0xFF (cargar datos)</span>
   <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="re1">1</span><span class="nu0">6384</span>       <span class="co1">; Destino del load = 16384</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">69</span><span class="re1">1</span><span class="nu0">2</span>        <span class="co1">; Tamaño a cargar = 6912</span>
   <span class="kw1">CALL</span> <span class="re1">1</span><span class="nu0">366</span>          <span class="co1">; Llamamos a la rutina de carga</span></pre>

<p>
 Este segundo programa cargaría un bloque de código ejecutable en memoria, y saltaría a él (un programa “cargador”):
</p>
<pre class="code z80">   <span class="kw1">SCF</span>               <span class="co1">; Set Carry Flag (LOAD)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span> 	     <span class="co1">; A = 0xFF (cargar datos)</span>
   <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="nu0">32768</span>      <span class="co1">; Destino de la carga</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">2</span><span class="re1">000</span>      <span class="co1">; Nuestro "programa" ocupa 12000 bytes.</span>
   <span class="kw1">CALL</span> <span class="re1">0</span><span class="nu0">556</span>  	     <span class="co1">; Recordemos que 0556h = 1366d</span>
   <span class="kw1">JP</span> <span class="nu0">32768</span>          <span class="co1">; Saltamos al programa código máquina cargado</span></pre>

<p>
<br>

</p>

</div>

<h3 class="sectionedit13" id="rutina-de-save-de-la-rom">Rutina de SAVE de la ROM</h3>
<div class="level3">

<p>
 La rutina SAVE de la ROM tiene unos parámetros muy similares a la de LOAD, y está alojada en 1218d (04c2h):
</p>
<div class="table-responsive sectionedit14"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Registro </th><th class="col1"> Valor </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> IX </td><td class="col1"> Dirección inicio de memoria de los datos que se van a grabar. </td>
	</tr>
	<tr class="row2">
		<td class="col0"> DE </td><td class="col1"> Longitud del bloque de datos a grabar (se grabarán los datos desde IX a IX+DE). </td>
	</tr>
	<tr class="row3">
		<td class="col0"> A </td><td class="col1"> Flag Byte, 0x00 para grabar cabeceras o 0xFF (255) para grabar datos. </td>
	</tr>
	<tr class="row4">
		<td class="col0"> CF (CarryFlag) </td><td class="col1"> 0 (SAVE) </td>
	</tr>
</tbody></table></div>

<p>
 Lo normal es que no tengamos que recurrir en prácticamente ninguna
ocasión a la rutina de grabación de datos, de modo que nos centraremos,
mediante ejemplos, en la rutina de carga.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit15" id="cargando-o-ignorando-la-cabecera">Cargando o Ignorando la cabecera</h3>
<div class="level3">

<p>
 Cuando salvamos datos desde BASIC, lo normal es que se generen 2
bloques de datos, el de la cabecera, y el de los datos en sí mismos. El
bloque de datos de la cabecera, cargado en memoria, nos permite saber el
 tamaño y destino de los datos que vendrán en el siguiente bloque. Es
decir, cargando el primer bloque obtenemos la información necesaria para
 cargar en IX y DE los valores adecuados para la carga del bloque de
datos.
</p>

<p>
 En ocasiones, podemos ignorar el bloque de cabecera totalmente, sobre
todo cuando sabemos qué vamos a cargar desde cinta, qué destino tiene, y
 qué tamaño tiene, y lo especificamos directamente en nuestro programa
ASM. En ese caso, podemos cargar la cabecera con el CARRY FLAG a cero
(verify), con lo cual la leemos pero no la almacenamos en memoria, y
después cargar los valores adecuados en IX, DE, A, etc, poner el CF a 1,
 y cargar los datos que vienen tras la cabecera.
</p>

<p>
 Supongamos que grabamos un bloque de datos, gráficos, una pantalla o
música en cinta usando SAVE, rutinas de la ROM, o desde un emulador o
herramienta cruzada de PC. Supongamos que sabemos el tamaño exacto en
cinta de dichos datos, y no necesitamos leer y analizar la cabecera para
 cargarlos. En tal caso, podemos ejecutar código como el siguiente:
</p>
<pre class="code z80">  <span class="kw1">AND</span> <span class="kw2">A</span>                           <span class="co1">; CF = 0 (verify)</span>
  <span class="kw1">CALL</span> <span class="re1">1</span><span class="nu0">366</span>                       <span class="co1">; Cargamos e ignoramos la cabecera</span>
&nbsp;
  <span class="kw1">SCF</span>                             <span class="co1">; Set Carry Flag -&gt; CF=1 -&gt; LOAD</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>                       <span class="co1">; A = 0xFF (cargar datos)</span>
  <span class="kw1">LD</span> <span class="kw2">IX</span>, direccion_destino        <span class="co1">; Destino del load</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, tamaño_a_cargar          <span class="co1">; Tamaño a cargar</span>
  <span class="kw1">CALL</span> <span class="re1">1</span><span class="nu0">366</span>                       <span class="co1">; Llamamos a la rutina de carga</span></pre>

<p>
 Posteriormente veremos un ejemplo que ignora la cabecera al cargar una pantalla SCR completa sobre la videoram.
</p>

<p>
 ¿Cuándo nos interesa analizar la cabecera? Principalmente cuando los
datos están generados desde nuestro propio programa y tienen un tamaño
variable. Por ejemplo, supongamos que programamos un editor de textos
que da al usuario la oportunidad de salvar y cargar los textos en cinta.
 En tal caso, necesitaremos leer la cabecera para saber el tamaño del
documento (bloque de datos) a cargar, ya que no lo conocemos de
antemano.
</p>

<p>
 No obstante, en el caso de un juego, normalmente se conoce con
antelación el tamaño de los datos a cargar, por lo que se puede ignorar
felizmente la cabecera del bloque de cinta..
</p>

<p>
<br>

</p>

</div>

<h2 id="convirtiendo-datos-en-cinta">Convirtiendo datos en cinta</h2>
<div class="level2">

<p>
 Lo primero que necesitamos saber es, ¿cómo convertimos nuestros datos
(gráficos, pantalla de carga, números, tablas precalculadas, sprites,
música, etc) en datos cargables desde las rutinas que hemos visto? Hay
múltiples formas de hacerlo.
</p>

<p>
 Para empezar, podemos hacerlo desde el mismo BASIC del Spectrum, usando
 el comando SAVE: esto nos permitirá grabar datos de memoria en cinta:
</p>
<pre class="code basic">SAVE "nombre" CODE direccion_inicio, tamaño</pre>

<p>
 En la mayoría de los casos, muchos de nosotros programamos hoy en
sistemas PC usando compiladores cruzados, ensambladores cruzados y
emuladores, por lo que normalmente lo que nos interesará es obtener
ficheros TAP para poder concatenarlos con nuestros cargadores o
programas.
</p>

<p>
 Supongamos que estamos programando un juego que, nada más acabar, lo
primero que hace es cargar desde cinta los datos del nivel actual
(gráficos, mapeado, etc). Esto implica que cuando programemos el juego,
tendremos por un lado el código, que nos proporcionará un fichero TAP
(por ejemplo) listo para ejecutar. A ese fichero TAP tendremos que
concatenarle los datos de los diferentes niveles (o gráficos, o los
datos que necesitemos).
</p>

<p>
 Así, nuestro “programa.asm” (código fuente) se convierte en
“programa.bin” tras el proceso de ensamblado, y finalmente obtenemos un
“programa.tap” (o .tzx) listo para cargar en un Spectrum.
</p>

<p>
 Pero en dicho TAP o TZX tenemos que añadir (al final del mismo) los
datos que el programa espera cargar. Imaginemos que estos datos son una
pantalla gráfica (.scr) de 6912 bytes. Tendremos un fichero
“pantalla.scr”, y tenemos que introducirlo dentro de nuestro fichero
TAP, al final, tras el código del programa, para que cuando este sea
ejecutado, lo siguiente que cargue desde cinta nuestro programa sea
dicha pantalla SCR.
</p>

<p>
 Para ello, con el objetivo de hacerlo de una manera muy sencilla,
utilizaremos ficheros TAP. El formato de este tipo de ficheros es muy
sencillo, simplemente contienen bloques de datos precedidos por 2 bytes
que indican el tamaño del bloque. Supongamos que tenemos en un fichero
los 2 primeros bytes de la ROM que vimos anteriormente:
</p>
<pre class="code">f3 af</pre>

<p>
 Este fichero de 2 bytes de tamaño (inicio_rom.bin, por ejemplo),
guardado en una cinta tendría el formato que vimos anteriormente: 2
bloques (cabecera y datos)
</p>
<pre class="code">00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1

+

ff f3 af a3</pre>

<p>
 Es decir, 2 bloques de cinta de 19 y 4 bytes de datos, que conforman un
 SAVE de nuestros 2 bytes. Pues un fichero TAP con estos datos sería,
sencillamente, el escribir estos 2 bloques en un fichero anteponiendo a
cada bloque el tamaño a cargar:
</p>
<pre class="code">13 00 00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1

+

04 00 ff f3 af a3</pre>

<p>
 Es decir “13 00” (número 19 en formato WORD, indicando el tamaño del
bloque que viene a continuación) seguido de los 19 bytes, y “04 00”
(número 4 en formato WORD) seguido de los 4 bytes del bloque.
</p>

<p>
 El contenido en binario de nuestro inicio_rom.tap sería, pues:
</p>
<pre class="code">13 00 00 03 52 4f 4d 20 20 20 20 20 20 20 02 00 00 00 00 80 f1 04 00 ff f3 af a3</pre>

<p>
 Y el tamaño resultante en bytes del fichero serían 2 + 19 + 2 + 4= 27 bytes.
</p>

<p>
 Gracias a este formato tan sencillo, podemos unir ficheros TAP
simplemente concatenándolos. De esta forma, si tenemos nuestro
“programa.tap” y la “graficos.tap”, y queremos unirlos porque nuestro
programa, al ejecutarse, carga los gráficos esperándolos en cinta tras
el código del mismo, bastaría con hacer:
</p>
<pre class="code">Linux:    cat programa.tap graficos.tap &gt; programa_final.tap
Windows:  copy /B programa.tap graficos.tap programa_final.tap</pre>

<p>
 Sabemos cómo podemos obtener nuestro programa en formato TAP: cogemos
el código fuente, lo compilamos, y o bien obtenemos un TAP directamente
(pasmo --tapbas), o bien obtenemos un BIN que convertimos con BIN2TAP.
Pero … ¿cómo convertimos nuestro “graficos.bin”, “pantalla_carga.bin”,
“musica.bin” o cualquier otro fichero de datos en crudo? No podemos usar
 el BIN2TAP original porque éste añade un cargador BASIC al principio
del programa… hay múltiples soluciones, pero la más sencilla es utilizar
 un ensamblador como <strong>pasmo</strong>.
</p>

<p>
 Para convertir un fichero .bin en un fichero tap sin cabecera, creamos un pequeño programa ASM (rom.asm) como el siguiente:
</p>
<pre class="code">INCBIN "rom.bin"</pre>

<p>
 A continuación, “ensamblamos” ese programa con PASMO indicando que queremos que nos genere un TAP sin cabecera BASIC:
</p>
<pre class="code">pasmo --tap rom.asm rom.tap</pre>

<p>
 Con esto, obtendremos un fichero “rom.tap” con el contenido de rom.bin, y sin cargador BASIC, listo para utilizar.
</p>

<p>
<br>

</p>

</div>

<h2 id="ejemplo-completo">Ejemplo completo</h2>
<div class="level2">

<p>
 Finamente, para aquellos programadores que quieran ver un ejemplo de
aplicación práctica de la recuperación de datos desde un binario en
ejecución, vamos a juntar todo lo visto para realizar un programa que
cargue una pantalla gráfica completa (fichero .scr) sobre la videoRAM.
</p>

<p>
 Los pasos a seguir para generar el ejemplo son los siguientes:
</p>

<p>
 Primero, buscamos un fichero .SCR de carga (por ejemplo, la pantalla de carga de cualquier juego obtenida desde <a href="http://www.worldofspectrum.org/infoseek.cgi" class="urlextern" title="http://www.worldofspectrum.org/infoseek.cgi">WOS InfoSeek</a> ) y lo almacenamos en disco.
</p>

<p>
 Segundo, mediante pasmo obtenemos un TAP con los datos del fichero SCR,
 sin cabecera BASIC. Dicho TAP tendrá un tamaño como el siguiente:
</p>
<pre class="code">$ ls -l zxcolumns.*
-rw-r--r-- 1 sromero sromero 6912 2007-10-08 13:01 zxcolumns.scr
-rw-r--r-- 1 sromero sromero 6937 2007-10-08 13:02 zxcolumns.tap</pre>

<p>
 Ahora ya tenemos una pantalla SCR guardada en formato TAP (en cinta). Nótese cómo podríamos cargar este TAP desde BASIC con un <em>LOAD “” CODE 16384,6912</em>, y aparecería la imagen en pantalla.
</p>

<p>
 Lo siguiente que necesitamos es el programa propiamente dicho, el cual hará la carga de la pantalla en videomemoria:
</p>
<pre class="code z80"><span class="co1">;----------------------------------------------------------------------</span>
<span class="co1">; Loadscr.asm : Demostración de las rutinas LOAD de la ROM, con</span>
<span class="co1">; la carga de un fichero SCR (desde cinta) en videomemoria.</span>
<span class="co1">;----------------------------------------------------------------------</span>
&nbsp;
  ORG <span class="nu0">32</span><span class="re1">000</span>
&nbsp;
  <span class="kw1">AND</span> <span class="kw2">A</span>                           <span class="co1">; CF = 0 (verify)</span>
  <span class="kw1">CALL</span> <span class="re1">1</span><span class="nu0">366</span>                       <span class="co1">; Cargamos e ignoramos la cabecera</span>
&nbsp;
  <span class="kw1">SCF</span>                             <span class="co1">; Set Carry Flag -&gt; CF=1 -&gt; LOAD</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>                       <span class="co1">; A = 0xFF (cargar datos)</span>
  <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="re1">1</span><span class="nu0">6384</span>                    <span class="co1">; Destino del load = 16384</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">69</span><span class="re1">1</span><span class="nu0">2</span>                     <span class="co1">; Tamaño a cargar = 6912</span>
  <span class="kw1">CALL</span> <span class="re1">1</span><span class="nu0">366</span>                       <span class="co1">; Llamamos a la rutina de carga</span>
&nbsp;
  <span class="kw1">RET</span>
&nbsp;
END <span class="nu0">32</span><span class="re1">000</span></pre>

<p>
 Al respecto del código fuente, como habréis notado, realizamos 2
llamadas a la rutina de la ROM. La primera carga (pero no almacena en
ningún sitio) el primer bloque de datos existente (la cabecera de la
pantalla de carga). La rutina de la ROM ignorará esta carga porque el
CARRY FLAG está a cero (0=VERIFY). La segunda llamada a 1366 realizará
la carga de los datos propiamente dichos. Al cargarlos sobre la
dirección de destino 16384 (la dirección de la videoram), veremos cómo
se van cargando sobre la pantalla directamente desde la cinta.
</p>

<p>
 Ensamblamos nuestro programa con “pasmo --tapbas loadscr.asm loadscr.tap” y tendremos lo siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> Un TAP (loadscr.tap) con nuestro programa (pero que no tiene datos después de él).
</li>
<li> Un TAP (zxcolumns.tap) con los datos gráficos (en este caso, una pantalla completa de 6912 bytes).
</li>
</ul>

<p>
 Si cargamos en el Spectrum, o en un emulador, el fichero loadscr.tap,
nos encontraríamos con que intenta cargar los datos desde cinta, pero no
 hay datos almacenados tras el programa. Para solucionarlo, concatenamos
 los 2 TAPs (con cat en Linux o copy en Windows/DOS):
</p>
<pre class="code">$ cat loadscr.tap zxcolumns.tap &gt; programa.tap</pre>

<p>
 Ahora sí, cargando “programa.tap” en el emulador, cargaremos nuestro
programa, el cual llama a la rutina de la ROM para cargar los datos que
van después del programa (la pantalla de carga) en videomemoria. Si lo
probáis en un emulador, recordad deshabilitar las opciones de carga
rápida o carga instantánea si queréis ver el efecto de la carga.
</p>

<p>
<br>

<img src="img/loadscreen.png" class="mediacenter" alt=" Nuestro programa cargando el fichero SCR "/>
<br>

</p>

<p>
 Si os fijáis durante la carga, veréis como primero se carga el LOADER,
luego el código máquina de nuestro programa, y después la pantalla.
Contando los tonos guía de carga también encontraréis el lugar donde se
lee, pero ignora, la cabecera (19 bytes, carga muy corta) de la pantalla
 SCR.
</p>

<p>
 Un apunte: tanto en el caso de la carga, como de la grabación de datos,
 recordad que las rutinas de la ROM no indican al usuario que debe
pulsar PLAY o REC, por lo que debemos indicar al usuario cuándo debe
pulsar PLAY o REC dentro de nuestros programas o juegos. Incluso, cuando
 acabemos de cargar los datos relativos a nuestro juego, resulta
conveniente indicarle al usuario cuándo debe detener la cinta
(especialmente en juegos multicarga) e insertar los segundos de
“espacio” que creamos convenientes entre bloques.
</p>

<p>
 Recordad que en este ejemplo hemos cargado 6912 bytes de un fichero SCR
 directamente sobre la videoRAM, pero nada nos impide cargar ficheros de
 cualquier otro tamaño, con cualquier otro contenido (sprites, fondos,
datos, mapeados) sobre cualquier lugar de la memoria (asegurándonos
primero que no hay nada en el lugar destino de la carga, como código, la
 pila, u otros datos o variables).
</p>

<p>
 Así pues, de la misma forma que hemos cargado una pantalla SCR, podemos
 organizar los gráficos y mapeados de nuestro juego en 1 “bloque de
datos” por nivel, cargar los datos del nivel 1 tras acabar la carga de
nuestro programa, y sobreescribir estos gráficos y mapeados “en memoria”
 con los de los diferentes niveles según vaya avanzando el jugador. En
otras palabras, podemos hacer un juego multicarga que nos permita tener
más sprites, pantallas o gráficos disponibles para cada nivel, que los
que tendríamos disponibles si cargamos todos los datos de todos los
niveles del juego, ya que usamos toda la memoria para cada nivel, en
lugar de dividirla en espacio para los diferentes niveles. A cambio, el
usuario tendrá que cargar desde cinta las diferentes fases conforme
avanza, y rebobinar para cargar los datos del “Nivel 1” cuando deba
empezar una nueva partida.
</p>

<p>
<br>

</p>

</div>

<h2 id="la-rutina-ld-bytes-load">La rutina LD-BYTES (Load)</h2>
<div class="level2">

<p>
 A continuación podemos ver el código desensamblado de la rutina
LD-BYTES ($0556), la que estamos utilizando para la carga de datos desde
 cinta. Es una rutina muy interesante y disponer de su código fuente
puede tener 2 usos directos.
</p>

<p>
 El primero es poder comprender de forma exácta cómo funciona la carga
de datos desde cinta y los tiempos que se manejan en dicha carga. El
segundo es el de reproducir la rutina en nuestro programa y añadir
funciones adicionales como un contador de carga o incluso algún tipo de
minijuego durante la misma.
</p>

<p>
 El código comentado está extraído del documento “The Complete Spectrum ROM Disassembly”, de Ian Logan y Frank O'Hara.
</p>
<pre class="code z80"><span class="co1">; THE 'LD-BYTES' SUBROUTINE</span>
<span class="co1">; This subroutine is called to LOAD the header information (from 07BE)</span>
<span class="co1">; and later LOAD, or VERIFY, an actual block of data (from 0802).</span>
<span class="re1">0</span><span class="nu0">556</span> LD<span class="sy0">-</span>BYTES:
                  <span class="kw1">INC</span>   <span class="kw2">D</span>                   <span class="co1">; This resets the zero flag. (D</span>
                                            <span class="co1">; cannot hold +FF.)</span>
                  <span class="kw1">EX</span>    <span class="kw2">AF</span>,<span class="kw2">A</span><span class="st0">'F'</span>             <span class="co1">; The A register holds +00 for a</span>
                                            <span class="co1">; header and +FF for a block of</span>
                                            <span class="co1">; data.</span>
                                            <span class="co1">; The carry flag is reset for</span>
                                            <span class="co1">; VERIFYing and set for</span>
                                            <span class="co1">; LOADing.</span>
                  <span class="kw1">DEC</span>   <span class="kw2">D</span>                   <span class="co1">; Restore D to its original value.</span>
&nbsp;
                  <span class="kw1">DI</span>                        <span class="co1">; The maskable interrupt is now</span>
                                            <span class="co1">; disabled.</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="sy0">+</span><span class="re1">0</span>F               <span class="co1">; The border is made WHITE.</span>
                  <span class="kw1">OUT</span>   <span class="br0">(</span><span class="sy0">+</span>FE<span class="br0">)</span>,<span class="kw2">A</span>
                  <span class="kw1">LD</span>    <span class="kw2">HL</span>,<span class="sy0">+</span><span class="re1">0</span>53F            <span class="co1">; Preload the machine stack</span>
                  <span class="kw1">PUSH</span>  <span class="kw2">HL</span>                  <span class="co1">; with the address - SA/LD-RET.</span>
                  <span class="kw1">IN</span>    <span class="kw2">A</span>,<span class="br0">(</span><span class="sy0">+</span>FE<span class="br0">)</span>             <span class="co1">; Make an initial read of port '254'</span>
                  <span class="kw1">RRA</span>                       <span class="co1">; Rotate the byte obtained but</span>
                  <span class="kw1">AND</span>   <span class="sy0">+</span><span class="nu0">2</span><span class="re1">0</span>                 <span class="co1">; keep only the EAR bit,</span>
                  <span class="kw1">OR</span>    <span class="sy0">+</span><span class="re1">0</span><span class="nu0">2</span>                 <span class="co1">; Signal 'RED' border.</span>
                  <span class="kw1">LD</span>    <span class="kw2">C</span>,<span class="kw2">A</span>                 <span class="co1">; Store the value in the C register. -</span>
                                            <span class="co1">; (+22 for 'off' and +02 for 'on'</span>
                                            <span class="co1">; - the present EAR state.)</span>
                  <span class="kw1">CP</span>    <span class="kw2">A</span>                   <span class="co1">; Set the zero flag.</span>
&nbsp;
<span class="co1">; The first stage of reading a tape involves showing that a pulsing</span>
<span class="co1">; signal actually exist (i.e. 'On/off' or 'off/on' edges.)</span>
&nbsp;
<span class="re1">0</span>56B LD<span class="sy0">-</span>BREAK     <span class="kw1">RET</span>   NZ                  <span class="co1">; Return if the BREAK key is</span>
                                            <span class="co1">; being pressed.</span>
<span class="re1">0</span>56C LD<span class="sy0">-</span>START     <span class="kw1">CALL</span>  <span class="re1">0</span>5E7,LD<span class="sy0">-</span>EDGE<span class="sy0">-</span><span class="re1">1</span>      <span class="co1">; Return with the carry flag reset</span>
                  <span class="kw1">JR</span>    NC,<span class="re1">0</span>56B,LD<span class="sy0">-</span>BREAK    <span class="co1">; if there is no 'edge' within</span>
                                            <span class="co1">; approx. 14,000 T states. But if</span>
                                            <span class="co1">; an 'edge' is found the border</span>
                                            <span class="co1">; will go CYAN.</span>
&nbsp;
<span class="co1">; The next stage involves waiting a while and then showing</span>
<span class="co1">; that the signal is still pulsing.</span>
&nbsp;
                  <span class="kw1">LD</span>    <span class="kw2">HL</span>,<span class="sy0">+</span><span class="re1">0</span><span class="nu0">4</span><span class="re1">1</span><span class="nu0">5</span>            <span class="co1">; The length of this waiting</span>
<span class="re1">0</span><span class="nu0">574</span> LD<span class="sy0">-</span>WAIT      <span class="kw1">DJNZ</span>  <span class="re1">0</span><span class="nu0">574</span>,LD<span class="sy0">-</span>WAIT        <span class="co1">; period will be almost one</span>
                  <span class="kw1">DEC</span>   <span class="kw2">HL</span>                  <span class="co1">; second in duration.</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">H</span>
                  <span class="kw1">OR</span>    <span class="kw2">L</span>
                  <span class="kw1">JR</span>    NZ,<span class="re1">0</span><span class="nu0">574</span>,LD<span class="sy0">-</span>WAIT
                  <span class="kw1">CALL</span>  <span class="re1">0</span>5E3,LD<span class="sy0">-</span>EDGE<span class="sy0">-</span><span class="nu0">2</span>      <span class="co1">; Continue only if two edges are</span>
                  <span class="kw1">JR</span>    NC,<span class="re1">0</span>56B,LD<span class="sy0">-</span>BREAK    <span class="co1">; found within the allowed time</span>
                                            <span class="co1">; period.</span>
&nbsp;
<span class="co1">; Now accept only a 'leader signal'.</span>
&nbsp;
<span class="re1">0</span><span class="nu0">58</span><span class="re1">0</span> LD<span class="sy0">-</span>LEADER    <span class="kw1">LD</span>    <span class="kw2">B</span>,<span class="sy0">+</span>9C               <span class="co1">; The timing constant,</span>
                  <span class="kw1">CALL</span>  <span class="re1">0</span>5E3,LD<span class="sy0">-</span>EDGE<span class="sy0">-</span><span class="nu0">2</span>      <span class="co1">; Continue only if two edges are</span>
                  <span class="kw1">JR</span>    NC,<span class="re1">0</span>56B,LD<span class="sy0">-</span>BREAK    <span class="co1">; found within the allowed time</span>
                                            <span class="co1">; period.</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="sy0">+</span>C6               <span class="co1">; However the edges must have</span>
                  <span class="kw1">CP</span>    <span class="kw2">B</span>                   <span class="co1">; been found within about</span>
                  <span class="kw1">JR</span>    NC,<span class="re1">0</span>56C,LD<span class="sy0">-</span>START    <span class="co1">; 3,000 T states of each other</span>
                  <span class="kw1">INC</span>   <span class="kw2">H</span>                   <span class="co1">; Count the pair of edges in the H</span>
                  <span class="kw1">JR</span>    NZ,<span class="re1">0</span><span class="nu0">58</span><span class="re1">0</span>,LD<span class="sy0">-</span>LEADER   <span class="co1">; register until '256' pairs have</span>
                                            <span class="co1">; been found.</span>
&nbsp;
<span class="co1">; After the leader come the 'off' and 'on' part's of the sync pulse.</span>
&nbsp;
<span class="re1">0</span>58F LD<span class="sy0">-</span>SYNC      <span class="kw1">LD</span>    <span class="kw2">B</span>,<span class="sy0">+</span>C9               <span class="co1">; The timing constant.</span>
                  <span class="kw1">CALL</span>  <span class="re1">0</span>5E7,LD<span class="sy0">-</span>EDGE<span class="sy0">-</span><span class="re1">1</span>      <span class="co1">; Every edge is considered until</span>
                  <span class="kw1">JR</span>    NC,<span class="re1">0</span>56B,LD<span class="sy0">-</span>BREAK    <span class="co1">; two edges are found close</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">B</span>                 <span class="co1">; together - these will be the</span>
                  <span class="kw1">CP</span>    <span class="sy0">+</span>D4                 <span class="co1">; start and finishing edges of</span>
                  <span class="kw1">JR</span>    NC,<span class="re1">0</span>58F,LD<span class="sy0">-</span>SYNC     <span class="co1">; the 'off' sync pulse.</span>
                  <span class="kw1">CALL</span>  <span class="re1">0</span>5E7,LD<span class="sy0">-</span>EDGE<span class="sy0">-</span><span class="re1">1</span>      <span class="co1">; The finishing edge of the</span>
                  <span class="kw1">RET</span>   NC                  <span class="co1">; 'on' pulse must exist.</span>
                                            <span class="co1">; (Return carry flag reset.)</span>
&nbsp;
<span class="co1">; The bytes of the header or the program/data block can now be LOADed or</span>
<span class="co1">; VERIFied. But the first byte is the type flag.</span>
&nbsp;
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">C</span>                 <span class="co1">; The border colours from now</span>
                  <span class="kw1">XOR</span>   <span class="sy0">+</span><span class="re1">0</span><span class="nu0">3</span>                 <span class="co1">; on will be BLUE &amp; YELLOW.</span>
&nbsp;
                  <span class="kw1">LD</span>    <span class="kw2">C</span>,<span class="kw2">A</span>
                  <span class="kw1">LD</span>    <span class="kw2">H</span>,<span class="sy0">+</span><span class="re1">00</span>               <span class="co1">; Initialise the 'parity matching'</span>
                                            <span class="co1">; byte to zero.</span>
                  <span class="kw1">LD</span>    <span class="kw2">B</span>,<span class="sy0">+</span>B<span class="re1">0</span>               <span class="co1">; Set the timing constant for the</span>
                                            <span class="co1">; flag byte.</span>
                  <span class="kw1">JR</span>    <span class="re1">0</span>5C8,LD<span class="sy0">-</span>MARKER      <span class="co1">; Jump forward into the byte</span>
                                            <span class="co1">; LOADING loop.</span>
&nbsp;
<span class="co1">; The byte LOADing loop is used to fetch the bytes one at a time.</span>
<span class="co1">; The flag byte is first. This is followed by the data bytes and</span>
<span class="co1">; the last byte is the 'parity' byte.</span>
&nbsp;
<span class="re1">0</span>5A9 LD<span class="sy0">-</span>LOOP      <span class="kw1">EX</span>    <span class="kw2">AF</span>,<span class="kw2">A</span><span class="st0">'F'</span>             <span class="co1">; Fetch the flags.</span>
                  <span class="kw1">JR</span>    NZ,<span class="re1">0</span>5B3,LD<span class="sy0">-</span>FLAG     <span class="co1">; Jump forward only when</span>
                                            <span class="co1">; handling the first byte.</span>
                  <span class="kw1">JR</span>    NC,<span class="re1">0</span>5BD,LD<span class="sy0">-</span>VERIFY   <span class="co1">; Jump forward if VERIFYing a</span>
                                            <span class="co1">; tape.</span>
                  <span class="kw1">LD</span>    <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">00</span><span class="br0">)</span>,<span class="kw2">L</span>           <span class="co1">; Make the actual LOAD when</span>
                                            <span class="co1">; required.</span>
                  <span class="kw1">JR</span>    <span class="re1">0</span>5C2,LD<span class="sy0">-</span>NEXT        <span class="co1">; Jump forward to LOAD the</span>
                                            <span class="co1">; next byte.</span>
<span class="re1">0</span>5B3 LD<span class="sy0">-</span>FLAG      <span class="kw1">RL</span>    <span class="kw2">C</span>                   <span class="co1">; Keep the carry flag in a safe</span>
                                            <span class="co1">; place temporarily.</span>
                  <span class="kw1">XOR</span>   <span class="kw2">L</span>                   <span class="co1">; Return now if the type flag does</span>
                  <span class="kw1">RET</span>   NZ                  <span class="co1">; not match the first byte on the</span>
                                            <span class="co1">; tape. (Carry flag reset.)</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">C</span>                 <span class="co1">; Restore the carry flag now.</span>
                  <span class="kw1">RRA</span>
                  <span class="kw1">LD</span>    <span class="kw2">C</span>,<span class="kw2">A</span>
                  <span class="kw1">INC</span>   <span class="kw2">DE</span>                  <span class="co1">; Increase the counter to</span>
                  <span class="kw1">JR</span>    <span class="re1">0</span>5CA,LD<span class="sy0">-</span><span class="kw1">DEC</span>         <span class="co1">; compensate for its 'decrease'</span>
                                            <span class="co1">; after the jump.</span>
&nbsp;
<span class="co1">; If a data block is being verified then the freshly loaded byte is</span>
<span class="co1">; tested against the original byte.</span>
&nbsp;
<span class="re1">0</span>5BD LD<span class="sy0">-</span>VERlFY    <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">00</span><span class="br0">)</span>           <span class="co1">; Fetch the original byte.</span>
                  <span class="kw1">XOR</span>   <span class="kw2">L</span>                   <span class="co1">; Match it against the new byte.</span>
                  <span class="kw1">RET</span>   NZ                  <span class="co1">; Return if 'no match'. (Carry</span>
                                            <span class="co1">; flag reset.)</span>
&nbsp;
<span class="co1">; A new byte can now be collected from the tape.</span>
&nbsp;
<span class="re1">0</span>5C2 LD<span class="sy0">-</span>NEXT      <span class="kw1">INC</span>   <span class="kw2">IX</span>                  <span class="co1">; Increase the 'destination'.</span>
<span class="re1">0</span>5C4 LD<span class="sy0">-</span><span class="kw1">DEC</span>       <span class="kw1">DEC</span>   <span class="kw2">DE</span>                  <span class="co1">; Decrease the 'counter'.</span>
                  <span class="kw1">EX</span>    <span class="kw2">AF</span>,<span class="kw2">A</span><span class="st0">'F'</span>             <span class="co1">; Save the flags.</span>
                  <span class="kw1">LD</span>    <span class="kw2">B</span>,<span class="sy0">+</span>B2               <span class="co1">; Set the timing constant.</span>
<span class="re1">0</span>5C8 LD<span class="sy0">-</span>MARKER    <span class="kw1">LD</span>    <span class="kw2">L</span>,<span class="sy0">+</span><span class="re1">01</span>               <span class="co1">; Clear the 'object' register apart</span>
                                            <span class="co1">; from a 'marker' bit.</span>
&nbsp;
<span class="co1">; The 'LD-8-BITS' loop is used to build up a byte in the L register.</span>
&nbsp;
<span class="re1">0</span>5CA LD<span class="sy0">-</span><span class="nu0">8</span><span class="sy0">-</span>BITS    <span class="kw1">CALL</span>  <span class="re1">0</span>5E3,LD<span class="sy0">-</span>EDGE<span class="sy0">-</span><span class="nu0">2</span>      <span class="co1">; Find the length of the 'off' and </span>
                                            <span class="co1">; 'on' pulses of the next bit.</span>
                  <span class="kw1">RET</span>   NC                  <span class="co1">; Return if the time period is</span>
                                            <span class="co1">; exceeded. (Carry flag reset.)</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="sy0">+</span>CB               <span class="co1">; Compare the length against</span>
                                            <span class="co1">; approx. 2,400 T states; resetting</span>
                  <span class="kw1">CP</span>    <span class="kw2">B</span>                   <span class="co1">; the carry flag for a '0' and</span>
                                            <span class="co1">; setting it for a '1'.</span>
                  <span class="kw1">RL</span>    <span class="kw2">L</span>                   <span class="co1">; Include the new bit in the L</span>
                                            <span class="co1">; register.</span>
                  <span class="kw1">LD</span>    <span class="kw2">B</span>,<span class="sy0">+</span>B<span class="re1">0</span>               <span class="co1">; Set the timing constant for the</span>
                                            <span class="co1">; next bit.</span>
                  <span class="kw1">JP</span>    NC,<span class="re1">0</span>5CA,LD<span class="sy0">-</span><span class="nu0">8</span><span class="sy0">-</span>BITS   <span class="co1">; Jump back whilst there are still</span>
                                            <span class="co1">; bits to be fetched.</span>
&nbsp;
<span class="co1">; The 'parity matching' byte has to be updated with each new byte.</span>
&nbsp;
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">H</span>                 <span class="co1">; Fetch the 'parity matching'</span>
                  <span class="kw1">XOR</span>   <span class="kw2">L</span>                   <span class="co1">; byte and include the new byte.</span>
                  <span class="kw1">LD</span>    <span class="kw2">H</span>,<span class="kw2">A</span>                 <span class="co1">; Save it once again.</span>
<span class="co1">; Passes round the loop are made until the 'counter' reaches zero. </span>
<span class="co1">; At that point the 'parity matching' byte should be holding zero.</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">D</span>                 <span class="co1">; Make a further pass if the DE</span>
                  <span class="kw1">OR</span>    <span class="kw2">E</span>                   <span class="co1">; register pair does not hold</span>
                  <span class="kw1">JR</span>    NZ,<span class="re1">0</span>5A9,LD<span class="sy0">-</span>LOOP     <span class="co1">; zero.</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">H</span>                 <span class="co1">; Fetch the 'parity matching'</span>
                                            <span class="co1">; byte.</span>
                  <span class="kw1">CP</span>    <span class="sy0">+</span><span class="re1">01</span>                 <span class="co1">; Return with the carry flat set</span>
                  <span class="kw1">RET</span>                       <span class="co1">; if the value is zero.</span>
                                            <span class="co1">; (Carry flag reset if in error.)</span>
&nbsp;
<span class="co1">; THE 'LD-EDGE-2' AND 'LD-EDGE-1' SUBROUTINES</span>
<span class="co1">; These two subroutines form the most important part of the LOAD/VERIFY</span>
<span class="co1">; operation. The subroutines are entered with a timing constant in the B</span>
<span class="co1">; register, and the previous border colour and 'edge-type' in the C register.</span>
<span class="co1">; The subroutines return with the carry flag set if the required number</span>
<span class="co1">; of 'edges' have been found in the time allowed; and the change to the</span>
<span class="co1">; value in the B register shows just how long it took to find the 'edge(s)'.</span>
<span class="co1">; The carry flag will be reset if there is an error. The zero flag then</span>
<span class="co1">; signals 'BREAK pressed' by being reset, or 'time-up' by being set.</span>
<span class="co1">; The entry point LD-EDGE-2 is used when the length of a complete pulse</span>
<span class="co1">; is required and LD-EDGE-1 is used to find the time before the next 'edge'.</span>
&nbsp;
<span class="re1">0</span>5E3 LD<span class="sy0">-</span>EDGE<span class="sy0">-</span><span class="nu0">2</span>    <span class="kw1">CALL</span>  <span class="re1">0</span>5E7,LD<span class="sy0">-</span>EDGE<span class="sy0">-</span><span class="re1">1</span>      <span class="co1">; In effect call LD-EDGE-1 twice;</span>
                  <span class="kw1">RET</span>   NC                  <span class="co1">; returning in between if there</span>
                                            <span class="co1">; is an error.</span>
<span class="re1">0</span>5E7 LD<span class="sy0">-</span>EDGE<span class="sy0">-</span><span class="re1">1</span>    <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="sy0">+</span><span class="re1">1</span><span class="nu0">6</span>               <span class="co1">; Wait 358 T states before</span>
<span class="re1">0</span>5E9 LD<span class="sy0">-</span>DELAY     <span class="kw1">DEC</span>   <span class="kw2">A</span>                   <span class="co1">; entering the sampling loop.</span>
                  <span class="kw1">JR</span>    NZ,<span class="re1">0</span>5E9,LD<span class="sy0">-</span>DELAY
                  <span class="kw1">AND</span>   <span class="kw2">A</span>
&nbsp;
<span class="co1">; The sampling loop is now entered. The value in the B register is</span>
<span class="co1">; incremented for each pass; 'time-up' is given when B reaches zero.</span>
&nbsp;
<span class="re1">0</span>5ED LD<span class="sy0">-</span>SAMPLE    <span class="kw1">INC</span>   <span class="kw2">B</span>                   <span class="co1">; Count each pass.</span>
                  <span class="kw1">RET</span>   Z                   <span class="co1">; Return carry reset &amp; zero set if</span>
                                            <span class="co1">; 'time-up'.</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="sy0">+</span>7F               <span class="co1">; Read from port +7FFE.</span>
                  <span class="kw1">IN</span>    <span class="kw2">A</span>,<span class="br0">(</span><span class="sy0">+</span>FE<span class="br0">)</span>             <span class="co1">; i.e. BREAK &amp; EAR.</span>
                  <span class="kw1">RRA</span>                       <span class="co1">; Shift the byte.</span>
                  <span class="kw1">RET</span>   NC                  <span class="co1">; Return carry reset &amp; zero reset</span>
                                            <span class="co1">; if BREAK was pressed.</span>
                  <span class="kw1">XOR</span>   <span class="kw2">C</span>                   <span class="co1">; Now test the byte against the</span>
                  <span class="kw1">AND</span>   <span class="sy0">+</span><span class="nu0">2</span><span class="re1">0</span>                 <span class="co1">; 'last edge-type'; jump back</span>
                  <span class="kw1">JR</span>    Z,<span class="re1">0</span>5ED,LD<span class="sy0">-</span>SAMPLE    <span class="co1">; unless it has changed.</span>
&nbsp;
<span class="co1">; A new 'edge' has been found within the time period allowed for the search.</span>
<span class="co1">; So change the border colour and set the carry flag.</span>
&nbsp;
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">C</span>                 <span class="co1">; Change the 'last edge-type'</span>
                  <span class="kw1">CPL</span>                       <span class="co1">; and border colour.</span>
                  <span class="kw1">LD</span>    <span class="kw2">C</span>,<span class="kw2">A</span>
                  <span class="kw1">AND</span>   <span class="sy0">+</span><span class="re1">0</span><span class="nu0">7</span>                 <span class="co1">; Keep only the border colour.</span>
                  <span class="kw1">OR</span>    <span class="sy0">+</span><span class="re1">0</span><span class="nu0">8</span>                 <span class="co1">; Signal 'MIC off'.</span>
                  <span class="kw1">OUT</span>   <span class="br0">(</span><span class="sy0">+</span>FE<span class="br0">)</span>,<span class="kw2">A</span>             <span class="co1">; Change the border colour (RED/</span>
                                            <span class="co1">; CYAN or BLUE/YELLOW).</span>
                  <span class="kw1">SCF</span>                       <span class="co1">; Signal the successful search</span>
                  <span class="kw1">RET</span>                       <span class="co1">; before returning.</span>
&nbsp;
<span class="co1">; Note: The LD-EDGE-1 subroutine takes 465 T states, plus an additional 58 T</span>
<span class="co1">; states for each unsuccessful pass around the sampling loop.</span>
&nbsp;
<span class="co1">; For example, therefore, when awaiting the sync pulse (see LD-SYNC at 058F)</span>
<span class="co1">; allowance is made for ten additional passes through the sampling loop.</span>
<span class="co1">; The search is thereby for the next edge to be found within, roughly,</span>
<span class="co1">; 1,100 T states (465 + 10 * 58 + overhead). This will prove successful</span>
<span class="co1">; for the sync 'off' pulse that comes after the long 'leader pulses'.</span></pre>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/09_loadscr.asm">Ejemplo de load de SCR sobre la VRAM</a>
</li>
<li><a href="src/09_ejcarga.zip">TAPs del ejemplo anterior</a>
</li>
<li><a href="src/bin2tap.c">bin2tap.c: Conversor de datos a fichero TAP</a>
</li>
<li><a href="src/bin2tap_nl.c">Bin2tap que no genera cargador BASIC</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/48kreference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/48kreference.htm">FAQ 48K de WOS</a></div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/48kreference.htm#TapeDataStructure" class="urlextern" title="external/worldofspectrum.org/faq/reference/48kreference.htm#TapeDataStructure">Tape Data Structure</a></div>
</li>
<li><div class="li"> <a href="http://www.worldofspectrum.org/tapsamp.html" class="urlextern" title="http://www.worldofspectrum.org/tapsamp.html">Cintas y TAPER</a></div>
</li>
<li><div class="li"> <a href="http://www.worldofspectrum.org/ldbytes.html" class="urlextern" title="http://www.worldofspectrum.org/ldbytes.html">Rutina de carga/grabación de la ROM, desemsamblada y comentada</a></div>
</li>
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt24.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt24.html">Manual del +3</a></div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a></div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a></div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/metalbrain/BIN2CODE.EXE" class="urlextern" title="http://www.speccy.org/metalbrain/BIN2CODE.EXE">BIN2CODE (Metalbrain)</a></div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="lectura-del-teclado-en-el-spectrum">Lectura del teclado en el Spectrum</h1>
<div class="level1">

<p>
 Este capítulo está íntegramente dedicado a la lectura del teclado mediante la instrucción de lectura de puertos “<strong>IN</strong>”.
 A lo largo del mismo veremos cómo responde el estado del puerto a los
cambios del teclado, y subrutinas útiles para la gestión del mismo.
</p>

<p>
 Tras este capítulo seremos capaces de consultar el estado del teclado,
ya sean teclas concretas predefinidas en el código o redefinidas por el
usuario, permitiéndonos interactuar con él y cubriendo una de las
principales necesidades a la hora de programar juegos para Spectrum: el
control, tanto de los menúes como del juego en sí.
</p>

<p>
<br>

</p>

</div>

<h2 id="el-teclado-a-nivel-hardware">El teclado a nivel hardware</h2>
<div class="level2">

<p>
El teclado del Spectrum es una matriz de 40 pulsadores (40 teclas) que
proporcionan al microprocesador, a través de las líneas de
Entrada/Salida, para diferentes filas, un valor de 8 bits en el rango
0-255, donde cada bit indica el estado de una determinada tecla.
Estrictamente hablando, la encargada de la lectura del teclado (como de
otros periféricos) es realmente la ULA, pero para nosotros esto es
transparente y podremos utilizar las funciones estándar de IO del
microprocesador Z80 para conocer el estado del teclado. Para leer el
estado de cada una de las teclas del teclado (0 = pulsada, 1 = no
pulsada), debemos obtener el estado del puerto $FE.
</p>

<p>
 La pregunta en este momento debe de ser: si $FE es el puerto de lectura
 del teclado, y el Z80A es un microprocesador con un bus de datos de 8
bits, ¿cómo leemos el estado de 40 teclas en un registro de 8 bits?
</p>

<p>
 La respuesta es: organizando el teclado en filas de teclas y seleccionando qué fila leer mediante el registro B.
</p>

<p>
<br>

<img src="img/teclado.jpg" class="mediacenter" alt="Teclado del Spectrum"/>
<br>

</p>

<p>
 Si abrimos físicamente nuestro Spectrum, veremos que el teclado está
conectado a la placa base del mismo mediante 2 cintas de datos: una de
ellas de 8 líneas y la otra de 5. La de 8 líneas (8 bits) se puede
considerar como el “byte de direcciones” del teclado, y es la que está
unida al byte alto (bits 8 al 15) del bus de direcciones del Spectrum.
La de 5 bits está conectado a los 5 bits inferiores (del 0 al 4) del bus
 de datos. Mediante la primera seleccionamos qué fila queremos leer (con
 el registro B), y mediante la segunda leemos el estado del teclado (en
ceros y unos).
</p>

<p>
<br>

<img src="img/teclado_hw.jpg" class="mediacenter" alt="El aspecto de la membrana de teclado"/>
<br>

</p>

<p>
 Así, en nuestros programas podemos leer el estado del teclado
accediendo a los puertos de Entrada / Salida del microprocesador a los
que están conectadas las diferentes líneas de dicha matriz.
</p>

<p>
<br>

<img src="img/08_plantillatec.jpg" class="mediacenter" alt="Plantilla eléctrica del teclado"/>
<br>

</p>

<p>
 Rescatemos el siguiente programa BASIC de uno de los capítulos iniciales del curso:
</p>
<pre class="code basic">5  REM Mostrando el estado de la fila 1-5 del teclado ($F7FE)
10 LET puerto=63486
20 LET V=IN puerto: PRINT AT 20,0; V ; "  " : GO TO 20</pre>

<p>
 Este ejemplo lee (en un bucle infinito) una de las filas del teclado,
concretamente la fila de las teclas del 1 al 5. Esta fila tiene sus
diferentes bits de estado conectados al puerto 63486 ($F7FEh), y como
podéis suponer, mediante la instrucción IN de BASIC realizamos la
misma función que con su equivalente ensamblador: consultar el valor
contenido en dicho puerto.
</p>

<p>
 El valor $FE se corresponde con el puerto del teclado, mientras que $F7
 se corresponde con 11110111 en binario, donde el cero selecciona la
fila concreta del teclado que queremos leer, en este caso, la fila de
teclas del 1 al 5.
</p>

<p>
 Por defecto, sin pulsar ninguna tecla, los diferentes bits del valor
leído en dicho puerto estarán a 1. Cuando pulsamos una tecla, el valor
del bit correspondiente a dicha tecla aparecerá como 0, y soltándola
volverá a su valor 1 original.
</p>

<p>
 Al ejecutar el ejemplo en BASIC, veremos que la pulsación de
cualquier tecla modifica el valor numérico que aparece en pantalla.
Si pasamos dicho valor numérico a formato binario veremos cómo el
cambio del valor se corresponde con las teclas que vamos pulsando y
liberando.
</p>

<p>
 Si no hay ninguna tecla pulsada, los 5 bits más bajos del byte que
hay en el puerto estarán todos a 1, mientras que si se pulsa alguna de
las teclas del 1 al 5, el bit correspondiente a dicha tecla pasará a
estado 0. Nosotros podemos leer el estado del puerto y saber, mirando
los unos y los ceros, si las teclas están pulsadas o no. Los 3 bits
más altos del byte debemos ignorarlos para este propósito, ya que no tienen relación
alguna con el teclado (son los bits de acceso al cassette, a la unidad de cinta y al altavoz del Spectrum).
</p>

<p>
 Así, por ejemplo, leyendo del puerto 63486 obtenemos un byte cuyos 5 últimos bits tienen
como significado el estado de cada una de las teclas de la semifila del “1” al “5”.
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit3"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bits: </th><th class="col1"> D7 </th><th class="col2"> D6 </th><th class="col3"> D5 </th><th class="col4"> D4 </th><th class="col5"> D3 </th><th class="col6"> D2 </th><th class="col7"> D1 </th><th class="col8"> D0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Teclas: </td><td class="col1"> XX </td><td class="col2"> XX </td><td class="col3"> XX </td><td class="col4"> “5” </td><td class="col5"> “4” </td><td class="col6"> “3” </td><td class="col7"> “2” </td><td class="col8"> “1” </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Como ya hemos dicho, los bits D7 a D5 no nos interesan en el caso del teclado (por
ejemplo, D6 tiene relación con la unidad de cinta), mientras que los
bits de D4 a D0 son bits de teclas (0=pulsada, 1=no pulsada). Tenemos
pues el teclado dividido en filas de teclas y disponemos de una serie
de puertos para leer el estado de todas ellas:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit4"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Puerto </th><th class="col1"> Teclas </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 65278d ($FEFE) </td><td class="col1"> de CAPS SHIFT a V </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 65022d ($FDFE) </td><td class="col1"> de A a G </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 64510d ($FBFE) </td><td class="col1"> de Q a T </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 63486d ($F7FE) </td><td class="col1"> de 1 a 5 (y JOYSTICK 1) </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 61438d ($EFFE) </td><td class="col1"> de 6 a 0 (y JOYSTICK 2) </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 57342d ($DFFE) </td><td class="col1"> de P a Y </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 49150d ($BFFE) </td><td class="col1"> de ENTER a H </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 32766d ($7FFE) </td><td class="col1"> de (space) a B </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 En el resultado de la lectura de  estos puertos, el bit menos significativo (D0)
siempre hace referencia a la tecla más alejada del centro del teclado
(“1” en nuestro ejemplo), mientras que el más significativo de los 5
(D5) lo hace a la tecla más cercana al centro del teclado.
</p>

<p>
 Concretamente:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit5"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Puerto </th><th class="col1"> Bits: </th><th class="col2"> D4 </th><th class="col3"> D3 </th><th class="col4"> D2 </th><th class="col5"> D1 </th><th class="col6"> D0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 65278d ($FEFE) </td><td class="col1"> Teclas: </td><td class="col2"> “V” </td><td class="col3"> “C” </td><td class="col4"> “X” </td><td class="col5"> “Z” </td><td class="col6"> CAPS </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 65022d ($FDFE) </td><td class="col1"> Teclas: </td><td class="col2"> “G” </td><td class="col3"> “F” </td><td class="col4"> “D” </td><td class="col5"> “S” </td><td class="col6"> “A” </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 64510d ($FBFE) </td><td class="col1"> Teclas: </td><td class="col2"> “T” </td><td class="col3"> “R” </td><td class="col4"> “E” </td><td class="col5"> “W” </td><td class="col6"> “Q” </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 63486d ($F7FE) </td><td class="col1"> Teclas: </td><td class="col2"> “5” </td><td class="col3"> “4” </td><td class="col4"> “3” </td><td class="col5"> “2” </td><td class="col6"> “1” </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 61438d ($EFFE) </td><td class="col1"> Teclas: </td><td class="col2"> “6” </td><td class="col3"> “7” </td><td class="col4"> “8” </td><td class="col5"> “9” </td><td class="col6"> “0” </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 57342d ($DFFE) </td><td class="col1"> Teclas: </td><td class="col2"> “Y” </td><td class="col3"> “U” </td><td class="col4"> “I” </td><td class="col5"> “O” </td><td class="col6"> “P” </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 49150d ($BFFE) </td><td class="col1"> Teclas: </td><td class="col2"> “H” </td><td class="col3"> “J” </td><td class="col4"> “K” </td><td class="col5"> “L” </td><td class="col6"> ENTER </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 32766d ($7FFE) </td><td class="col1"> Teclas: </td><td class="col2"> “B” </td><td class="col3"> “N” </td><td class="col4"> “M” </td><td class="col5"> SYMB </td><td class="col6"> SPACE </td>
	</tr>
	<tr class="row9">
		<th class="col0 rightalign">  SINCLAIR 1 y 2 (las mismas teclas 0-9) </th><th class="col1"> </th><th class="col2"> </th><th class="col3"> </th><th class="col4"> </th><th class="col5"> </th><th class="col6"> </th>
	</tr>
	<tr class="row10">
		<td class="col0"> 61438d ($EFFE) </td><td class="col1"> SINCL1 </td><td class="col2"> LEFT </td><td class="col3"> RIGHT </td><td class="col4"> DOWN </td><td class="col5"> UP </td><td class="col6"> FIRE </td>
	</tr>
	<tr class="row11">
		<td class="col0"> 63486d ($F7FE) </td><td class="col1"> SINCL2 </td><td class="col2 rightalign">  FIRE </td><td class="col3"> DOWN </td><td class="col4"> UP </td><td class="col5"> RIGHT </td><td class="col6"> LEFT </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Como puede verse en la tabla, la parte baja de los 16 bits del puerto
representan siempre $FE (254d), el puerto al que está conectado el
teclado.
</p>

<p>
 La parte alta es, la única que varía según la semifila a leer, y su valor consiste,
como hemos visto, en la puesta a cero de la semifila deseada, teniendo en cuenta que
cada semifila de teclas está conectada a uno de los bits del bus de direcciones:
</p>
<div class="table-responsive sectionedit6"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> FILA DE TECLAS </th><th class="col1"> LINEA BUS </th><th class="col2"> VALOR </th><th class="col3"> VALOR BINARIO </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> CAPSSHIFT a V </td><td class="col1"> A8 </td><td class="col2"> $FE </td><td class="col3"> 1 1 1 1 1 1 1 0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> A-G </td><td class="col1"> A9 </td><td class="col2"> $FD </td><td class="col3"> 1 1 1 1 1 1 0 1 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> Q-T </td><td class="col1"> A10 </td><td class="col2"> $FB </td><td class="col3"> 1 1 1 1 1 0 1 1 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 1-5 </td><td class="col1"> A11 </td><td class="col2"> $F7 </td><td class="col3"> 1 1 1 1 0 1 1 1 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 6-0 </td><td class="col1"> A12 </td><td class="col2"> $EF </td><td class="col3"> 1 1 1 0 1 1 1 1 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> Y-P </td><td class="col1"> A13 </td><td class="col2"> $DF </td><td class="col3"> 1 1 0 1 1 1 1 1 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> H-ENTER </td><td class="col1"> A14 </td><td class="col2"> $BF </td><td class="col3"> 1 0 1 1 1 1 1 1 </td>
	</tr>
	<tr class="row8">
		<td class="col0"> B-SPACE </td><td class="col1"> A15 </td><td class="col2"> $7F </td><td class="col3"> 0 1 1 1 1 1 1 1 </td>
	</tr>
</tbody></table></div>

<p>
 Así, al mandar estos valores en la lectura de puerto (en la parte alta
del mismo), lo que hacemos realmente es seleccionar cuál de las líneas
del bus de direcciones (cada una de
ellas conectada a una fila del teclado) queremos leer.
</p>

<p>
 En resumen: es posible obtener el estado de una tecla determinada
leyendo de un puerto de Entrada / Salida del microprocesador. Este
puerto de 16 bits se compone poniendo en su parte alta el valor de la
semifila de teclado a leer (todo “1”s excepto un “0” en la semifila de
interés, según la tabla vista anteriormente), y poniendo en su parte
baja el valor $FE. El IN de dicho puerto nos proporcionará un valor de 8
 bits cuyos 5 últimos bits indicarán el estado de las 5 teclas de la
semifila seleccionada (1=no pulsada, 0=pulsada).
</p>

<p>
(Nótese que es posible leer el estado de 2 o más semifilas
simultáneamente haciendo 0 a la vez valor 2 de los bits del byte alto
del puerto. El resultado obtenido será un AND del estado de los bits de
todas las semifilas leídas).
</p>

<p>
<br>

</p>

</div>

<h2 id="ejemplo-practicoleyendo-el-teclado">Ejemplo práctico: leyendo el teclado</h2>
<div class="level2">

<p>
 Veamos un ejemplo en ASM que se queda en un bucle infinito hasta que
pulsamos la tecla “p”:
</p>
<pre class="code z80">  <span class="co1">; Lectura de la tecla "P" en un bucle</span>
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
bucle:
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>DFFE         <span class="co1">; Semifila "P" a "Y"</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>            <span class="co1">; Leemos el puerto</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>             <span class="co1">; Testeamos el bit 0</span>
  <span class="kw1">JR</span> Z, salir          <span class="co1">; Si esta a 0 (pulsado) salir.</span>
  <span class="kw1">JR</span> bucle             <span class="co1">; Si no (a 1, no pulsado) repetimos</span>
&nbsp;
salir:
  <span class="kw1">RET</span>
&nbsp;
  END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 De nuevo ensamblamos nuestro programa con “<em>pasmo --tapbas keyb1.asm
keyb1.tap</em>”, y lo cargamos en el Spectrum o en un emulador.
</p>

<p>
 Efectivamente, el programa se mantendrá en un bucle infinito hasta
que se ponga a cero el bit 0 del puerto $DFFE, que se corresponde con
el estado de la tecla “P”. Al pulsar esa tecla, la comparación hecha
con BIT hará que el Zero Flag se active y el “JR Z” saldrá de dicho
bucle, retornando al BASIC.
</p>

<p>
 Nótese cómo en ciertos casos puede ser más recomendable la
utilización de una u otra forma de IN. Por ejemplo, nuestro ejemplo
anterior se podría escribir con “IN A, (N)”, y sería más recomendable,
puesto que evita el tener que utilizar el registro B:
</p>
<pre class="code z80">  <span class="co1">; Lectura de la tecla "P" en un bucle (FORMA 2)</span>
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
bucle:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>DF            <span class="co1">; Semifila "P" a "Y"</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>          <span class="co1">; Leemos el puerto</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>             <span class="co1">; Testeamos el bit 0</span>
  <span class="kw1">JR</span> Z, salir          <span class="co1">; Si esta a 0 (pulsado) salir.</span>
  <span class="kw1">JR</span> bucle             <span class="co1">; Si no (a 1, no pulsado) repetimos</span>
&nbsp;
salir:
  <span class="kw1">RET</span>
  END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 En este ejemplo B no se usa, usamos A para albergar la semifila a
leer, que no nos afecta puesto que ya íbamos a perder su valor tras
la lectura (como resultado de ella). Si estamos usando B, por ejemplo
como contador de un bucle, nos interesa más esta forma de uso.
</p>

<p>
<br>

</p>

</div>

<h2 id="esperar-pulsacion-y-esperar-liberacion-de-tecla">Esperar pulsación y esperar liberación de tecla</h2>
<div class="level2">

<p>
 Veamos otras 2 rutinas interesantes para nuestros programas. La
primera espera a que se pulse cualquier tecla (por ejemplo, para
realizar una pausa), y la segunda espera a que se suelte la tecla
pulsada (esta la podemos usar tras detectar una pulsación para esperar
a que el usuario suelte la tecla y no volver a leer la misma tecla en
una segunda iteración de nuestro bucle).
</p>

<p>
 Ambas rutinas se basan en el hecho de que, realmente, es posible leer más
de una semifila del teclado simultáneamente. Como ya vimos, el valor que
mandamos como byte alto del puerto tiene a valor 0 el bit que representa
a la línea de datos que queremos leer.
</p>

<p>
 Pero como vamos a ver, podemos leer más de una línea simultáneamente,
poniendo a cero tantos bits como deseemos en la parte alta del puerto. En
estos ejemplos, con el XOR A (que equivale a “LD A, 0” dado que un XOR de
un registro con sí mismo es cero) dejamos a 0 todo el byte alto con lo
que leemos la información de todas las semifilas simultáneamente.
</p>

<p>
 Este tipo de “multilectura” no nos permite saber de forma exacta
qué tecla ha sido pulsada. Por ejemplo, si intentamos leer simultaneamente
las semifilas 1-5 y Q-T, el bit 0 del resultado valdrá “0” (tecla pulsada)
si se pulsa “1”, se pulsa “Q”, o se pulsan ambas.
</p>

<p>
 Así, podemos saber que una de las teclas de las semifilas está siendo leída,
pero no cuál de ellas. Para saber qué valor debemos enviar al puerto para
leer varias semifilas de forma simultánea, recordemos la tabla vista en
el anterior apartado:
</p>
<div class="table-responsive sectionedit9"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> FILA DE TECLAS </th><th class="col1"> BIT A CERO </th><th class="col2"> VALOR BINARIO </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> CAPSSHIFT a V </td><td class="col1"> A8 </td><td class="col2"> 1 1 1 1 1 1 1 0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> A-G </td><td class="col1"> A9 </td><td class="col2"> 1 1 1 1 1 1 0 1 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> Q-T </td><td class="col1"> A10 </td><td class="col2"> 1 1 1 1 1 0 1 1 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 1-5 </td><td class="col1"> A11 </td><td class="col2"> 1 1 1 1 0 1 1 1 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 6-0 </td><td class="col1"> A12 </td><td class="col2"> 1 1 1 0 1 1 1 1 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> Y-P </td><td class="col1"> A13 </td><td class="col2"> 1 1 0 1 1 1 1 1 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> H-ENTER </td><td class="col1"> A14 </td><td class="col2"> 1 0 1 1 1 1 1 1 </td>
	</tr>
	<tr class="row8">
		<td class="col0"> B-SPACE </td><td class="col1"> A15 </td><td class="col2"> 0 1 1 1 1 1 1 1 </td>
	</tr>
</tbody></table></div>

<p>
 Así, para leer tanto 1-5 como Q-T, necesitamos tener 2 ceros: uno en el
bit 10 y otro en el bit 11. El valor decimal que corresponde con
(11110011d), 243d, nos permite la lectura de ambas semifilas de forma
simultánea.
</p>

<p>
 En el caso de una rutina de espera de pulsación o liberación de
tecla, podemos hacer la parte alta del byte igual a cero (activar
todas las semifilas) para leer todo el teclado, ya que no nos importa
cuál de las teclas ha sido pulsada sino el hecho de que lo haya sido o
no.
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Esta rutina espera a que haya alguna tecla pulsada para volver,</span>
<span class="co1">; consultando las diferentes filas del teclado en un bucle.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Pressed:
 <span class="kw1">XOR</span> <span class="kw2">A</span>                        <span class="co1">; A = 0</span>
 <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
 <span class="kw1">OR</span> <span class="nu0">224</span>
 <span class="kw1">INC</span> <span class="kw2">A</span>
 <span class="kw1">JR</span> Z, Wait_For_Keys_Pressed
 <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Esta rutina espera a que no haya ninguna tecla pulsada para volver,</span>
<span class="co1">; consultando las diferentes filas del teclado en un bucle.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Released:
 <span class="kw1">XOR</span> <span class="kw2">A</span>
 <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>
 <span class="kw1">OR</span> <span class="nu0">224</span>
 <span class="kw1">INC</span> <span class="kw2">A</span>
 <span class="kw1">JR</span> NZ, Wait_For_Keys_Released
 <span class="kw1">RET</span></pre>

<p>
 Existe otra forma de codificar <em>Wait_For_Keys_Pressed</em> consistente en utilizar CPL para “complementar” los bits del resultado leído:
</p>
<pre class="code z80">Wait_For_Key_Pressed:
  <span class="kw1">XOR</span> <span class="kw2">A</span>                        <span class="co1">; Leer todas las teclas</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>
  <span class="kw1">CPL</span>
  <span class="kw1">AND</span> <span class="re1">1</span>Fh                      <span class="co1">; Comprobar todos los unos</span>
  <span class="kw1">JR</span> Z, Wait_For_Key_Pressed
  <span class="kw1">RET</span></pre>

<p>
<br>

</p>

</div>

<h2 id="leyendo-todas-las-direcciones">Leyendo todas las direcciones</h2>
<div class="level2">

<p>
 En el siguiente ejemplo veremos cómo leer las 4 direcciones más
la tecla de disparo en un juego y codificar la información de la lectura en un
formato usable en el bucle principal del programa (para poder chequear cómodamente el
estado de las teclas consultadas).
</p>

<p>
 La idea sería que, utilizando los diferentes bits de un byte, podemos
codificar el estado de las 5 teclas básicas (arriba, abajo, izquierda,
derecha, disparo) en 5 de los 8 bits de un registro, y que nuestra
función de detección de teclado sea algo parecido a lo siguiente:
</p>
<pre class="code z80"><span class="co1">; Lee el estado de O, P, Q, A, ESPACIO y devuelve</span>
<span class="co1">; en A en A el estado de las teclas (1=pulsada, 0=no pulsada).</span>
<span class="co1">; El byte está codificado de forma que:</span>
<span class="co1">;</span>
<span class="co1">; BITS            4    3    2     1   0</span>
<span class="co1">; SIGNIFICADO   FIRE LEFT RIGHT DOWN  UP</span>
<span class="co1">;</span>
LEER_TECLADO:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="re1">0</span>                    <span class="co1">; Keyboard status flag register (D)</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>FBFE
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>                   <span class="co1">; Leemos la tecla Q</span>
  <span class="kw1">JR</span> NZ, Control_no_up       <span class="co1">; No pulsada, no cambiamos nada en D</span>
  <span class="kw1">SET</span> <span class="re1">0</span>, <span class="kw2">D</span>                   <span class="co1">; Pulsada, ponemos a 1 el bit 0</span>
Control_no_up:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>FDFE
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>                   <span class="co1">; Leemos la tecla A</span>
  <span class="kw1">JR</span> NZ, Control_no_down     <span class="co1">; No pulsada, no cambianos nada en D</span>
  <span class="kw1">SET</span> <span class="re1">1</span>, <span class="kw2">D</span>                   <span class="co1">; Pulsada, ponemos a 1 el bit 1</span>
Control_no_down:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>DFFE
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>                   <span class="co1">; Leemos la tecla P</span>
  <span class="kw1">JR</span> NZ, Control_no_right    <span class="co1">; No pulsada</span>
  <span class="kw1">SET</span> <span class="nu0">2</span>, <span class="kw2">D</span>                   <span class="co1">; Pulsada, ponemos a 1 el bit 2</span>
Control_no_right:
                             <span class="co1">; BC ya vale $DFFE, (O y P en misma fila)</span>
  <span class="kw1">BIT</span> <span class="re1">1</span>, <span class="kw2">A</span>                   <span class="co1">; Tecla O</span>
  <span class="kw1">JR</span> NZ, Control_no_left
  <span class="kw1">SET</span> <span class="nu0">3</span>, <span class="kw2">D</span>
Control_no_left:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>7FFE
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>                   <span class="co1">; Tecla Espacio</span>
  <span class="kw1">JR</span> NZ, Control_no_fire
  <span class="kw1">SET</span> <span class="nu0">4</span>, <span class="kw2">D</span>
Control_no_fire:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>                    <span class="co1">; Devolvemos en A el estado de las teclas</span>
  <span class="kw1">RET</span></pre>

<p>
 El bucle principal del programa deberá llamar a esta función de lectura
 del teclado y después, con el valor devuelto en el registro A, actuar
consecuentemente de acuerdo al estado de los bits (aprovechando las
funciones de testeo de bits del Z80). De esta forma, al volver de la
llamada a esta subrutina sabremos si el usuario pretende mover el
personaje en una dirección u otra, o si ha pulsado disparo, según el
estado de los diferentes bits. La rutina que hemos visto trabaja con 5
teclas, pero todavía tenemos espacio para almacenar el estado de 3
teclas más en los bits 5, 6 y 7 del registro A.
</p>

<p>
 Con esta información sobre el teclado y las instrucciones IN y OUT,
nada os impide dotar de interacción y movimiento vuestros programas,
utilizando la lectura del teclado en menúes, acciones sobre los
personajes, etc.
</p>

<p>
 Por otra parte, el código que acabamos de ver se basa en leer las
semifilas de teclado y comprobar el estado de teclas concretas y
definidas (“hardcodeadas”) en el propio listado del programa. Esto
quiere decir que las teclas de control son fijas y no seleccionables por
 el usuario. Este es el mecanismo de “lectura de teclado” más rápido y
que menos espacio ocupa puesto que no es necesario crear rutinas para
re-definir las teclas de juego, almacenarlas en variables de memoria y
comparar el estado del teclado de los scancodes seleccionados por el
usuario.
</p>

<p>
 No obstante, una de las cosas que más agradecen los usuarios es la
posibilidad de que las teclas de control se puedan redefinir y no sean
fijas, por lo que a continuación veremos mecanismos para obtener del
usuario las teclas de control y posteriormente poder detectar su
pulsación en el transcurso de la lógica del programa o juego.
</p>

<p>
<br>

</p>

</div>

<h2 id="redefinicion-de-teclas">Redefinicion de teclas</h2>
<div class="level2">

<p>
 Hasta ahora hemos visto cómo verificar el estado de unas teclas predeterminadas
del teclado. Normalmente los juegos o programas suelen incluir la opción de
redefinir las teclas asociadas a las acciones del juego, de forma que sea el
jugador quien elija la combinación de teclas con la que se sienta más cómodo.
</p>

<p>
 Para ello necesitaremos una rutina que haga lo siguiente:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Antes de ser llamada, deberemos
llegar a ella con el mensaje apropiado en pantalla (“Pulse tecla para
ARRIBA”, por ejemplo). La rutina se dedicará sólo al escaneo del teclado
 en sí mismo, de forma que pueda ser llamada tantas veces como teclas a
redefinir. Además, tenemos que asegurarnos de  que cuando la llamamos no
 haya ninguna tecla pulsada. Para eso podemos usar la rutina
Wait_For_Keys_Released vista previamente.
</li>
<li> La rutina deberá devolver un valor
único para cada tecla pulsada, y asegurarse (o informarnos) de que no
está siendo pulsada más de una tecla simultáneamente.
</li>
<li> Dicho valor devuelto por la rutina
será almacenado para su posterior chequeo durante el juego, utilizando
una rutina que nos indique si la tecla asociada a ese “valor único” está
 siendo pulsada.
</li>
</ul>

<p>
<br>

</p>

<p>
 <em>David Webb</em> nos ofrece el siguiente conjunto de rutinas para este propósito.
Existen bastantes posibilidades de realizar esta tarea (tablas con las semifilas
y bits y sus correspondientes en <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>, modificación en tiempo real de los
opcodes que hacen los testeos, elegir entre un conjunto de combinaciones de
teclas predeterminadas, etc), pero la que nos muestra David Webb es elegante
y sencilla de utilizar.
</p>

<p>
 Consiste en escanear el teclado completo y, al detectar la pulsación de
una tecla, codificar la semifila y el bit donde se han detectado en un
mismo byte, utilizando los 3 bits más bajos para “el bit de la tecla pulsada”
y los 3 siguientes para “la semifila (puerto)” en que se ha detectado la
pulsación.
</p>
<pre class="code z80"><span class="co1">; Chequea el teclado para detectar la pulsación de una tecla.</span>
<span class="co1">; Devuelve un código en el registro D que indica:</span>
<span class="co1">;</span>
<span class="co1">;    Bits 0, 1 y 2 de "D": Fila de teclas (puerto) detectada.</span>
<span class="co1">;    Bits 3, 4 y 5 de "D": Posición de la tecla en esa media fila</span>
<span class="co1">;</span>
<span class="co1">; Así, el valor devuelto nos indica la semifila a leer y el bit a testear.</span>
<span class="co1">; El registro D valdrá 255 ($FF) si no hay ninguna tecla pulsada.</span>
<span class="co1">;</span>
<span class="co1">; Flags: ZF desactivado: Más de una tecla pulsada</span>
<span class="co1">;        ZF activado: Tecla correctamente leída</span>
Find_Key:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="sy0">$</span>FF2F         <span class="co1">; Valor inicial "ninguna tecla"</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>FEFE         <span class="co1">; Puerto</span>
&nbsp;
NXHALF:
   <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>
   <span class="kw1">CPL</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span>F
   <span class="kw1">JR</span> Z, NPRESS         <span class="co1">; Saltar si ninguna tecla pulsada</span>
&nbsp;
   <span class="kw1">INC</span> <span class="kw2">D</span>                <span class="co1">; Comprobamos si hay más de 1 tecla pulsada</span>
   <span class="kw1">RET</span> NZ               <span class="co1">; Si es así volver con Z a 0</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>              <span class="co1">; Cálculo del valor de la tecla</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>
&nbsp;
KLOOP:
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">SRL</span> <span class="kw2">H</span>
   <span class="kw1">JR</span> NC, KLOOP
&nbsp;
   <span class="kw1">RET</span> NZ               <span class="co1">; Comprobar si más de una tecla pulsada</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>              <span class="co1">; Guardar valor de tecla en D</span>
&nbsp;
NPRESS:                 <span class="co1">; Comprobar el resto de semifilas</span>
   <span class="kw1">DEC</span> <span class="kw2">E</span>
   <span class="kw1">RLC</span> <span class="kw2">B</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, NXHALF         <span class="co1">; Repetimos escaneo para otra semifila</span>
&nbsp;
   <span class="kw1">CP</span> <span class="kw2">A</span>                 <span class="co1">; Ponemos flag a zero</span>
   <span class="kw1">RET</span> Z                <span class="co1">; Volvemos</span></pre>

<p>
 La forma en que llamaríamos a esta subrutina sería la siguiente:
</p>
<pre class="code z80">  <span class="co1">;; Pedimos tecla ARRIBA</span>
  <span class="kw1">CALL</span> Imprimir_Texto_Pulse_Arriba
  <span class="kw1">CALL</span> Wait_For_Keys_Released     <span class="co1">; Esperamos teclado libre</span>
&nbsp;
Pedir_Arriba:
&nbsp;
  <span class="kw1">CALL</span> Find_Key                   <span class="co1">; Llamamos a la rutina</span>
  <span class="kw1">JR</span> NZ, Pedir_Arriba             <span class="co1">; Repetir si la tecla no es válida</span>
  <span class="kw1">INC</span> <span class="kw2">D</span>
  <span class="kw1">JR</span> Z, Pedir_Arriba              <span class="co1">; Repetir si no se pulsó ninguna tecla</span>
  <span class="kw1">DEC</span> <span class="kw2">D</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
  <span class="kw1">LD</span> <span class="br0">(</span>tecla_arriba<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
  <span class="co1">;; Pedimos siguiente tecla (ABAJO)</span>
  <span class="kw1">CALL</span> Imprimir_Texto_Pulse_Abajo
  <span class="kw1">CALL</span> Wait_For_Keys_Released     <span class="co1">; Esperamos teclado libre</span>
&nbsp;
Pedir_Abajo:
&nbsp;
  <span class="kw1">CALL</span> Find_Key                   <span class="co1">; Llamamos a la rutina</span>
  <span class="kw1">JR</span> NZ, Pedir_Abajo              <span class="co1">; Repetir si la tecla no es válida</span>
  <span class="kw1">INC</span> <span class="kw2">D</span>
  <span class="kw1">JR</span> Z, Pedir_Abajo               <span class="co1">; Repetir si no se pulsó ninguna tecla</span>
  <span class="kw1">DEC</span> <span class="kw2">D</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
  <span class="kw1">LD</span> <span class="br0">(</span>tecla_abajo<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
  <span class="co1">;;; Repetir el mismo código para IZQ, DERECHA, DISPARO, etc.</span>
&nbsp;
tecla_arriba DEFB <span class="re1">0</span>
tecla_abajo  DEFB <span class="re1">0</span></pre>

<p>
 A continuación podemos ver un <strong>ejemplo</strong> (scancode.asm) que “dibuja” en pantalla de
forma gráfica el SCANCODE que devuelve la función Find_Key:
</p>
<pre class="code z80"><span class="co1">; Visualizando los scancodes de las teclas codificadas con "Find_Key"</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
Bucle_entrada:
  <span class="kw1">CALL</span> Wait_For_Keys_Released
&nbsp;
Pedir_Tecla:
  <span class="kw1">CALL</span> Find_Key                   <span class="co1">; Llamamos a la rutina</span>
  <span class="kw1">JR</span> NZ, Pedir_Tecla              <span class="co1">; Repetir si la tecla no es valida</span>
  <span class="kw1">INC</span> <span class="kw2">D</span>
  <span class="kw1">JR</span> Z, Pedir_Tecla               <span class="co1">; Repetir si no se pulsa ninguna tecla</span>
  <span class="kw1">DEC</span> <span class="kw2">D</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>                         <span class="co1">; Guardamos en A copia del resultado</span>
  <span class="kw1">CALL</span> PrintBin                   <span class="co1">; Imprimimos el scancode bin en pantalla</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>                         <span class="co1">; Guardamos en A copia del resultado</span>
  <span class="kw1">CALL</span> PrintHex                   <span class="co1">; Imprimimos el scancode hex en pantalla</span>
&nbsp;
  <span class="kw1">CP</span> <span class="sy0">$</span>2<span class="re1">1</span>                          <span class="co1">; Comprobamos si A == 21h (enter)</span>
  <span class="kw1">JR</span> NZ, Bucle_entrada            <span class="co1">; Si no lo es, repetir</span>
&nbsp;
  <span class="kw1">RET</span>                             <span class="co1">; Si es enter, fin del programa</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; PrintBin: Imprime en la pantalla un patron para visualizar el valor</span>
<span class="co1">; de A en binario, usando 8 pixels "puros" para "1" y punteados para "0"</span>
<span class="co1">;</span>
<span class="co1">; Entrada: A = valor a "imprimir" en binario</span>
<span class="co1">;-----------------------------------------------------------------------</span>
PrintBin:
  <span class="kw1">PUSH</span> <span class="kw2">AF</span>
  <span class="kw1">PUSH</span> <span class="kw2">HL</span>
  <span class="kw1">PUSH</span> <span class="kw2">BC</span>                            <span class="co1">; Preservamos los registros que se usarÃ¡</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">2</span><span class="re1">0</span><span class="nu0">7</span><span class="re1">0</span><span class="nu0">4</span>                       <span class="co1">; Esquina (0,24) de la pantalla</span>
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>                            <span class="co1">; Guardamos en C copia de A</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                            <span class="co1">; Imprimiremos el estado de los 8 bits</span>
&nbsp;
printbin_loop:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>FF                          <span class="co1">; Para bit = 1, todo negro</span>
  <span class="kw1">BIT</span> <span class="nu0">7</span>, <span class="kw2">C</span>                           <span class="co1">; Chequeamos el estado del bit 7</span>
  <span class="kw1">JR</span> NZ, printbin_es_uno             <span class="co1">; Dejamos A = 255</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>55                          <span class="co1">; Para bit = 0, punteado/gris</span>
&nbsp;
printbin_es_uno:
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                         <span class="co1">; Lo "imprimimos" (A) y pasamos a la</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>                             <span class="co1">; Siguiente posiciÃ³ en memoria</span>
  <span class="kw1">RLC</span> <span class="kw2">C</span>                              <span class="co1">; Rotamos C a la izq para que podamos</span>
                                     <span class="co1">; usar de nuevo el BIT 7 en el bucle</span>
  <span class="kw1">DJNZ</span> printbin_loop                 <span class="co1">; Repetimos 8 veces</span>
&nbsp;
  <span class="kw1">POP</span> <span class="kw2">BC</span>
  <span class="kw1">POP</span> <span class="kw2">HL</span>
  <span class="kw1">POP</span> <span class="kw2">AF</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; PrintHex: Imprime en la pantalla un numero de 1 byte en hexadecimal.</span>
<span class="co1">;        Para ello convierte el valor numérico en una cadena llamando</span>
<span class="co1">;        a Byte2ASCII_Hex y luego llama a RST 16 para imprimir cada</span>
<span class="co1">;        caracter por separado. Imprime un $ delante y ESPACIO detrás.</span>
<span class="co1">;</span>
<span class="co1">; Entrada: A = valor a "imprimir" en binario</span>
<span class="co1">;-----------------------------------------------------------------------</span>
PrintHex:
  <span class="kw1">PUSH</span> <span class="kw2">HL</span>
  <span class="kw1">PUSH</span> <span class="kw2">AF</span>
  <span class="kw1">PUSH</span> <span class="kw2">DE</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
  <span class="kw1">CALL</span> Byte2ASCII_Hex            <span class="co1">; Convertimos A en Cadena HEX</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, Byte2ASCII_output       <span class="co1">; HL apunta a la cadena</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">"$"</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>                         <span class="co1">; Imprimimos un "$"</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>                         <span class="co1">; Imprimimos primer valor HEX</span>
&nbsp;
  <span class="kw1">INC</span> <span class="kw2">HL</span>                         <span class="co1">; Avanzar en la cadena</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>                         <span class="co1">; Imprimimos segundo valor HEX</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">" "</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>                         <span class="co1">; Imprimimos un espacio</span>
&nbsp;
  <span class="kw1">POP</span> <span class="kw2">DE</span>
  <span class="kw1">POP</span> <span class="kw2">AF</span>
  <span class="kw1">POP</span> <span class="kw2">HL</span>
&nbsp;
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Byte2ASCII_Hex: Convierte el valor del registro H en una cadena</span>
<span class="co1">; de texto de max. 2 caracteres hexadecimales, para poder imprimirla.</span>
<span class="co1">; Rutina adaptada de Num2Hex en http://baze.au.com/misc/z80bits.html .</span>
<span class="co1">;</span>
<span class="co1">; IN:   H = Numero a convertir</span>
<span class="co1">; OUT:  [Byte2ASCII_output] = Espacio de 2 bytes con los ASCIIs</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Byte2ASCII_Hex:
&nbsp;
   <span class="kw1">ld</span> <span class="kw2">de</span>, Byte2ASCII_output
   <span class="kw1">ld</span> <span class="kw2">a</span>, <span class="kw2">h</span>
   <span class="kw1">call</span> B2AHex_Num<span class="re1">1</span>
   <span class="kw1">ld</span> <span class="kw2">a</span>, <span class="kw2">h</span>
   <span class="kw1">call</span> B2AHex_Num2
   <span class="kw1">ret</span>
&nbsp;
B2AHex_Num<span class="re1">1</span>:
   <span class="kw1">rra</span>
   <span class="kw1">rra</span>
   <span class="kw1">rra</span>
   <span class="kw1">rra</span>
&nbsp;
B2AHex_Num2:
   <span class="kw1">or</span> <span class="sy0">$</span>F<span class="re1">0</span>
   <span class="kw1">daa</span>
   <span class="kw1">add</span> <span class="kw2">a</span>, <span class="sy0">$</span>A<span class="re1">0</span>
   <span class="kw1">adc</span> <span class="kw2">a</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">ld</span> <span class="br0">(</span><span class="kw2">de</span><span class="br0">)</span>, <span class="kw2">a</span>
   <span class="kw1">inc</span> <span class="kw2">de</span>
   <span class="kw1">ret</span>
&nbsp;
Byte2ASCII_output DB <span class="re1">0</span>, <span class="re1">0</span>
<span class="co1">;-----------------------------------------------------------------------</span>
&nbsp;
<span class="co1">; Debemos incluir, además, el código de Wait_For_Keys_Released y</span>
<span class="co1">; de Find_Key dentro de este ejemplo para que ensamble correctamente.</span>
&nbsp;
<span class="co1">; Nota: recuerda que acabando el programa con END 50000 no sería necesario</span>
<span class="co1">; ejecutarlo manualmente con randomize usr 50000 al ensamblarlo con PASMO.</span></pre>

<p>
 Este ejemplo proporcionará en pantalla (hasta que se pulse ENTER)
una salida como la siguiente:
</p>

<p>
<br>

<img src="img/scancode.png" class="mediacenter" alt="Representación binaria de las teclas pulsadas"/>
<br>

</p>

<p>
 Mediante Byte2ASCII_Hex convertimos el scancode en una cadena de 2
caracteres, que imprimimos en pantalla con PrintHex. Esta función,
PrintHex, hace uso de la RST 16 para trazar caracteres por pantalla en
la posición actual del cursor.
</p>

<p>
 Por otra parte, se incluye una rutina PrintBin para mostrar el estado
de los diferentes bits del valor del scancode mediante pixeles
“encendidos” y “apagados”. Como véis, la rutina PrintBin es una forma
rudimentaria de mostrar en
pantalla el valor del registro A en binario. Lo que muestra es una
representación
gráfica binaria de las teclas pulsadas.
</p>

<p>
 Los scancodes asociados a las diferentes teclas son:
</p>
<div class="table-responsive sectionedit12"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Teclas: </th><th class="col1"> 1 </th><th class="col2"> 2 </th><th class="col3"> 3 </th><th class="col4"> 4 </th><th class="col5"> 5 </th><th class="col6"> 6 </th><th class="col7"> 7 </th><th class="col8"> 8 </th><th class="col9"> 9 </th><th class="col10"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<th class="col0"> Scancodes: </th><td class="col1"> $24 </td><td class="col2"> $1C </td><td class="col3"> $14 </td><td class="col4"> $0C </td><td class="col5"> $04 </td><td class="col6"> $03 </td><td class="col7"> $0B </td><td class="col8"> $13 </td><td class="col9"> $1B </td><td class="col10"> $23 </td>
	</tr>
</tbody></table></div>
<div class="table-responsive sectionedit13"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Teclas: </th><th class="col1"> Q </th><th class="col2"> W </th><th class="col3"> E </th><th class="col4"> R </th><th class="col5"> T </th><th class="col6"> Y </th><th class="col7"> U </th><th class="col8"> I </th><th class="col9"> O </th><th class="col10"> P </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<th class="col0"> Scancodes: </th><td class="col1"> $25 </td><td class="col2"> $1D </td><td class="col3"> $15 </td><td class="col4"> $0D </td><td class="col5"> $05 </td><td class="col6"> $02 </td><td class="col7"> $0A </td><td class="col8"> $12 </td><td class="col9"> $1A </td><td class="col10"> $22 </td>
	</tr>
</tbody></table></div>
<div class="table-responsive sectionedit14"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Teclas: </th><th class="col1"> A </th><th class="col2"> S </th><th class="col3"> D </th><th class="col4"> F </th><th class="col5"> G </th><th class="col6"> H </th><th class="col7"> J </th><th class="col8"> K </th><th class="col9"> L </th><th class="col10"> ENTER </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<th class="col0"> Scancodes: </th><td class="col1"> $26 </td><td class="col2"> $1E </td><td class="col3"> $16 </td><td class="col4"> $0E </td><td class="col5"> $06 </td><td class="col6"> $01 </td><td class="col7"> $09 </td><td class="col8"> $11 </td><td class="col9"> $19 </td><td class="col10 centeralign">  $21  </td>
	</tr>
</tbody></table></div>
<div class="table-responsive sectionedit15"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Teclas: </th><th class="col1"> CAPS </th><th class="col2"> Z </th><th class="col3"> X </th><th class="col4"> C </th><th class="col5"> V </th><th class="col6"> B </th><th class="col7"> N </th><th class="col8"> M </th><th class="col9"> SYMB </th><th class="col10"> SPACE </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<th class="col0"> Scancodes: </th><td class="col1 centeralign">  $27  </td><td class="col2"> $1F </td><td class="col3"> $17 </td><td class="col4"> $0F </td><td class="col5"> $07 </td><td class="col6"> $00 </td><td class="col7"> $08 </td><td class="col8"> $10 </td><td class="col9 centeralign">  $18  </td><td class="col10 centeralign">  $20  </td>
	</tr>
</tbody></table></div>

<p>
 Estos valores nos serán necesarios si queremos establecer unos scancodes por
defecto para las teclas del programa, de forma que si el usuario no las
redefine, tengan unos valores de comprobación determinados para la rutina
de chequeo que veremos a continuación.
</p>

<p>
<br>

</p>

</div>

<h2 id="chequeando-las-teclas-redefinidas">Chequeando las teclas redefinidas</h2>
<div class="level2">

<p>
 Llegados a este punto tenemos una función que nos devuelve un
“scancode”
propio (creado a nuestra medida) de una tecla pulsada. De esta forma,
podemos
almacenar en variables de memoria (por ejemplo: “tecla_arriba DEFB 0”)
los
valore que nos devuelve dicha función. En lugar de dar a estas variables
 un valor de 0 por defecto, tenemos una tabla de “scancodes” que nos
permitiría definir unas “teclas iniciales” como:
</p>
<pre class="code z80">tecla_arriba  DEFB  <span class="sy0">$</span>25
tecla_abajo   DEFB  <span class="sy0">$</span>26
tecla_izq     DEFB  <span class="sy0">$</span><span class="re1">1</span>A
tecla_der     DEFB  <span class="sy0">$</span>22
tecla_disp    DEFB  <span class="sy0">$</span>2<span class="re1">0</span></pre>

<p>
 Dichos valores podrán ser modificados (o no) por la rutina de redefinición
del teclado.
</p>

<p>
 Lo único que nos falta para un control total del teclado en nuestro juego
sería una rutina que reciba un scancode y nos indique si dicho scancode
está pulsado o no. De esta forma, llamaríamos a la rutina 5 veces, poniendo
el valor de las diferentes teclas (tecla_arriba, tecla_abajo, etc.) en el
registro A antes de cada llamada, para conocer el estado de las mismas.
</p>

<p>
 Llamaremos a esta rutina Check_Key:
</p>
<pre class="code z80"><span class="co1">; Chequea el estado de una tecla concreta, aquella de scancode</span>
<span class="co1">; codificado en A (como parametro de entrada).</span>
<span class="co1">;</span>
<span class="co1">; Devuelve:    CARRY FLAG = 0 -&gt; Tecla pulsada</span>
<span class="co1">;              CARRY FLAG = 1 y BC = 0 -&gt; Tecla no pulsada</span>
<span class="co1">;</span>
Check_Key:
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; Copia de A</span>
&nbsp;
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>          <span class="co1">; B = 16 - (num. linea dirección)</span>
&nbsp;
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">5</span>
   <span class="kw1">SUB</span> <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; C = (semifila + 1)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>FE
&nbsp;
CKHiFind:           <span class="co1">; Calcular el octeto de mayor peso del puerto</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">DJNZ</span> CKHiFind
&nbsp;
   <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>      <span class="co1">; Leemos la semifila</span>
&nbsp;
CKNXKey:
   <span class="kw1">RRA</span>
   <span class="kw1">DEC</span> <span class="kw2">C</span>
   <span class="kw1">JR</span> NZ, CKNXKey   <span class="co1">; Ponemos el bit de tecla en el CF</span>
&nbsp;
   <span class="kw1">RET</span>   </pre>

<p>
 La forma en que se debe llamar a esta rutina sería la siguiente:
</p>
<pre class="code z80">Comprobar_tecla_izquierda:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>teclaizq<span class="br0">)</span>
  <span class="kw1">CALL</span> Check_Key
  <span class="kw1">JR</span> <span class="kw2">C</span>, izq_no_pulsada            <span class="co1">; Carry = 1, tecla no pulsada</span>
&nbsp;
  <span class="br0">(</span>acciones <span class="kw2">a</span> realizar si se pulso izq<span class="br0">)</span>
&nbsp;
izq_no_pulsada:
&nbsp;
Comprobar_tecla_derecha:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>teclader<span class="br0">)</span>
  <span class="kw1">CALL</span> Check_Key
  <span class="kw1">JR</span> <span class="kw2">C</span>, der_no_pulsada            <span class="co1">; Carry = 1, tecla no pulsada</span>
&nbsp;
  <span class="br0">(</span>acciones <span class="kw2">a</span> realizar si se pulso der<span class="br0">)</span>
&nbsp;
<span class="co1">; Repetir para arriba, abajo, disparo, etc.</span></pre>

<p>
 También podemos generar una rutina que combine lo que acabamos de ver
con la codificación de las direcciones en los 5 bits de un único byte,
de la misma forma que lo realizamos con teclas predefinidas.
</p>

<p>
 Por supuesto, estas rutinas son sólo de ejemplo y pueden ser modificadas
para que devuelvan los resultados en otros flags (Zero, Carry), en otros
registros, sean llamadas con diferentes parámetros, etc.
</p>

<p>
 Veamos a continuación un ejemplo final que permite modificar el valor
de una variable en memoria (“valor”) mediante las teclas Q y A (sumando o
restando 1 a su valor de 8 bits). Cada vez que el valor de la variable
cambie, se mostrará en pantalla con nuestra la sencilla rutina PrintBin.
</p>
<pre class="code z80">  <span class="co1">; Controlando el valor de "valor" con Q y A</span>
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>valor<span class="br0">)</span>
  <span class="kw1">CALL</span> PrintBin                   <span class="co1">; Imprimimos el scancode en pantalla</span>
&nbsp;
Bucle_entrada:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">2</span><span class="re1">0000</span>                    <span class="co1">; Retardo (bucle 20000 iteraciones)</span>
retardo:
  <span class="kw1">DEC</span> <span class="kw2">BC</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
  <span class="kw1">OR</span> <span class="kw2">C</span>
  <span class="kw1">JR</span> NZ, retardo                  <span class="co1">; Fin retardo</span>
&nbsp;
Comprobar_tecla_mas:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>tecla_mas<span class="br0">)</span>
  <span class="kw1">CALL</span> Check_Key
  <span class="kw1">JR</span> <span class="kw2">C</span>, mas_no_pulsado            <span class="co1">; Carry = 1, tecla_mas no pulsada</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>valor<span class="br0">)</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>valor<span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Incrementamos (valor)</span>
  <span class="kw1">JR</span> Print_Valor
&nbsp;
mas_no_pulsado:
&nbsp;
Comprobar_tecla_menos:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>tecla_menos<span class="br0">)</span>
  <span class="kw1">CALL</span> Check_Key
  <span class="kw1">JR</span> <span class="kw2">C</span>, menos_no_pulsado          <span class="co1">; Carry = 1, tecla_menos no pulsada</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>valor<span class="br0">)</span>
  <span class="kw1">DEC</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>valor<span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Decrementamos (valor)</span>
  <span class="kw1">JR</span> Print_Valor
&nbsp;
menos_no_pulsado:
&nbsp;
  <span class="kw1">JR</span> Bucle_entrada                <span class="co1">; Repetimos continuamente hasta que se</span>
                                  <span class="co1">; pulse algo (tecla_mas o tecla_menos)</span>
&nbsp;
Print_Valor:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>valor<span class="br0">)</span>                   <span class="co1">; Guardamos en A copia del resultado</span>
  <span class="kw1">CALL</span> PrintBin                   <span class="co1">; Imprimimos el scancode en pantalla</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>valor<span class="br0">)</span>                   <span class="co1">; Guardamos en A copia del resultado</span>
  <span class="kw1">CALL</span> PrintHex                   <span class="co1">; Imprimimos el scancode HEX en pantalla</span>
&nbsp;
  <span class="kw1">JR</span> Bucle_entrada                <span class="co1">; Repetimos</span>
&nbsp;
valor        DEFB  <span class="re1">0</span>
tecla_mas    DEFB  <span class="sy0">$</span>25
tecla_menos  DEFB  <span class="sy0">$</span>26
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Chequea el estado de una tecla concreta, aquella de scancode</span>
<span class="co1">; codificado en A (como parametro de entrada).</span>
<span class="co1">;</span>
<span class="co1">; Devuelve:    CARRY FLAG = 0 -&gt; Tecla pulsada</span>
<span class="co1">;              CARRY FLAG = 1 y BC = 0 -&gt; Tecla no pulsada</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Check_Key:
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; Copia de A</span>
&nbsp;
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>          <span class="co1">; B = 16 - (num. linea direcció</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">5</span>
   <span class="kw1">SUB</span> <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; C = (semifila + 1)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>FE
&nbsp;
CKHiFind:           <span class="co1">; Calcular el octeto de mayor peso del puerto</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">DJNZ</span> CKHiFind
&nbsp;
   <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>      <span class="co1">; Leemos la semifila</span>
&nbsp;
CKNXKey:
   <span class="kw1">RRA</span>
   <span class="kw1">DEC</span> <span class="kw2">C</span>
   <span class="kw1">JR</span> NZ, CKNXKey   <span class="co1">; Ponemos el bit de tecla en el CF</span>
&nbsp;
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;; Nota: Incluir en el código las siguientes rutinas para re-ensamblarlo:</span>
<span class="co1">;;       Wait_For_Keys_Released, PrintBin, PrintHex y Byte2ASCII_Hex.</span>
&nbsp;
 END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 Queda como ejercicio para el lector la modificación del programa para que,
antes de entrar en el bucle principal, lea 2 teclas válidas y diferentes
del teclado para permitir la redefinición de “<em>tecla_mas</em>” y “<em>tecla_menos</em>”
con respecto a sus valores por defecto.
</p>

<p>
<br>

</p>

</div>

<h2 id="redefinicion-de-las-teclas">Redefinición de las teclas</h2>
<div class="level2">

<p>
 En las secciones anteriores hemos visto las rutinas Find_Key y
Check_Key para detectar las pulsaciones de teclas y chequear el estado
de una tecla concreta. Estas teclas concretas las guardamos en variables
 de memoria y así podemos permitir al jugador redefinirlas.
</p>

<p>
 El menú principal deberá de tener una opción que permita modificar el
contenido de estas variables de memoria con aquellos scancodes que el
jugador elija para controlar el juego.
</p>

<p>
 El sistema de redefinición de teclas debe:
</p>

<p>
A.- Establecer en el arranque del programa unos valores por defecto para las teclas:
</p>
<pre class="code z80">tecla_arriba   DEFB  <span class="sy0">$</span>25
tecla_abajo    DEFB  <span class="sy0">$</span>26
tecla_izq      DEFB  <span class="sy0">$</span><span class="re1">1</span>A
tecla_der      DEFB  <span class="sy0">$</span>22
tecla_disp     DEFB  <span class="sy0">$</span>2<span class="re1">0</span></pre>

<p>
B.- Repetir N veces (uno por cada control a redefinir):
</p>
<ul class="fix-media-list-overlap">
<li> Esperar a que ninguna tecla del
teclado esté pulsada (para evitar que la tecla de selección del menú
para entrar en la redefinición, o la anterior tecla pulsada, se
seleccione como tecla pulsada por el usuario).
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Mostrar por pantalla el mensaje de “Pulse una tecla para (dirección a redefinir)”.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Esperar una pulsación de teclado del usuario.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Opcionalmente, comprobar que esa
pulsación no se corresponda con ninguna de las teclas anteriores, para
evitar que el usuario seleccione la misma dirección para, por ejemplo,
izquierda y derecha. Este paso es opcional porque el usuario, si se
equivoca, siempre puede redefinir de nuevo el teclado con las teclas
adecuadas, y para nosotros esta comprobación representa tiempo de
programación y espacio ocupado innecesariamente en el programa.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> Mostrar al usuario la tecla que ha
pulsado a la derecha del mensaje impreso pidiendo dicha tecla. Para eso
tenemos que convertir el Scancode en un código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> imprimible en pantalla.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Modificar la variable en memoria que
 deba almacenar el scancode de la tecla pulsada para poder usarla
posteriormente en el transcurso del juego (es decir, guardar el scancode
 obtenido en tecla_arriba, tecla_abajo, tecla_izq, o en la variable que
corresponda).
</li>
</ul>

<p>
 Hasta ahora tenemos todos los mecanismos necesarios para crear nuestra
propia rutina de redefinición de teclas, salvo la rutina para convertir
un scancode en su correspondiente <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>. A continuación tenemos una rutina Scancode2Ascii basada en una tabla que relaciona cada scancode con su <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> (40 bytes más adelante en la misma tabla):
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Scancode2Ascii: convierte un scancode en un valor ASCII</span>
<span class="co1">; IN:  D = scancode de la tecla a analizar</span>
<span class="co1">; OUT: A = Codigo ASCII de la tecla</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Scancode2Ascii:
&nbsp;
   <span class="kw1">push</span> <span class="kw2">hl</span>
   <span class="kw1">push</span> <span class="kw2">bc</span>
&nbsp;
   <span class="kw1">ld</span> <span class="kw2">hl</span>,<span class="re1">0</span>
   <span class="kw1">ld</span> <span class="kw2">bc</span>, TABLA_S2ASCII
   <span class="kw1">add</span> <span class="kw2">hl</span>, <span class="kw2">bc</span>           <span class="co1">; hl apunta al inicio de la tabla</span>
&nbsp;
   <span class="co1">; buscamos en la tabla un max de 40 veces por el codigo</span>
   <span class="co1">; le sumamos 40 a HL, leemos el valor de (HL) y ret A</span>
SC2Ascii_<span class="re1">1</span>:
   <span class="kw1">ld</span> <span class="kw2">a</span>, <span class="br0">(</span><span class="kw2">hl</span><span class="br0">)</span>           <span class="co1">; leemos un byte de la tabla</span>
   <span class="kw1">cp</span> <span class="st0">"1"</span>               <span class="co1">; Si es "1" fin de la rutina (porque en</span>
                        <span class="co1">; (la tabla habriamos llegado a los ASCIIs)</span>
   <span class="kw1">jr</span> z, SC2Ascii_Exit  <span class="co1">; (y es condicion de forzado de salida) </span>
   <span class="kw1">inc</span> <span class="kw2">hl</span>               <span class="co1">; incrementamos puntero de HL</span>
   <span class="kw1">cp</span> <span class="kw2">d</span>                 <span class="co1">; comparamos si A==D (nuestro scancode)</span>
   <span class="kw1">jr</span> nz, SC2Ascii_<span class="re1">1</span>
&nbsp;
SC2Ascii_Found:
   <span class="kw1">ld</span> <span class="kw2">bc</span>, <span class="nu0">39</span>            <span class="co1">; Sumamos 39(+INC HL=40) para ir a la seccion</span>
   <span class="kw1">add</span> <span class="kw2">hl</span>, <span class="kw2">bc</span>           <span class="co1">; de la tabla con los codigos ASCII</span>
   <span class="kw1">ld</span> <span class="kw2">a</span>,<span class="br0">(</span><span class="kw2">hl</span><span class="br0">)</span>            <span class="co1">; leemos el codigo ASCII de esa tabla</span>
&nbsp;
SC2Ascii_Exit:
   <span class="kw1">pop</span> <span class="kw2">bc</span>
   <span class="kw1">pop</span> <span class="kw2">hl</span>
   <span class="kw1">ret</span>
&nbsp;
   <span class="co1">; 40 scancodes seguidos de sus ASCIIs equivalentes</span>
TABLA_S2ASCII:
   defb <span class="sy0">$</span>24, <span class="sy0">$</span><span class="re1">1</span>C, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">4</span>, <span class="sy0">$</span><span class="re1">0</span>C, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">4</span>, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">3</span>, <span class="sy0">$</span><span class="re1">0B</span>, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">3</span>, <span class="sy0">$</span><span class="re1">1B</span>, <span class="sy0">$</span>23
   defb <span class="sy0">$</span>25, <span class="sy0">$</span><span class="re1">1</span>D, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">5</span>, <span class="sy0">$</span><span class="re1">0</span>D, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">5</span>, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>, <span class="sy0">$</span><span class="re1">0</span>A, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">2</span>, <span class="sy0">$</span><span class="re1">1</span>A, <span class="sy0">$</span>22
   defb <span class="sy0">$</span>26, <span class="sy0">$</span><span class="re1">1</span>E, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">6</span>, <span class="sy0">$</span><span class="re1">0</span>E, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">6</span>, <span class="sy0">$</span><span class="re1">01</span>, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">9</span>, <span class="sy0">$</span><span class="re1">11</span>, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">9</span>, <span class="sy0">$</span>2<span class="re1">1</span>
   defb <span class="sy0">$</span>27, <span class="sy0">$</span><span class="re1">1</span>F, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">7</span>, <span class="sy0">$</span><span class="re1">0</span>F, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">7</span>, <span class="sy0">$</span><span class="re1">00</span>, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">8</span>, <span class="sy0">$</span><span class="re1">10</span>, <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>, <span class="sy0">$</span>2<span class="re1">0</span>
   defm <span class="st0">"1234567890QWERTYUIOPASDFGHJKLecZXCVBNMys"</span></pre>

<p>
 La rutina recibe en el registro D el scancode obtenido con la rutina Find_Key y devuelve en el registro A el código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>
 correspondiente directamente imprimible. Los primeros 40 bytes de la
tabla contienen los Scancodes y la última línea defm (últimos 40 bytes)
los ASCIIs a los que corresponden, en orden, los anterior 40 códigos.
</p>

<p>
 Nótese que las teclas se devuelven como ASCIIs en mayúsculas,
aprovechando las letras minúsculas para los caracteres especiales no
directamente representables:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> e = ENTER
</li>
<li> c = CAPS SHIFT
</li>
<li> y = SYMBOL SHIFT
</li>
<li> s = SPACE
</li>
</ul>

<p>
<br>

</p>

<p>
 De esta forma, “E” se corresponde a la tecla E y “e” a la tecla de
ENTER. Podemos utilizar estos ASCIIs en minúsculas para mostrar en
pantalla cadenas como “ENTER” o “SPACE” durante la redefinición de las
teclas.
</p>

<p>
 A continuación podemos ver un ejemplo que utiliza las rutinas Find_Key y Scancode2Ascii para mostrar en pantalla el código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> de cualquier tecla pulsada:
</p>
<pre class="code z80"><span class="co1">;--------------------------------------------------------------</span>
<span class="co1">; Prueba de conversion de Scancode a ASCII</span>
<span class="co1">; Recuerda que para compilarla necesitarás añadir las rutinas</span>
<span class="co1">; Find_Key y Scancode2ASCII a este listado, se han eliminado</span>
<span class="co1">; del mismo para reducir la longitud del programa.</span>
<span class="co1">;--------------------------------------------------------------</span>
&nbsp;
ORG <span class="nu0">32768</span>
&nbsp;
START:
  <span class="kw1">CALL</span> Wait_For_Keys_Released
&nbsp;
chequear_teclas:
  <span class="kw1">CALL</span> Find_Key                   <span class="co1">; Llamamos a la rutina</span>
  <span class="kw1">JR</span> NZ, chequear_teclas          <span class="co1">; Repetir si la tecla no es válida</span>
  <span class="kw1">INC</span> <span class="kw2">D</span>
  <span class="kw1">JR</span> Z, chequear_teclas           <span class="co1">; Repetir si no se pulsó ninguna tecla</span>
  <span class="kw1">DEC</span> <span class="kw2">D</span>
&nbsp;
  <span class="co1">; En este punto D es un scancode valido </span>
  <span class="kw1">call</span> Scancode2Ascii
&nbsp;
  <span class="co1">; En este punto A contiene el ASCII del scancode en D</span>
  <span class="co1">; lo imprimimos por pantalla con rst 16.</span>
  <span class="kw1">rst</span> <span class="re1">1</span><span class="nu0">6</span>
&nbsp;
  <span class="kw1">CALL</span> Wait_For_Keys_Released
  <span class="kw1">jr</span> START                        <span class="co1">; vuelta a empezar</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Esta rutina espera a que no haya ninguna tecla pulsada para volver.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Released:
 <span class="kw1">XOR</span> <span class="kw2">A</span>
 <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>
 <span class="kw1">OR</span> <span class="nu0">224</span>
 <span class="kw1">INC</span> <span class="kw2">A</span>
 <span class="kw1">JR</span> NZ, Wait_For_Keys_Released
 <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">;--- Introducir aquí las rutinas Find_Keys y Scancode2ASCII ------------</span>
<span class="co1">;-----------------------------------------------------------------------</span>
&nbsp;
END <span class="nu0">32768</span></pre>

<p>
 Una vez en ejecución y tras pulsar múltiples teclas, este es el aspecto del programa anterior:
</p>

<p>
<br>

<img src="img/sc2ascii.png" class="mediacenter" alt="Conversión de Scancode a ASCII"/>
<br>

</p>

<p>
<br>

</p>

</div>

<h2 id="issue-2-vs-issue-3">ISSUE 2 vs ISSUE 3</h2>
<div class="level2">

<p>
 Una recomendación a la hora de verificar el estado de las teclas es que
 utilicemos las herramientas de que nos provee el Z80 para testear los
bits del valor devuelto por IN, en lugar de, simplemente tratar de
comparar el valor del estado del teclado con algún valor predefinido.
Esto evitará que nuestro programa funcione de forma diferente en
Spectrums con teclado ISSUE 2, ISSUE 3, o con algún periférico
conectado.
</p>

<p>
 Si alguna vez has cargado un snapshot de algún juego en un emulador y
has visto que el personaje se movía “sólo”, como si alguien estuviera
pulsando teclas que realmente no están pulsadas (por ejemplo, Abu Simbel
 Profanation), y has tenido que activar la opción “ISSUE 2 KEYBOARD
EMULATION” para que funcione adecuadamente, entonces ya has sufrido los
efectos de una incorrecta lectura del teclado.
</p>

<p>
 Ahora mismo veremos por qué, y empezaremos para ello recordando uno de los primeros párrafos de esta entrega:
</p>

<p>
<em> Así, leyendo del puerto 63486 obtenemos un byte cuyos 8 bits tienen
 como significado el estado de cada una de las teclas de la semifila
del “1” al “5”. </em>
</p>
<div class="table-responsive sectionedit19"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bits: </th><th class="col1"> D7 </th><th class="col2"> D6 </th><th class="col3"> D5 </th><th class="col4"> D4 </th><th class="col5"> D3 </th><th class="col6"> D2 </th><th class="col7"> D1 </th><th class="col8"> D0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Teclas: </td><td class="col1"> XX </td><td class="col2"> XX </td><td class="col3"> XX </td><td class="col4"> “5” </td><td class="col5"> “4” </td><td class="col6"> “3” </td><td class="col7"> “2” </td><td class="col8"> “1” </td>
	</tr>
</tbody></table></div>

<p>
 Con esta información “rescatada”, volvamos al punto en que estábamos: A
 la hora de comprobar si la tecla “2” está pulsada, lo recomendable es
testear (por ejemplo, con el nmemónico *BIT*), el bit 1 del valor
devuelto por un IN del puerto 63486. Recordemos que dicho bit valdrá 0
si la tecla está pulsada, y 1 si no lo está.
</p>

<p>
 Teniendo en cuenta que un bit a “1” significa tecla no pulsada y “0”
significa pulsada, si en nuestro teclado no está pulsada ninguna tecla
del 1 al 5, los últimos 5 bits del valor leído del puerto serán
“11111b”, y que si está pulsada la tecla “2”, tendremos “11101b”.
</p>

<p>
 Viendo esto, podría surgirnos la tentación de utilizar COMPARACIONES
para chequear el estado de la tecla “2”. Pulsamos “2” en nuestro
Spectrum, leemos el valor del puerto, y obtenemos 253 (“11111101b”), con
 lo cual basamos el chequeo de teclas de nuestro programa en cosas como
el siguiente pseudocódigo:
</p>
<pre class="code"> valor = IN(63486)
 SI valor == 253 ENTONCES: TECLA_DOS_PULSADA</pre>

<p>
 Comparando con 253 (11111101b), estamos asumiendo que los bits D7, D6 y
 D5 valen siempre 1, porque en *nuestro* Spectrum es así, pero … ¿Qué
valor tienen los bits D7, D6 y D5? La realidad es que la gran mayoría de
 las veces será, efectivamente, 1, pero este valor puede verse alterado
si tenemos determinados periféricos hardware conectados al bus de
expansión trasero, e incluso existen unos determinados modelos de placas
 (ISSUE 2) que contienen otros valores en estos bits.
</p>

<p>
 Uno de los componentes del grupo <em>Mojon Twins</em>, na_th_an, nos proporciona a través de su blog la siguiente prueba de concepto BASIC:
<br>

</p>

<p>
<em>Una ligera prueba en Spectaculator, que puede configurarse para que
use el teclado de issue 2, nos da los valores que buscamos para los bits
 que desconocemos. Sólo tenemos que teclear y ejecutar este pequeño
programa, y fijarnos como normalmente obtenemos 253 y 254 (255 sin
pulsar nada) para las pulsaciones de O y P, respectivamente, y otros
valores diferentes si activamos el teclado issue 2 en las opciones del
emulador:</em>
</p>
<pre class="code basic">10 PRINT AT 0,0; IN 57342; " "
20 GOTO 10</pre>

<p>
<em>Los valores que obtenemos para estas pulsaciones son 189 y 190 (con
191 sin pulsar), lo que significa que los bits desconocidos son nada más
 y nada menos que XXX = 101. Podremos garantizar que nuestro programa
funcionará en todos los Spectrum si comparamos siempre con ambos valores
 (por ejemplo, para detectar O deberíamos mirar si IN 57342=253 OR IN
57342=189).</em>
</p>

<p>
 La solución que Na_th_an nos expone en el párrafo anterior está
orientada a la creación de programas en BASIC, dado que la variante “ZX
Spectrum” de este lenguaje no dispone de operaciones de testeo de bits,
pero en nuestro caso, en ensamblador, la mejor opción para leer una
tecla (pongamos “P” en el siguiente ejemplo) sería:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>DF            <span class="co1">; Semifila "P" a "Y"</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>          <span class="co1">; Leemos el puerto</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>             <span class="co1">; Testeamos el bit 0</span>
  <span class="kw1">JR</span> Z, pulsado        <span class="co1">; Si esta a 0 (pulsado) salir.</span></pre>

<p>
<br>

</p>

</div>

<h2 id="curiosidades-con-el-teclado">Curiosidades con el teclado</h2>
<div class="level2">

<p>
 1.- Debido al diseño del Spectrum, existen combinaciones de teclas que siendo pulsadas
simultáneamente no permiten la detección de teclas adicionales en la misma u otras
filas. A la hora de definir unas teclas por defecto, deberemos de realizar pruebas
con nuestro programa para asegurarnos de que podemos pulsar todas las combinaciones
de teclas elegidas.
</p>

<p>
 2.- Aparte, existen al menos 4 combinaciones de teclas que producen el mismo efecto
que pulsar la tecla BREAK:
</p>
<pre class="code"> CAPS SHIFT + Z + SYMBOL SHIFT
 CAPS SHIFT + X + M
 CAPS SHIFT + C + N
 CAPS SHIFT + V + B</pre>

<p>
 3.- Para los casos en los cuales queramos comprobar sólo el bit 0 de una semifila,
podemos ahorrarnos la sentencia BIT utilizando RRA para mover el bit b0 al
carry flag. ¿La utilidad de esto? Sencillamente que RRA se ejecuta en 4 ciclos
de reloj mientras que BIT en 8.
</p>
<pre class="code z80"> <span class="co1">; Ejemplo: leyendo la tecla espacio (bit 0)</span>
 <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>7F
 <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>
 <span class="kw1">RRA</span>                    <span class="co1">; pone b0 en el carry flag</span>
 <span class="kw1">JP</span> NC, key_pressed</pre>

<p>
 4.- Algunas compañías de videojuegos (por ejemplo, ULTIMATE), seleccionaban para
los juegos teclas como Q, W, E, R y T. Como habéis podido ver en este capítulo,
esa selección no es casualidad: todas estas teclas están en la misma semifila
del teclado, con lo que se puede leer el estado de todas ellas con una sóla
lectura de puerto. Esto permitía ahorrar tanto memoria como tiempo de proceso.
</p>

<p>
 En ese sentido, la lectura de los joysticks Sinclair (1-5 y 0-9) también es
muy cómoda para nuestros programas.
</p>

<p>
<br>

</p>

</div>

<h2 id="microrebotes-y-ghosting-en-la-lectura-del-teclado">Microrebotes y Ghosting en la lectura del teclado</h2>
<div class="level2">

<p>
 Miguel A. Rodríguez Jódar nos cuenta dos detalles a tener en cuenta a la hora de leer las teclas en ensamblador.
</p>

<p>
 El primero está relacionado con la lectura de cadenas de texto y no simplemente “controlar” un personaje.
</p>

<p>
 El problema: <strong>los microrebotes del teclado</strong>, provocarán
el conocido efecto de “repetición de teclas” aún cuando sólo hayamos
pulsado y liberado una tecla. Citando a Miguel Ángel:
</p>
<pre class="code">Cuando se usa el teclado para mover un personaje, lo que se busca es ver qué tecla
se pulsa, y mientras esté pulsada se mueve en una determinada dirección. Si se suelta
un momento pero después se vuelve a pulsar, el personaje se sigue moviendo, así que
en este caso los microrrebotes parecen no afectar.

Otra cosa es cuando se usa el teclado para "teclear". En este caso la secuencia es:
esperar a que se pulse una tecla, recoger qué tecla es, almacenarla, esperar a que se
suelte, y volver al principio.

En este caso es cuando ocurre el problema: si el bucle que implementa el algoritmo
anterior es muy rápido, es posible escanear el teclado cada pocos microsegundos. Si
una trama de microrrebotes dura más que el tiempo entre escaneos de teclado, el programa
puede detectar pulsaciones incorrectas, al estar leyendo datos que corresponden a un
microrrebote. Dado que lo que buscamos son secuencias pulsado/no pulsado, estos
microrrebotes se interpretarán erróneamente como pulsaciones y nos podemos encontrar
con que lo que tecleamos aparece repetido dos o tres veces.

Bucle:
EsperaSoltar:   xor a
                in a,(254)
                and 00011111b
                cp 00011111b
                jr nz,EsperaSoltar

EsperaPulsar:   xor a
                in a,(254)
                and 00011111b
                cp 00011111b
                jr z,EsperaPulsar

                ;Se registra la pulsacion...
                jr Bucle

Un bucle así ejecutándose en un Spectrum real podría enfrentarse con la siguiente
pulsación de teclado:

Teclado: 11111111111111111111111001011010000000000000000000000000
Lectura: ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^   ^

Esto es lo que quería destacar: si el intervalo entre dos lecturas es menor que el
tiempo que dura una trama de microrrebotes, se interpretarán como pulsaciones
independientes. Aquí se comienza con la tecla soltada. En un determinado momento,
el usuario la pulsa y genera la secuencia que se ve. El bucle de lectura detecta
una pulsación dentro de la trama de microrrebotes, en la siguiente lectura
detecta una no-pulsación, y en la siguiente, otra pulsación. El resultado final
es que se almacenan dos pulsaciones de tecla en lugar de una.

La descripción técnica del Spectrum apunta a que la supresión de rebotes de teclado
se hace por software, en la rutina de lectura de la ROM. Pero si no se usa dicha
rutina y se lee el teclado directamente, hay que tener en cuenta esto. En nuestro
software basta con insertar una pausa de 1ms en la que se ignora al teclado.
1 milisegundo cuando el teclado se usa no para mover un personaje en un arcade,
sino para registrar entrada del usuario, no afecta a la respuesta del programa.

Bucle:
EsperaSoltar:   xor a
                in a,(254)
                and 00011111b
                cp 00011111b
                jr nz,EsperaSoltar

                ;Hacer pausa AQUI

EsperaPulsar:   xor a
                in a,(254)
                and 00011111b
                cp 00011111b
                jr z,EsperaPulsar

                ;Hacer pausa AQUI

                ;Se registra la pulsacion...
                jr Bucle

 El efecto que esto tiene sobre el comportamiento de las lecturas es el siguiente:

Teclado: 11111111111111111111111001011010000000000000000000000000
Lectura: ^   ^   ^   ^   ^   ^   ^              ^   ^   ^   ^   ^

Cuando se detecta una pulsación (sea en medio de un microrrebote o no), el
teclado deja de explorarse durante 1 ms (o quizás baste con menos). Al soltar
también se generar microrrebotes, que se amortiguarían con la segunda pausa. </pre>

<p>
 Resumiendo: la lectura del teclado en ensamblador sólo está limitada,
“físicamente”, por la velocidad con la que responde la lectura del
puerto con el comando IN. Como explica Miguel Ángel, electrónicamente
existen una serie de rebotes de la señal que pueden inducir a generarnos
 pulsaciones de teclado “residuales” que realmente no se han dado. Esto
hace necesario insertar “pausas” entre lecturas para no leer
“microrebotes” de los estados del teclado al tomar caracteres de teclado
 en determinadas circunstancias (lectura de “cadenas de texto”, por
ejemplo).
</p>

<p>
 El segundo problema se refiere al “Ghosting”. Debido al funcionamiento
interno del teclado, como matriz de pulsadores sin tener aislado cada
uno de ellos con diodos (que hubieran encarecido el producto final al
tener que acoplarlos al teclado de membrana del Spectrum), el estado de
“0 voltios” se propaga por todas las líneas conectadas entre sí mediante
 los circuitos que han cerrado los pulsadores (teclas), por lo que en
ciertas combinaciones de teclas podemos encontrar teclas no pulsadas con
 su línea a 0 voltios, interpretando erróneamente nuestro programa que
dicha tecla está realmente pulsada.
</p>

<p>
 Tal y como nos cuenta Miguel A. Rodríguez Jódar en los foros de Speccy.org:
</p>
<pre class="code">Esto implica, por ejemplo, que al pulsar tres teclas que forman los tres vértices
de un cuadrado en la matriz, la cuarta tecla perteneciente al cuarto vértice también
aparece como pulsada, y por tanto no se puede detectar cuando NO está pulsada.

Lo que ocurre exactamente es lo siguiente: cuando se pulsan dos teclas que pertenecen
a distintas filas, pero que pertenecen a la misma columna las filas de ambas teclas
adquieren el potencial de 0 voltios, así que aunque nosotros hayamos seleccionado
una fila para leer, en realidad se están seleccionando dos filas para leer. Si en la
fila que no pretendíamos leer hay más de una tecla pulsada (la I), ésta obviamente
aparecerá en la línea de salida.

Esto es el "ghosting" en un teclado de matriz. Para detener este efecto, es necesario
impedir que se formen circuitos cerrados allí donde no queremos, o al menos que si
se forman sea porque la corriente deba circular por ese circuito en el sentido adecuado.</pre>

<p>
 La solución es meramente hardware, por lo que a nosotros nos queda
simplemente la posibilidad de modificar la rutina de redefinición de
teclas para impedir que el usuario seleccione teclas cuya combinación
provoque la pulsación no real a nivel de línea de otra.
</p>

<p>
 El propio Miguel A. nos propone un programa en BASIC que nos puede
mostrar las combinaciones de teclado que producen Ghosting y que podemos
 implementar en ASM si consideramos necesario que nuestro programa tenga
 en cuenta esta particularidad (Nota: se han partido los comentarios REM
 y las líneas largas en líneas múltiples para facilitar la lectura):
</p>
<pre class="code basic">       1 REM Datos de la matriz a cargar en T. No podremos usar CAPS SHIT y SYMBOL
             SHIFT porque la rutina de la ROM que usamos no las puede detectar
             "aisladas" asi que en su lugar ponemos CHR$ 0 (NOTA: ambas a la vez
             si puede, es CHR$ 14)
       2 DATA "b","n","m",CHR$ 0," ","h","j","k","l",CHR$ 13,"y","u","i","o","p",
              "6","7","8","9","0","5","4","3","2","1","t","r","e","w","q","g","f",
              "d","s","a","v","c","x","z",CHR$ 0
      10 DIM t(8,5,2):
         REM Estado de la matriz. t(f,c,s) es:f=fila, c=columna, s=codigo ascii tecla
      15 DIM r(7,2):
         REM Nuestra seleccion de teclas. Para cada una se guarda su fila y columna.
      17 FOR f=1 TO 8: FOR c=1 TO 5: READ t$: LET t(f,c,2)=CODE t$: NEXT c: NEXT f:
         REM Rellenamos la matriz T
      20 DATA "Arriba","Abajo","Izquerda","Derecha","Fuego","Pausa","Abortar"
      30 FOR n=1 TO 7
      40 READ t$
      50 PRINT "Elige tecla para ";t$;": ";
      60 PAUSE 0: LET tecl=PEEK 23560:
         REM Leemos tecla. Valdria tambien hacer LET tecl=CODE INKEY$
      65 BEEP .05,0:
         REM pitido de realimentacion al usuario para que sepa que su tecla
             ha sido leida y va a ser procesada
      70 FOR f=1 TO 8: FOR c=1 TO 5: IF t(f,c,2)=tecl THEN GO TO 90:
         REM La buscamos en la matriz
      80 NEXT c: NEXT f: PRINT "Fallo en la matriz! :(": STOP :
         REM Esto no deberia pasar...
      90 IF t(f,c,1)=1 THEN BEEP .5,-20: GO TO 60:
         REM Si ya estaba marcada, error! y a elegir otra
    100 LET t(f,c,1)=1:
         REM No esta marcada, asi que la aceptamos y la marcamos
    105 IF tecl=13 THEN PRINT "ENTER": GO TO 110
    106 IF tecl=32 THEN PRINT "SPACE": GO TO 110
    108 PRINT CHR$ tecl
    110 BEEP .1,20:
        REM pitido para indicar tecla OK
    120 LET r(n,1)=f: LET r(n,2)=c:
        REM La guardamos en nuestra matriz de teclas seleccionadas.
    130 FOR m=1 TO n: LET fil=r(m,1): LET col=r(m,2): GO SUB 900: NEXT m:
        REM Repasamos la lista de teclas seleccionadas hasta el momento para
            actualizar la matriz con las teclas "fantasma" que encontremos
    140 NEXT n: STOP
    900 FOR i=1 TO 8:
        REM recorremos todas las teclas de la misma columna que nuestra tecla
    910 IF t(i,col,1)=1 THEN GO SUB 1000:
        REM si alguna esta seleccionada, significa que tenemos dos teclas en
            una misma columna. Miramos si hay una tercera en la misma fila
    920 NEXT i: RETURN
    1000 FOR j=1 TO 5:
        REM Recorremos una fila buscando una tercera tecla seleccionada
    1010 IF t(i,j,1)=1 THEN LET t(fil,j,1)=1:
        REM Si la encontramos, entonces tenemos tres teclas en un cuadrado.
            Marcamos como seleccionada la cuarta tecla del cuadrado, para que
            no podamos elegirla
    1020 NEXT j: RETURN</pre>

<p>
 Por otra parte, es bastante complicado que los usuarios seleccionen
combinaciones de teclado no estándar (OPQA, 6789, etc.) y que puedan
suponer problemas de ghosting, por lo que lo más normal para evitar la
inclusión de código adicional en nuestro programa será permitir al
usuario que seleccione las teclas sin este tipo de comprobación.
</p>

<p>
<br>

</p>

</div>

<h2 id="uso-de-las-rutinas-de-la-rom">Uso de las rutinas de la ROM</h2>
<div class="level2">

<p>
 La ROM dispone de diferentes rutinas para la lectura del teclado y el tratamiento de scancodes (por ejemplo, conversión a <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>, guardar la última tecla pulsada en una variable de sistema, etc).
</p>

<p>
 Como veremos en la entrega dedicada a las Interrupciones del
procesador, ciertas rutinas de servicio (ISR) son llamadas regularmente
por el procesador (RST $38). Estas rutinas son utilizadas por el
intérprete de BASIC, por ejemplo, pero pueden ser utilizadas por
nosotros siempre y cuando no cambiemos del modo de Interrupción 1 (por
defecto) al modo de Interrupción 2 (un modo que nos permite programar
nuestras propias rutinas ISR personalizadas).
</p>

<p>
 Estando en modo 1, la ROM lee regularmente el teclado y actualiza
ciertas variables del sistema como LAST_K (23560), que contiene el
código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>
 de la última tecla que se haya pulsado. La tecla pulsada permanece en
dicha variable del sistema incluso aunque ya se haya liberado, por lo
que podemos forzar una lectura de teclado estableciéndola dicha celdilla
 de memoria a 0 e invocando una RST $38 (lo que provocaría su
actualización a un valor <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>
 válido en caso de que se esté pulsando una tecla, o 0 en caso
contrario). La rutina en RST $38 ya nos asegura una correcta gestión de
los microrebotes del teclado y su conversión a un <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> válido.
</p>

<p>
 No obstante, no es lo normal utilizar las rutinas de teclado de la ROM
en juegos, puesto que en la mayoría de ellos necesitaremos entrar en el
modo 2 de Interrupciones, en el cual no se ejecuta RST $38 y por lo
tanto no se actualizan variables como LAST_K. Además, es posible que
nuestro programa tenga que hacer uso de la zona de memoria en que las
rutinas de la ROM guardan los datos de las teclas leídas (de 23552 a
23560), lo que no haría factible el uso de estas rutinas (ni siquiera
llamando a RST $38) a menos que preservemos el contenido de esta zona de
 memoria y de otros registros del procesador antes de volver a a IM1,
llamar a RST $38, y saltar de nuevo a IM 2. Seguramente todo este
proceso es totalmente innecesario en un juego si éste ya dispone de
rutinas para leer el teclado y podemos aprovecharlas.
</p>

<p>
 Nuestro curso está orientado a no utilizar las rutinas de la ROM a
menos que sea estríctamente necesario, como en el caso de la utilización
 de RST 16 en alguno de los ejemplos mostrados para imprimir texto por
pantalla, dado que todavía no hemos llegado a la sección del curso
dedicada a trazado de texto e imágenes en la videomemoria. Habrá otras
ocasiones en que alguna rutina de la ROM sea más útil o rápida que la
que podamos escribir nosotros, o, sencillamente, dado que está
disponible en la ROM nos pueda ahorrar espacio en nuestro programa. En
ese caso está justificada su utilización siempre y cuando asumamos que a
 la hora de portar nuestro programa a otras plataformas Z80 (Amstrad,
MSX), dicha rutina no estará disponible y tendremos que reescribirla
adecuándola a la plataforma destino.
</p>

<p>
 En la sección de ficheros se incluye un listado de las rutinas de la ROM desensambladas y comentadas, obtenidas del libro “<em>The Complete Spectrum ROM Disassembly</em>”.
 Estas rutinas incluyen funciones de lectura de scancodes y
decodificación de los mismos para convertirlos en ASCIIs. Podemos
aprovecharlas en programas que no requieran precisión con el teclado
(por ejemplo, para aplicaciones en lugar de para juegos).
</p>

<p>
 En cualquier caso, en el capítulo dedicado a la impresión de texto veremos un ejemplo de utilización de la rutina de la ROM <strong>KEY_SCAN</strong> para la lectura de cadenas de texto tecleadas por el usuario (INPUT).
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/08_keyb1.asm">Lectura de la tecla "P"</a>
</li>
<li><a href="src/08_keyb1.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/08_keyb2.asm">Lectura de la tecla "P" (método 2)</a>
</li>
<li><a href="src/08_keyb2.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/08_scancode.asm">Scancodes de las diferentes teclas</a>
</li>
<li><a href="src/08_scancode.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/08_checkkey.asm">Chequeando el estado de un scancode concreto</a>
</li>
<li><a href="src/08_checkkey.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/08_key2ascii.asm">Conversión de scancodes en ASCIIs</a>
</li>
<li><a href="src/08_key2ascii.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/rom_keyboard.asm">Desensamblado de las rutinas de teclado de la ROM</a>.
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt23.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt23.html">Puerto E/S</a></div>
</li>
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt28.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt28.html">Set de caracteres</a></div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a></div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
<li><div class="li"> <a href="external/ti86.acz.org/z80_ref.htm" class="urlextern" title="external/ti86.acz.org/z80_ref.htm">Z80 Reference de TI86</a>  </div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a></div>
</li>
<li><div class="li"> <a href="http://www.robertp.net/MicroHobby/CodiMaquina/Pagina344.htm" class="urlextern" title="http://www.robertp.net/MicroHobby/CodiMaquina/Pagina344.htm">Disposición electrónica del teclado del Spectrum</a></div>
</li>
<li><a href="src/plantilla_membrana_sp48k.pdf">Plantilla del teclado del Spectrum</a> en formato PDF (por mcleod_ideafix).
</li>
<li><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/index.html" class="urlextern" title="external/www.ticalc.org/pub/text/z80/index.html">Tablas de ensamblado y t-estados</a> (pulsar en z80.txt, z80_reference.txt, z80time.txt).</div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a></div>
</li>
<li><div class="li"> The Complete Spectrum ROM Disassembly <a href="ftp://ftp.worldofspectrum.org/pub/sinclair/books/CompleteSpectrumROMDisassemblyThe.txt" class="urlextern" title="ftp://ftp.worldofspectrum.org/pub/sinclair/books/CompleteSpectrumROMDisassemblyThe.txt">TXT</a> y <a href="ftp://ftp.worldofspectrum.org/pub/sinclair/books/CompleteSpectrumROMDisassemblyThe.pdf" class="urlextern" title="ftp://ftp.worldofspectrum.org/pub/sinclair/books/CompleteSpectrumROMDisassemblyThe.pdf">PDF</a>.</div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="interrupciones-del-procesador-z80">Interrupciones del procesador Z80</h1>
<div class="level1">

<p>
 En este capítulo vamos a ver qué son las interrupciones del
microprocesador Z80 y cómo utilizarlas en nuestro beneficio para
ejecutar rutinas de servicio “en paralelo” al flujo del programa. Aunque
 la introducción inicial sera básicamente teórica, la aplicación
práctica es bastante sencilla, pudiendo utilizar las rutinas de esta
entrega directamente sin conocimiento total de la información teórica
presentada.
</p>

<p>
 Los microprocesadores suelen disponer como mínimo de una señal de
Interrupción. Esta señal, normalmente es invocada externamente por
dispositivos de I/O que requieren la atención del procesador,
solicitando la atención del mismo por algún tipo de evento.
</p>

<p>
 De esta forma, no es necesario que sea nuestro programa el encargado de
 comprobar continuamente si ha ocurrido un evento concreto.
</p>

<p>
 Una señal de interrupción provoca que el procesador termine de ejecutar
 la instrucción en curso y ya no continúe con la ejecución de la
siguiente instrucción apuntada por PC (el contador de programa). En
lugar de esto, temporalmente, lanza una porción de código definida como
ISR (Interrupt Service Program), en la que podemos realizar determinadas
 tareas regulares, desde actualizar variables de
ticks/segundos/minutos/horas con precisión, hasta enviar datos musicales
 al chip de música AY, por ejemplo.
</p>

<p>
 Cuando se finaliza la ejecución de la rutina ISR, el procesador
continúa la ejecución desde donde se detuvo al llegarle la señal de
interrupción. Para nuestro programa la ejecución de la ISR es
“transparente”. No obstante, es importante que estas rutinas ISR sean lo
 más reducidas y rápidas posibles para no afectar a la velocidad de
ejecución del programa principal.
</p>

<p>
 El Z80A (el corazón del ZX Spectrum) dispone de 2 tipos de señales de
interrupción: una señal de alta prioridad (NMI,
Non-mascarable-Interrupt), y otra señal enmascarable de menor prioridad
(MI). El procesador, como hemos dicho, lee el estado de las señales /NMI
 e /INT al acabar la ejecución de cada instrucción (salvo en el caso de
instrucciones repetitivas como LDDR, por ejemplo, que lo realiza al
acabar cada subinstrucción como LDD).
</p>

<p>
<img src="img/nmi_int_pinout.png" class="mediacenter" alt=" Pinout del uP z80 "/>
</p>

<p>
 Veamos a continuación los 2 tipos de interrupciones, en qué modos pueden operar, y qué podemos hacer con ellas.
</p>

<p>
<br>

</p>

</div>

<h2 id="interrupciones-nmi">Interrupciones NMI</h2>
<div class="level2">

<p>
 Las interrupciones no enmascarables (NMI) permiten que dispositivos I/O
 ajenos al procesador le interrumpan solicitando atención por parte del
mismo. El microprocesador Z80 verifica el estado de la señal de
interrupción NMI en el correspondiente pin del procesador en el último
T-estado del ciclo de ejecución actual (incluyendo las instrucciones con
 prefijo al opcode). En ese momento realiza un “PUSH PC” y salta a la
dirección de la ISR (hacia $0066). Tras 11 ciclos de reloj, se ejecuta
el código correspondiente, se recupera “PC” de la pila y se continúa la
ejecución del programa original.  En el caso de que ocurran 2
interrupciones simultáneamente (una de tipo NMI y otra de tipo MI), la
interrupción NMI tiene prioridad.
</p>

<p>
 En el caso del Sinclair ZX Spectrum, las NMI simplemente provocan un
RESET del ordenador, puesto que $0066 es una posición de memoria que cae
 dentro de la ROM y que no puede modificarse salvo hacia $0000,
dirección de inicio del ciclo de ejecución y que provoca el mencionado
reset.
</p>

<p>
<br>

</p>

</div>

<h2 id="interrupciones-mi">Interrupciones MI</h2>
<div class="level2">

<p>
 Las interrupciones enmascarables (MI, INT o INTRQ) se denominan así
porque, al contrario que las NMI, pueden ser ignoradas por el procesador
 cuando han sido deshabilitadas con la instrucción DI (Disable
Interrupt).
</p>

<p>
 Cuando el procesador recibe una de estas interrupciones actúa de 3
formas diferentes según el modo actual de interrupción en que esté. El
Z80 puede estar en 3 modos de interrupción o IM (Interrupt Mode):
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Modo 0</strong>: En este
modo de interrupción, el dispositivo que desea interrumpir al procesador
 activa la pantilla /INT del mismo y durante el ciclo de reconocimiento
de interrupción del procesador coloca el opcode de una instrucción en el
 bus de datos del Z80. Normalmente será una instrucción de 1 sólo byte
(normalmente un RST XX) ya que esto sólo hace necesario escribir y
mantener un opcode en el bus de datos (aunque puede ser, en periféricos
más complejos y con una correcta temporización, un JP o CALL seguido de
la dirección de salto). Este modo de interrupción existe principalmente
por compatibilidad con el procesador 8080.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Modo 1</strong>: Cuando se
recibe una señal INT y el procesador está en IM 1, el Z80 ejecuta un DI
(Disable Interrupts), se salva en la pila el valor actual de PC, y se
realiza un salto a la ISR ubicada en la dirección $0038 (en la ROM). Es
el modo de interrupción por defecto del Spectrum (por ejemplo, en el
intérprete BASIC), y en este modo el Spectrum no sabe qué dispositivo ha
 causado la interrupción y es la rutina ISR la encargada de determinar
qué dispositivo externo (o proceso interno) es el que requiere la
atención del procesador.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Modo 2</strong>: Es el modo
más utilizado en los programas comerciales e implica el uso del registro
 I y el bus de datos para generar un vector de salto. Los 8 bits
superiores de la dirección de salto del ISR se cargan en el registro I.
El dispositivo que desea interrumpir al procesador colocar los 8 bits
bajos de la dirección (por convención, un número par, es decir, con el
bit 0 a 0) en el bus de datos.</div>
</li>
</ul>

<p>
 La lectura de la parte baja de la dirección de salto desde el bus de
datos permite que cada dispositivo pueda tener su propia rutina ISR y
solicitar una interrupción al procesador y que ésta sea atendida por la
rutina especializada adecuada.
</p>

<p>
 El vector resultante de combinar I y BUS_DATOS no apunta a la ISR en sí
 misma, sino a una dirección de 2 bytes que es la que realmente contiene
 la dirección de la ISR. Esto nos permite también utilizar nuestras
propias ISRs por software, desde nuestros propios programas.
Concretamente I*256 apunta a una tabla de direcciones de ISRs (Tabla de
Vectores de Interrupción) que será indexada por el byte bajo de la
dirección (lo que nos da un total de 128 ISRs posibles de 2 bytes de
dirección de inicio absoluta cada una). Es por esto que la dirección del
 byte bajo es, por convención, un número par, de forma que siempre
accedamos a las direcciones de 16 bits correctas en la tabla (I*256+N y
I*256+N+1 siendo N par) y no a media dirección de una ISR y media de
otra (como veremos más adelante).
</p>

<p>
 Así pues, se puede definir la dirección de salto de la interrupción en modo IM2 como:
</p>
<pre class="code"> DIR_SALTO = [ (I*256)+VALOR_EN_BUS_DE_DATOS ]</pre>

<p>
 Finalmente, este es el coste en T-estados de la aceptación de interrupciones en cada modo:
</p>
<ul class="fix-media-list-overlap">
<li> NMI: 11 t-estados
</li>
<li> INT IM 0: 13 t-estados (si la instrucción del bus es un RST)
</li>
<li> INT IM 1: 13 t-estados
</li>
<li> INT IM 2: 19 t-estados
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="instrucciones-relacionadas-con-las-interrupciones">Instrucciones relacionadas con las interrupciones</h2>
<div class="level2">

<p>
<br>

</p>

</div>

<h3 class="sectionedit5" id="cambio-del-modo-de-interrupcion-im">Cambio del modo de interrupción (IM)</h3>
<div class="level3">

<p>
 Podemos cambiar el modo de interrupcion en el Spectrum con la instrucción del procesador “IM”:
</p>
<pre class="code z80">  <span class="kw1">IM</span> <span class="re1">0</span>       <span class="co1">; Cambiar a modo IM 0 (8 T-Estados).</span>
  <span class="kw1">IM</span> <span class="re1">1</span>       <span class="co1">; Cambiar a modo IM 1 (8 T-Estados).</span>
  <span class="kw1">IM</span> <span class="nu0">2</span>       <span class="co1">; Cambiar a modo IM 2 (8 T-Estados).</span></pre>

<p>
 Como ya hemos dicho, el Spectrum opera normalmente en IM 1, donde se
llama regularmente a una ISR que actualiza lee el estado del teclado y
actualiza ciertas variables del sistema (LAST_K, FRAMES, etc) para la
conveniencia del intérprete de BASIC (y, en algunos casos, de nuestros
propios programas). Esta ISR (la RST $38) pretende hacer uso exclusivo
del registro IY por lo que si nuestro programa necesita hacer uso de
este registro es importante hacerlo entre un DI y un EI para evitar que
pueda ocurrir una interrupción con su valor modificado por nosotros y
provocar un reset en el Spectrum. También tenemos que tener en cuenta
esto si estando en modo IM 2 llamamos manualmente a la RST $38 para
actualizar variables del sistema (aunque no es habitual que necesitemos
ejecutar la ISR que usa el intérprete de BASIC).
</p>

<p>
 En el caso de aplicaciones y juegos, lo normal es cambiar a IM 2 con
una rutina propia de ISR que realice las tareas que nosotros
necesitemos, especialmente temporización, actualización del buffer del
chip AY de audio para reproducir melodías, etc.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit6" id="activar-y-desactivar-las-interrupciones-del-procesador">Activar y desactivar las interrupciones del procesador</h3>
<div class="level3">

<p>
 Existen también 2 instrucciones especiales para DESACTIVAR las
interrupciones (DI, Disable Interrupts), y ACTIVARLAS (EI, Enable
Interrupts), manipulando el flip-flop del procesador IFF.
</p>
<pre class="code z80">  <span class="kw1">DI</span>         <span class="co1">; Disable Interrupts (4 T-estados) -&gt; IFF=0</span>
  <span class="kw1">EI</span>         <span class="co1">; Enable Interrupts (4 T-estados). -&gt; IFF=1</span></pre>

<p>
 Nótese el hecho importantísimo de que las interrupciones no se
habilitan de nuevo al final la ejecución del EI, sino tras la ejecución
de la instrucción que lo sigue en el flujo del programa. Más adelante
veremos por qué.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit7" id="instruccion-halt">Instrucción HALT</h3>
<div class="level3">

<p>
 La instrucción HALT es una instrucción muy útil que detiene el proceso
de ejecución la CPU. Al llamarla, la CPU comienza a ejecutar
continuamente NOPs de 4 t-estados (sin incrementar el contador de
programa), hasta que se vea interrumpido por una NMI o una MI (INT), en
cuyo momento se incrementa PC y se procesa la interrupción. Al volver de
 la ISR, el procesador continúa la ejecución del programa en la
instrucción siguiente al HALT.
</p>
<pre class="code z80">  <span class="kw1">HALT</span>       <span class="co1">; Halt computer and wait for INT (4 T-Estados).</span></pre>

<p>
 Como veremos más adelante, la instrucción HALT nos será especialmente
útil en determinadas ocasiones al trabajar con la manipulación del área
de datos de la videomemoria.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit8" id="instrucciones-rst">Instrucciones RST</h3>
<div class="level3">

<p>
 Las instrucciones RST (ReSTart) que se utilizan para realizar un salto a
 una dirección concreta y específica mediante una instrucción de un sólo
 opcode. Existen las siguientes posibles instrucciones RST:
</p>
<pre class="code z80">  <span class="kw1">RST</span> <span class="re1">0</span>      <span class="co1">; Opcode C7 (11 T-estados).</span>
  <span class="kw1">RST</span> <span class="nu0">8</span>      <span class="co1">; Opcode CF (11 T-estados).</span>
  <span class="kw1">RST</span> <span class="re1">10</span>h    <span class="co1">; Opcode D7 (11 T-estados).</span>
  <span class="kw1">RST</span> <span class="re1">1</span>8h    <span class="co1">; Opcode DF (11 T-estados).</span>
  <span class="kw1">RST</span> <span class="nu0">2</span><span class="re1">0</span>h    <span class="co1">; Opcode E7 (11 T-estados).</span>
  <span class="kw1">RST</span> 28h    <span class="co1">; Opcode EF (11 T-estados).</span>
  <span class="kw1">RST</span> <span class="nu0">3</span><span class="re1">0</span>h    <span class="co1">; Opcode F7 (11 T-estados).</span>
  <span class="kw1">RST</span> 38h    <span class="co1">; Opcode FF (11 T-estados).</span></pre>

<p>
 El equivalente de esta instrucción de 1 sólo opcode es un “CALL 00XXh”,
 y su existencia está justificada en que es necesario disponer de estas
instrucciones de un sólo byte para que puedan así ser emplazadas en el
bus de datos y leídas en el modo de interrupción IM 0, algo que no se
podría hacer de una forma tan sencilla con la instrucción multibyte
CALL.
</p>

<p>
 En nuestros programas podemos utilizar estas instrucciones RST si
queremos llamar manualmente a alguna de las rutinas de la ROM a la que
hacen referencia, como RST $10 (o RST 16), que utilizamos en la entrega
sobre el teclado para llamar a $0010, que aloja la rutina PRINT-A (la
cual imprime en pantalla el carácter <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> correspondiente al valor del registro A).
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit9" id="instrucciones-ld-a-r-y-ld-a-i">Instrucciones "LD A, R" y "LD A, I"</h3>
<div class="level3">

<p>
 Una instrucción de uso infrecuente con una peculiar utilidad es <strong>LD A, R</strong>.
 Con esta instrucción cargamos el valor del registro interno del
procesador R (utilizado para el refresco de la DRAM) en el acumulador.
Comunmente se utiliza para obtener algún tipo de valor “variable” como
semilla o parte del proceso de generación de números aleatorios.
</p>

<p>
 No obstante, esta instrucción de 2 bytes ($ED $5F) y 9 t-estados de
ejecución tiene la particular utilidad de copiar en el flag P/V el
contenido del flip-flop IFF2, por lo que podemos utilizarla para conocer
 el estado de las interrupciones enmascarables.
</p>

<p>
 Así, una vez ejecuado un “LD A, R”, sabemos que si la bandera está a 1
es que las interrupciones están habilitadas, mientras que si están a
cero, es porque han sido deshabilitadas.
</p>

<p>
 Como curiosidad, la instrucción <strong>LD A, I</strong> produce la misma afectación de P/V que <strong>LD A, R</strong>. Otros flags afectados por ambas instrucciones son “S”, “C” (reseteado) y “z”.
</p>

<p>
<br>

</p>

</div>

<h2 id="las-interrupciones-de-la-ula">Las interrupciones de la ULA</h2>
<div class="level2">

<p>
 Como ya hemos dicho, las interrupciones están diseñadas para que los
dispositivos externos puedan interrumpir al procesador Z80. En el caso
del Spectrum, existe un dispositivo externo común a todos los modelos y
que tiene funciones críticas para el sistema. Hablamos de la ULA, que en
 un Spectrum sin dispositivos conectados al puerto de expansión es el
único periférico que provoca señales de interrupción al procesador.
</p>

<p>
 La ULA, como encargada de gestionar la I/O, el teclado, y de refrescar
el contenido de la pantalla usando los datos almacenados en el área de
videoram del Spectrum, interrumpe al procesador de forma constante, a
razón de 50 veces por segundo en sistemas de televisión PAL (Europa y
Australia) y 60 veces por segundo en sistemas NTSC (USA).
</p>

<p>
 Esto quiere decir que cada 1/50 (o 1/60) segundos, la ULA produce una
señal INT (interrupción enmascarable), que provoca la ejecución de la
ISR de turno (RST $38 en modo IM 1 ó la ISR que hayamos definido en modo
 IM 2).
</p>

<p>
 En el modo IM 1 (el modo en que arranca el Spectrum), el salto a RST
$38 provocado por las interrupciones generadas por la ULA produce la
ejecución regular y continua cada 1/50 segundos de las rutinas de
lectura del teclado, actualización de variables del sistema de BASIC y
del reloj del sistema (FRAMES) requeridas por el intérprete de BASIC
para funcionar.
</p>

<p>
 En cuanto al modo IM 2, el que nos interesa principalmente para la
realización de programas y juegos, la dirección de salto del ISR se
compone como 16 bits a partir del registro I (en la parte alta de la
dirección), y el identificador de dispositivo (par) en el bus de datos,
utilizado como parte baja del vector de salto.
</p>

<p>
 Como ya hemos visto en la definición del modo IM 2, la dirección
resultante ((I*256)+ID_DE_DISPOSITIVO_EN_BUS_DATOS) se utiliza para
consultar una tabla de vectores de interrupción para saltar. A partir de
 la dirección I*256, debe de haber una tabla de 256 bytes con 128
direcciones de salto absolutas de 2 bytes cada una.
</p>

<p>
 De esta forma, cada dispositivo de hasta un total de 128 puede colocar
su ID en el bus de datos y tener su propia ISR en la tabla:
</p>
<ul class="fix-media-list-overlap">
<li> Un dispositivo con ID 0 tendría su dirección de salto a la ISR en (I*256+0 e I*256+1).
</li>
<li> Un dispositivo con ID 2 tendría su dirección de salto a la ISR en (I*256+2 e I*256+3).
</li>
<li> Un dispositivo con ID 4 tendría su dirección de salto a la ISR en (I*256+4 e I*256+5).
</li>
<li> (…)
</li>
<li> Un dispositivo con ID 254 tendría su dirección de salto a la ISR en (I*256+254 e I*256+255).
</li>
</ul>

<p>
 Debido a que la tabla de saltos requiere 2 bytes por cada dirección y
que existen 256 posibles valores en el bus de datos, el identificador de
 dispositivo tiene que ser un valor PAR, ya que si un dispositivo
introdujera un valor IMPAR en el bus de datos, el procesador podría
realizar un salto a una dirección compuesta a partir de los datos de
salto de 2 dispositivos diferentes. Comprenderemos este problema con un
ejemplo muy sencillo:
</p>
<ul class="fix-media-list-overlap">
<li> Un dispositivo con ID 1 tendría su
dirección de salto a la ISR en (I*256+1 e I*256+2) (que forman parte de
las direcciones de salto de los dispositivos con ID 0 e ID 2).
</li>
<li> Un dispositivo con ID 255 tendría su
 dirección de salto a la ISR en (I*256+255 e I*256+256), lo que
implicaría tratar de utilizar parte de la dirección de salto del
dispositivo con ID 254 además de un byte de fuera de la tabla de
vectores de interrupción.
</li>
</ul>

<p>
 Así pues, por convención, todos los dispositivos que se conectan a un
Z80 tienen que colocar como ID de dispositivo en el bus de datos un
identificador único par, que asegure que los vectores de salto de 2
dispositivos nunca puedan solaparse.
</p>

<p>
 Existe una excepción notable a esta regla, y no es otra que la propia
ULA. La ULA no está diseñada para funcionar en modo IM 2, ya que no
coloca ningún identificador de dispositivo en el bus de datos cuando
genera interrupciones. Está diseñada para funcionar en modo 1, donde no
se espera este identificador y siempre se produce el salto a RST $38,
sea cual sea el dispositivo que solicita la interrupción.
</p>

<p>
 Por suerte, cuando no se coloca ningún valor en el bus de datos del
Spectrum, éste adquiere el valor de 8 señales uno (11111111b, 255d o
FFh), debido a las resistencias de pull-up al que están conectadas las
líneas de dicho bus. Por lo tanto, nuestro procesador Z80A obtendrá como
 device-id del dispositivo que interrumpe un valor FFh (con cierta
particularidad que veremos en la sección sobre Compatibilidad).
</p>

<p>
 Este valor, impar, produce el siguiente valor dentro de la tabla de
vectores de interrupción: (I*256+255) e (I*256+255+1), lo que produce la
 lectura dentro de la tabla de vectores del campo 255 y del 256,
provocando la necesidad de que nuestra tabla de vectores requiera 257 en
 lugar de 256 bytes.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit11" id="la-interrupcion-de-la-ula-y-el-vsync-de-video">La interrupción de la ULA y el VSync de vídeo</h3>
<div class="level3">

<p>
 Como acabamos de ver, la ULA provee al procesador en modo IM1 de un
mecanismo para, regularmente, escanear el teclado y evitar así que sean
los propios programas quienes tengan que realizar esa tarea por
software.
</p>

<p>
 La interrupción generada por la ULA debe de ser de una regularidad tal
que se ejecute suficientes veces por segundo para que el escaneo del
teclado no pierda posibles pulsaciones de teclas del usuario, pero no
tan frecuente como para que requiera gran cantidad de tiempo de
procesador ejecutando una y otra vez la ISR asociada.
</p>

<p>
 Como nos cuenta el libro sobre la ULA de Chris Smith, el ingenierio de
Sinclair, Richard Altwasser, aprovechó la señal de VSYNC que la ULA
genera como señal de sincronización para el televisor como lanzador de
la señal de interrupción. Esta señal se genera 50 veces por segundo para
 televisiones PAL y 60 para televisiones NTSC, y tiene la duración
adecuada para que el procesador detecte la interrupción en su patilla
INTrq.
</p>

<p>
 Este es el precisamente el motivo por el cual la interrupción generada
por la ULA se genera 50 (ó 60 veces por segundo): un aprovechamiento de
la señal de VSYNC para los televisores, con el consiguiente ahorro de
electrónica adicional que supondría generar otra señal adicional para
INTrq.
</p>

<p>
 Por otra parte, para los programadores es una enorme ventaja el saber
que la interrupción del procesador por parte de la ULA coincide con el
VSYNC, ya que nos permite el uso de la instrucción HALT en nuestro
programa para forzar al mismo a esperar a dicha interrupción y poder
ejecutar código después del HALT que trabaje sobre la pantalla sabiendo
que el haz de electrones no la está redibujando.
</p>

<p>
 Como veremos en el capítulo dedicado a la memoria de vídeo, la ULA lee
regularmente un área de aprox. 7 KB que empieza en la dirección de
memoria $4000 y con los datos que hay en ese área alimenta al haz de
electrones del monitor para que forme la imagen que aparece en pantalla.
 Como parte del proceso de generación de la imagen, 50 veces por segundo
 (una vez por cada “cuadro de imagen”) la ULA debe de generar un pulso
de VSYNC durante 256 microsegundos para el monitor que asegure que el
inicio de la generación de la imagen está sincronizado con las líneas de
 vídeo que se le envían. Durante ese período, la ULA no está generando
señal de vídeo sobre el televisor y podemos alterar el contenido de la
videoram con seguridad.
</p>

<p>
 ¿Por qué es necesario tener esta certeza acerca de la ubicación del haz
 de electrones? La respuesta es que si alteramos el contenido de la
videoram durante la generación de la imagen, es posible que se muestren
en pantalla datos de la imagen del cuadro de vídeo anterior (datos de
videoram ya trazados por el haz de electrones) junto a datos de la
imagen del cuadro de vídeo que estamos generando, mostrando un efecto
“cortinilla” o “efecto nieve”.
</p>

<p>
 Por mostrarlo de una manera gráfica (y con un ejemplo “teórico”),
supongamos que tenemos una pantalla de color totalmente azul y queremos
cambiarla a una pantalla de color totalmente verde. Imaginemos que
cuando el haz de electrones ha mostrado la mitad de la pantalla nosotros
 cambiamos el contenido de la zona de atributos para que la pantalla
completa sea verde. Con el haz en el centro de la pantalla, todavía
recorriendo la videoram y “trazando” los colores en pantalla, todos los
datos mostrados a partir de ese momento serán píxeles verdes, por lo que
 durante ese cuadro de imagen tendremos el 50% inicial de la pantalla en
 color azul y el 50% restante en verde, y no toda verde como era nuestra
 intención. Será en el próximo cuadro de retrazado de la pantalla cuando
 se leerán los valores de color verde de la VRAM de la zona superior de
la pantalla y se retrazarán dichos píxeles en verde, dejándonos la
pantalla totalmente de dicho color.
</p>

<p>
 ¿Cómo podemos evitar este efecto? Mediante la instrucción <strong>HALT</strong>.
</p>

<p>
 El haz de electrones del monitor barre la pantalla empezando en la
esquina superior izquierda de la misma, recorriendola de derecha a
izquierda, trazando líneas horizontales con el contenido de la
videomemoria. Cuando el haz llega a la derecha del televisor, baja a la
siguiente línea de pantalla retrocediendo a la izquierda de la misma y
se sincroniza con la ULA mediante una señal de HSYNC. De nuevo el haz de
 electrones traza una nueva línea horizontal hacia la derecha,
repitiendo el proceso una y otra vez hasta llegar a la esquina inferor
derecha. El haz de electrones debe entonces volver a la parte superior
izquierda de la pantalla (mediante una diagonal directa) y sincronizarse
 con la ULA mediante un pulso VSYNC.
</p>

<p>
<br>

<img src="img/vsync_int.png" class="mediacenter" alt=" Recorrido del haz de electrones del monitor/TV "/>
</p>

<p>
 Sabemos que la interrupción generada por la ULA llega al procesador
cuando se realiza el VSYNC con el monitor (cuando el haz de electrones
está en el punto superior de su retroceso a la esquina superior
izquierda de la pantalla), así que podemos utilizar HALT en nuestro
programa para forzar al mismo a esperar una interrupción, es decir, a
que se finalice el trazado del cuadro actual, asegurándonos que no se
está escribiendo en pantalla. Esto nos deja un valioso pero limitado
tiempo para realizar actualizaciones de la misma antes de que el haz de
electrones comience el retrazado o incluso alcance el punto que queremos
 modificar.
</p>

<p>
 En nuestro ejemplo anterior de la pantalla azul y verde, un HALT antes
de llamar a la rutina que pinta la pantalla de verde aseguraría que la
pantalla se mostrara completamente en verde (y no parcialmente) al haber
 realizado el cambio de los atributos tras el HALT (durante el VSYNC) y
no durante el retrazado de la pantalla en sí misma.
</p>

<p>
 Hay que tener en cuenta un detalle para temporizaciones precisas:
aunque el microprocesador siempre recibe la señal de interrupción en el
mismo instante de retorno del haz, la señal sólo es leída por el
microprocesador al acabar la ejecución de la instrucción en curso, por
lo que dependiendo del estado actual de ejecución y del tipo de
instrucción (su tamaño y tiempo de ejecución) puede haber una variación
de hasta 23 t-estados en el tiempo de procesado de la INT.
</p>

<p>
 Una vez se produce la interrupción, tenemos un tiempo finito para
trabajar sobre la pantalla antes de que comience el redibujado de la
misma:
</p>
<div class="table-responsive sectionedit12"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Modelo de Spectrum </th><th class="col1"> t-estados disponibles (+-1 t-estado)</th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 16K </td><td class="col1"> 14336 t-estados </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 48K </td><td class="col1"> 14336 t-estados </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 128K </td><td class="col1"> 14361 t-estados </td>
	</tr>
	<tr class="row4">
		<td class="col0"> +2 </td><td class="col1"> 14361 t-estados </td>
	</tr>
	<tr class="row5">
		<td class="col0"> +2A </td><td class="col1"> 14364 t-estados </td>
	</tr>
	<tr class="row6">
		<td class="col0"> +3 </td><td class="col1"> 14364 t-estados </td>
	</tr>
</tbody></table></div>

<p>
 Detalles de temporización con este son los que permiten a algunos
juegos realizar auténticas virguerías con el borde (como Aquaplane), o
generar rutinas que permitan varios colores por carácter controlando la
posición exacta del haz de electrones y cambiando los atributos mientras
 el haz está trazando un determinado scanline.
</p>

<p>
<br>

</p>

</div>

<h2 id="las-rutinas-de-isr">Las rutinas de ISR</h2>
<div class="level2">

<p>
 Hemos hablado ya de las rutinas de ISR y de cómo son llamadas 50 (o 60)
 veces por segundo. Lo normal en el desarrollo de un juego o programa
medianamente complejo es que utilicemos el modo IM 2 y desarrollemos
nuestra propia rutina ISR para que cumpla nuestras necesidades.
</p>

<p>
 Las ISRs deben de optimizarse lo máximo posible, tratando de que sean
lo más rápidas y óptimas posibles, ya que nuestro programa se ha visto
interrumpido y no se continuará su ejecución hasta la salida de la ISR.
Si tenemos en cuenta que normalmente nuestras ISRs se ejecutarán 50
veces por segundo, es importante no ralentizar la ejecución del programa
 principal llenando de código innecesario la ISR.
</p>

<p>
 Es crítico también que en la salida de la ISR no hayamos modificado los
 valores de los registros con respecto a su entrada. Para eso, podemos
utilizar la pila y hacer PUSH + POP de los registros utilizados o
incluso utilizar los Shadow Registers si sabemos a ciencia cierta que
nuestro programa no los utiliza (con un EXX y un EX AF, AF al principio y
 al final de nuestra ISR).
</p>

<p>
 Al principio de nuestra ISR no es necesario desactivar las
interrupciones con DI, ya que el Z80 las deshabilita al aceptar la
interrupción. Debido a este “DI” automático realizado por el procesador,
 las rutinas de ISR deben incluir un EI antes del RET/RETI.
</p>

<p>
 Así pues, de las rutinas ISR llamadas en las interrupciones se debe de
volver con una instrucción RETN en las interrupciones no enmascarables y
 un EI + RETI en las enmascarables (aunque en algunos casos, según el
periférico que provoca la interrupción, también se puede utilizar
EI+RET, que es ligeramente más rápido y que tiene el mismo efecto en
sistemas como el Spectrum).
</p>
<pre class="code z80">  <span class="kw1">RETI</span>        <span class="co1">; Return from interrupt (14 T-Estados).</span>
  <span class="kw1">RETN</span>        <span class="co1">; Return from non-maskable interrupt (14 T-Estados).</span></pre>

<p>
 Existe un motivo por el cual existe RETI y no se utiliza simplemente
RET, y es que existen unos flip-flops internos en el procesador que le
marcan cierto estados al procesador y que en el caso de salida de una
interrupción deben resetearse.
</p>

<p>
 Citando el documento z80undoc3.txt de Z80.info (por Sean Young):
</p>
<pre class="code">3.1) Non-maskable interrupts (NMI)

When a NMI is accepted, IFF1 is reset. At the end of the routine, IFF1 must
be restored (so the running program is not affected). That's why IFF2 is
there; to keep a copy of IFF1.

An NMI is accepted when the NMI pin on the Z80 is made low. The Z80 responds
to the /change/ of the line from +5 to 0. When this happens, a call is done
to address 0066h and IFF1 is reset so the routine isn't bothered by maskable
interrupts. The routine should end with an RETN (RETurn from Nmi) which is
just a usual RET, but also copies IFF2 to IFF1, so the IFFs are the same as
before the interrupt.


3.2) Maskable interrupts (INT)

At the end of a maskable interrupt, the interrupts should be enabled again.
You can assume that was the state of the IFFs because otherwise the interrupt
wasn't accepted. So, an INT routine always ends with an EI and a RET
(RETI according to the official documentation, more about that later):

INT:	.
	.
	.
	EI
	RETI (or RET)

Note a fact about EI: a maskable interrupt isn't accepted directly after it,
so the next opportunity for an INT is after the RETI. This is very useful;
if the INT is still low, an INT is generated again. If this happens a lot and
the interrupt is generated before the RETI, the stack could overflow (since
the routine is called again and again). But this property of EI prevents this.

You can use RET in stead of RETI too, it depends on hardware setup. RETI
is only useful if you have something like a Z80 PIO to support daisy-chaining:
queueing interrupts. The PIO can detect that the routine has ended by the
opcode of RETI, and let another device generate an interrupt. That is why
I called all the undocumented EDxx RET instructions RETN: All of them
operate like RETN, the only difference to RETI is its specific opcode.
(Which the Z80 PIO recognises.)</pre>

<p>
 Es decir, para aquellos sistemas basados en Z80 con hardware PIO que
soporte múltiples dispositivos I/O encadenando sus interrupciones, se
define un opcode especial RETI distinto de RET de forma que el PIO pueda
 detectar el fin de la ISR y pueda permitir a otros dispositivos generar
 una interrupción.
</p>

<p>
 En el caso del Spectrum con la ULA como (habitualmente) único
dispositivo que interrumpe, se utiliza normalmente RET en lugar de RETI
por ser ligeramente más rápida en ejecución. No obstante, en nuestros
ejemplos hemos utilizado RETI para acomodarlos a la teoría mostrada.
</p>

<p>
 Como ya hemos comentado antes, EI no activa las interrupciones al
acabar su ejecución, sino al acabar la ejecución de la siguiente
instrucción. El motivo de esto es evitar que se pueda recibir una
interrupción estando dentro de una ISR entre el EI y el RET:
</p>
<pre class="code z80">Nuestra_ISR:
    <span class="kw1">PUSH</span> <span class="kw2">HL</span>
&nbsp;
    <span class="br0">(</span><span class="kw2">c</span>ódigo <span class="kw2">de</span> la ISR<span class="br0">)</span>
&nbsp;
    <span class="kw1">POP</span> <span class="kw2">HL</span>
    <span class="kw1">EI</span>
    <span class="kw1">RETI</span></pre>

<p>
 Si EI habilitar las interrupciones de forma instantánea y se recibiera
una interrupción entre la instrucción EI y el RETI, se volvería a entrar
 en la ISR, y por lo tanto se volvería a realizar el PUSH de PC y el
PUSH de HL, rompiendo el flujo correcto del programa. Por contra, tal y
como funciona EI sólo se habilitarán de nuevo las interrupciones tras la
 ejecución de RETI y la recuperación de PC de la pila, permitiendo así
la ejecución de una nueva interrupción sin corromper el contenido del
stack.
</p>

<p>
 Finalmente, es importantísimo en los modelos de más de 16K (48K y 128K
paginados) utilizar una tabla de vector de interrupciones ubicada en la
página superior de la RAM (memoria por encima de los 32K), ya que la
utilización del bloque inferior de memoria (dejando de lado la ROM, el
bloque desde 16K a 32K) provocaría un efecto nieve en la pantalla. La
elección estándar de la dirección de la tabla de vector de
interrupciones recae en direcciones a partir de $FE00, por motivos que
veremos al hablar sobre la ULA. Por otra parte, en la sección de <em>Consideraciones y Curiosidades</em> veremos cómo solucionar este problema en sistemas de 16K de memoria RAM.
</p>

<p>
 Ninguna de las instrucciones que hemos visto (RST XX, EI, DI, RETI,
RETN, HALT o IM XX) produce afectación alguna en los flags, salvo <strong>LD A, R</strong>, que altera el flag P/V con la utilidad que ya hemos visto.
</p>

<p>
<br>

</p>

</div>

<h2 id="la-isr-de-im-1">La ISR de IM 1</h2>
<div class="level2">

<p>
 A modo de curiosidad, vamos a ver el código de la ISR que se ejecuta en modo 1 (RST $38), tomado del documento <strong>The Complete Spectrum ROM Disassembly</strong> con alguna modificación en los comentarios:
</p>
<pre class="code z80"><span class="co1">; THE 'MASKABLE INTERRUPT' ROUTINE</span>
<span class="co1">; The real time clock (FRAMES) is incremented and the keyboard</span>
<span class="co1">; scanned whenever a maskable interrupt occurs.</span>
<span class="co1">;</span>
<span class="co1">; FRAMES = 3 bytes variable.</span>
&nbsp;
<span class="co1">; BYTES 1 &amp; 2 FRAMES -&gt; $5C78 and $5C79</span>
<span class="co1">; BYTE 3 FRAMES      -&gt; IY+40h = $5C7A</span>
<span class="co1">;</span>
<span class="re1">00</span><span class="nu0">38</span> MASK<span class="sy0">-</span>INT:
                  <span class="kw1">PUSH</span>  <span class="kw2">AF</span>                  <span class="co1">; Save the current values held in</span>
                  <span class="kw1">PUSH</span>  <span class="kw2">HL</span>                  <span class="co1">; these registers.</span>
                  <span class="kw1">LD</span>    <span class="kw2">HL</span>,<span class="br0">(</span><span class="sy0">$</span>5C78<span class="br0">)</span>          <span class="co1">; The lower two bytes of the</span>
&nbsp;
                  <span class="kw1">INC</span>   <span class="kw2">HL</span>                  <span class="co1">; frame counter are incremented (FRAMES)</span>
                  <span class="kw1">LD</span>    <span class="br0">(</span><span class="sy0">$</span>5C78<span class="br0">)</span>,<span class="kw2">HL</span>          <span class="co1">; every 20 ms. (UK) -&gt; INC BYTE_1_2(FRAMES)</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">H</span>                 <span class="co1">; The highest byte of the frame counter is</span>
                  <span class="kw1">OR</span>    <span class="kw2">L</span>                   <span class="co1">; only incremented when the value</span>
                  <span class="kw1">JR</span>    NZ,KEY<span class="sy0">-</span>INT          <span class="co1">; of the lower two bytes is zero</span>
                  <span class="kw1">INC</span>   <span class="br0">(</span><span class="kw2">IY</span><span class="sy0">+</span><span class="nu0">4</span><span class="re1">0</span>h<span class="br0">)</span>            <span class="co1">; INC BYTE_3(FRAMES) ($5C7A)</span>
<span class="re1">00</span><span class="nu0">48</span> KEY<span class="sy0">-</span>INT:
                  <span class="kw1">PUSH</span>  <span class="kw2">BC</span>                  <span class="co1">; Save the current values held</span>
                  <span class="kw1">PUSH</span>  <span class="kw2">DE</span>                  <span class="co1">; in these registers.</span>
                  <span class="kw1">CALL</span>  KEYBOARD            <span class="co1">; Now scan the keyboard. (CALL $02BF)</span>
                  <span class="kw1">POP</span>   <span class="kw2">DE</span>                  <span class="co1">; Restore the values.</span>
                  <span class="kw1">POP</span>   <span class="kw2">BC</span>
                  <span class="kw1">POP</span>   <span class="kw2">HL</span>
                  <span class="kw1">POP</span>   <span class="kw2">AF</span>
                  <span class="kw1">EI</span>                        <span class="co1">; The maskable interrupt is en-</span>
                  <span class="kw1">RET</span>                       <span class="co1">; abled before returning.</span></pre>

<p>
 Nótese cómo la ISR del modo 1 se ajusta a lo visto hasta ahora: se
preserva cualquier registro que pueda utilizarse dentro de la misma, se
reduce el tamaño y tiempo de ejecución de la ISR en la medida de lo
posible, y se vuelve con un EI+RET.
</p>

<p>
 La rutina actualiza el valor de la variable del sistema FRAMES (que
viene a ser el equivalente de la variable “abs_ticks” del ejemplo que
veremos en el siguiente apartado) y llama a la rutina de la ROM
“KEYBOARD” ($02BF) que es la encargada de chequear el estado del teclado
 y actualizar ciertas variables del sistema para que el intérprete BASIC
 (o nuestros programas si corren en IM 1) pueda gestionar las
pulsaciones de teclado realizadas por el usuario. Si bien la rutina
“KEYBOARD” a la que se llama desde la ISR no es todo lo “pequeña” que se
 podría esperar de algo que se va a ejecutar en una ISR, sí que es
cierto que es una de las partes primordiales del intérprete BASIC y que
es más óptimo y rápido obtener el estado del teclado en la ISR (aunque
la rutina sea larga e interrumpa 50 veces por segundo a nuestro programa
 con su ejecución) que tener que realizar la lectura del teclado dentro
del propio intérprete de forma continuada.
</p>

<p>
 Nótese, como nos apunta <em>metalbrain</em> en los foros de Speccy.org,
 que FRAMES es una variable de 3 bytes y que esta rutina ISR utiliza IY
para acceder al tercer byte de esta variable cuando el incremento de los
 2 bytes más bajos requieren el incremente del tercer byte. Lo hace a
través de IY+40h y esto explica porqué desde BASIC, bajo IM1, no debemos
 utilizar código ASM que haga uso de IY, bajo riesgo de que este “INC”
pueda realizarse sobre un valor de IY que no sea el esperado y por tanto
 “corromper” un byte de código de nuestro programa o de datos, pantalla,
 etc.
</p>

<p>
<br>

</p>

</div>

<h2 id="isr-de-atencion-a-la-ula-en-im-2">ISR de atención a la ULA en IM 2</h2>
<div class="level2">

<p>
 La clave de este capítulo, y la principal utilidad del uso de
interrupciones en nuestros programas es la de aprovechar las
interrupciones que la ULA genera 50 veces por segundo (60 en América) en
 el modo IM 2.
</p>

<p>
 Antes de pasar al modo IM 2, nosotros somos los responsables de generar
 la tabla de vectores de interrupción con los valores a los que el
procesador debe de saltar en caso de recibir una interrupción de un
dispositivo externo. Para eso, generamos en memoria una tabla de 257
bytes y en ella introducimos las direcciones de salto de las ISRs. En un
 Spectrum estándar sin dispositivos conectados al bus de expansión sólo
recibiremos interrupciones generadas por la ULA, con un device_id
predictible de valor $FF (este device-id es también el causante de que
la tabla sea de 257 bytes y no de 256).
</p>

<p>
 Veamos cómo instalar una rutina ISR que se ejecute cada vez que se
recibe una interrupción de la ULA. Para ello podemos generar nuestra
tabla de vectores de interrupción a partir de una posición de memoria
como, por ejemplo, $FE00. Para ello asignamos a I el valor $FE, lo que
implica que nuestra tabla de vectores de interrupción estará localizada
desde $FE00 hasta $FEFF+1 ($FF00).
</p>

<p>
 Para atender a las interrupciones generadas por la ULA (device_id $FF), tendremos que realizar los siguientes pasos:
</p>
<ul class="fix-media-list-overlap">
<li> Crear una rutina de ISR correcta (preservar registros, salir con EI+RETI o EI+RET, etc).
</li>
<li> Colocar la dirección de nuestra ISR
en las posiciones de memoria $FEFF y $FEFF+1 (que es de donde leerá el
Z80 la dirección de salto cuando reciba la interrupción con ID $FF).
</li>
<li> Asignar a I el valor $FE y saltar a
IM 2 (de esta forma, le decimos al Z80 que la tabla de vectores de
interrupción empieza en $FE00).
</li>
</ul>

<p>
 El código resultante sería el siguiente:
</p>
<pre class="code z80"> <span class="co1">; Instalando una ISR de atención a la ULA.</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="co1">; Instalamos la ISR:</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, ISR_ASM_ROUTINE        <span class="co1">; HL = direccion de la rutina de ISR</span>
  <span class="kw1">DI</span>                            <span class="co1">; Deshabilitamos las interrupciones</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="sy0">$</span>FEFF<span class="br0">)</span>, <span class="kw2">HL</span>                <span class="co1">; Guardamos en (65279 = $FEFF) la direccion</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">254</span>                     <span class="co1">; de la rutina ISR_ASM_ROUTINE</span>
  <span class="kw1">LD</span> I, <span class="kw2">A</span>                       <span class="co1">; Colocamos en I el valor $FE </span>
  <span class="kw1">IM</span> <span class="nu0">2</span>                          <span class="co1">; Saltamos al modo de interrupciones 2</span>
  <span class="kw1">EI</span>
&nbsp;
  <span class="br0">(</span>resto programa<span class="br0">)</span>
&nbsp;
&nbsp;
<span class="co1">;--- Rutina de ISR. ---------------------------------------------</span>
ISR_ASM_ROUTINE:
   <span class="kw1">PUSH</span> <span class="kw2">AF</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
&nbsp;
   <span class="br0">(</span><span class="kw2">c</span>ódigo <span class="kw2">de</span> la ISR<span class="br0">)</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">AF</span>
&nbsp;
   <span class="kw1">EI</span>
   <span class="kw1">RETI</span></pre>

<p>
 De esta forma, saltamos a IM 2 y el procesador se encargará de ejecutar
 la rutina ISR_ASM_ROUTINE 50 veces por segundo, por el siguiente
proceso:
</p>
<ul class="fix-media-list-overlap">
<li> La ULA provoca una señal de interrupción enmascarable INT.
</li>
<li> La ULA no coloca ningún device ID en el bus de datos; debido a las resistencias de pull-up, el bus de datos toma el valor $FF.
</li>
<li> El procesador termina de ejecutar la
 instrucción en curso y, si las interrupciones están actualmente
habilitadas procesa la interrupción.
</li>
<li> El procesador lee del bus de datos
el valor $FE y, al estar en modo IM 2, compone junto al registro una
dirección “$FEFF” (campo $FF dentro de la tabla de vectores de
interrupción que empieza en $FE*256 = $FE00).
</li>
<li> El procesador lee la dirección de 16
 bits que se compone con el contenido de las celdillas de memoria $FEFF y
 $FEFF+1 ($FF00). Esta dirección de 16 bits es la que hemos cargado
nosotros con “LD ($FEFF), HL” y que apunta a nuestra rutina ISR.
</li>
<li> El procesador salta a la dirección de 16 bits compuesta, que es la dirección de nuestra ISR.
</li>
<li> Se ejecuta la ISR, de la cual
salimos con EI+RETI, provocando la continuación de la ejecución del
programa original hasta la siguiente interrupción.
</li>
</ul>

<p>
 Como hemos dicho en el apartado sobre ISRs, es crítico que la tabla de
vectores de interrupción se ubique en una página alta de la RAM, es
decir; que no esté dentro del área comprendida entre los 16K y los 32K
que el procesador y la ULA comparten regularmente para que la ULA pueda
actualizar la pantalla. En todos los ejemplos que hemos visto y veremos,
 la dirección de la tabla de vectores de interrupción comienza a partir
de $FE00. Ubicarla a partir de $FF00 (que es la única página más alta
que $FE00) no sería una elección apropiada puesto que al necesitar una
tabla de 257 bytes para la ULA (device ID=$FF), parte de la dirección de
 salto se compondría con “$FFFF +1 = $0000” (la ROM).
</p>

<p>
 Con la teoría descrita hasta ahora ya tenemos los mecanismos para
realizar programas que dispongan de sus propias ISRs de servicio, como
los ejemplos que veremos a continuación.
</p>

<p>
<br>

</p>

</div>

<h2 id="ejemplos-y-aplicaciones">Ejemplos y aplicaciones</h2>
<div class="level2">

</div>

<h3 class="sectionedit17" id="control-de-ticks-segundos-y-minutos">Control de ticks, segundos y minutos</h3>
<div class="level3">

<p>
 A continuación se muestra un ejemplo completo de ISR que gestiona una serie de variables en memoria:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>abs_ticks</strong> : Esta
variable se incrementa en cada ejecución de la interrupción (es decir,
50 veces por segundo), y al ser de 16 bits se resetea a 0 al superar el
valor 65535. Puede ser muy útil como controlador de tiempo entre 2
sucesos que duren menos de 21 minutos (65535/50/60).</div>
</li>
<li><div class="li"> <strong>timer</strong>: Esta variable es igual que <strong>abs_ticks</strong>
 pero se decrementa en lugar de incrementarse. Existe para ser utilizada
 por ciertas funciones útiles que veremos más adelante en este mismo
capítulo.</div>
</li>
<li><div class="li"> <strong>ticks</strong> : Esta
variable se incrementa igual que abs_ticks en cada ejecución de la ISR
(50 veces por segundo), pero cuando su valor llega a 50 la seteamos a 0 y
 aprovechamos este cambio para incrementar la variable <strong>segundos</strong>.</div>
</li>
<li><div class="li"> <strong>seconds</strong> : Esta variable almacena segundos transcurridos. Sólo se incrementa cuando <strong>ticks</strong>
 vale 50, es decir, cuando han pasado 50 ticks que son 1 segundo. Cuando
 la variable llega a 60, se resetea a cero y se incrementa la variable <strong>minutes</strong>.</div>
</li>
<li><div class="li"> <strong>pause</strong> : Esta variable nos permite que la ISR no incremente el tiempo cuando estamos en “modo pausa”.</div>
</li>
<li><div class="li"> <strong>clock_changed</strong> :
Esta variable cambia de 0 a 1 cuando nuestra ISR ha modificado el
“reloj” interno formado por las variables minutos y segundos. La utiliza
 el bucle principal del programa para saber cuándo actualizar el reloj
en pantalla.</div>
</li>
</ul>

<p>
 Para ello generamos una ISR y la enlazamos con el modo 2 de interrupciones.
</p>

<p>
 Tras esto, nos mantenemos en un bucle de programa infinito que detecta cuándo la variable <strong>clock_changed</strong>
 cambia de 0 a 1 y que actualiza el valor en pantalla del reloj,
volviendo a setear dicha variable a 0 hasta que la ISR modifique de
nuevo el reloj. Cuando clock_changed vale 0, el programa se mantiene en
un simple bucle que no realiza acciones salvo comprobar el estado de
clock_changed continuamente. La ISR se ejecuta, por tanto, “en paralelo”
 a nuestro programa cuando las interrupciones solicitan la atención del
procesador, 50 veces por segundo.
</p>
<pre class="code z80"><span class="co1">; Ejemplo de ISR que gestiona un contador de ticks, minutos y segundos.</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="co1">; Instalamos la ISR:</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, CLOCK_ISR_ASM_ROUTINE
  <span class="kw1">DI</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="nu0">65279</span><span class="br0">)</span>, <span class="kw2">HL</span>                <span class="co1">; Guardamos en (65279 = $FEFF) la direccion</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">254</span>                     <span class="co1">; de la rutina CLOCK_ISR_ASM_ROUTINE</span>
  <span class="kw1">LD</span> I, <span class="kw2">A</span>
  <span class="kw1">IM</span> <span class="nu0">2</span>
  <span class="kw1">EI</span>
&nbsp;
Bucle_entrada:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>clock_changed<span class="br0">)</span>
  <span class="kw1">AND</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> Z, Bucle_entrada           <span class="co1">; Si clock_changed no vale 1, no hay</span>
                                <span class="co1">; que imprimir el mensaje -&gt; loop</span>
&nbsp;
  <span class="co1">; Si estamos aqui es que clock_changed = 1... lo reseteamos</span>
  <span class="co1">; e imprimimos por pantalla la información como MM:SS</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>clock_changed<span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; clock_changed = 0</span>
&nbsp;
  <span class="kw1">CALL</span> <span class="re0">0DAFh</span>                    <span class="co1">; Llamamos a la rutina de la ROM que</span>
                                <span class="co1">; hace un CLS y pone el cursor en (0,0)</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>minutes<span class="br0">)</span>               <span class="co1">; Imprimimos minutos + ":" + segundos</span>
  <span class="kw1">CALL</span> PrintInteger2Digits
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">":"</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>seconds<span class="br0">)</span>
  <span class="kw1">CALL</span> PrintInteger2Digits
&nbsp;
  <span class="kw1">JR</span> Bucle_entrada
&nbsp;
clock_changed DB <span class="re1">0</span>
ticks         DB <span class="re1">0</span>
seconds       DB <span class="re1">0</span>
minutes       DB <span class="re1">0</span>
pause         DB <span class="re1">0</span>
abs_ticks     DW <span class="re1">0</span>
timer         DW <span class="re1">0</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Rutina de ISR : incrementa ticks 50 veces por segundo, y el resto</span>
<span class="co1">; de las variables de acuerdo al valor de ticks.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
CLOCK_ISR_ASM_ROUTINE:
   <span class="kw1">PUSH</span> <span class="kw2">AF</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>pause<span class="br0">)</span>
   <span class="kw1">OR</span> <span class="kw2">A</span>
   <span class="kw1">JR</span> NZ, clock_isr_fin          <span class="co1">; Si pause==1, no continuamos la ISR</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>abs_ticks<span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="br0">(</span>abs_ticks<span class="br0">)</span>, <span class="kw2">HL</span>            <span class="co1">; Incrementamos abs_ticks (absolutos)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>timer<span class="br0">)</span>
   <span class="kw1">DEC</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="br0">(</span>timer<span class="br0">)</span>, <span class="kw2">HL</span>                <span class="co1">; Decrementamos timer (ticks absolutos)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>ticks<span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>ticks<span class="br0">)</span>, <span class="kw2">A</span>                 <span class="co1">; Incrementamos ticks (50 veces/seg)</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">5</span><span class="re1">0</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, clock_isr_fin           <span class="co1">; if ticks &lt; 50,  fin de la ISR</span>
                                 <span class="co1">; si ticks &gt;= 50, cambiar seg:min</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>ticks<span class="br0">)</span>, <span class="kw2">A</span>                 <span class="co1">; ticks = 0</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span>
   <span class="kw1">LD</span> <span class="br0">(</span>clock_changed<span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; ha cambiado el numero de segundos</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>seconds<span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>seconds<span class="br0">)</span>, <span class="kw2">A</span>               <span class="co1">; segundos = segundos +1</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">6</span><span class="re1">0</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, clock_isr_fin           <span class="co1">; si segundos &lt; 60 -&gt; salir de la ISR</span>
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>                         <span class="co1">; si segundos == 60 -&gt; inc minutos</span>
   <span class="kw1">LD</span> <span class="br0">(</span>seconds<span class="br0">)</span>, <span class="kw2">A</span>               <span class="co1">; segundos = 0</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>minutes<span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>minutes<span class="br0">)</span>, <span class="kw2">A</span>               <span class="co1">; minutos = minutos + 1</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">6</span><span class="re1">0</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, clock_isr_fin           <span class="co1">; si minutos &gt; 60 -&gt; resetear minutos</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>minutes<span class="br0">)</span>, <span class="kw2">A</span>               <span class="co1">; minutos = 0</span>
&nbsp;
clock_isr_fin:
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">AF</span>
&nbsp;
   <span class="kw1">EI</span>
   <span class="kw1">RETI</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; PrintInteger2Digits: Imprime en la pantalla un numero de 1 byte en</span>
<span class="co1">;        base 10, pero solo los 2 primeros digitos (0-99).</span>
<span class="co1">;        Para ello convierte el valor numerico en una cadena llamando</span>
<span class="co1">;        a Byte2ASCII_2Dig y luego llama a RST 16 para imprimir cada</span>
<span class="co1">;        caracter por separado.</span>
<span class="co1">;</span>
<span class="co1">; Entrada: A = valor a "imprimir" en 2 digitos de base 10.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
PrintInteger2Digits:
  <span class="kw1">PUSH</span> <span class="kw2">AF</span>
  <span class="kw1">PUSH</span> <span class="kw2">DE</span>
  <span class="kw1">CALL</span> Byte2ASCII_Dec2Digits     <span class="co1">; Convertimos A en Cadena Dec 0-99</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>                         <span class="co1">; Imprimimos primer valor HEX</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>                         <span class="co1">; Imprimimos segundo valor HEX</span>
&nbsp;
  <span class="kw1">POP</span> <span class="kw2">DE</span>
  <span class="kw1">POP</span> <span class="kw2">AF</span>
  <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Byte2ASCII_Dec2Digits: Convierte el valor del registro H en una </span>
<span class="co1">; cadena de texto de max. 2 caracteres (0-99) decimales.</span>
<span class="co1">;</span>
<span class="co1">; IN:   A = Numero a convertir</span>
<span class="co1">; OUT:  DE = 2 bytes con los ASCIIs</span>
<span class="co1">;</span>
<span class="co1">; Basado en rutina dtoa2d de:</span>
<span class="co1">; http://99-bottles-of-beer.net/language-assembler-%28z80%29-813.html</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Byte2ASCII_Dec2Digits:
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="st0">'0'</span>                      <span class="co1">; Starting from ASCII '0' </span>
   <span class="kw1">DEC</span> <span class="kw2">D</span>                          <span class="co1">; Because we are inc'ing in the loop</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="re1">10</span>                       <span class="co1">; Want base 10 please</span>
   <span class="kw1">AND</span> <span class="kw2">A</span>                          <span class="co1">; Clear carry flag</span>
&nbsp;
dtoa2dloop:
   <span class="kw1">INC</span> <span class="kw2">D</span>                          <span class="co1">; Increase the number of tens</span>
   <span class="kw1">SUB</span> <span class="kw2">E</span>                          <span class="co1">; Take away one unit of ten from A</span>
   <span class="kw1">JR</span> NC, dtoa2dloop              <span class="co1">; If A still hasn't gone negative, do another</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">E</span>                       <span class="co1">; Decreased it too much, put it back</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="st0">'0'</span>                     <span class="co1">; Convert to ASCII</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>                        <span class="co1">; Stick remainder in E</span>
   <span class="kw1">RET</span>
<span class="co1">;-----------------------------------------------------------------------</span>
&nbsp;
END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 La siguiente captura muestra la salida del anterior programa de ejemplo
 transcurridos 1 minuto y 5 segundos desde el inicio de su ejecución:
</p>

<p>
<a href="img/im_isrclock.png" class="media" title="cursos:ensamblador:im_isrclock.png"><img src="img/im_isrclock.png" class="mediacenter" alt=""></a>
</p>

<p>
 El programa anterior nos muestra algunos detalles interesantes:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>CALL 0DAFh</strong> y <strong>RST 16</strong>
 (CLS y PRINT-A): Podemos aprovechar las rutinas de la ROM (CLS, PLOT,
DRAW, PRINT-A) dentro de nuestros programas, evitando escribir más
código del necesario cuando la ROM ya provee de alguna rutina para ello.
 Por contra, esto hace nuestros programas no portables, ya que las
rutinas de la ROM del Spectrum no están presentes (al menos no en las
mismas direcciones y con los mismos parámetros de entrada y salida) en
otros sistemas basados en Z80 como el Amstrad o el MSX.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Byte2ASCII_Dec2Digits</strong> : Esta rutina permite convertir un valor numérico de 8 bits de 0 a 99 en 2 caracteres <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> para imprimir después con la rutina <strong>PrintInteger2Digits</strong>.</div>
</li>
</ul>

<p>
<br>

 Algo tan básico como disponer de un reloj interno de ticks, segundos y
minutos es sumamente importante para los juegos, puesto que podemos:
</p>
<ul class="fix-media-list-overlap">
<li> Temporizar el juego para
proporcionar al jugador un tiempo límite o informarle de cuánto tiempo
lleva transcurrido. La variable “pause” permite que la ISR no cuente el
tiempo cuando a nosotros nos interese detener el contaje (juego pausado
por el jugador, al mostrar escenas entre fase y fase o mensajes modales
en pantalla, etc).
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Utilizar la información de ticks
(como “timer” o “abs_ticks” y/o otras variables “temporales” que podemos
 agregar a la ISR) para que el tiempo afecte al juego. Esto permite, por
 ejemplo, para reducir el nivel de vida de un personaje con el tiempo,
etc.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Actualizar regularmente el buffer de
 “notas” del chip AY de los modelos de 128K para reproducir melodías AY
en paralelo a la ejecución de nuestro programa.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> Llevar un control exacto de ticks
para procesos de retardos con valores precisos. Es decir, si necesitamos
 hacer una espera de N ticks, o de N segundos (sabiendo que 50 ticks son
 1 segundo), podemos utilizar la variable de 16 bits “timer” que se
decrementa en cada ejecución de la ISR. Podemos así generar una rutina
WaitNTicks en la que establecer “timer” a un valor concreto y esperar a
que valga 0 (ya que será decrementado por la ISR).<br>
<br>
 En este ejemplo en lugar de esperar a que timer valga 0, esperamos a
que su byte alto valga FFh, en previsión de utilizarla en otros bloques
de código más largos en el que se nos pueda pasar el ciclo exacto en que
 timer sea igual a cero. Comprobando que el byte alto de timer sea FFh,
tenemos una rutina que nos permite tiempos de espera desde 1 tick hasta
49151/50/60=16 minutos. Veamos el siguiente ejemplo:<br>
</div>
</li>
</ul>
<pre class="code z80"><span class="co1">; Ejemplo de WaitNticks</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="co1">; Instalamos la ISR:</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, CLOCK_ISR_ASM_ROUTINE
  <span class="kw1">DI</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="nu0">65279</span><span class="br0">)</span>, <span class="kw2">HL</span>                <span class="co1">; Guardamos en (65279 = $FEFF) la direccion</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">254</span>                     <span class="co1">; de la rutina CLOCK_ISR_ASM_ROUTINE</span>
  <span class="kw1">LD</span> I, <span class="kw2">A</span>
  <span class="kw1">IM</span> <span class="nu0">2</span>
  <span class="kw1">EI</span>
&nbsp;
Bucle_entrada:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">"."</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">"5"</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">" "</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>                        <span class="co1">; Imprimimos por pantalla ".5 "</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">25</span>                     <span class="co1">; Esperamos 25 ticks (0.5 segundos)</span>
  <span class="kw1">CALL</span> WaitNTicks
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">"3"</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">" "</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>                        <span class="co1">; Imprimimos por pantalla "3 "</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">3</span><span class="sy0">*</span><span class="nu0">5</span><span class="re1">0</span>                   <span class="co1">; Esperamos 150 ticks (3 segundos)</span>
  <span class="kw1">CALL</span> WaitNTicks
&nbsp;
  <span class="kw1">JP</span> Bucle_entrada
&nbsp;
ticks         DB <span class="re1">0</span>
timer         DW <span class="re1">0</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; WaitNTicks: Esperamos N ticks de procesador (1/50th) en un bucle.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
WaitNTicks:
   <span class="kw1">LD</span> <span class="br0">(</span>timer<span class="br0">)</span>, <span class="kw2">HL</span>          <span class="co1">; seteamos "timer" con el tiempo de espera</span>
&nbsp;
Waitnticks_loop:           <span class="co1">; bucle de espera, la ISR lo ira decrementando</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>timer<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                 <span class="co1">; cuando (timer) valga 0 y lo decrementen, su</span>
   <span class="kw1">CP</span> <span class="sy0">$</span>FF                  <span class="co1">; byte alto pasara a valer FFh, lo que quiere</span>
                           <span class="co1">; decir que ha pasado el tiempo a esperar.</span>
   <span class="kw1">JR</span> NZ, Waitnticks_loop  <span class="co1">; si no, al bucle de nuevo.</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Rutina de ISR : incrementa ticks y decrementa timer 50 veces por seg.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
CLOCK_ISR_ASM_ROUTINE:
   <span class="kw1">PUSH</span> <span class="kw2">AF</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>timer<span class="br0">)</span>
   <span class="kw1">DEC</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="br0">(</span>timer<span class="br0">)</span>, <span class="kw2">HL</span>                <span class="co1">; Decrementamos timer (absolutos)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>ticks<span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>ticks<span class="br0">)</span>, <span class="kw2">A</span>                 <span class="co1">; Incrementamos ticks (50 veces/seg)</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">5</span><span class="re1">0</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, clock_isr_fin           <span class="co1">; if ticks &lt; 50,  fin de la ISR</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>                         <span class="co1">; si ticks &gt;= 50, cambiar seg:min</span>
   <span class="kw1">LD</span> <span class="br0">(</span>ticks<span class="br0">)</span>, <span class="kw2">A</span>                 <span class="co1">; y ticks = 0</span>
&nbsp;
clock_isr_fin:
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">AF</span>
   <span class="kw1">EI</span>
   <span class="kw1">RETI</span>
&nbsp;
END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 Este ejemplo muestra por pantalla la cadena de texto “.5 ” (con un
espacio al final) y después espera 25 ticks (0.5 segundos). A
continuación muestra la cadena “3 ” y espera 150 ticks (3 segundos).
Este proceso se repite en un bucle infinito.
</p>

<p>
<br>

<img src="img/im_wait.png" class="mediacenter" alt=" Ejemplo de espera con ISR "/>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Aprovechando las rutinas anteriores,
 y que tenemos disponible al procesador para, por ejemplo, chequear el
teclado, podemos agregar a nuestro programa funciones como la siguiente,
 la cual mantiene al procesador dentro de un bucle durante N segundos o
bien hasta el usuario pulse una tecla, permitiendo pantallas de
presentación o de créditos donde no es necesario obligar al usuario a
pulsar una tecla para avanzar, aunque siga existiendo esta posibilidad.
</li>
</ul>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; WaitKeyOrTime: Esperamos N ticks de procesador o una tecla.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
WaitKeyOrTime:
   <span class="kw1">LD</span> <span class="br0">(</span>timer<span class="br0">)</span>, <span class="kw2">HL</span>            <span class="co1">; seteamos "timer" con el tiempo de espera</span>
&nbsp;
Waitkeyticks_loop:           <span class="co1">; bucle de espera, la ISR lo ira decrementando</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">IN</span> <span class="kw2">A</span>,<span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
   <span class="kw1">OR</span> <span class="nu0">224</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>                     <span class="co1">; Comprobamos el estado del teclado</span>
   <span class="kw1">RET</span> NZ                    <span class="co1">; Si hay tecla pulsada, salimos</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>timer<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                   <span class="co1">; cuando (timer) valga 0 y lo decrementen, su</span>
   <span class="kw1">CP</span> <span class="sy0">$</span>FF                    <span class="co1">; byte alto pasara a valer FFh, lo que quiere</span>
                             <span class="co1">; decir que ha pasado el tiempo a esperar.</span>
   <span class="kw1">JR</span> NZ, Waitkeyticks_loop  <span class="co1">; si no, al bucle de nuevo.</span>
   <span class="kw1">RET</span></pre>

<p>
<br>

</p>

</div>

<h2 id="compatibilidad-de-nuestra-isr-en-timex-sinclair-y-con-otros-perifericos">Compatibilidad de nuestra ISR en Timex Sinclair y con otros periféricos</h2>
<div class="level2">

<p>
 Este apartado es extremadamente importante si pretendemos realizar
programas totalmente funcionales en otros modelos de Spectrum como los
TIMEX SINCLAIR vendidos en el continente Americano, o bien en modelos
estándar con dispositivos conectados al bus de expansión.
</p>

<p>
 Como ya hemos dicho, la ULA no está preparada para funcionar en IM 2 y
por lo tanto no coloca ningún valor en el bus de datos antes de generar
una señal de interrupción. Debido a las resistencias pull-up, el valor
“por defecto” de este bus es $FFh (11111111b), que es el valor que hemos
 utilizado en nuestros anteriores ejemplos para diseñar una ISR que se
ejecute las 50 (ó 60) veces por segundo que interrumpe la ULA al Z80A.
Es por eso que en los ejemplos anteriores estamos escribiendo la
dirección de nuestra ISR en ($FEFF y $FEFF+1).
</p>

<p>
 Por desgracia, si tenemos conectado algún dispositivo hardware mal
diseñado en el bus de expansión del Spectrum, el valor del bus ya no
tiene por qué ser $FFh sino que estos dispositivos externos pueden
provocar que dicho valor sea diferente. El mismo problema sucede en
ciertos modelos de Timex Sinclair, como por ejemplo el TS2068, el cual
no tiene las resistencias de pull-up conectadas a las líneas del bus de
datos por lo que el valor que aparezca en dicho bus puede ser totalmente
 arbitrario o aleatorio. Los programas anteriores de ejemplo, que
ubicaba la ISR en $FEFF (asumiendo el device-id de $FF), no tendría
asegurada la compatibilidad con este modelo.
</p>

<p>
 Con un valor aleatorio en el bus de datos, el procesador podría saltar a
 cualquiera de las direcciones de la tabla de vectores de interrupción.
</p>

<p>
 Una primera aproximación a solucionar este problema podría ser la de
introducir la misma dirección de salto (la de nuestra rutina ISR) en las
 128 direcciones de salto de la tabla de vectores. De esta forma, fuera
cual fuera el valor en el bus de datos, el procesador siempre saltaría a
 nuestra ISR.
</p>
<pre class="code">TABLA DE VECTORES DE INTERRUPCION

Posición   -  Valor
--------------------
($FE00)    -   $FE
($FE01)    -   $00
($FE02)    -   $FE
($FE03)    -   $00
(...)      -
($FEFF)    -   $FE
($FF00)    -   $00</pre>

<p>
 El problema es que tampoco podemos determinar si este valor aleatorio
en el bus es par o impar, de forma que si fuera par saltaría a la
dirección correcta de uno de los vectores ($FE00), mientras que si fuera
 impar saltaría a una dirección incorrecta compuesta por parte de la
dirección de un device-id, y parte de la dirección del otro ($00FE),
como ya vimos en un apartado anterior.
</p>

<p>
 La forma de solucionar esta problemática es bastante curiosa y
original: basta con ubicar nuestra ISR en una dirección “capicúa”, donde
 coincidan la parte alta y la parte baja de la misma, y rellenar la
tabla de vectores de interrupción con este valor. Por ejemplo, en el
compilador de C z88dk y la librería SPlib se utiliza para su ISR la
dirección $F1F1. De esta forma, la tabla de vectores de interrupción se
llena con 257 valores “$F1”. Así, sea cual sea el valor que tome el bus
de datos cuando se recibe la interrupción (y sea par o impar), el
procesador siempre saltará a $F1F1, donde estará nuestra ISR.
</p>
<pre class="code">TABLA DE VECTORES DE INTERRUPCION

Posición   -  Valor
--------------------
($FE00)    -   $F1
($FE01)    -   $F1
($FE02)    -   $F1
($FE03)    -   $F1
(...)      -   $F1
($FEFF)    -   $F1
($FF00)    -   $F1</pre>

<p>
 La pega de este sistema es que convertimos al versátil modo IM 2 con
posibilidad de ejecutar hasta 128 ISRs diferentes que atiendan cada una a
 su periférico correspondiente en una evolución del IM 1 (donde siempre
se saltaba a $0038), pero en la cual la dirección de salto está fuera de
 la ROM y es personalizable. Este “IM 1 mejorado” lo que nos permite es
funcionar como en IM1 pero con nuestra propia ISR única. De hecho, esta
es la forma más habitual de utilizar IM 2.
</p>

<p>
 La única desventaja es que en esta ISR deberemos gestionar todas las
interrupciones de cualquier periférico basado en interrupciones que
queramos que interactúe con nuestro programa, aunque en el 99% de los
programas o juegos (a excepción del uso del AMX mouse o similares) no se
 suele interactuar con los periféricos mediante este sistema.
</p>

<p>
 Resumamos lo que acabamos de ver y comprender de forma esquemática las
ventajas de una tabla de 257 bytes con el valor $F1 en cada elemento de
la misma:
</p>
<ol class="fix-media-list-overlap">
<li> Por lo que hemos visto hasta ahora,
en un Spectrum estándar sin dispositivos en el bus de expansión la ULA
se identifica al interrumpir el procesador como $FF, aunque no
intencionadamente pues es el resultado del valor por defecto que hay en
el bus de datos cuando no se coloca ningún dato debido a las
resistencias de pull-up.
</li>
<li> En nuestras anteriores rutinas
guardábamos en FEFFh la dirección de la rutina de ISR que queríamos que
se ejecutara cuando la interrupcion se identificaba con ID $FF (la ULA).
</li>
<li> Cargábamos I con 256 (FE) antes de
saltar a IM2, de esta forma cuando la ULA producía una interrupción con
id $FFh se saltaba a la direccion que había en ($FEFF), que era la de
nuestra ISR.
</li>
<li> Por desgracia, en ciertos modelos
Timex Sinclair o si tenemos dispositivos conectados al bus de expansion
puede que no encontremos $FF en el bus de datos, sino un valor
arbitrario. Esto puede producir que la interrupcion no llegue como
“ID=FF” y que, por lo tanto, no se produzca el salto a ($FEFF) sino a
otro de los elementos de la tabla de vectores de interrupcion.
</li>
<li> Para evitar que esto ocurra, podemos
 generar una tabla de 257 bytes y llenarla con el valor “$F1”. De esta
forma, sea cual sea el valor leído en el bus de datos, se saltará a
$F1F1 (ya sea par o impar el valor del bus, las 2 partes de la dirección
 de salto en la tabla siempre sería $F1 + $F1).
</li>
<li> Nuestra ISR deberá de estar pues en
$F1F1 y ser la responsable de gestionar cualquier periferico que pueda
haber generado la interrupción.
</li>
</ol>

<p>
<br>

 A continuación podemos ver cómo sería el esqueleto del programa de
ejemplo de reloj temporizador visto anteriormente utilizando una ISR
diseñada para funcionar aunque existan dispositivos conectados al bus de
 expansión que modifiquen el valor del mismo cuando no haya datos en él.
</p>
<pre class="code z80"><span class="co1">; Ejemplo de ISR que gestiona un contador de ticks, minutos y segundos.</span>
<span class="co1">; Este sistema de definir la ISR y saltar a IM2 es el mas compatible</span>
<span class="co1">; con todos los modelos de Sinclair Spectrum y dispositivos conectados.</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="co1">; Generamos una tabla de 257 valores "$F1" desde $FE00 a $FF00</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="sy0">$</span>FE<span class="re1">00</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>F<span class="re1">1</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                    <span class="co1">; Cargamos $F1 en $FE00 </span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="sy0">$</span>FE<span class="re1">01</span>                  <span class="co1">; Apuntamos DE a $FE01</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">256</span>                    <span class="co1">; Realizamos 256 LDI para copiar $F1</span>
  <span class="kw1">LDIR</span>                          <span class="co1">; en toda la tabla de vectores de int.</span>
&nbsp;
  <span class="co1">; Instalamos la ISR:</span>
  <span class="kw1">DI</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">254</span>                     <span class="co1">; Definimos la tabla a partir de $FE00.</span>
  <span class="kw1">LD</span> I, <span class="kw2">A</span>
  <span class="kw1">IM</span> <span class="nu0">2</span>                          <span class="co1">; Saltamos a IM2</span>
  <span class="kw1">EI</span>
&nbsp;
  : <span class="sy0">---------------------------------------------------------------</span>
  <span class="co1">; (aqui insertamos el codigo del programa, incluidas subrutinas)</span>
  : <span class="sy0">---------------------------------------------------------------</span>
&nbsp;
&nbsp;
<span class="co1">; A continuación la rutina ISR, ensamblada en $F1F1:</span>
<span class="co1">;</span>
<span class="co1">; Con el ORG $F1F1 nos aseguramos de que la ISR sera ensamblada</span>
<span class="co1">; por el ensamblador a partir de esta direccion, que es donde queremos</span>
<span class="co1">; que este ubicada para que el salto del procesador sea a la ISR.</span>
<span class="co1">; Asi pues, todo lo que siga a este ORG se ensamblara para cargarse</span>
<span class="co1">; a partir de la direccion $F1F1 de la RAM.</span>
&nbsp;
ORG <span class="sy0">$</span>F<span class="re1">1</span>F<span class="re1">1</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Rutina de ISR : incrementa ticks 50 veces por segundo, y el resto</span>
<span class="co1">; de las variables de acuerdo al valor de ticks.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
CLOCK_ISR_ASM_ROUTINE:
   <span class="kw1">PUSH</span> <span class="kw2">AF</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
&nbsp;
   <span class="co1">; (... aqui insertamos el resto de la ISR...)</span>
&nbsp;
clock_isr_fin:
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">AF</span>
&nbsp;
   <span class="kw1">EI</span>
   <span class="kw1">RETI</span>
&nbsp;
<span class="co1">; Si vamos a colocar mas codigo en el fichero ASM detra de la ISR; este</span>
<span class="co1">; sera ensamblado en direcciones a partir del final de la ISR en memoria</span>
<span class="co1">; (siguiendo a la misma). Como seguramente no queremos esto, es mejor ubicar</span>
<span class="co1">; la ISR con su ORG $F1F1 al final del listado, o bien enlazarla como</span>
<span class="co1">; un binario aparte junto al resto del programa, o bien colocar otro ORG</span>
<span class="co1">; tras las ISR y antes de la siguiente rutina a ensamblar.</span>
&nbsp;
END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 El “ORG $F1F1” indica al assembler (pasmo en este caso) que debe
ensamblar todo lo que va detrás de esta directiva a partir de la
dirección de memoria indicada. En el ejemplo anterior hemos ubicado la
rutina de ISR al final del programa, puesto que si seguimos añadiendo
código tras la ISR, esté será ensamblado en ($F1F1 + TAMAÑO_ISR). Si no
queremos que la ISR esté al final del listado fuente, podemos utilizar
las siguientes directivas de pasmo para continuar el ensamblado de más
rutinas a partir de la dirección inmediatamente anterior al ORG:
</p>
<pre class="code z80"><span class="co1">; Recuperando una posicion de ensamblado</span>
ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
 <span class="co1">; Nuestro programa</span>
 <span class="co1">; (...)</span>
&nbsp;
 <span class="co1">; Guardamos en una variable de preprocesador la posicion</span>
 <span class="co1">; de este punto en el proceso de ensamblado ($)</span>
 PUNTO_ENSAMBLADO <span class="kw3">EQU</span> <span class="sy0">$</span>
&nbsp;
<span class="co1">;----------------------------------------------------</span>
<span class="co1">; Nuestra rutina de ISR ensamblada en $F1F1 debido</span>
<span class="co1">; a la directiva ORG $F1F1</span>
<span class="co1">;----------------------------------------------------</span>
ORG <span class="sy0">$</span>F<span class="re1">1</span>F<span class="re1">1</span>
Rutina_ISR:
  <span class="co1">; La rutina ISR</span>
&nbsp;
&nbsp;
ORG PUNTO_ENSAMBLADO
<span class="co1">;----------------------------------------------------</span>
<span class="co1">; El codigo continua pero no ensamblado tras $F1F1</span>
<span class="co1">; sino en la direccion anterior al ORG</span>
<span class="co1">;----------------------------------------------------</span>
Mas_Rutinas:
  <span class="co1">; Resto del programa</span></pre>

<p>
 El listado completo del ejemplo está disponible para su descarga al
final del capítulo, pero es esencialmente igual al primer ejemplo de
reloj interno basado en ISR con ciertas excepciones:
</p>
<ul class="fix-media-list-overlap">
<li> La rutina de ISR se ensambla en
$F1F1 mediante una directiva del ensamblador ORG $F1F1 antes de la
misma, lo cual hace que en el programa resultante, dicho código se
ubique a partir de $F1F1.
</li>
<li> Se genera en $FE00 una tabla de 257
bytes conteniendo el valor $F1, para que la dirección de salto de una
interrupción sea siempre $F1F1 independientemente de cuál sea el valor
del device_id en el bus de datos (sea también par o impar).
</li>
</ul>

<p>
 De esta forma nuestra ISR será compatible con los diferentes modelos de
 Sinclair Spectrum con o sin periféricos conectados al bus de expansión.
</p>

<p>
 Otros autores de libros sobre programación (y a su vez programadores),
como David Webb, proponen la utilización de $FDFD como vector de salto, y
 colocar en esta dirección un JP a la dirección de la rutina real.
Nótese que $FDFD está 3 bytes en memoria antes que $FE00, por lo que de
esta forma se puede tener el salto a la ISR junto a la tabla de vectores
 de interrupción, consecutivos en memoria. No obstante, esto añade 10
t-estados adicionales a la ejecución de la ISR, los relativos al salto, y
 no nos es de especial utilidad dada la posibilidad de los ensambladores
 cruzados de ubicar nuestra ISR en $F1F1 mediante la directiva ORG.
</p>

<p>
<br>

</p>

</div>

<h2 id="curiosidades-y-consideraciones">Curiosidades y consideraciones</h2>
<div class="level2">

<p>
<br>

</p>

</div>

<h3 class="sectionedit20" id="teclado-y-el-cassette-por-interrupciones">Teclado y el cassette por interrupciones</h3>
<div class="level3">

<p>
 Estando conectados los puertos de teclado y de unidad de cassette y
disco a la ULA, el lector podría preguntarse por qué las pulsaciones de
teclado o la entrada de datos desde estos dispositivos de almacenamiento
 no se gestionan mediante interrupciones.
</p>

<p>
 Lamentablemente, en el caso del ZX Spectrum no se gestiona la pulsación
 de teclas ni la E/S del cassette mediante interrupciones, sino que la
ULA proporciona al procesador acceso al estado de estos componentes
directamente mediante operaciones de I/O (instrucciones Z80 IN/OUT).
</p>

<p>
 Las instrucciones de acceso al cassette, por ejemplo, requieren tanta
cantidad de tiempo de ejecución del procesador que no sería factible
tratarlo en una ISR de interrupción, sobre todo en un microprocesador
con la “escasa” potencia del Z80 y a 3.50 Mhz.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit21" id="el-bug-de-la-isr-de-nmi-en-la-rom">El bug de la ISR de NMI en la ROM</h3>
<div class="level3">

<p>
 Resulta especialmente curioso el motivo por el cual las interrupciones
NMI son generalmente de nula utilidad en el Spectrum salvo para provocar
 un reset. Como ya hemos dicho, al recibirse una NMI se realiza un salto
 a $0066 donde hay un bloque de código “ISR” especial de la ROM el cual,
 en teoría, estaba preparado para permitir la ejecución de una subrutina
 propia cuya dirección ubicaramos en la dirección de memoria $5CB0, a
menos que el contenido de $5CB0 fuera 0, que provocaría un retorno de la
 NMI.
</p>

<p>
Por desgracia, un bug en esta subrutina acabó dejándola inservible salvo
 en el caso de ubicar un cero en esta variable del sistema, con RESET
como única consecuencia.
</p>
<pre class="code z80"><span class="co1">; THE 'NON-MASKABLE INTERRUPT' ROUTINE</span>
<span class="co1">; This routine is not used in the standard Spectrum but the code</span>
<span class="co1">; allows for a system reset to occur following activation of the</span>
<span class="co1">; NMI line. The system variable at 5CB0, named here NMIADD, has</span>
<span class="co1">; to have the value zero for the reset to occur.</span>
<span class="re1">00</span><span class="nu0">66</span> RESET:       <span class="kw1">PUSH</span>  <span class="kw2">AF</span>                  <span class="co1">; Save the current values held</span>
                  <span class="kw1">PUSH</span>  <span class="kw2">HL</span>                  <span class="co1">; in these registers.</span>
                  <span class="kw1">LD</span>    <span class="kw2">HL</span>,<span class="br0">(</span><span class="sy0">$</span>5CB<span class="re1">0</span><span class="br0">)</span>          <span class="co1">; The two bytes of NMIADD</span>
                  <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">H</span>                 <span class="co1">; must both be zero for the reset</span>
                  <span class="kw1">OR</span>    <span class="kw2">L</span>                   <span class="co1">; to occur.</span>
                  <span class="kw1">JR</span>    NZ,<span class="sy0">$</span><span class="re1">00</span><span class="nu0">7</span><span class="re1">0</span>            <span class="co1">; Note: This should have been JR Z!</span>
                  <span class="kw1">JP</span>    <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Jump to START.</span>
<span class="re1">00</span><span class="nu0">7</span><span class="re1">0</span> NO<span class="sy0">-</span>RESET     <span class="kw1">POP</span>   <span class="kw2">HL</span>                  <span class="co1">; Restore the current values to</span>
                  <span class="kw1">POP</span>   <span class="kw2">AF</span>                  <span class="co1">; these registers and return.</span>
                  <span class="kw1">RETN</span></pre>

<p>
 La instrucción “<strong>JR NZ, $0070</strong>” debería haber sido un “<strong>JR Z, $0070</strong>” para permitir un “<strong>JP ($5CB0)</strong>” al recibir una NMI.
</p>

<p>
 Este bug estaba presente en la primera versión de la ROM del Spectrum y
 no fue corregido en futuras versiones, entendemos que para preservar la
 compatibilidad hacia atrás y evitar que aparecieran dispositivos
hardware que no funcionara en revisiones del Spectrum con el bug en su
ROM.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit22" id="modo-im-2-en-spectrum-16k">Modo IM 2 en Spectrum 16K</h3>
<div class="level3">

<p>
 Como ya hemos comentado, la ULA y el procesador compiten en uso por la
zona de memoria comprendida entre los 16K y los 32K, por lo que es
crítico ubicar el vector de interrupciones en un banco de memoria por
encima de los 32K (típicamente, en $FE00).
</p>

<p>
 Lamentablemente, en los modelos de 16KB de memoria sólo tenemos
disponible la famosa página de 16KB entre $4000 y $7FFF que se ve
afectada por las lecturas de memoria de la ULA.
</p>

<p>
 Aunque no es habitual diseñar programas para los modelos de Spectrum de
 16KB, Miguel A. Rodríguez Jódar nos aporta una solución basada en
apuntar el registro I a la ROM de tal forma que (I*256)+$FF proporcione
un valor de la ROM cuyo contenido sea una dirección de memoria física en
 RAM disponible para ubicar nuestra ISR. Para poder realizar este
pequeño truco es importante saber que el valor del bus de datos durante
la interrupción será $FF, es decir, saber que no hay dispositivos mal
diseñados conectados al bus de expansión que puedan alterar el valor del
 bus de datos:
</p>

<p>
 Citando a Miguel A.:
</p>

<p>
<br>

<em>La idea es poner un valor a I que esté comprendido entre 00h y 3Fh.
Esto, claro está, hace que I apunte a la ROM, y que por tanto la
dirección final de salto tenga que estar en la ROM. ¿Y esto plantea
alguna dificultad? No, si encontramos algún valor de I tal que la
posición I*256+255 contenga un valor de 16 bits (la dirección final de
la ISR) que esté entre 4000h y 7FFFh.</em>
</p>

<p>
<em>El siguiente programa en BASIC escanea la ROM probando todas las
combinaciones de I posibles entre 0 y 63, y muestra en pantalla la
dirección en la que debería comenzar la ISR para los valores válidos que
 encuentre:</em>
</p>

<p>
<img src="img/busqueda_i.png" class="mediacenter" alt=" Búsqueda de direcciones en la ROM "/>
</p>

<p>
<em>El resultado, con la ROM estándar del Spectrum 16/48K, es éste:</em>
</p>

<p>
<img src="img/result_busqueda_i.png" class="mediacenter" alt=" Búsqueda de direcciones en la ROM "/>
</p>

<p>
 <em>Así, por ejemplo, se puede escribir una rutina IM 2 para un programa de 16K, así:</em>
</p>
<pre class="code z80">  <span class="kw1">LD</span> I, <span class="nu0">4</span><span class="re1">0</span>
  <span class="kw1">IM</span> <span class="nu0">2</span>
  ... resto del programa...
&nbsp;
  ORG <span class="nu0">32348</span>
  ...aqui va la ISR...</pre>

<p>
 <em>Aunque se use este sistema, hay aún un “peligro” oculto, aunque
considero que es de menor relevancia, al menos hoy día. Es el hecho de
que los periféricos “copiones” tipo Transtape y similares, usados en un
Spectrum real para crear un snapshot, no pueden saber si el micro está
en modo IM1 o IM2. Pueden saber si las interrupciones estaban
habilitadas o no consultando el valor del flip-flop IFF2 al que se
accede mediante el bit de paridad del registro F tras ejecutar una
instrucción LD A,I ó LD A,R , pero no se puede saber directamente si el
micro está en modo IM 0, IM1 ó IM 2.</em>
</p>

<p>
<em>En un emulador que cree snapshosts esto no es un problema, pero en
un Spectrum real sí. Los “copiones” usan un método puramente heurístico
que consiste en ver el valor de I: si dicho valor es mayor que 63,
entonces asumen que el programa lo ha modificado con la intención de
usar su propia ISR, por lo que graban el snapshot indicando que el micro
 estaba en modo IM 2. En cualquier otro caso, asumen IM 1.</em>
</p>

<p>
<em>Habría que ver el código de la ROM de los copiones más populares
para ver qué condición chequean, ya que la otra opción es que asuman IM 1
 sólamente cuando I valga 63 (el valor que la ROM pone por defecto) y
asuman IM 2 en cualquier otro caso. Si es así como lo hacen, un snapshot
 de 16K con interrupciones se generará con la información correcta.</em>
<br>

</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/im_isrclock.asm">Ejemplo de ISR con control de ticks y temporizador</a>
</li>
<li><a href="src/im_isrclock.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/im_wait.asm">Ejemplo de rutina de espera con ISR</a>
</li>
<li><a href="src/im_wait.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/im_isrgeneric.asm">Ejemplo de rutina de espera con ISR compatible TIMEX</a>
</li>
<li><a href="src/im_isrgeneric.tap">Tap del ejemplo anterior</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a>.</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/z80undoc3.txt" class="urlextern" title="external/www.z80.info/z80undoc3.txt">z80undoc3.txt en z80.info</a>.</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/interrup2.htm" class="urlextern" title="external/www.z80.info/interrup2.htm">El bit 0 en IM2</a>.</div>
</li>
<li><div class="li"> <a href="http://www.z88dk.org/wiki/doku.php?id=library:interrupts" class="urlextern" title="http://www.z88dk.org/wiki/doku.php?id=library:interrupts">Interrupciones en Z88DK</a>.</div>
</li>
<li><div class="li"> The Complete Spectrum ROM Disassembly <a href="ftp://ftp.worldofspectrum.org/pub/sinclair/books/CompleteSpectrumROMDisassemblyThe.txt" class="urlextern" title="ftp://ftp.worldofspectrum.org/pub/sinclair/books/CompleteSpectrumROMDisassemblyThe.txt">TXT</a> y <a href="ftp://ftp.worldofspectrum.org/pub/sinclair/books/CompleteSpectrumROMDisassemblyThe.pdf" class="urlextern" title="ftp://ftp.worldofspectrum.org/pub/sinclair/books/CompleteSpectrumROMDisassemblyThe.pdf">PDF</a>.</div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a>.</div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a>.</div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a>.</div>
</li>
</ul>

<p>
<br>

</p>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="paginacion-de-memoria-128k">Paginación de memoria 128K</h1>
<div class="level1">

<p>
 Si el bus de direcciones del Spectrum es de 16 bits y por lo tanto sólo
 puede acceder a posiciones de memoria entre 0 y 65535… ¿cómo se las
arreglan los modelos de 128KB para acceder a la memoria situada entre
las celdillas 65535 y 131071? La respuesta es un mecanismo tan simple
como ingenioso: se utiliza una técnica conocida como <em>paginación de memoria</em>.
</p>

<p>
 En este artículo aprenderemos a aprovechar los 128K de memoria de que
disponen los modelos de Spectrum 128K, +2, +2A y +3. Gracias a la
paginación nos saltaremos la limitación de direccionamiento de 64K del
microprocesador Z80 para acceder a la totalidad de la memoria
disponible.
</p>

<p>
<br>

</p>

</div>

<h2 id="paginacion">Paginación</h2>
<div class="level2">

<p>
 Los modelos de Spectrum 128K, +2, +2A, +2B y +3 disponen de 128KB de
memoria, aunque no toda está disponible simultáneamente. Al igual que en
 el modelo de 48KB, el microprocesador Z80 sólo puede direccionar
64K-direcciones de memoria, por lo que para acceder a esta memoria
“extra”, se divide en bloques de 16KB y se “mapea” (pagina) sobre la
dirección de memoria $c000.
</p>

<p>
 ¿Qué quiere decir esto? Que nuestro procesador, con un bus de
direcciones de 16 bits, sólo puede acceder a la memoria para leer las
“celdillas” entre $0000 y $FFFF (0-65535). Para leer casillas de memoria
 superiores a 65535, harían falta más de 16 bits de direcciones, ya que
65535 es el mayor entero que se puede formar con 16 bits
(1111111111111111b).
</p>

<p>
 Así que … ¿cómo hacemos para utilizar más de 64KB de memoria si nuestro
 procesador sólo puede leer datos de la celdilla 0, 1, 2, 3 … 65534 y
65535? La respuesta es: <strong>mediante la paginación</strong>.
</p>

<p>
 Los 64KB de memoria del Spectrum, se dividen en 4 bloques de 16KB. El
primer bloque ($0000 - $4000) está mapeado sobre la ROM del Spectrum.
Accediendo a los bytes desde $0000 a $3FFF de la memoria estamos
accediendo a los bytes $0000 a $3FFF del “chip (físico)” de 16K de
memoria  que almacena la ROM del Spectrum. Se dice, pues, que la ROM
está mapeada (o paginada) sobre $0000 en el mapa de memoria.
</p>

<p>
 Dejando la ROM de lado (16KB), los 48KB de memoria restantes están
formados por 3 bloques de 16KB. El segundo bloque de 16K de memoria
(primero de los 3 que estamos comentando), en el rango $4000 a $7FFF
está mapeado sobre el “chip de memoria” que almacena el área de pantalla
 del Spectrum. El tercero ($8000 a $BFFFF) es memoria de propósito
general (normalmente cargaremos nuestros programas aquí).
</p>

<p>
 El bloque que nos interesa a nosotros es el cuarto. La zona final del
área de memoria, desde $C000 a $FFFF, es nuestra “ventana” hacia el
resto de memoria del 128K. Dividiendo los 128KB de memoria en bloques de
 16KB, tendremos 8 bloques que podremos “montar” (o paginar) sobre el
área $C000 a $FFFF.
</p>

<p>
 Veamos una figura donde se muestra el estado del <strong>mapa de memoria</strong> del Spectrum:
</p>

<p>
<br>

<img src="img/mapa_memoria.png" class="mediacenter" alt=" Mapa de memoria "/>
<br>

</p>

<p>
 Cualquiera de los 8 bloques de 16KB (128 KB / 16 KB = 8 bloques) puede
ser “mapeado” en los 16Kb que van desde $c000 a $ffff, y podremos
cambiar este mapeo de un bloque a otro mediante instrucciones I/O
concretas.
</p>

<p>
 La última porción de 16KB de la memoria es, pues, una “ventana” que
podemos deslizar para que nos dé acceso a cualquiera de los 8 bloques
disponibles. Esto nos permite “paginar” el bloque 0 y escribir o leer
sobre él, por ejemplo. El byte 0 del bloque 0 se accede a través de la
posición de memoria $C000 una vez paginado, el byte 1 desde $C0001, y
así hasta el byte 16383, al que accedemos mediante $FFFF.
</p>

<p>
 Si paginamos el bloque 1 en nuestra ventana $C000-$FFFF, cuando
accedamos a este rango de memoria, ya no accederíamos a los mismos datos
 que guardamos en el banco 0, sino a la zona de memoria “Banco 1”. Es
posible incluso mapear la zona de pantalla (Banco 5), de forma que las
direcciones $4000 y $C000 serían equivalentes: los 8 primeros píxeles de
 la pantalla.
</p>

<p>
 El mapa de memoria del Spectrum con los bloques mapeables/paginables sobre $C000 es el siguiente:
</p>

<p>
<br>

<img src="img/pag_normal.png" class="mediacenter" alt=" Paginación de los modelos 128K/+2 "/>
</p>

<p>
<br>

</p>

</div>

<h2 id="cambiando-de-banco">Cambiando de banco</h2>
<div class="level2">

<p>
 El puerto que controla la paginación en los modelos 128K es el $7FFD.
En realidad, nuestro Spectrum sólo decodifica los bits 1 y 15, por lo
que cualquier combinación con los bits 1 y 15 a cero accederá a la
gestión de paginación. No obstante, se recomiente utilizar $7FFD por
compatibilidad con otros sistemas.
</p>

<p>
 La lectura del puerto $7FFD no devolverá ningún valor útil, pero sí podemos escribir en él un valor con cierto formato:
</p>
<div class="table-responsive sectionedit4"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bits </th><th class="col1"> Significado </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0-2 </td><td class="col1"> Página de la RAM (0-7) a mapear en el bloque $c000 - $ffff. </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 3 </td><td class="col1"> Visualizar la pantalla gráfica “normal” (0) o shadow (1).<br>
La pantalla normal está en el banco 5, y la shadow en el 7.<br>
Aunque cambiemos a la visualización de la pantalla shadow,<br>
la pantalla “normal” RAM5 seguirá mapeada entre $4000 y $7fff.<br>
No es necesario tener mapeada la pantalla shadow<br>
para que pueda ser visualizado su contenido. </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 4 </td><td class="col1"> Selección de la ROM, entre (0) ROM BASIC 128K (Menú y editor), y (1) BASIC 48K. </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 5 </td><td class="col1"> Si lo activamos, se desactivará el paginado de memoria hasta que se resetee el<br>
Spectrum. El hardware ignorará toda escritura al puerto $7FFD. </td>
	</tr>
</tbody></table></div>

<p>
 A la hora de cambiar de página de memoria hay que tener en cuenta lo siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> La pila (stack) debe de estar
ubicada en una zona de memoria que no vaya a ser paginada (no puede
estar dentro de la zona que va a cambiar).
</li>
<li> Las interrupciones deben de estar deshabilitadas para realizar el cambio de banco.
</li>
<li> Si se va a ejecutar código con
interrupciones (y no pueden estar deshabilitadas), entonces debemos
actualizar la variable del sistema $5B5C (23388d) con el último valor
enviado al puerto $7FFD.
</li>
</ul>

<p>
 Un ejemplo de cambio de banco en ASM:
</p>
<pre class="code z80">     <span class="kw1">LD</span>      <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>5b5c<span class="br0">)</span>      <span class="co1">; Valor previo del puerto (variable del sistema)</span>
     <span class="kw1">AND</span>     <span class="sy0">$</span>f8             <span class="co1">; Cambia sólo los bits que debas cambiar</span>
     <span class="kw1">OR</span>      <span class="nu0">4</span>               <span class="co1">; Seleccionar banco 4</span>
     <span class="kw1">LD</span>      <span class="kw2">BC</span>, <span class="sy0">$</span>7ffd       <span class="co1">; Colocamos en BC el puerto a</span>
     <span class="kw1">DI</span>                      <span class="co1">; Deshabilitamos las interrupciones</span>
     <span class="kw1">LD</span>      <span class="br0">(</span><span class="sy0">$</span>5b5c<span class="br0">)</span>, <span class="kw2">A</span>      <span class="co1">; Actualizamos la variable del sistema</span>
     <span class="kw1">OUT</span>     <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>, <span class="kw2">A</span>          <span class="co1">; Realizamos el paginado</span>
     <span class="kw1">EI</span></pre>

<p>
 Podemos crearnos una rutina lista para usar con este código, como la que sigue:
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; SetRAMBank: Establece un banco de memoria sobre $c000</span>
<span class="co1">; Entrada   : B = banco (0-7) a paginar entre $c000-$ffff</span>
<span class="co1">; Modifica  : A, B, C</span>
<span class="co1">;-----------------------------------------------------------------------</span>
SetRAMBank:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>5b5c<span class="br0">)</span>      <span class="co1">; Valor previo del puerto (variable del sistema)</span>
   <span class="kw1">AND</span> <span class="sy0">$</span>f8             <span class="co1">; Cambia sólo los bits que debas cambiar</span>
   <span class="kw1">OR</span> <span class="kw2">B</span>               <span class="co1">; Seleccionar banco "B"</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>7ffd       <span class="co1">; Colocamos en BC el puerto a</span>
   <span class="kw1">DI</span>                      <span class="co1">; Deshabilitamos las interrupciones</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="sy0">$</span>5b5c<span class="br0">)</span>, <span class="kw2">A</span>      <span class="co1">; Actualizamos la variable del sistema</span>
   <span class="kw1">OUT</span> <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>, <span class="kw2">A</span>          <span class="co1">; Realizamos el paginado</span>
   <span class="kw1">EI</span>
   <span class="kw1">RET</span></pre>

<p>
 Un detalle apuntado por la documentación de World Of Spectrum es que
los bancos 1, 3, 5 y 7 son “contended memory”, lo que quiere decir que
se reduce ligeramente la velocidad de acceso a estos bancos con respecto
 a los otros bancos. Un apunte muy importante es que en el caso del +2A y
 +3, los bancos de contended-memory ya no son el 1, 3, 5 y 7, sino los
bloques 4, 5, 6 y 7. Al final de este capítulo veremos con más detalle
qué es la contended-memory y en qué puede afectar a nuestros programas.
</p>

<p>
<br>

</p>

</div>

<h2 id="particularidades-2a3">Particularidades +2A/+3</h2>
<div class="level2">

<p>
 En el caso del +2A y +3 hay que tener en cuenta una serie de detalles
“extra” a lo visto anteriormente, y es que estos 2 modelos tienen un
modo de paginación especial, aunque siguen siendo compatible con el
sistema de paginación que hemos visto. Por eso estos detalles que
veremos a continuación son opcionales, ya que podemos utilizar el modo
de paginación de la misma forma que en el +2 y 128K (paginación normal):
</p>
<ul class="fix-media-list-overlap">
<li> Los bancos de contended-memory son los bloques 4, 5, 6 y 7 (no el 1, 3, 5 y 7).
</li>
<li> +2A y +3 tienen 4 ROMS en lugar de
2, por lo que el bit 4 del puerto $7FFD se convierte ahora en el bit
bajo de la ROM a seleccionar, mientras que el bit alto se toma del bit
2.
</li>
<li> +2A y +3 tienen funcionalidades extra de paginado, que se controlan con el puerto $1FFD.
</li>
</ul>

<p>
 Este puerto (el $1FFD) tiene el siguiente significado a la hora de escribir en él:
</p>
<div class="table-responsive sectionedit6"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bits </th><th class="col1"> Significado </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> Modo de paginado (0=normal, 1=especial) </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> Ignorado en el modo normal, usando en el modo especial. </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> En modo normal, bit alto de la selección de ROM.<br>
Usado de forma diferente en el modo especial. </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3-4 </td><td class="col1"> 3=Motor del disco (1/0, ON/OFF), 4=Impresora </td>
	</tr>
</tbody></table></div>

<p>
 Cuando se activa el modo especial, el mapa de memoria cambia a una de
estas configuraciones, según los valores de los bits 1 y 2 del puerto
$1FFD:
</p>

<p>
<br>

<img src="img/pag_especial.png" class="mediacenter" alt=" Paginación especial +2A/+3"/>
<br>

</p>

<p>
 Por otra parte, las 4 ROMS mapeables del +2A y +3 son:
</p>
<div class="table-responsive sectionedit7"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> ROM </th><th class="col1"> Contenido </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> Editor 128K, Menú y programa de testeo </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> Chequeador de sintaxis 128K BASIC </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> +3DOS </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> BASIC 48K </td>
	</tr>
</tbody></table></div>

<p>
 De nuevo, al igual que en el caso del puerto genérico sobre paginación,
 es recomendable actualizar la variable del sistema que almacena el
“valor actual” de este puerto, en $5B67 (23399).
</p>

<p>
<br>

</p>

</div>

<h2 id="ejemplo-sencilloalternando-bancos-0-y-1">Ejemplo sencillo: alternando Bancos 0 y 1</h2>
<div class="level2">

<p>
 El siguiente ejemplo muestra la paginación de la siguiente forma:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Paginamos el bloque/banco 0 sobre el área $C000-$FFFF.
</li>
<li> Escribimos en memoria, en la posición $C000, el valor $AA.
</li>
<li> Paginamos el bloque/banco 1 sobre el área $C000-$FFFF.
</li>
<li> Escribimos en memoria, en la posición $C000, el valor $01.
</li>
<li> Volvemos a paginar el banco 0 sobre el área de paginación.
</li>
<li> Leemos el valor de la posición de memoria $C000 y rellenamos toda la pantalla con dicho valor.
</li>
<li> Volvemos a paginar el banco 1 sobre el área de paginación.
</li>
<li> Leemos el valor de la posición de memoria $C000 y rellenamos toda la pantalla con dicho valor.
</li>
</ul>

<p>
<br>

</p>

<p>
 Haciendo esto, guardamos 2 valores diferentes en 2 bancos diferentes, y
 posteriormente recuperamos dichos bancos para verificar que,
efectivamente, los valores siguen en las posiciones (0000) de los bancos
 y que la paginación de una banco a otro funciona adecuadamente. Se han
elegido los valores $AA y $01 porque se muestra en pantalla como 2
tramas de pixeles bastante diferenciadas, siendo la primera un entramado
 de barras verticales separadas por 1 pixel, y la segunda separados por 7
 pixeles.
</p>

<p>
 Para terminar de comprender el ejemplo, lo mejor es compilarlo y ejecutarlo:
</p>
<pre class="code z80"><span class="co1">;----------------------------------------------------------------------</span>
<span class="co1">; Bancos.asm</span>
<span class="co1">;</span>
<span class="co1">; Demostracion del uso de bancos / paginación en modo 128K</span>
<span class="co1">;----------------------------------------------------------------------</span>
&nbsp;
  ORG <span class="nu0">32</span><span class="re1">000</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">0</span>
  <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">SP</span>                      <span class="co1">; Guardamos el valor actual de SP</span>
  <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                       <span class="co1">; lo almacenamos en DE</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">SP</span>, <span class="nu0">24</span><span class="re1">000</span>                    <span class="co1">; Pila fuera de $c000-$ffff</span>
&nbsp;
  <span class="kw1">CALL</span> Wait_For_Keys_Released
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="sy0">$</span>c<span class="re1">000</span>                   <span class="co1">; Nuestro puntero</span>
&nbsp;
  <span class="co1">; Ahora paginamos el banco 0 sobre $c000 y guardamos un valor</span>
  <span class="co1">; en el primer byte de sus 16K (en la direccion $c000):</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>
  <span class="kw1">CALL</span> SetRAMBank                 <span class="co1">; Banco 0</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>AA
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                      <span class="co1">; ($c000) = $AA</span>
&nbsp;
  <span class="co1">; Ahora paginamos el banco 1 sobre $c000 y guardamos un valor</span>
  <span class="co1">; en el primer byte de sus 16K (en la direccion $c000):</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span>
  <span class="kw1">CALL</span> SetRAMBank                 <span class="co1">; Banco 1</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span><span class="re1">01</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                      <span class="co1">; ($C000) = $01</span>
&nbsp;
  <span class="co1">; Esperamos una pulsación de teclas antes de empezar:</span>
  <span class="kw1">CALL</span> Wait_For_Keys_Pressed
  <span class="kw1">CALL</span> Wait_For_Keys_Released
&nbsp;
  <span class="co1">; Ahora vamos a cambiar de nuevo al banco 0, leemos el valor que</span>
  <span class="co1">; hay en $c000 y lo representamos en pantalla. Recordemos que</span>
  <span class="co1">; acabamos de escribir $01 (00000001) antes de cambiar de banco,</span>
  <span class="co1">; y que en su momento pusimos $AA (unos y ceros alternados):</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>
  <span class="kw1">CALL</span> SetRAMBank                 <span class="co1">; Banco 0</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                      <span class="co1">; Leemos ($c000)</span>
  <span class="kw1">CALL</span> ClearScreen                <span class="co1">; Lo pintamos en pantalla</span>
&nbsp;
  <span class="co1">; Esperamos una pulsación de teclas:</span>
  <span class="kw1">CALL</span> Wait_For_Keys_Pressed
  <span class="kw1">CALL</span> Wait_For_Keys_Released
&nbsp;
  <span class="co1">; Ahora vamos a cambiar de nuevo al banco 1, leemos el valor que</span>
  <span class="co1">; hay en $c000 y lo representamos en pantalla. Recordemos que</span>
  <span class="co1">; acabamos de leer $A antes de cambiar de banco, y que en su</span>
  <span class="co1">; momento pusimos $01:</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span>
  <span class="kw1">CALL</span> SetRAMBank                 <span class="co1">; Banco 0</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                      <span class="co1">; Leemos ($c000)</span>
  <span class="kw1">CALL</span> ClearScreen                <span class="co1">; Lo pintamos en pantalla</span>
&nbsp;
  <span class="co1">; Esperamos una pulsación de teclas:</span>
  <span class="kw1">CALL</span> Wait_For_Keys_Pressed
  <span class="kw1">CALL</span> Wait_For_Keys_Released
&nbsp;
  <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                       <span class="co1">; Recuperamos SP para poder volver</span>
  <span class="kw1">LD</span> <span class="kw2">SP</span>, <span class="kw2">HL</span>                       <span class="co1">; a BASIC sin errores</span>
  <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; SetRAMBank: Establece un banco de memoria sobre $c000</span>
<span class="co1">; Entrada: B = banco (0-7) a paginar entre $c000-$ffff</span>
<span class="co1">;-----------------------------------------------------------------------</span>
SetRAMBank:
   <span class="kw1">LD</span> <span class="kw2">A</span>,<span class="br0">(</span><span class="sy0">$</span>5b5c<span class="br0">)</span>                  <span class="co1">; Valor anterior del puerto</span>
   <span class="kw1">AND</span> <span class="sy0">$</span>f8                       <span class="co1">; Sólo cambiamos los bits necesarios</span>
   <span class="kw1">OR</span> <span class="kw2">B</span>                           <span class="co1">; Elegir banco "B"</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>,<span class="sy0">$</span>7ffd
   <span class="kw1">DI</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="sy0">$</span>5b5c<span class="br0">)</span>,<span class="kw2">A</span>
   <span class="kw1">OUT</span> <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>,<span class="kw2">A</span>
   <span class="kw1">EI</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; ClearScreen: Limpia toda la pantalla con un patrón gráfico dado.</span>
<span class="co1">; Entrada: A = valor a "imprimir" en pantalla.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
ClearScreen:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">6</span><span class="re1">1</span><span class="nu0">43</span>
   <span class="kw1">LDIR</span>
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Rutinas para esperar la pulsación y liberación de todas las teclas:</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Pressed:
   <span class="kw1">XOR</span> <span class="kw2">A</span>                        <span class="co1">; A = 0</span>
   <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
   <span class="kw1">OR</span> <span class="nu0">224</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>
   <span class="kw1">JR</span> Z, Wait_For_Keys_Pressed
   <span class="kw1">RET</span>
&nbsp;
Wait_For_Keys_Released:
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
   <span class="kw1">OR</span> <span class="nu0">224</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>
   <span class="kw1">JR</span> NZ, Wait_For_Keys_Released
   <span class="kw1">RET</span>
&nbsp;
END <span class="nu0">32</span><span class="re1">000</span></pre>

<p>
 El programa anterior, una vez ensamblado y ejecutado, esperará la
pulsación de una tecla para mostrarnos en pantalla el valor de la
celdilla de memoria $c000 mapeando primero uno de los bancos, y luego el
 otro.
</p>

<p>
<br>

</p>

</div>

<h2 id="contended-memory">Contended Memory</h2>
<div class="level2">

<p>
 En este capítulo hemos hablado de la <em>Contended Memory</em> (podríamos traducirlo por “contención de memoria” o “memoria contenida”).
</p>

<p>
 Esta peculiaridad de la memoria del Spectrum puede traernos de cabeza
en circunstancias muy concretas, como la programación de emuladores, o
la creación de rutinas críticas donde el timming sea muy importante o
donde tengamos que sincronizarnos de una forma muy precisa con algún
evento.
</p>

<p>
 El <strong>efecto</strong> es el siguiente: algunas zonas de memoria,
en determinadas circunstancias, son de acceso más lento que otras en
cuanto a ejecución de código que afecten a ellas (leer de esas zonas,
escribir en esas zonas, ejecutar código que está en esas zonas). La <strong>causa</strong> es sencilla: una misma celdilla de memoria no puede ser accedida por 2 dispositivos diferentes simultáneamente.
</p>

<p>
 ¿Acaso existen en el Spectrum otro dispositivo que acceda a la memoria
además del microprocesador (cuando lee, decodifica y ejecuta
instrucciones, o cuando lee/escribe en memoria)? Sí, lo hay, y es la ULA
 (Uncommited Logic Array).
</p>

<p>
<br>

<img src="img/esquema_zx.gif" class="mediacenter" alt=" La ULA y su papel en el Spectrum "/>
<br>

</p>

<p>
 La ULA es, digamos, “el chip gráfico” del Spectrum. Su labor no es como
 en los chips gráficos actuales o los chips gráficos de otros
ordenadores (y consolas) de 8 bits, la de apoyar al software con
funciones extra, sino que en el Spectrum la ULA se limita a leer la
VIDEORAM (parte de la memoria que contiene la información gráfica a
representar en el monitor), interpretarla, y mandar al modulador de TV
las señales adecuadas para la visualización de dicha información en la
TV. Sencillamente, es el chip que lee la VideoMemoria y la convierte en
los píxeles que vemos en la TV.
</p>

<p>
 ¿Cómo trabaja la ULA? Este pequeño chip fabricado por Ferranti recorre
50 veces por segundo la zona de memoria que comienza en $4000 (16384) y
transforma los datos numéricos en píxeles apagados o encendidos con el
color de la tinta y papel asociado a cada celdilla 8×1 (8×8 en realidad)
 que va leyendo byte a byte, horizontalmente. Esto implica una
sincronización con el haz de electrones del monitor de TV, que empieza
en la esquina superior-izquierda y avanza horizontalmente hasta llegar
al final de cada línea para, como en una máquina de escribir, pasar a la
 siguiente línea horizontal, y así hasta llegar hasta la esquina
inferior derecha.
</p>

<p>
<br>

<img src="img/retrazo.png" class="mediacenter" alt=" El retrazado de la pantalla "/>
<br>

</p>

<p>
 El problema es que mientras el haz de electrones del monitor avanza
redibujando la imagen, el Spectrum no puede interrumpirlo (de hecho, no
puede controlarlo, sólo se sincroniza con él) y tiene que servirle todos
 los datos necesarios para el retrazado de la imagen.
</p>

<p>
 Esto implica que cuando la ULA está “redibujando” la pantalla (y
recordemos que lo hace 50 veces por segundo) y por tanto leyendo de las
sucesivas posiciones de memoria comenzando en $4000, el procesador no
puede acceder a las celdillas exactas de memoria a las que accede la ULA
 hasta que ésta deja de hacer uso de ellas. En otras palabras, a la hora
 de leer celdillas de memoria entre $4000 y $7FFF, la ULA tiene
prioridad sobre el procesador.
</p>

<p>
 Por eso, los programas que corren en la zona de memoria entre $4000 y
$7FFF (o pretenden acceder a la misma justo cuando la ULA quiere leer
algún dato gráfico de la VRAM) pueden ser ralentizados cuando la ULA
está leyendo la pantalla.
</p>

<p>
 Como se detalla en la <abbr title="" data-original-title="Frequently Asked Questions">FAQ</abbr>
 de comp.sys.sinclair alojada en World Of Spectrum, este efecto sólo se
da cuando se está dibujando la pantalla propiamente dicha, ya que para
el trazado del borde la ULA proporciona al haz de electrones el color a
dibujar y no se accede a memoria, por lo que no se produce este retraso o
 delay.
</p>

<p>
 Controlar exactamente los retrasos que se producen y cómo afectarán a
la ejecución de nuestros programas es un ejercicio bastante complejo que
 requiere conocimiento de los tiempos de ejecución de las diferentes
instrucciones, número de ciclo desde que comenzó el retrazado de la
pantalla, etc. Por ejemplo, una misma instrucción, NOP, que requiere 4
ciclos de reloj para ejecutarse en condiciones normales, puede ver
aumentado su tiempo de ejecución a 10 ciclos (4 de ejecución y 6 de
delay) si el contador de programa (PC) está dentro de una zona de
memoria contenida, y dicho delay afectaría sólo al primer ciclo (lectura
 de la instrucción por parte del procesador). Por contra, si en lugar de
 una instrucción NOP tenemos una instrucción LD que acceda a memoria
(también contenida), el delay puede ser mayor.
</p>

<p>
 Como podéis imaginar, este es uno de los mayores quebraderos de cabeza
para los programadores de emuladores, y es la principal causa (junto con
 la <strong>Contended I/O</strong>, su equivalente en cuanto a acceso de
 puertos, también producido por la ULA), de que hasta ahora no todos los
 juegos fueran correctamente emulados con respecto a su funcionamiento
en un Spectrum. También muchas demos con complejas sincronizaciones y
timmings dejaban de funcionar en emuladores de Spectrum que no
implementaban estos “retrasos” y que, en su emulación “perfecta del
micro”, ejecutaban siempre todas las instrucciones a su velocidad
“teórica”.
</p>

<p>
 En nuestro caso, como programadores, la mejor manera de evitar
problemas en la ejecución de nuestros programas es la tratar de no
situar código, siempre que sea posible, entre $4000 y $7FFF.
</p>

<p>
 Si recordáis, en el capítulo dedicado a la gestión de la pila, ya
obtuvimos la recomendación de no ubicar la pila en el bloque de 16KB a
partir de $4000 precisamente por este motivo.
</p>

<p>
<br>

</p>

</div>

<h2 id="contended-memory-paginacion">Contended Memory + Paginación</h2>
<div class="level2">

<p>
 ¿Cómo afecta la contended-memory al sistema de paginación de los
modelos 128K? Al igual que en el 48K existe una “página” ($4000-$7FFF) a
 la que la ULA accede y por tanto afectada por sus lecturas, en el caso
de los 128K existen bancos de memoria completos (páginas) de memoria
contenida. Como ya hemos visto, estos bancos son:
</p>
<ul class="fix-media-list-overlap">
<li> Modelos +2/128K : Bancos 1, 3, 5 y 7.
</li>
<li> Modelos +2A/+3: Bancos 4, 5, 6 y 7.
</li>
</ul>

<p>
La afectación de velocidad de lectura de esta memoria es más importante de lo que parece. Según el manual del +3:
</p>
<pre class="code">The RAM banks are of two types: RAM pages 4 to 7 which are contended
(meaning that they share time with the video circuitry), and RAM pages
0 to 3 which are uncontended (where the processor has exclusive use).
Any machine code which has critical timing loops (such as music or
communications programs) should keep all such routines in uncontended
banks.

For example, executing NOPs in contended RAM will give an effective
clock frequency of 2.66Mhz as opposed to the normal 3.55MHz in
uncontended RAM.

This is a reduction in speed of about 25%.</pre>

<p>
 Es decir, la velocidad de acceso a memoria (y por tanto, también de
ejecución) cae a un 25% de promedio en un banco con contended-memory con
 respecto a un banco que no lo sea.
</p>

<p>
 El problema, que para el 128K y +2 las páginas que sufre una
penalización son unas, y para el +2A y +3 otras diferentes, por lo que
parece que siempre tendremos que primar a uno de los modelos sobre
otros: o usamos números de bancos que no penalicen al +2A/+3, o lo
hacemos para el 128K/+2.
</p>

<p>
 Lo mejor es no situar en la zona paginada rutinas como las de vídeo o
audio, o al menos, no hacerlo si éstas son críticas. En cualquier caso,
es probable que para el 90% de las rutinas o datos de un programa no
existan problemas derivados de correr o estar alojados en memoria
contenida, pero puede ser un detalle a tener muy en cuenta en rutinas
que requieran un timming perfecto (efectos con el borde, efectos
gráficos complejos, etc).
</p>

<p>
<br>

</p>

</div>

<h2 id="paginacion-de-memoria-desde-z88dk-c">Paginación de memoria desde Z88DK (C)</h2>
<div class="level2">

<p>
 Podemos paginar memoria también desde C usando Z88DK mediante un código como el siguiente:
</p>
<pre class="code c"><span class="co1">//--- SetRAMBank ------------------------------------------------------</span>
<span class="co1">//</span>
<span class="co1">// Se mapea el banco (0-7) indicado sobre $C000.</span>
<span class="co1">//</span>
<span class="co1">// Ojo: aqui no se deshabilitan las interrupciones y ademas en lugar</span>
<span class="co1">// de usar el registro B, se usa un parametro tomado desde la pila.</span>
<span class="co1">// En caso de ser importante la velocidad, se puede usar "B" y no pasar</span>
<span class="co1">// el parametro en la pila, llamando SetRAMBank con un CALL.</span>
<span class="co1">//</span>
<span class="kw4">void</span> SetRAMBank<span class="br0">(</span> <span class="kw4">char</span> banco <span class="br0">)</span>
<span class="br0">{</span>
  <span class="co2">#asm</span>
   .<span class="me1">SetRAMBank</span>
     ld hl<span class="sy0">,</span> <span class="nu0">2</span>
     add hl<span class="sy0">,</span> sp
     ld a<span class="sy0">,</span> <span class="br0">(</span>hl<span class="br0">)</span>
&nbsp;
     ld b<span class="sy0">,</span> a
     ld  A<span class="sy0">,</span> <span class="br0">(</span>$5B5C<span class="br0">)</span>
     and F8h
     or  B
     ld  BC<span class="sy0">,</span> $7FFD
     ld  <span class="br0">(</span>$5B5C<span class="br0">)</span><span class="sy0">,</span> A
     out <span class="br0">(</span>C<span class="br0">)</span><span class="sy0">,</span> A
   <span class="co2">#endasm</span>
<span class="br0">}</span></pre>

<p>
Con el anterior código podemos mapear uno de los bancos de memoria de
16KB sobre la página que va desde $C000 a $FFFF, pero debido al uso de
memoria, variables y estructuras internas que hace Z88DK, debemos seguir
 una serie de consideraciones.
</p>
<ul class="fix-media-list-overlap">
<li> Todo el código en ejecución debe
estar por debajo de $C000, para lo cual es recomendable definir los
gráficos al final del “binario”.
</li>
<li> Es importantísimo colocar la pila en
 la memoria baja, mediante la siguiente instrucción (o similar, según la
 dirección en que queremos colocarla) al principio de nuestro programa:
</li>
</ul>
<pre class="code">/* Allocate space for the stack */
#pragma output STACKPTR=24500</pre>

<p>
 La regla general es asegurarse de que no haya nada importante (para la
ejecución de nuestro programa) en el bloque $C000 a $FFFF cuando se haga
 el cambio: ni la pila, ni código al que debamos acceder. Tan sólo datos
 que puedan ser intercambiandos de un banco a otro sin riesgo para la
ejecución del mismo (por ejemplo, los datos de un nivel de juego en el
que ya no estamos).
</p>

<p>
<br>

</p>

</div>

<h2 id="en-resumen">En resumen</h2>
<div class="level2">

<p>
 Comprendiendo el sistema de paginación de los modelos de 128K y
aprendiendo a utilizarlo conseguimos una gran cantidad de memoria
adicional que ir paginando sobre el bloque $C000-$FFFF.
</p>

<p>
 Así, podemos almacenar los datos de diferentes niveles en diferentes
bloques, y cambiar de uno a otro mediante paginación en el momento
adecuado. Esto permite realizar cargas de datos desde cinta almacenando
la totalidad de los datos del juego o programa en bancos libres de
memoria y convertir nuestro juego multicarga (con una carga por fase) en
 un juego de carga única (con todos los elementos del juego almacenados
en memoria), evitando el tedioso sistema de rebobinar y volver a cargar
la primera fase cuando el jugador muere.
</p>

<p>
 Ahora bastará con que nuestro programa, una vez cargado en memoria y en
 ejecución, pagine un determinado bloque, cargue 16K-datos sobre él,
pagine otro bloque diferente, y realice otra carga de datos desde cinta,
 y así sucesivamente con todos los bloques de datos del juego. Estas
cargas de datos podemos hacerlas bien desde nuestro programa “principal”
 una vez cargado y en memoria, o bien desde un mini-programa lanzado por
 el cargador BASIC y previo a cargar el programa definitivo.
</p>

<p>
 El resultado: 128KB de memoria a nuestro alcance, tanto para cargar
múltiples datos gráficos o de mapeado sobre ellos como para llenarlos
internamente desde nuestro programa.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/10_bancos.asm">Ejemplo de paginación 128k</a>
</li>
<li><a href="src/10_bancos.tap">Tap del ejemplo anterior</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/128kreference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/128kreference.htm">FAQ 128K de WOS</a></div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/48kreference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/48kreference.htm">FAQ 48K de WOS</a></div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/48kreference.htm#Contention" class="urlextern" title="external/worldofspectrum.org/faq/reference/48kreference.htm#Contention">Contended Memory</a></div>
</li>
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt24.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt24.html">Manual del +3</a></div>
</li>
<li><div class="li"> <a href="external/ZXSpectrum128+3Manual/chapter8pt23.html" class="urlextern" title="external/ZXSpectrum128+3Manual/chapter8pt23.html">Puertos E/S</a></div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a></div>
</li>
<li><div class="li"> <a href="http://microhobby.speccy.cz/mhf/137/MH137_24.jpg" class="urlextern" title="http://microhobby.speccy.cz/mhf/137/MH137_24.jpg">MH 137: La memoria paginada del Spectrum 128K</a> (Pág 1.).</div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a></div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="graficos-ila-videomemoria-del-spectrum">Gráficos (I): la videomemoria del Spectrum</h1>
<div class="level1">

<p>
 En este capítulo vamos a ver la teoría relacionada con la generación de
 gráficos en el Spectrum: cómo se almacena en memoria el estado de cada
pixel de pantalla y el color de cada celdilla y cómo la ULA utiliza esta
 información para regenerar las imágenes. Este capítulo es una
preparación teórica y práctica básica e imprescindible para los próximos
 capitulos del curso.
</p>

<p>
<br>

</p>

</div>

<h2 id="como-funciona-un-monitor-crt">Cómo funciona un monitor CRT</h2>
<div class="level2">

<p>
 Para comprender el funcionamiento de la videomemoria del Spectrum
debemos empezar por comprender cómo el monitor o TV CRT genera las
imágenes.
</p>

<p>
 Los monitores/televisiones CRT (de Cathode Ray Tube, o Tubo de Rayos
Catódicos), que incluye tanto a los televisores como a los monitores
estándar que no sean de tecnología TFT/LED/PLASMA, funcionan mediante un
 “bombardeo” de electrones que excitan los elementos fosforescentes de
pantalla.
</p>

<p>
 Simplificando el proceso, podría decirse que el monitor o pantalla es una <em>matriz de elementos fosforescentes</em> (los <em>píxeles</em>) protegidos y delimitados por una <em>máscara</em> (que determina la “posición” de los mismos) y el CRT un <em>cañón de electrones</em>
 capaz de “iluminar” el pixel al que apunta. Este pixel se mantiene
“excitado” y por tanto “encendido” un tiempo limitado, ya que se va
apagando progresivamente cuando el haz de electrones deja de excitarlo.
Esto implica que hay que volver a bombardear dicho punto de nuevo para
que se encienda durante otro período de tiempo. Realizando esta
operación suficientes veces por segundo (50 veces por segundo en
sistemas PAL y 60 en sistemas NTSC), dará la sensación óptica de que el
pixel no se apaga nunca.
</p>

<p>
<br>

<img src="img/tubo_rayos.gif" class="mediacenter" alt=" El CRT generando un pixel "/>
</p>
<div style="text-align: center;"><em>El CRT generando un pixel</em>
</div>
<p>
<br>

</p>

<p>
 Concretando un poco más, en el caso de los monitores de fósforo verde o
 de blanco y negro, cada pixel se compone de un único elemento de la
matriz (habitualmente de fósforo) excitable, que puede estar encendido o
 apagado. En el caso de los monitores de color, cada pixel se compone de
 3 sub-pixels muy cercanos de colores Rojo, Azul y Verde (Red Green
Blue) los cuales podemos ver si nos acercamos lo suficiente a un monitor
 CRT:
</p>

<p>
<br>

<img src="img/pixeles-crt.jpg" class="mediacenter" alt=" Trama de subpíxeles RGB que forman un pixel "/>
<br>

</p>

<p>
 El haz de electrones activa 1, 2 ó los 3 subpíxeles (las componentes)
que forman un pixel con una intensidad mayor o menor según el color RGB y
 los valores de las componentes que forman el color real. Así, activando
 con máxima intensidad las 3 componentes RGB (en 8 bits, R=255, G=255 y
B=255), debido a la cercanía de los subpíxeles, nuestro ojo apreciará
desde la distancia de visión “normal” un único píxel de color blanco. Si
 el haz de electrones excitara sólo el subpixel R y no el G y el B
(R=valor, G=0, B=0), veríamos un pixel de color rojo cuya tonalidad
variaría en función del valor de la componente R.
</p>

<p>
 La ULA tiene definidos los colores del Spectrum con unas componentes de
 color concretas que podemos ver aproximadamente en la siguiente tabla y
 en la imagen donde se representan:
</p>
<div class="table-responsive sectionedit3"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Valor </th><th class="col1"> Color </th><th class="col2"> Componentes RGB </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> Negro </td><td class="col2"> (0, 0, 0 ) </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> Azul </td><td class="col2"> (0, 0, 192) </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> Rojo </td><td class="col2"> (192, 0, 0) </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> Magenta </td><td class="col2"> (192, 0, 192) </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> Verde </td><td class="col2"> (0, 192, 0) </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1"> Cian </td><td class="col2"> (0, 192, 192) </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 6 </td><td class="col1"> Amarillo </td><td class="col2"> (192, 192, 0) </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 7 </td><td class="col1"> Blanco </td><td class="col2"> (192, 192, 192) </td>
	</tr>
	<tr class="row9">
		<td class="col0"> 8 </td><td class="col1"> Negro + Brillo </td><td class="col2"> (0, 0, 0) </td>
	</tr>
	<tr class="row10">
		<td class="col0"> 9 </td><td class="col1"> Azul + Brillo </td><td class="col2"> (0, 0, 255) </td>
	</tr>
	<tr class="row11">
		<td class="col0"> 10 </td><td class="col1"> Rojo + Brillo </td><td class="col2"> (255, 0, 0) </td>
	</tr>
	<tr class="row12">
		<td class="col0"> 11 </td><td class="col1"> Magenta + Brillo </td><td class="col2"> (255, 0, 255) </td>
	</tr>
	<tr class="row13">
		<td class="col0"> 12 </td><td class="col1"> Verde + Brillo </td><td class="col2"> (0, 255, 0) </td>
	</tr>
	<tr class="row14">
		<td class="col0"> 13 </td><td class="col1"> Cian + Brillo </td><td class="col2"> (0, 255, 255) </td>
	</tr>
	<tr class="row15">
		<td class="col0"> 14 </td><td class="col1"> Amarillo + Brillo </td><td class="col2"> (255, 255, 0) </td>
	</tr>
	<tr class="row16">
		<td class="col0"> 15 </td><td class="col1"> Blanco + Brillo </td><td class="col2"> (255, 255, 255) </td>
	</tr>
</tbody></table></div>

<p>
<br>

<img src="img/colores_zx.png" class="mediacenter" alt=" Gama de colores del Spectrum "/>
</p>
<div style="text-align: center;"><em>La gama de colores del Spectrum</em>
</div>
<p>
<br>

</p>

<p>
 Pero volvamos al retrazado de nuestra imagen: y es que no sólo hay que
trazar y refrescar un único pixel: el CRT debe de refrescar todos los
píxeles de la pantalla. Para ello, el cañón de electrones del monitor
(un triple cañón realmente, para atacar a las 3 componentes de color)
realiza un recorrido desde la esquina superior izquierda hasta la
inferior derecha refrescando todos los píxeles de la pantalla y
volviendo de nuevo a la posición inicial para repetir el proceso.
</p>

<p>
 Como ya vimos en el capítulo dedicado a las interrupciones, el haz de
electrones de una pantalla CRT comienza su recorrido en la esquina
superior izquierda del monitor y avanza horizontalmente hacia a la
derecha retrazando lo que se conoce como un “scanline” (una línea
horizontal). Al llegar a la derecha del monitor y tras haber trazado
todos los píxeles de la primera línea, se desactiva el bombardeo de
electrones y se produce un retorno a la parte izquierda de la pantalla y
 un descenso al scanline inferior. Al llegar aquí, mediante la
sincronización con una señal HSYNC monitor-dispositivo, se “activa” de
nuevo el trazado de imagen para redibujar el nuevo scanline con la
información que le suministra el dispositivo que está conectado al
monitor.
</p>

<p>
 El haz de electrones traza pues, scanline a scanline, toda la pantalla
hasta llegar a la parte inferior derecha, momento en el que el haz de
electrones vuelve a la parte superior izquierda dejando de bombardear
electrones durante el retorno, sincronizándose con el dispositivo al que
 esté conectado (la ULA y el modulador de vídeo del Spectrum en este
caso) mediante una señal VSYNC.
</p>

<p>
<br>

<img src="img/vsync_int.png" class="mediacenter" alt=" Retrazado de la imagen "/>
</p>
<div style="text-align: center;"><em>Proceso de retrazado de la imagen</em>
</div>
<p>
<br>

</p>

<p>
 Este proceso se repite continuamente (a razón de 50 ó 60 veces por
segundo según el sistema de televisión de nuestra región) y no se puede
interrumpir ni variar (ni el tiempo de avance de la señal de televisión
en horizontal ni el tiempo total que se tarda en retrazar un cuadro.
</p>

<p>
 Es el dispositivo conectado a la televisión o monitor (el Spectrum en
este caso) quien le debe de proporcionar los datos gráficos que el
monitor ha de retrazar, sincronizándose este dispositivo con el monitor
mediante las señales de HSYNC y VSYNC.
</p>

<p>
 Cuando se produce un VSYNC y el monitor va a comenzar a trazar los
datos del primer scanline, es la ULA en el caso del Spectrum la
encargada de alimentar el flujo de datos a dibujar con el timing
correcto que necesita el monitor conforme avanza por la pantalla.
Mediante la señal de HSYNC se vuelven a sincronizar de forma que la ULA
pueda comenzar a surtir los datos del siguiente scanline, repitiendo el
proceso hasta acabar el retrazado de toda la imagen.
</p>

<p>
 Así pues, sabemos que la televisión necesita retrazar continuamente la
imagen que aparece en pantalla, por lo que ésta debe de estar almacenada
 en algún lugar para que la ULA pueda leer estos datos y
proporcionarselos al monitor a través del cable de vídeo. Este almacen
no es un área de memoria dentro de la ULA sino dentro de la propia RAM
de nuestro Spectrum. Hablamos de la videomemoria, videoram, o “fichero
de imagen”.
</p>

<p>
<br>

</p>

</div>

<h2 id="la-videomemoria-del-spectrum">La videomemoria del Spectrum</h2>
<div class="level2">

<p>
 Cuando comenzamos nuestro curso de ensamblador vimos la organización
del mapa de memoria del Spectrum, con la ROM mapeada entre $0000 y
$3FFFF, y los 16 o 48KB de memoria a continuación de la misma. A partir
de la dirección de memoria $4000 y hasta $7FFF nos encontramos un área
de memoria etiquetada como “videoram” o “videomemoria”.
</p>

<p>
 Este área de aprox. 7 KB de memoria es donde podemos encontrar la
representación digital de la imagen que estamos viendo en el monitor y
que la ULA lee regularmente para poder generar la señal de vídeo que
requiere el retrazar la imagen.
</p>

<p>
<br>

<img src="img/romram.gif" class="mediacenter" alt=" La VRAM en el mapa de memoria del Spectrum "/>
</p>
<div style="text-align: center;"><em>La videoram en el mapa de memoria del Spectrum</em>
</div>
<p>
<br>

</p>

<p>
 Las rutinas de la ROM o de BASIC que dibujan puntos, líneas,
rectángulos o caracteres de texto, lo que realmente hacen internamente
es escribir datos en posiciones concretas y calculadas de la videoram ya
 que estos datos escritos se convertirán en píxeles en el monitor cuando
 la ULA los recoja en su proceso de envío de datos al monitor y éste los
 dibuje en la pantalla.
</p>

<p>
 Algo tan sencillo como establecer a “1” el bit 7 de la posición de
memoria $4000 provocará la aparición en el monitor de un pixel activo en
 la posición (0,0) de la pantalla. Si en lugar de cambiar un único bit
en esa posición, cambiamos los bits apropiados en las posiciones
apropiadas, podremos provocar el trazado de una imagen, un carácter,
etc.
</p>

<p>
 Veamos un sencillo ejemplo de esto. Vamos a imprimir una letra A
empezando en la posición (128,96) de la pantalla. Definimos primero los
píxeles que van a conformar esta letra mediante esta matriz de 8×8:
</p>
<pre class="code"> Pixel       76543210
 --------------------
 Scanline 0  --XXXX--
 Scanline 1  -X----X-
 Scanline 2  -X----X-
 Scanline 3  -XXXXXX-
 Scanline 4  -X----X-
 Scanline 5  -X----X-
 Scanline 6  -X----X-
 Scanline 7  --------</pre>

<p>
 Esta representación gráfica, convertida en bits a 1 (pixel activo) o a 0 (bit no activo) sería la siguiente:
</p>
<pre class="code"> Valor BIT   76543210    Decimal
 --------------------------------
 Scanline 0  00111100  =   60d
 Scanline 1  01000010  =   66d
 Scanline 2  01000010  =   66d
 Scanline 3  01111110  =  126d
 Scanline 4  01000010  =   66d
 Scanline 5  01000010  =   66d
 Scanline 6  01000010  =   66d
 Scanline 7  00000000  =    0d</pre>

<p>
 Habrá que escribir estos valores en posiciones concretas de la
videomemoria que provoquen que los píxeles de nuestra letra A aparezcan
unos sobre otros y en la posición de pantalla elegida.
</p>

<p>
 Así pues, ensamblamos y ejecutamos el siguiente programa:
</p>
<pre class="code z80"><span class="co1">; Ejemplo de escritura de un grafico con forma de A</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">85</span><span class="re1">1</span><span class="nu0">4</span>       <span class="co1">; Scanline 0 en Y=96</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">6</span><span class="re1">0</span>           <span class="co1">; 00111100b</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribir</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">877</span><span class="re1">0</span>       <span class="co1">; Scanline 1 en Y=97</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">66</span>           <span class="co1">; 01000010b</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribir</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">9</span><span class="re1">0</span><span class="nu0">26</span>       <span class="co1">; Scanline 2 en Y=98</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">66</span>           <span class="co1">; 01000010b</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribir</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">9282</span>       <span class="co1">; Scanline 3 en Y=99</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">26</span>          <span class="co1">; 01111110b</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribir</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">9538</span>       <span class="co1">; Scanline 4 en Y=100</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">66</span>           <span class="co1">; 01000001b</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribir</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">9794</span>       <span class="co1">; Scanline 5 en Y=101</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">66</span>           <span class="co1">; 01000001b</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribir</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">2</span><span class="re1">00</span><span class="nu0">5</span><span class="re1">0</span>       <span class="co1">; Scanline 6 en Y=102</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">66</span>           <span class="co1">; 01000001b</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribir</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">2</span><span class="re1">0</span><span class="nu0">3</span><span class="re1">0</span><span class="nu0">6</span>       <span class="co1">; Scanline 7 en Y=103</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>            <span class="co1">; 00000000b</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribir</span>
&nbsp;
  <span class="kw1">RET</span>
END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 Lo que produce la siguiente imagen en pantalla:
</p>

<p>
<br>

<img src="img/letra_a.png" class="mediacenter" alt=" Trazando una letra A en pantalla "/>
<br>

</p>

<p>
 Los valores de posiciones de memoria en que hemos escrito el estado de
los píxeles han sido precalculadas manualmente para que los valores que
escribíamos en ella aparecieran en la posición exacta de pantalla en que
 los vemos al ejecutar el programa.
</p>

<p>
 Esto es una demostración de cómo alterar el contenido de la videoram es
 la forma real de generar gráficos en la pantalla del Spectrum. Estos
gráficos generados pueden ir desde un simple pixel de coordenadas (x,y)
(cambio de un bit en la dirección de memoria adecuada) hasta un sprite
completo, una pantalla de carga o fuentes de texto.
</p>

<p>
 La resolución gráfica del Spectrum permite la activación o
desactivación de 256 píxeles horizontales contra 192 píxeles verticales,
 es decir, la pantalla tiene una resolución de 256×192 píxeles que
pueden estar, cada uno de ellos, encendido o apagado.
</p>

<p>
 Si nos olvidamos del color y pensamos en el Spectrum como en un sistema
 monocromo, se puede considerar que 256×192 es una resolución de
pantalla bastante respetable para la potencia de un microprocesador como
 el Z80A, ya que a más resolución de pantalla, más operaciones de
escritura y lectura de memoria necesitaremos para generar los gráficos
en nuestros juegos.
</p>

<p>
 Por desgracia, la “alta” resolución del Spectrum se ve ligeramente
empañada por el sistema de color en baja resolución diseñado para poder
reducir la cantidad de RAM necesaria para alojar la videomemoria.
</p>

<p>
 A nivel de color, existe la posibilidad de definir color en baja
resolución. Esto implica que podemos establecer un color de tinta y otro
 de papel (así como brillo y parpadeo) en bloques de 8×8 píxeles con una
 resolución de 32×24 bloques. Se puede decir que la definición de los
colores es, pues, a nivel de “carácter”.
</p>

<p>
 Debido a esta mezcla de gráficos en alta definición y colorido en baja
definición, la videomemoria del Spectrum se divide en 2 áreas:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>El área de imagen</strong>:
Es el área de memoria que va desde $4000 (16384) hasta $57FF (22527).
Este área de memoria de 6 KB almacena la información gráfica de 256×192
píxeles, donde cada byte (de 8 bits) define el estado de 8 píxeles (en
cada bit del byte se tiene el estado de un pixel, con 1=activo, 0=no
activo), de forma que se puede codificar cada línea de 256 pixeles con
256/8=32 bytes. Utilizando 32 bytes por línea, podemos almacenar el
estado de una pantalla completa con 32*192 = 6144 bytes = 6 KB de
memoria. Por ejemplo, la celdilla de memoria 16384 contiene el estado de
 los 8 primeros píxeles de la línea 0 de la pantalla, desde (0,0) a
(7,0).</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>El área de atributos</strong>: Es el área de memoria comprendida entre $5800 (22528) y $5AFF (23295). Cada uno de estos 768 bytes se denomina <strong>atributo</strong>
 y almacena los colores de pixel activo (tinta) y no activo (papel) de
un bloque de 8×8 de la pantalla. Por ejemplo, la celdilla de memoria
22528 almacena el atributo de color del bloque (0,0) que se corresponde
con los 64 píxeles desde las posiciones de pantalla (0,0) hasta (7,7).</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 La ULA genera para el monitor una imagen utilizando los píxeles
definidos en el área de imagen junto a los colores que le corresponde a
ese píxel según el valor del atributo del bloque en baja resolución al
que corresponda la posición del pixel.
</p>

<p>
 Así, para generar el valor del punto de pantalla (6,0), la ULA utiliza
el bit 1 de la posición de memoria 16384, representando este pixel con
el color de tinta (si el bit vale 1) o de papel (si vale 0) del atributo
 definido en (22528), ya que el pixel (6,0) forma parte del primer
bloque de baja resolución de pantalla.
</p>

<p>
 En la siguiente imagen podemos ver un ejemplo simplificado de cómo se
produce la generación de la imagen como “superposición” de la
información gráfica en alta resolución y la información de color en baja
 resolución:
</p>

<p>
<br>

<img src="img/gfx1_gfx_y_attr.png" class="mediacenter" alt=" Gráficos de 256x192 con color a 32x24 "/>
</p>
<div style="text-align: center;"><em>Gráficos de 256×192 con color a 32×24</em>
</div>
<p>
<br>

</p>

<p>
 ¿Cuál es el motivo de crear este sistema mixto de imagen de alta resolución y atributos de baja resolución? No es otro que <strong>el ahorro de memoria</strong>.
 Si quisieramos disponer de un sistema de 256×192 píxeles donde cada
pixel pudiera disponer de su propio valor de color o de un índice en una
 paleta de colores, necesitaríamos la siguiente cantidad de memoria para
 alojar la pantalla:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Utilizando un sistema de 3
componentes RGB que vayan desde 0 a 255, necesitaríamos 3 bytes por cada
 pixel, lo que implicaría la necesidad de 256x192x3 = 147456 bytes =
144KB sólo para almacenar la imagen de pantalla actual. No sólo sería
una enorme cantidad de memoria, sino que nuestro Z80A a 3.50Mhz a duras
penas podría generar gráficos a pantalla completa con suficiente
velocidad, ya que la cantidad de operaciones de lectura y escritura
serían enormes para su capacidad.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Utilizando el sistema de paleta
actual con 16 posibles colores (4 bits), codificando 2 píxeles en cada
byte (4 bits de índice de color en la paleta * 2 píxeles = 8 bits),
obtendríamos un sistema de 4 bits por píxel (2 píxeles por byte) que
requeriría 256×192/2 bytes = 24576 = 24KB de memoria para alojar la
videomemoria. Esto representa la mitad exacta de toda la memoria RAM
disponible del Spectrum y 8KB más de lo que disponía el modelo de 16KB
que, no nos olvidemos, fue el Spectrum original. Además, se perdería la
posibilidad de hacer flash al no disponer de un bit a tal efecto.
</li>
</ul>

<p>
<br>

</p>

<p>
 Buscando una solución más económica (recordemos que Sir Clive Sinclair
quería que los precios de sus productos fueran realmente reducidos) se
optó por un sistema de vídeo mixto (que fue incluso patentado) con
256×192 = 6144 bytes (6KB) dedicados al fichero de imagen y 32×24 = 768
bytes dedicados a los atributos de bloques de color, resultando en un
total de 6912 bytes. La videomemoria del Spectrum ocupaba así menos de 7
 KB, permitiendo que el ZX Spectrum de 16KB de RAM todavía dispusiera de
 9 KB de memoria de trabajo.
</p>

<p>
 A cambio de este enorme ahorro de memoria, el color en el Spectrum
implica realizar un cuidadoso diseño de los gráficos y los mapeados para
 evitar lo que se conoce como “<strong>colour clash</strong>” o “<strong>attribute clash</strong>”
 (colisión de atributos), que se produce cuando los gráficos pasan de un
 bloque de color en baja resolución a otro, con lo que los colores que
debía tener un determinado gráfico modifican los del fondo, los de otro
gráfico, etc.
</p>

<p>
 Para demostrar el efecto de la colisión de atributos podemos acudir a un sencillo programa en BASIC:
</p>
<pre class="code basic">10 BORDER 1: PAPER 1: INK 7: CLS
20 FOR R = 10 TO 70 STEP 10 : CIRCLE 128, 96, R : NEXT R
30 PAUSE 0
40 INK 2 : PLOT 30, 30 : DRAW 220, 120</pre>

<p>
 Lo primero que hace el programa es dibujar una serie de círculos
concéntricos de color blanco (INK 7) sobre papel azul (PAPER 1):
</p>

<p>
<br>

<img src="img/cclash_01.png" class="mediacenter" alt=" Círculos concéntricos "/>
<br>

</p>

<p>
 A continuación pulsamos una tecla y se ejecuta el “INK 2 + PLOT + DRAW”
 que traza una línea diagonal roja. Como en una misma celdilla de 8×8 no
 pueden haber 2 colores de tinta diferentes, cada pixel rojo que dibuja
la rutina DRAW afecta a los 8×8 píxeles del recuadro al que corresponde.
 Cada nuevo pixel dibujado modifica los atributos de su correspondiente
bloque en baja resolución, por lo que se alteran también los colores de
los círculos allá donde coincidan con la línea:
</p>

<p>
<br>

<img src="img/cclash_02.png" class="mediacenter" alt=" Añadimos una línea "/>
<br>

</p>

<p>
 Ampliando la zona central podemos ver el efecto del “attribute clash”
con la alteración de los colores del círculo debido al dibujado de los
píxeles rojos de la línea:
</p>

<p>
<br>

<img src="img/cclash_03.png" class="mediacenter" alt=" Attribute clash "/>
<br>

</p>

<p>
 En los juegos con colorido podemos apreciar el “attribute clash”
fácilmente si es necesario gran cantidad de colores en pantalla o el
movimiento de los personajes debe de ser pixel a pixel sobre un fondo
colorido. En el siguiente ejemplo podemos ver una ampliación del sprite
del juego Altered Beast donde el color de tanto las botas como el cuerpo
 del personaje provocan el cambio de color de los píxeles del decorado
que entran dentro del mismo bloque de caracteres en baja resolución:
</p>

<p>
<br>

<img src="img/altbeast.png" class="mediacenter" alt=" Attribute Clash en Altered Beast "/>
</p>
<div style="text-align: center;"><em>“Ligero” Attribute Clash en Altered Beast</em>
</div>
<p>
<br>

</p>

<p>
 Los programadores tienen diferentes técnicas para dotar a los juegos de
 color sorteando las limitaciones del color en baja resolución y
evitando el “attribute clash”. La más obvia y sencilla es de generar el
juego en formato monocolor, ya sea toda la pantalla o sólo el área de
juego:
</p>

<p>
<br>

<img src="img/hate.gif" class="mediacenter" alt=" Area de juego monocolor en H.A.T.E. "/>
</p>
<div style="text-align: center;"><em>Area de juego monocolor en H.A.T.E.</em>
</div>
<p>
<br>

</p>

<p>
 De esta forma, todo el área donde se mueven los sprites es del mismo
color por lo que no existen colisiones de atributos entre ellos.
</p>

<p>
 La forma más elaborada es la de realizar un diseño gráfico teniendo en
mente el sistema de atributos del Spectrum, de forma que se posicionen
los elementos en pantalla de tal modo que no haya colisiones entre los
mismos. A continuación podemos ver un par de capturas que muestran un
excelente colorido sin apenas colisiones de atributos:
</p>

<p>
<br>

<img src="img/buen_disenyo.gif" class="mediacenter" alt=" Excelente diseño gráfico que disimula la colisión de atributos "/>
</p>
<div style="text-align: center;"><em>Excelente diseño gráfico que disimula la colisión de atributos</em>
</div>
<p>
<br>

</p>

<p>
 En este capítulo trataremos la organización de la zona de imagen y la
zona de atributos de cara a tratar en el próximo capítulo el cómo
calcular las posiciones de memoria relativas a cada coordenada (x,y) de
pixel o de atributo en que deseemos escribir. Tras estos 2 capítulos
sobre la videoram trabajaremos con sprites de baja o alta resolución
(movimiento de 32×24 vs 256×192 posiciones diferentes), fuentes de
texto, etc.
</p>

<p>
 A continuación veremos una descripción más detallada de cada una de estas 2 áreas de memoria.
</p>

<p>
<br>

</p>

</div>

<h2 id="videomemoriaarea-de-imagen">Videomemoria: Área de Imagen</h2>
<div class="level2">

<p>
 El área de imagen del Spectrum es el bloque de 6144 bytes (6KB) entre
16384 ($4000) y 22527 ($57FF). Cada una de las posiciones de memoria de
este área almacenan la información de imagen (estado de los píxeles) de 8
 píxeles de pantalla consecutivos, donde un bit a 1 significa que el
pixel está encendido y un valor de 0 que está apagado.
</p>

<p>
 Como veremos cuando hablemos del área de atributos, que los píxeles
estén a ON o a OFF no implica que la ULA sólo dibuje los píxeles
activos. Si el pixel está activo (bit a 1), la ULA lo traza en pantalla
utilizando el color de tinta actual que corresponda a ese píxel mientras
 que un bit a 0 significa que el pixel no está encendido y que la ULA
debe de dibujarlo con el color de papel actual.
</p>

<p>
 Así pues, en este área se codifica el estado de cada pixel a razón de 1
 bit por píxel, lo que implica que cada byte almacena la información de 8
 píxeles consecutivos requiriendo la totalidad de la pantalla (256/8) *
192 = 32 * 192 = 6144 bytes.
</p>

<p>
 Tomemos como ejemplo la primera celdilla de memoria del área de imagen,
 la $4000 o 16384. Los diferentes bits de esta celdilla de memoria se
corresponden con el estado de los píxeles desde (0,0) hasta (7,0):
</p>
<div class="table-responsive sectionedit6"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bits de (16384) </th><th class="col1"> 7 </th><th class="col2"> 6 </th><th class="col3"> 5 </th><th class="col4"> 4 </th><th class="col5"> 3 </th><th class="col6"> 2 </th><th class="col7"> 1 </th><th class="col8"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Pixel </td><td class="col1"> (0,0) </td><td class="col2"> (1,0) </td><td class="col3"> (2,0) </td><td class="col4"> (3,0) </td><td class="col5"> (4,0) </td><td class="col6"> (5,0) </td><td class="col7"> (6,0) </td><td class="col8"> (7,0) </td>
	</tr>
</tbody></table></div>

<p>
 Podemos comprobar esto de una forma rápida ejecutando este sencillo programa en BASIC:
</p>
<pre class="code basic">10 CLS
20 POKE 16384, 170
30 PAUSE 0</pre>

<p>
 Con este programa escribimos el valor 170 (10101010 en binario) en la
posición de memoria 16384, que implica poner a ON (a 1) los píxeles
(0,0), (2,0), (4,0) y (6,0), y poner a OFF (a 0) los píxeles (1,0),
(3,0), (5,0) y (7,0).
</p>

<p>
 Si ejecutáis el programa en BASIC veréis aparecer en la esquina
superior de la pantalla 4 píxeles activos, alternándose con otros 4
píxeles no activos. Os mostramos una ampliación de la esquina superior
de la pantalla con el resultado de la ejecución:
</p>

<p>
<br>

<img src="img/gfx1_poke.png" class="mediacenter" alt=" POKE 16384, 170 "/>
<br>

</p>

<p>
 Si avanzamos a la siguiente celdilla de memoria, la $4001 (o 16385),
tendremos el estado de los siguientes píxeles de la misma línea
horizontal:
</p>
<div class="table-responsive sectionedit7"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bit de (16385) </th><th class="col1"> 7 </th><th class="col2"> 6 </th><th class="col3"> 5 </th><th class="col4"> 4 </th><th class="col5"> 3 </th><th class="col6"> 2 </th><th class="col7"> 1 </th><th class="col8"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Pixel </td><td class="col1"> (8,0) </td><td class="col2"> (9,0) </td><td class="col3"> (10,0) </td><td class="col4"> (11,0) </td><td class="col5"> (12,0) </td><td class="col6"> (13,0) </td><td class="col7"> (14,0) </td><td class="col8"> (15,0) </td>
	</tr>
</tbody></table></div>

<p>
 De nuevo, avanzando 1 byte más en memoria, avanzamos otros 8 píxeles horizontalmente:
</p>
<div class="table-responsive sectionedit8"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bit de (16386) </th><th class="col1"> 7 </th><th class="col2"> 6 </th><th class="col3"> 5 </th><th class="col4"> 4 </th><th class="col5"> 3 </th><th class="col6"> 2 </th><th class="col7"> 1 </th><th class="col8"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Pixel </td><td class="col1"> (16,0) </td><td class="col2"> (17,0) </td><td class="col3"> (18,0) </td><td class="col4"> (19,0) </td><td class="col5"> (20,0) </td><td class="col6"> (21,0) </td><td class="col7"> (22,0) </td><td class="col8"> (23,0) </td>
	</tr>
</tbody></table></div>

<p>
 Así, hasta que llegamos al byte número 32 desde 16384, es decir, a la celdilla 16415, donde:
</p>
<div class="table-responsive sectionedit9"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bit de (16415) </th><th class="col1"> 7 </th><th class="col2"> 6 </th><th class="col3"> 5 </th><th class="col4"> 4 </th><th class="col5"> 3 </th><th class="col6"> 2 </th><th class="col7"> 1 </th><th class="col8"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Pixel </td><td class="col1"> (248,0) </td><td class="col2"> (249,0) </td><td class="col3"> (250,0) </td><td class="col4"> (251,0) </td><td class="col5"> (252,0) </td><td class="col6"> (253,0) </td><td class="col7"> (254,0) </td><td class="col8"> (255,0) </td>
	</tr>
</tbody></table></div>

<p>
 Con este byte acabamos el primer “scanline” de 256 píxeles, que va
desde (0,0) hasta (255,0). Comprobémoslo con el siguiente programa en
BASIC que guarda el valor 170 (10101010b) en las 32  posiciones de
memoria consecutivas a 16384:
</p>
<pre class="code basic">10 CLS
20 FOR I=0 TO 31 : POKE 16384+I, 170 : NEXT I
30 PAUSE 0</pre>

<p>
 En pantalla aparecerá lo siguiente:
</p>

<p>
<br>

<img src="img/gfx1_poke0.png" class="mediacenter" alt=" 32 bytes 170 desde 16384 "/>
<br>

</p>

<p>
 Ahora la pregunta crucial es … ¿a qué pixel corresponderá el siguiente
byte en videomemoria? Si aplicamos la lógica, lo más intuitivo sería que
 la posición de memoria 16416 (16384+32) tuviera los datos de los
píxeles desde (0,1) hasta (7,1), es decir, los 8 primeros píxeles de la
segunda línea (segundo scanline) de la pantalla.
</p>

<p>
 Por desgracia, esto no es así, y los 32 bytes a partir de 16416 no
hacen referencia a la segunda línea de pantalla sino a la primera línea
del segundo “bloque” de caracteres, es decir, a los píxeles desde (0,8) a
 (255,8), por lo que realmente, los bits de 16416 representan:
</p>
<div class="table-responsive sectionedit10"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bit de (16416) </th><th class="col1"> 7 </th><th class="col2"> 6 </th><th class="col3"> 5 </th><th class="col4"> 4 </th><th class="col5"> 3 </th><th class="col6"> 2 </th><th class="col7"> 1 </th><th class="col8"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Pixel </td><td class="col1"> (0,8) </td><td class="col2"> (1,8) </td><td class="col3"> (2,8) </td><td class="col4"> (3,8) </td><td class="col5"> (4,8) </td><td class="col6"> (5,8) </td><td class="col7"> (6,8) </td><td class="col8"> (7,8) </td>
	</tr>
</tbody></table></div>

<p>
 Podemos comprobar esto mediante el siguiente programa en BASIC, que
escribe el valor 170 en las primeras 64 posiciones de memoria de la
VRAM:
</p>
<pre class="code basic">10 CLS
20 FOR I=0 TO 63 : POKE 16384+I, 170 : NEXT I
30 PAUSE 0</pre>

<p>
<br>

<img src="img/gfx1_poke1.png" class="mediacenter" alt=" 64 bytes 170 desde 16384 "/>
<br>

</p>

<p>
 Se podría esperar que al rellenar las primeras 2 posiciones de memoria
se alteraran las 2 primeras líneas de la pantalla, pero como hemos
explicado, no es así sino que se escribe en la primera línea del primer
carácter, y la primera línea del segundo carácter en baja resolución.
</p>

<p>
 En resumen, si avanzamos de 32 en 32 bytes, tenemos lo siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> La videomemoria empieza en 16384 y contiene “ristras” consecutivas de 32 bytes que almacenan en estado de 256 píxeles.
</li>
<li> Los primeros 32 bytes definen la línea 0 del bloque en baja resolución Y=0 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 0 del bloque Y=1 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 0 del bloque Y=3 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 0 del bloque Y=4 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 0 del bloque Y=5 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 0 del bloque Y=6 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 0 del bloque Y=7 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 1 del bloque Y=1 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 1 del bloque Y=2 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 1 del bloque Y=3 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 1 del bloque Y=4 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 1 del bloque Y=5 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 1 del bloque Y=6 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 1 del bloque Y=7 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 2 del bloque Y=1 de pantalla.
</li>
<li> Los siguientes 32 bytes definen la línea 2 del bloque Y=2 de pantalla.
</li>
<li> (etc…)
</li>
</ul>

<p>
 Así hasta el byte 18331 o $47FF (cuando hemos avanzado 32*8*8  = 32
bytes por 8 líneas de cada una de las 8 filas de caracteres), que
contiene el estado de los 8 píxeles del bloque de baja resolución (31,7)
 de la pantalla.
</p>

<p>
<br>

<img src="img/gfx1_vramorg.png" class="mediacenter" alt=" Organización del área de imagen de la VRAM "/>
</p>
<div style="text-align: center;"><em>Organización del área de imagen de la VRAM</em>
</div>
<p>
<br>

</p>

<p>
 ¿Qué quiere decir esto? Que los primeros 2KB de videoram (entre $4000 y
 $47FF) contienen la información de todos los píxeles de los 8 primeros
bloques en baja resolución de pantalla, de forma que primero vienen
todas las líneas horizontales 0 de cada bloque, luego todas las líneas
horizontales 1 de cada bloque, líneas horizontales 2 de cada bloque,
etc, hasta que se rellenan las últimas líneas horizontales (líneas 7) de
 los 8 primeros caracteres. Esto produce que el rellenado de los 2
primeros KB de la videoram rellene un área de pantalla entre (0,0) y
(255,63), lo que se conoce como el <strong>primer tercio</strong> de la pantalla.
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Primer tercio</strong>: Los 2
 primeros KB de la videoram (de $4000 a $47FF) cubren los datos gráficos
 de los primeros 64 scanlines de la pantalla (líneas 0 a 7).</div>
</li>
<li><div class="li"> <strong>Segundo tercio</strong>: Los
 siguientes 2KB de la videoram (de $4800 a $4FFF) cubren los datos
gráficos de los siguientes 64 scanlines de la pantalla (líneas 8 a 15).</div>
</li>
<li><div class="li"> <strong>Tercer tercio</strong>: Los
siguientes 2KB de la videoram (de $5000 a $57FF) cubren los datos
gráficos de los últimos 64 scanlines de la pantalla (líneas 16 a 23).</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 Y, resumiendo en un sólo párrafo la organización de cada tercio:
</p>

<p>
 Cuando nos movemos dentro de la videomemoria que representa cada tercio
 de pantalla primero tenemos todas las primeras líneas de cada “carácter
 8×8”, después todas las segundas líneas de cada carácter, y así hasta
las octavas líneas de cada carácter, de tal forma que el último byte del
 “tércio” coincide con el pixel (7,7) del carácter (31,7) de esa zona de
 la pantalla.
</p>

<p>
 En la siguiente imagen podemos ver la ubicación de los 3 tercios y sus posiciones de inicio y final:
</p>

<p>
<br>

<img src="img/gfx1_tercios.png" class="mediacenter" alt=" Los 3 tercios de la pantalla "/>
</p>
<div style="text-align: center;"><em>División de la pantalla en 3 tercios de 2KB de VRAM</em>
</div>
<p>
<br>

</p>

<p>
 Con el programa de ejemplo del apartado <em>Explorando el área de imagen con un ejemplo</em>
 podremos comprobar experimentalmente la organización de la videomemoria
 y la división de la pantalla en tercios de 8 “caracteres” de 8
scanlines cada uno.
</p>

<p>
 Mientras tanto, sabiendo que entre $4000 y $57FF (6144 bytes) tenemos
el área de imagen de la pantalla, donde cada byte representa el estado
de 8 píxeles, podemos realizar la siguiente rutina útil que sirve para
rellenar toda la pantalla con un patrón de píxeles determinado (CLS con
patrón):
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------</span>
<span class="co1">; Limpiar la pantalla con el patron de pixeles indicado.</span>
<span class="co1">; Entrada:  A = patron a utilizar</span>
<span class="co1">;-------------------------------------------------------</span>
ClearScreen:
  <span class="kw1">PUSH</span> <span class="kw2">HL</span>
  <span class="kw1">PUSH</span> <span class="kw2">DE</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>          <span class="co1">; HL = Inicio de la videoram</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Escribimos el patron A en (HL)</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>          <span class="co1">; Apuntamos DE a 16385</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1</span><span class="nu0">92</span><span class="sy0">*</span><span class="nu0">32</span><span class="sy0">-</span><span class="re1">1</span>       <span class="co1">; Copiamos 192*32-1 veces (HL) en (DE)</span>
  <span class="kw1">LDIR</span>                  <span class="co1">; e incrementamos HL y DL. Restamos 1</span>
                        <span class="co1">; porque ya hemos escrito en 16384.</span>
  <span class="kw1">POP</span> <span class="kw2">DE</span>
  <span class="kw1">POP</span> <span class="kw2">HL</span>
  <span class="kw1">RET</span>                   </pre>

<p>
 De esta forma, podemos llamar a nuestra rutina ClearScreen colocando en
 A el patron con el que rellenar la pantalla, que puede ser 0 para
“limpiarla” o 1 para activar todos los píxeles a 1.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit11" id="explorando-el-area-de-imagen-con-un-ejemplo">Explorando el área de imagen con un ejemplo</h3>
<div class="level3">

<p>
 Veamos un sencillo programa (vramtest.asm) que nos va a permitir
verificar de forma experimental la teoría sobre la videomemoria que
hemos visto en los apartados anteriores.
</p>

<p>
 Este programa carga HL con el inicio del área de imágen de la
videomemoria (16384 o $4000), y escribe bloques de 32 bytes (todo un
scanline horizontal) con el valor 255 (11111111b o, lo que es lo mismo,
los 8 píxeles de ese bloque activos).
</p>

<p>
 Cada iteración del bucle interno escribe una línea de 256 píxeles en
pantalla (32 bytes de valor 11111111b = 32*8 = 256 píxeles). Este bucle
interno lo repetimos 192 veces para cubrir la totalidad de scanlines de
la pantalla.
</p>

<p>
 Hemos añadido en cada iteración del bucle externo la necesidad de
pulsar y liberar una tecla para permitir al lector estudiar los efectos
de cada escritura de 32 bytes en la pantalla.
</p>

<p>
 Nótese como HL va a incrementarse de 32 en 32 bytes siempre, pero sin
embargo, como ya sabemos por la organización de la videoram, esto no se
reflejará en pantalla con un avance línea a línea de nuestro “patrón” de
 256 píxeles.
</p>

<p>
 A continuación tenemos el código fuente del programa y 2 capturas de pantalla que ilustran lo que acabamos de explicar.
</p>
<pre class="code z80">  <span class="co1">; Mostrando la organizacion de la videomemoria</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="co1">; Pseudocodigo del programa:</span>
  <span class="co1">; </span>
  <span class="co1">; Limpiamos la pantalla</span>
  <span class="co1">; Apuntamos HL a 16384</span>
  <span class="co1">; Repetimos 192 veces:</span>
  <span class="co1">;    Esperamos pulsacion de una tecla</span>
  <span class="co1">;    Repetimos 32 veces:</span>
  <span class="co1">;       Escribir 255 en la direccion apuntada por HL</span>
  <span class="co1">;       Incrementar HL</span>
&nbsp;
Start:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>
  <span class="kw1">CALL</span> ClearScreen           <span class="co1">; Borramos la pantalla</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>               <span class="co1">; HL apunta a la VRAM</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span><span class="nu0">92</span>                  <span class="co1">; Repetimos para 192 lineas</span>
&nbsp;
bucle_<span class="re1">1</span><span class="nu0">92</span>_lineas:
  <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">B</span>                    <span class="co1">; Nos guardamos el valor de D para el</span>
                             <span class="co1">; bucle exterior (usaremos B ahora en otro)</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">32</span>                   <span class="co1">; B=32 para el bucle interior</span>
&nbsp;
                             <span class="co1">; Esperamos que se pulse y libere tecla</span>
  <span class="kw1">CALL</span> Wait_For_Keys_Pressed
  <span class="kw1">CALL</span> Wait_For_Keys_Released
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>                  <span class="co1">; 255 = 11111111b = todos los pixeles</span>
&nbsp;
bucle_32_bytes:
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                 <span class="co1">; Almacenamos A en (HL) = 8 pixeles</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>                     <span class="co1">; siguiente byte (siguientes 8 pix.)</span>
  <span class="kw1">DJNZ</span> bucle_32_bytes        <span class="co1">; 32 veces = 32 bytes = 1 scanline</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">D</span>                    <span class="co1">; Recuperamos el B del bucle exterior</span>
&nbsp;
  <span class="kw1">DJNZ</span> bucle_<span class="re1">1</span><span class="nu0">92</span>_lineas      <span class="co1">; Repetir 192 veces</span>
&nbsp;
  <span class="kw1">JP</span> Start                   <span class="co1">; Inicio del programa</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Esta rutina espera a que haya alguna tecla pulsada para volver.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Pressed:
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
  <span class="kw1">OR</span> <span class="nu0">224</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> Z, Wait_For_Keys_Pressed
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Esta rutina espera a que no haya ninguna tecla pulsada para volver.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Released:
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
  <span class="kw1">OR</span> <span class="nu0">224</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> NZ, Wait_For_Keys_Released
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Limpiar la pantalla con el patron de pixeles indicado.</span>
<span class="co1">; Entrada:  A = patron a utilizar</span>
<span class="co1">;-----------------------------------------------------------------------</span>
ClearScreen:
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1</span><span class="nu0">92</span><span class="sy0">*</span><span class="nu0">32</span><span class="sy0">-</span><span class="re1">1</span>
  <span class="kw1">LDIR</span>
  <span class="kw1">RET</span>
&nbsp;
END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 La ejecución del programa tras realizar 6 pulsaciones de teclado mostraría el siguiente aspecto:
</p>

<p>
<br>

<img src="img/gfx1_vramtest01.png" class="mediacenter" alt=" Nuestro programa de ejemplo tras 6 pulsaciones "/>
</p>

<p>
 Comentemos esta captura de pantalla: como cabría esperar ahora que
conocemos la organización del área de imagen de la VRAM, aunque hemos
escrito en la memoria de forma lineal (desde 16384 hasta
16384+(32*6)-1), los scanlines en pantalla no son consecutivos, ya que
no hemos cubierto los 6 primeros scanlines de la pantalla sino el primer
 scanline de los 6 primeros bloques 8×8 del primer tercio.
</p>

<p>
 Si continuamos realizando pulsaciones de teclado, agotaremos las líneas
 del primer tercio y pasaremos al segundo, con una organización similar
al del primero:
</p>

<p>
<br>

<img src="img/gfx1_vramtest02.png" class="mediacenter" alt=" Nuestro programa de ejemplo tras muchas pulsaciones "/>
</p>

<p>
 Recomendamos al lector que continue la ejecución del programa hasta
recorrer toda la pantalla y que trate de anticiparse mentalmente acerca
de dónde se mostrará la siguiente línea antes de realizar la pulsación
de teclado.
</p>

<p>
 Es probable que la pauta de rellenado de la pantalla de nuestro ejemplo
 le resulte más que familiar al lector: efectivamente, es el mismo orden
 de relleno que producen las pantallas de carga de los juegos cargadas a
 partir de un <em>LOAD “” SCREEN$</em>. La carga de pantalla desde cinta
 con “LOAD ”“ SCREEN$” no es más que la lectura desde cinta de los 6912
bytes de una pantalla completa (6144 bytes de imagen y 768 bytes de
atributos) y su almacenamiento lineal en $4000.
</p>

<p>
 La lectura secuencial desde cinta y su escritura lineal en videomemoria
 resulta en la carga de los datos gráficos en el mismo orden de
scanlines en que nuestro programa de ejemplo ha rellenado la pantalla,
seguida de la carga de los atributos, que en un rápido avance (sólo 768
bytes a cargar desde cinta) dotaba a la pantalla de carga de su color.
</p>

<p>
 Del mismo modo, un simple <em>SAVE “imagen” SCREEN$</em> o <em>SAVE “imagen” CODE 16384, 6912</em> toma los 6912 bytes de la videoram y los almacena en cinta. El lector puede acudir al capítulo dedicado a <em>Rutinas de SAVE y LOAD</em>
 para refrescar la información acerca de la carga de datos desde cinta e
 inclusión de pantallas gráficas completas en sus programas.
</p>

<p>
 Muchos programas comerciales trataban de evitar la carga de la pantalla
 visible scanline a scanline, para lo que cargaban los datos de SCREEN$
en un área de memoria libre y después transferían rápidamente esta
pantalla a videoram con instrucciones LDIR.
</p>

<p>
 Este concepto, el de Pantalla Virtual, resulta muy interesante: podemos
 utilizar un área de memoria alta para simular que es la pantalla
completa o una zona (la de juego) de la misma. Esto permitía dibujar los
 sprites y gráficos sobre ella (sin que el jugador viera nada de estos
dibujados, puesto que dicha zona de RAM no es videoram), y volcarla
regularmente sobre videoram tras un HALT. De esta forma se evita que el
jugador pueda ver parpadeos en el dibujado de los sprites o la
construcción de la pantalla “a trozos”. La utilización de una pantalla
virtual implicará el consumo de casi 7KB de memoria para almacenar
nuestra “vscreen”, por lo que lo normal sería sólo replicar el área de
juego (evitando marcadores y demás) si pensamos utilizar esta técnica.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit12" id="motivaciones-de-la-organizacion-del-area-de-imagenes">Motivaciones de la organización del área de imágenes</h3>
<div class="level3">

<p>
 Una vez ejecutado el programa anterior en todas sus iteraciones el
lector podría preguntarse: ¿qué utilidad tiene esta caprichosa
organización de la videomemoria en lugar de una organización lineal y
continua donde cada nuevo bloque de 32 bytes se correspondiera con el
siguiente scanline de pantalla?
</p>

<p>
 Esta organización de memoria tiene como objetivo el facilitar las
rutinas de impresión de texto, algo que podemos ver en las posiciones de
 inicio de las diferentes líneas de un mismo carácter:
</p>
<div class="table-responsive sectionedit13"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Scanline del carácter </th><th class="col1"> Dirección de memoria </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> $4000 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> $4100 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> $4200 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> $4300 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> $4400 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1"> $4500 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 6 </td><td class="col1"> $4600 </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 7 </td><td class="col1"> $4700 </td>
	</tr>
</tbody></table></div>

<p>
 Tal y como está organizada la videoram, basta con calcular la dirección
 de inicio del bloque en baja resolución donde queremos trazar un
carácter, imprimir los 8 píxeles que forman su scanline (con la
escritura de un único byte en videomemoria), y saltar a la siguiente
posición de videomemoria donde escribir. Como se puede apreciar en la
tabla anterior, este salto a la siguiente línea se realiza con un simple
 INC del byte alto de la direccion (INC H en el caso de que estemos
usando HL para escribir). De esta forma se simplifican las rutinas de
trazado de caracteres y UDGs de la ROM.
</p>

<p>
 Pensemos que los antecesores del ZX Spectrum (ZX80 y ZX81) tenían una
videomemoria orientada al texto en baja resolución, y con la visión del
software de la época y la potencia de los microprocesadores existentes
lo normal era pensar en el Spectrum como un microordenador orientado a
programar en BASIC y realizar programas “de gestión”, más que pensar en
él como una máquina de juegos. En este contexto, potenciar la velocidad
de ejecución del trazado de texto era crucial.
</p>

<p>
<br>

</p>

</div>

<h2 id="videomemoriaarea-de-atributos">Videomemoria: Área de atributos</h2>
<div class="level2">

<p>
 El área de atributos es el bloque de 768 bytes entre $5800 (22528) y
$5AFF (23295), ambas celdillas de memoria incluídas. Cada una de las
posiciones de memoria de este área almacenan la información de color
(color de tinta, color de papel, brillo y flash) de un bloque de 8×8
píxeles en la pantalla.
</p>

<p>
 El tamaño de 768 bytes de este área viene determinado por la resolución
 del sistema de color del Spectrum: Hemos dicho que el sistema gráfico
dispone de una resolución de 256×192, pero el sistema de color divide la
 pantalla en bloques de 8×8 píxeles, lo que nos da una resolución de
color de 256/8 x 192/8 = 32×24 bloques. Como la información de color de
cada bloque se codifica en un único byte, para almacenar la información
de color de toda una pantalla se requieren 32 x 24 x 1 = 768 bytes.
</p>

<p>
 Sabemos ya pues que hay una correspondencia directa entre los 32×24
bloques de 8×8 píxeles de la pantalla y cada byte individual del área de
 atributos, pero ¿cómo se estructura esta información?
</p>

<p>
 La organización lógica del área de atributos es más sencilla y directa
que la del área de imagen. Aquí, los 32 primeros bytes del área de
atributos se corresponden con los 32 primeros bloques horizontales de la
 pantalla. Es decir, la celdilla 22528 se corresponde con el bloque
(0,0), la 22529 se corresponde con (1,0), la 22530 con (2,0), y así
hasta llegar a la celdilla 22559 en (31,0). La siguiente celdilla en
memoria, 22560, se corresponde con el siguiente bloque en pantalla, el
primero de la segunda línea, (0,1), y así de forma sucesiva.
</p>

<p>
<br>

<img src="img/gfx1_attribblocks.png" class="mediacenter" alt=" Atributos: correspondencia entre memoria y pantalla "/>
</p>
<div style="text-align: center;"><em>Atributos: correspondencia entre memoria y pantalla</em>
</div>
<p>
<br>

</p>

<p>
 Se puede decir que el área de atributos es totalmente lineal; consta de
 768 bytes que se corresponden de forma consecutiva con el estado de
cada bloque y de cada fila horizontal de bloques de pantalla: Los
primeros 32 bytes del área se corresponden con la primera fila
horizontal de bloques, los siguientes 32 bytes con la segunda, los
siguientes 32 bytes con la tercera, hasta los últimos 32 bytes, que se
corresponden con los de la línea 23. El byte alojado en la última
posición ($5AFF) se corresponde con el atributo del bloque (31,23).
</p>

<p>
 A continuación podemos ver una tabla que muestra los inicios y fin de cada línea de atributos en pantalla:
</p>
<div class="table-responsive sectionedit15"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Línea </th><th class="col1"> Inicio (carácter 0,N) </th><th class="col2"> Fin (carácter 31,N) </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> $5800 </td><td class="col2"> $581F </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> $5820 </td><td class="col2"> $583F </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> $5860 </td><td class="col2"> $585F </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> $5840 </td><td class="col2"> $587F </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> $5880 </td><td class="col2"> $589F </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1"> $58A0 </td><td class="col2"> $58BF </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 6 </td><td class="col1"> $58C0 </td><td class="col2"> $58DF </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 7 </td><td class="col1"> $58E0 </td><td class="col2"> $58FF </td>
	</tr>
	<tr class="row9">
		<td class="col0"> 8 </td><td class="col1"> $5900 </td><td class="col2"> $591F </td>
	</tr>
	<tr class="row10">
		<td class="col0"> 9 </td><td class="col1"> $5920 </td><td class="col2"> $593F </td>
	</tr>
	<tr class="row11">
		<td class="col0"> 10 </td><td class="col1"> $5940 </td><td class="col2"> $595F </td>
	</tr>
	<tr class="row12">
		<td class="col0"> 11 </td><td class="col1"> $5960 </td><td class="col2"> $597F </td>
	</tr>
	<tr class="row13">
		<td class="col0"> 12 </td><td class="col1"> $5980 </td><td class="col2"> $599F </td>
	</tr>
	<tr class="row14">
		<td class="col0"> 13 </td><td class="col1"> $59A0 </td><td class="col2"> $59BF </td>
	</tr>
	<tr class="row15">
		<td class="col0"> 14 </td><td class="col1"> $59C0 </td><td class="col2"> $59DF </td>
	</tr>
	<tr class="row16">
		<td class="col0"> 15 </td><td class="col1"> $59E0 </td><td class="col2"> $59FF </td>
	</tr>
	<tr class="row17">
		<td class="col0"> 16 </td><td class="col1"> $5A00 </td><td class="col2"> $5A1F </td>
	</tr>
	<tr class="row18">
		<td class="col0"> 17 </td><td class="col1"> $5A20 </td><td class="col2"> $5A3F </td>
	</tr>
	<tr class="row19">
		<td class="col0"> 18 </td><td class="col1"> $5A40 </td><td class="col2"> $5A5F </td>
	</tr>
	<tr class="row20">
		<td class="col0"> 19 </td><td class="col1"> $5A60 </td><td class="col2"> $5A7F </td>
	</tr>
	<tr class="row21">
		<td class="col0"> 20 </td><td class="col1"> $5A80 </td><td class="col2"> $5A9F </td>
	</tr>
	<tr class="row22">
		<td class="col0"> 21 </td><td class="col1"> $5AA0 </td><td class="col2"> $5ABF </td>
	</tr>
	<tr class="row23">
		<td class="col0"> 22 </td><td class="col1"> $5AC0 </td><td class="col2"> $5ADF </td>
	</tr>
	<tr class="row24">
		<td class="col0"> 23 </td><td class="col1"> $5AE0 </td><td class="col2"> $5AFF </td>
	</tr>
</tbody></table></div>

<p>
 Esta organización del área de atributos es muy sencilla y permite un
cálculo muy sencillo de la posición de memoria del atributo de un bloque
 concreto de pantalla. Es decir, podemos encontrar fácilmente la
posición de memoria que almacena el atributo que corresponde a un bloque
 concreto en baja resolución de pantalla mediante:
</p>
<pre class="code"> Direccion_Atributo(x_bloque,y_bloque) = 22528 + (y_bloque*32) + x_bloque </pre>

<p>
 O, con desplazamientos:
</p>
<pre class="code"> Direccion_Atributo(x_bloque,y_bloque) = 22528 + (y_bloque&lt;&lt;5) + x_bloque </pre>

<p>
 Si en vez de una posición de bloque tenemos una posición de pixel, podemos convertirla primero a bloque dividiendo por 8:
</p>
<pre class="code"> Direccion_Atributo(x_pixel,y_pixel) = 22528 + ((y_pixel/8)*32) + (x_pixel/8)</pre>

<p>
 Con desplazamientos:
</p>
<pre class="code"> Direccion_Atributo(x_pixel,y_pixel) = 22528 + ((y_pixel&gt;&gt;3)&lt;&lt;5) + (x_pixel&gt;&gt;3)</pre>

<p>
 La información en cada byte de este área se codifica de la siguiente manera:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit16"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0 centeralign">  Bit  </th><th class="col1 centeralign">  7  </th><th class="col2 centeralign">  6  </th><th class="col3 centeralign">  5 - 4 - 3  </th><th class="col4 centeralign">  2 - 1 - 0  </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0 centeralign">  Valor  </td><td class="col1 centeralign">  FLASH  </td><td class="col2 centeralign">  BRIGHT  </td><td class="col3 centeralign">  PAPER  </td><td class="col4 centeralign">  INK  </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Es decir, utilizamos:
</p>
<ul class="fix-media-list-overlap">
<li> Los bits 0, 1 y 2 para almacenar el
color de tinta, es decir, el color que la ULA utilizará para trazar los
píxeles que estén activos (=1) del recuadro 8×8 al que referencia este
atributo. Nótese que con 3 bits podemos almacenar un valor numérico
entre 0 y 7, que son los 8 colores básicos del Spectrum.
</li>
<li> Los bits 3, 4 y 5 para almacenar el
color de tinta, es decir, el color que la ULA utilizará para trazar los
píxeles que estén activos (=1) del recuadro 8×8 al que referencia este
atributo. De nuevo, se utiliza un valor de 0-7.
</li>
<li> El bit 6 para indicar si está activado el modo brillo de color o no.
</li>
<li> El bit 7 para indicar si el bloque
8×8 al que referencia este atributo debe parpadear o no. El parpadeo,
para la ULA, consiste en el intercambio de las señales de color de tinta
 y color de papel que envía al monitor, alternándolas cada
aproximadamente medio segundo.
</li>
</ul>

<p>
 Recordemos que estos colores básicos son:
</p>
<div class="table-responsive sectionedit17"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Valor </th><th class="col1"> Color </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> Negro </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> Azul </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> Rojo </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> Magenta </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> Verde </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1"> Cian </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 6 </td><td class="col1"> Amarillo </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 7 </td><td class="col1"> Blanco </td>
	</tr>
</tbody></table></div>

<p>
 A estos colores se les puede activar el bit de brillo para obtener una
tonalidad más cercana a la intensidad máxima de dicho color. Examinando
de nuevo la captura que veíamos al principio del artículo:
</p>

<p>
<img src="img/colores_zx.png" class="mediacenter" alt=" Los colores del Spectrum "/>
</p>

<p>
 La relación de los colores con su “identificador numérico” está basada
en el estado de 4 bits: BRILLO, COMPONENTE_R, COMPONENTE_G y
COMPONENTE_B:
</p>
<div class="table-responsive sectionedit18"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Valor </th><th class="col1"> Bits “BRILLO R G B” </th><th class="col2"> Color </th><th class="col3"> Componentes RGB </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> 0000b </td><td class="col2"> Negro </td><td class="col3"> (0, 0, 0 ) </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> 0001b </td><td class="col2"> Azul </td><td class="col3"> (0, 0, 192) </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> 0010b </td><td class="col2"> Rojo </td><td class="col3"> (192, 0, 0) </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> 0011b </td><td class="col2"> Magenta </td><td class="col3"> (192, 0, 192) </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> 0100b </td><td class="col2"> Verde </td><td class="col3"> (0, 192, 0) </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1"> 0101b </td><td class="col2"> Cian </td><td class="col3"> (0, 192, 192) </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 6 </td><td class="col1"> 0110b </td><td class="col2"> Amarillo </td><td class="col3"> (192, 192, 0) </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 7 </td><td class="col1"> 0111b </td><td class="col2"> Blanco </td><td class="col3"> (192, 192, 192) </td>
	</tr>
	<tr class="row9">
		<td class="col0"> 8 </td><td class="col1"> 1000b </td><td class="col2"> Negro + Brillo </td><td class="col3"> (0, 0, 0) </td>
	</tr>
	<tr class="row10">
		<td class="col0"> 9 </td><td class="col1"> 1001b </td><td class="col2"> Azul + Brillo </td><td class="col3"> (0, 0, 255) </td>
	</tr>
	<tr class="row11">
		<td class="col0"> 10 </td><td class="col1"> 1010b </td><td class="col2"> Rojo + Brillo </td><td class="col3"> (255, 0, 0) </td>
	</tr>
	<tr class="row12">
		<td class="col0"> 11 </td><td class="col1"> 1011b </td><td class="col2"> Magenta + Brillo </td><td class="col3"> (255, 0, 255) </td>
	</tr>
	<tr class="row13">
		<td class="col0"> 12 </td><td class="col1"> 1100b </td><td class="col2"> Verde + Brillo </td><td class="col3"> (0, 255, 0) </td>
	</tr>
	<tr class="row14">
		<td class="col0"> 13 </td><td class="col1"> 1101b </td><td class="col2"> Cian + Brillo </td><td class="col3"> (0, 255, 255) </td>
	</tr>
	<tr class="row15">
		<td class="col0"> 14 </td><td class="col1"> 1110b </td><td class="col2"> Amarillo + Brillo </td><td class="col3"> (255, 255, 0) </td>
	</tr>
	<tr class="row16">
		<td class="col0"> 15 </td><td class="col1"> 1111b </td><td class="col2"> Blanco + Brillo </td><td class="col3"> (255, 255, 255) </td>
	</tr>
</tbody></table></div>

<p>
 Todos los colores se componen a través del estado de las componentes R,
 G y B (entre 0 y 1), así como de mezclas de dichas componentes (Ej:
Cian = 5 = 101b = R+B). Sería perfectamente posible separar la memoria
de atributos en 3 pantallas alojando el estado de las 3 componentes de
color (o incluso de combinaciones de ellas) extrayendo la información de
 los bits correspondientes.
</p>

<p>
 Pero volvamos a cada atributo individual: Si tuvieramos que codificar
mediante una operación matemática un color directamente como atributo, y
 sabiendo que las multiplicaciones por potencias de dos equivalen a
desplazamientos, se podría realizar de la siguiente forma:
</p>
<pre class="code"> Atributo = (Flash*128) + (Bright*64) + (Paper*8) + Ink</pre>

<p>
 O lo que es lo mismo:
</p>
<pre class="code"> Atributo = (Flash&lt;&lt;7) + (Bright&lt;&lt;6) + (Paper&lt;&lt;3) + Ink</pre>

<p>
 A continuación veremos un ejemplo similar al del capítulo anterior para estudiar la organización de la memoria de atributos.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit19" id="explorando-el-area-de-atributos-con-un-ejemplo">Explorando el área de atributos con un ejemplo</h3>
<div class="level3">

<p>
 A continuación tenemos el código de otro un sencillo programa
(attrtest.asm) que muestra la total linealidad del área de atributos con
 respecto a los bloques de baja resolución de la pantalla.
</p>

<p>
 Este programa carga HL con el inicio del área de atributos de la
videomemoria (22528), y escribe bloques de 32 bytes (los atributos de 32
 bloques de 8×8) con un valor que cambia entre 8 y 15 (o lo que es lo
mismo, variando entre 0 y 7 los 3 bits de PAPEL del atributo, bits del 3
 al 5).
</p>

<p>
 Al igual que en el ejemplo anterior. hemos añadido de nuevo en cada
iteración del bucle externo la necesidad de pulsar y liberar una tecla
para permitir al lector estudiar los efectos de cada escritura de 32
bytes en la pantalla, y poder tratar de predecir el efecto de la
escritura de los siguientes 32 bytes.
</p>
<pre class="code z80">  <span class="co1">; Mostrando la organizacion de la videomemoria (atributos)</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="co1">; Pseudocodigo del programa:</span>
  <span class="co1">; </span>
  <span class="co1">; Borramos la pantalla</span>
  <span class="co1">; Apuntamos HL a 22528</span>
  <span class="co1">; Repetimos 24 veces:</span>
  <span class="co1">;    Esperamos pulsacion de una tecla</span>
  <span class="co1">;    Repetimos 32 veces:</span>
  <span class="co1">;       Escribir un valor de PAPEL 0-7 en la direccion apuntada por HL</span>
  <span class="co1">;       Incrementar HL</span>
&nbsp;
Start:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>
  <span class="kw1">CALL</span> ClearScreen           <span class="co1">; Borramos la pantalla</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">22528</span>               <span class="co1">; HL apunta a la VRAM</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">24</span>                  <span class="co1">; Repetimos para 192 lineas</span>
&nbsp;
bucle_lineas:
  <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">B</span>                    <span class="co1">; Nos guardamos el valor de D para el</span>
                             <span class="co1">; bucle exterior (usaremos B ahora en otro)</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">32</span>                   <span class="co1">; B=32 para el bucle interior</span>
&nbsp;
                             <span class="co1">; Esperamos que se pulse y libere tecla</span>
  <span class="kw1">CALL</span> Wait_For_Keys_Pressed
  <span class="kw1">CALL</span> Wait_For_Keys_Released
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>papel<span class="br0">)</span>              <span class="co1">; Cogemos el valor del papel</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>                      <span class="co1">; Lo incrementamos</span>
  <span class="kw1">LD</span> <span class="br0">(</span>papel<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; Lo guardamos de nuevo</span>
  <span class="kw1">CP</span> <span class="nu0">8</span>                       <span class="co1">; Si es == 8 (&gt;7), resetear</span>
  <span class="kw1">JR</span> NZ,no_resetear_papel
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>
  <span class="kw1">LD</span> <span class="br0">(</span>papel<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; Lo hemos reseteado: lo guardamos</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>                      <span class="co1">; A=0</span>
&nbsp;
no_resetear_papel:
&nbsp;
  <span class="kw1">SLA</span> <span class="kw2">A</span>                      <span class="co1">; Desplazamos A 3 veces a la izquierda</span>
  <span class="kw1">SLA</span> <span class="kw2">A</span>                      <span class="co1">; para colocar el valor 0-7 en los bits</span>
  <span class="kw1">SLA</span> <span class="kw2">A</span>                      <span class="co1">; donde se debe ubicar PAPER (bits 3-5).</span>
&nbsp;
bucle_32_bytes:
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                 <span class="co1">; Almacenamos A en (HL) = attrib de 8x8</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>                     <span class="co1">; siguiente byte (siguientes 8x8 pixeles.)</span>
  <span class="kw1">DJNZ</span> bucle_32_bytes        <span class="co1">; 32 veces = 32 bytes = 1 scanline de bloques</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">D</span>                    <span class="co1">; Recuperamos el B del bucle exterior</span>
&nbsp;
  <span class="kw1">DJNZ</span> bucle_lineas          <span class="co1">; Repetir 24 veces</span>
&nbsp;
  <span class="kw1">JP</span> Start                   <span class="co1">; Inicio del programa</span>
&nbsp;
papel  defb   <span class="nu0">255</span>            <span class="co1">; Valor del papel</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Esta rutina espera a que haya alguna tecla pulsada para volver.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Pressed:
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
  <span class="kw1">OR</span> <span class="nu0">224</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> Z, Wait_For_Keys_Pressed
  <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Esta rutina espera a que no haya ninguna tecla pulsada para volver.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Released:
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
  <span class="kw1">OR</span> <span class="nu0">224</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> NZ, Wait_For_Keys_Released
  <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Limpiar la pantalla con el patron de pixeles indicado.</span>
<span class="co1">; Entrada:  A = patron a utilizar</span>
<span class="co1">;-----------------------------------------------------------------------</span>
ClearScreen:
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1</span><span class="nu0">92</span><span class="sy0">*</span><span class="nu0">32</span><span class="sy0">-</span><span class="re1">1</span>
  <span class="kw1">LDIR</span>
  <span class="kw1">RET</span>
&nbsp;
END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 Si ensamblamos y ejecutamos el programa veremos lo siguiente tras algunos ciclos de iteración del bucle externo:
</p>

<p>
<br>

<img src="img/gfx1_attr.png" class="mediacenter" alt=" Explorando el área de atributos "/>
<br>

</p>

<p>
 Nótese que no estamos trazando ningún pixel sino cambiando el color de
PAPEL de cada bloque de 8×8 lo que provoca el cambio de color de los 64
píxeles del bloque que no estén activos (que son todos pues hemos
borrado el contenido del área gráfica al principio del programa).
</p>

<p>
 Con cada pulsación de teclado escribimos 32 bytes más en la zona de
atributos, los cuales se corresponden con la siguiente fila de bloques
de pantalla en baja resolución.
</p>

<p>
 La memoria de atributos difiere de la de imagen en cuanto a que es
totalmente lineal y que cada byte representa al bloque inmediatamente
siguiente. Al llegar a la esquina derecha de la pantalla, el siguiente
byte se corresponde con el primero de la siguiente línea.
</p>

<p>
 Con esta información, nos podemos crear la siguiente rutina para establecer el valor de atributos de toda la pantalla:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------</span>
<span class="co1">; Establecer los colores de la pantalla con el byte de</span>
<span class="co1">; atributos indicado.</span>
<span class="co1">; Entrada:  A = atributo a utilizar</span>
<span class="co1">;-------------------------------------------------------</span>
ClearAttributes:
  <span class="kw1">PUSH</span> <span class="kw2">HL</span>
  <span class="kw1">PUSH</span> <span class="kw2">DE</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">22528</span>          <span class="co1">; HL = Inicio del area de atributos</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Escribimos el patron A en (HL)</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">22529</span>          <span class="co1">; Apuntamos DE a 22528</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">24</span><span class="sy0">*</span><span class="nu0">32</span><span class="sy0">-</span><span class="re1">1</span>        <span class="co1">; Copiamos 767 veces (HL) en (DE)</span>
  <span class="kw1">LDIR</span>                  <span class="co1">; e incrementamos HL y DL. Restamos 1</span>
                        <span class="co1">; porque ya hemos escrito en 22528.</span>
  <span class="kw1">POP</span> <span class="kw2">DE</span>
  <span class="kw1">POP</span> <span class="kw2">HL</span>
  <span class="kw1">RET</span>                   </pre>

<p>
<br>

</p>

</div>

<h2 id="el-color-del-borde-de-la-pantalla">El color del borde de la pantalla</h2>
<div class="level2">

<p>
 El área gráfica de 256×192 píxeles está centrada en el centro de la
pantalla o monitor, dejando alrededor de ella un marco denominado BORDE.
 Este borde tiene 64 píxeles en las franjas horizontales y 48 píxeles en
 las verticales.
</p>

<p>
 El borde tiene un color único que la ULA utiliza para retrazar todos y
cada uno de los píxeles de este marco. Podemos cambiar este color
accediendo en el Z80 al puerto de la ULA que controla el borde.
</p>

<p>
 El conocido comando de BASIC “BORDER” llama a la rutina de la ROM <em>BORDER</em>
 en $2294, la cual realiza el cambio del color del borde mediante el
acceso a la ULA y además actualiza la variable del sistema BORDCR en
23624d.
</p>

<p>
 Concretamente, basta con escribir un valor en el rango 0-7 en el puerto
 $FE (254) para que la ULA utilice ese valor desde ese instante como
color del borde. Las típicas líneas “de carga” en el borde que podemos
ver durante las rutinas de LOAD y SAVE son cambios del color del borde
realizados rápidamente como indicadores de la carga mientras la ULA está
 dibujando el cuadro actual. Si se cambia el borde con la suficiente
rapidez, la ULA cambiará el color con que lo está dibujando cuando
todavía no ha acabado la generación del cuadro de imagen actual. El
valor 0-7 representa el identificador de color a utilizar de la paleta
de 8 colores de la ULA, y este valor lo almacena internamente la ULA (no
 el Z80), ya que requiere de acceso instantáneo a él durante la
generación del vídeo.
</p>

<p>
 En el capítulo dedicado a los Puertos de Entrada / Salida pudimos ya
observar un ejemplo de cambio de color del borde, que ahora vamos a
modificar para separar el OUT en una función <em>SetBorder</em> propia:
</p>
<pre class="code z80"><span class="co1">; Cambio del color del borde al pulsar espacio</span>
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">6</span>              <span class="co1">; 6 iteraciones, color inicial borde</span>
&nbsp;
start:
&nbsp;
bucle:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>7F            <span class="co1">; Semifila B a ESPACIO</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>          <span class="co1">; Leemos el puerto</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>             <span class="co1">; Testeamos el bit 0 (ESPACIO)</span>
  <span class="kw1">JR</span> NZ, bucle         <span class="co1">; Si esta a 1 (no pulsado), esperar</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>              <span class="co1">; A = B</span>
  <span class="kw1">CALL</span> SetBorder       <span class="co1">; Cambiamos el color del borde</span>
&nbsp;
suelta_tecla:          <span class="co1">; Ahora esperamos a que se suelte la tecla</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>7F            <span class="co1">; Semifila B a ESPACIO</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="sy0">$</span>FE<span class="br0">)</span>          <span class="co1">; Leemos el puerto</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>             <span class="co1">; Testeamos el bit 0</span>
  <span class="kw1">JR</span> Z, suelta_tecla   <span class="co1">; Saltamos hasta que se suelte</span>
&nbsp;
  <span class="kw1">DJNZ</span> bucle           <span class="co1">; Repetimos "B" veces</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">7</span>
  <span class="kw1">JP</span> start             <span class="co1">; Y repetir</span>
&nbsp;
salir:
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;------------------------------------------------------------</span>
<span class="co1">; SetBorder: Cambio del color del borde al del registro A</span>
<span class="co1">;------------------------------------------------------------</span>
SetBorder:
  <span class="kw1">OUT</span> <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">RET</span>
&nbsp;
  END <span class="nu0">5</span><span class="re1">0000</span>            <span class="co1">; Ejecucion en 50000</span></pre>

<p>
 La ejecución del programa anterior cambiará el color del borde con cada pulsación de la tecla ESPACIO:
</p>

<p>
<br>

<img src="img/borde.png" class="mediacenter" alt=" Cambio del color del borde "/>
</p>

<p>
 Si por algún motivo necesitaramos actualizar la variable del sistema
BORDCR (porque vayamos a llamar a rutinas de la ROM que lo puedan
manipular), bastará con modificar SetBorder para que almacene el valor
del borde en la posición de memoria (23624) colocando primero el valor
0-7 en la posición de bits de PAPEL y estableciendo la tinta a negro si
el brillo está activo:
</p>
<pre class="code z80"><span class="co1">;------------------------------------------------------------</span>
<span class="co1">; SetBorder: Cambio del color del borde al del registro A</span>
<span class="co1">; Se establece BORDCR tal cual lo requiere BASIC.</span>
<span class="co1">;------------------------------------------------------------</span>
SetBorder:
  <span class="kw1">OUT</span> <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>, <span class="kw2">A</span>           <span class="co1">; Cambiamos el color del borde</span>
  <span class="kw1">RLCA</span>
  <span class="kw1">RLCA</span>
  <span class="kw1">RLCA</span>                   <span class="co1">; A = A*8 (colocar en bits PAPER)</span>
  <span class="kw1">BIT</span> <span class="nu0">5</span>, <span class="kw2">A</span>               <span class="co1">; Mirar si es un color BRIGHT</span>
  <span class="kw1">JR</span> NZ, SetBorder_fin   <span class="co1">; No es bright -&gt; guardarlo</span>
                         <span class="co1">; Si es bright</span>
  <span class="kw1">XOR</span> <span class="nu0">7</span>                  <span class="co1">; -&gt; cambiar la tinta a 0</span>
&nbsp;
SetBorder_fin:
  <span class="kw1">LD</span> <span class="br0">(</span><span class="nu0">23624</span><span class="br0">)</span>, <span class="kw2">A</span>        <span class="co1">; Salvar el valor en BORDCR</span>
&nbsp;
  <span class="kw1">RET</span></pre>

<p>
 Mantener actualizado BORDCR puede ser útil si pretendemos llamar a la
rutina de la ROM BEEPER (en $03B65), ya que el puerto que se utiliza
para controlar el altavoz es el mismo que el del borde (salvo que se
utiliza el bit 4 del valor que se envía con OUT $FE). La rutina BEEPER
carga el valor de BORDCR para, además del manipular el bit 4 del puerto,
 cargar los bits 0, 1 y 2 con el borde actual para que éste no cambie.
Si no estuviera almacenado el valor del borde en BORDCR y BEEPER no lo
incluyera en los bits 0-2 de su OUT, lo establecería en negro (000) con
cada cambio del estado del speaker.
</p>

<p>
 Finalmente, recomendamos al lector que elimine del programa anterior la
 necesidad de pulsar y soltar una tecla. De esta forma podrá verificar
qué sucede cuando se cambia el color del borde mientras la ULA lo está
dibujando:
</p>
<pre class="code z80"> <span class="co1">; Cambio del color del borde mientras la ULA dibuja</span>
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">6</span>              <span class="co1">; 6 iteraciones, color inicial borde</span>
&nbsp;
start:
&nbsp;
bucle:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>              <span class="co1">; A = B</span>
  <span class="kw1">CALL</span> SetBorder       <span class="co1">; Cambiamos el color del borde</span>
&nbsp;
  <span class="kw1">DJNZ</span> bucle           <span class="co1">; Repetimos "B" veces</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">7</span>
  <span class="kw1">JP</span> start             <span class="co1">; Y repetir</span>
&nbsp;
salir:
  <span class="kw1">RET</span></pre>

<p>
 El resultado de la ejecución es el siguiente:
</p>

<p>
<br>

<img src="img/gfx_border_np.png" class="mediacenter" alt=" Cambiando el borde, sin pausa "/>
<br>

</p>

<p>
 Como curiosidad al respecto de la diferencia de velocidad entre BASIC y
 ensamblador, pruebe a ejecutar el siguiente programa en su intérprete
BASIC:
</p>
<pre class="code basic">10 FOR I=0 TO 7 : BORDER I : NEXT I : GOTO 10</pre>

<p>
 La ejecución del anterior programa sólo es capaz de establecer 2 (3 a
lo sumo) bordes diferentes en un mismo cuadro de imagen mientras que la
versión ASM puede cambiar el color del borde más de 35 veces por cuadro:
</p>

<p>
<br>

<img src="img/gfx_border_basic.png" class="mediacenter" alt=" Cambiando el borde, sin pausa "/>
<br>

</p>

<p>
 Cabe destacar que en esta ocasión BASIC es todavía más rápido de lo
normal pues la ejecución de BORDER I acaba resultando en la llamada a la
 función de la ROM “BORDER” que apenas tiene 12 instrucciones (parecida a
 nuestra SetBorder), lo que deja todavía más en evidencia la velocidad
de lo que es el intérprete de BASIC en sí.
</p>

<p>
<br>

</p>

</div>

<h2 id="el-atributo-actual-attr-t">El "atributo actual" ATTR-T</h2>
<div class="level2">

<p>
 Ahora que conocemos el formato de una celdilla de atributo podemos
hablar de la variable del sistema ATTR-T (dirección de memoria 23695),
la cual almacena el atributo actual que las rutinas de la ROM del
Spectrum como nuestra conocida RST 16.
</p>

<p>
 A continuación tenemos un ejemplo que imprime cadenas con diferentes
atributos de color. Para ello se ha creado una rutina PrintString basada
 en imprimir caracteres mediante RST 16, que utiliza el valor de ATTR-T.
</p>
<pre class="code z80">  <span class="co1">; Mostrando la organizacion de la videomemoria (atributos)</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
  <span class="co1">; Pseudocodigo del programa:</span>
  <span class="co1">; </span>
  <span class="co1">; Borramos la pantalla</span>
  <span class="co1">; Apuntamos HL a 22528</span>
  <span class="co1">; Repetimos 24 veces:</span>
  <span class="co1">;    Esperamos pulsacion de una tecla</span>
  <span class="co1">;    Repetimos 32 veces:</span>
  <span class="co1">;       Escribir un valor de PAPEL 0-7 en la direccion apuntada por HL</span>
  <span class="co1">;       Incrementar HL</span>
&nbsp;
Start:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span>                    <span class="co1">; Borde azul</span>
  <span class="kw1">CALL</span> SetBorder
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>
  <span class="kw1">CALL</span> ClearScreen           <span class="co1">; Borramos la pantalla</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">8</span><span class="sy0">+</span><span class="nu0">4</span>                  <span class="co1">; Atributos: rojo sobre azul</span>
  <span class="kw1">CALL</span> ClearAttributes
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, linea<span class="re1">1</span>
  <span class="kw1">CALL</span> PrintString
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">2</span>                   <span class="co1">; Atributos: verde sobre azul</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="nu0">23695</span><span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, linea2
  <span class="kw1">CALL</span> PrintString
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">64</span><span class="sy0">+</span><span class="nu0">2</span><span class="sy0">+</span><span class="nu0">9</span>              <span class="co1">; Atributos: magenta sobre cyan + brillo.</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="nu0">23695</span><span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, linea2
  <span class="kw1">CALL</span> PrintString
&nbsp;
  <span class="co1">; Esperamos que se pulse y libere tecla</span>
  <span class="kw1">CALL</span> Wait_For_Keys_Pressed
  <span class="kw1">CALL</span> Wait_For_Keys_Released
&nbsp;
  <span class="kw1">RET</span>                      <span class="co1">; Fin del programa</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Esta rutina espera a que haya alguna tecla pulsada para volver.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Pressed:
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
  <span class="kw1">OR</span> <span class="nu0">224</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> Z, Wait_For_Keys_Pressed
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Esta rutina espera a que no haya ninguna tecla pulsada para volver.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Released:
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
  <span class="kw1">OR</span> <span class="nu0">224</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> NZ, Wait_For_Keys_Released
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Limpiar la pantalla con el patron de pixeles indicado.</span>
<span class="co1">; Entrada:  A = patron a utilizar</span>
<span class="co1">;-----------------------------------------------------------------------</span>
ClearScreen:
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>          <span class="co1">; HL = Inicio del area de imagen</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Escribimos el valor de A en (HL)</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>          <span class="co1">; Apuntamos DE a 16385</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1</span><span class="nu0">92</span><span class="sy0">*</span><span class="nu0">32</span><span class="sy0">-</span><span class="re1">1</span>       <span class="co1">; Copiamos 6142 veces (HL) en (DE)</span>
  <span class="kw1">LDIR</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-------------------------------------------------------------------------</span>
<span class="co1">; Establecer los colores de la pantalla con el byte de atributos indicado.</span>
<span class="co1">; Entrada:  A = atributo a utilizar</span>
<span class="co1">;-------------------------------------------------------------------------</span>
ClearAttributes:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="nu0">22528</span>          <span class="co1">; HL = Inicio del area de atributos</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Escribimos el patron A en (HL)</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">22529</span>          <span class="co1">; Apuntamos DE a 22529</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">24</span><span class="sy0">*</span><span class="nu0">32</span><span class="sy0">-</span><span class="re1">1</span>        <span class="co1">; Copiamos 767 veces (HL) en (DE)</span>
  <span class="kw1">LDIR</span>                  <span class="co1">; e incrementamos HL y DL. Restamos 1</span>
                        <span class="co1">; porque ya hemos escrito en 22528.</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-------------------------------------------------------------------------</span>
<span class="co1">; SetBorder: Cambio del color del borde al del registro A</span>
<span class="co1">; Se establece BORDCR tal cual lo requiere BASIC.</span>
<span class="co1">;-------------------------------------------------------------------------</span>
SetBorder:
  <span class="kw1">OUT</span> <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>, <span class="kw2">A</span>           <span class="co1">; Cambiamos el color del borde</span>
  <span class="kw1">RLCA</span>
  <span class="kw1">RLCA</span>
  <span class="kw1">RLCA</span>                   <span class="co1">; A = A*8 (colocar en bits PAPER)</span>
  <span class="kw1">BIT</span> <span class="nu0">5</span>, <span class="kw2">A</span>               <span class="co1">; Mirar si es un color BRIGHT</span>
  <span class="kw1">JR</span> NZ, SetBorder_fin   <span class="co1">; No es bright -&gt; guardarlo</span>
                         <span class="co1">; Si es bright</span>
  <span class="kw1">XOR</span> <span class="nu0">7</span>                  <span class="co1">; -&gt; cambiar la tinta a 0</span>
&nbsp;
SetBorder_fin:
  <span class="kw1">LD</span> <span class="br0">(</span><span class="nu0">23624</span><span class="br0">)</span>, <span class="kw2">A</span>          <span class="co1">; Salvar el valor en BORDCR</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-------------------------------------------------------------------------</span>
<span class="co1">; PrintString: imprime una cadena acabada en valor cero (no caracter 0).</span>
<span class="co1">; HL = direccion de la cadena de texto a imprimir.</span>
<span class="co1">;-------------------------------------------------------------------------</span>
PrintString:
&nbsp;
printstrloop:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>             <span class="co1">; Obtener el siguiente caracter a imprimir</span>
  <span class="kw1">CP</span> <span class="re1">0</span>                   <span class="co1">; Comprobar si es un 0 (fin de linea)</span>
  <span class="kw1">RET</span> Z                  <span class="co1">; Si es cero, fin de la rutina</span>
  <span class="kw1">RST</span> <span class="re1">1</span><span class="nu0">6</span>                 <span class="co1">; No es cero, imprimir caracter o codigo</span>
                         <span class="co1">; de control (13=enter, etc).</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>                 <span class="co1">; Avanzar al siguiente caracter</span>
  <span class="kw1">JP</span> printstrloop        <span class="co1">; Repetir bucle         </span>
  <span class="kw1">ret</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------------------</span>
<span class="co1">; Datos</span>
<span class="co1">;-------------------------------------------------------------------------</span>
linea<span class="re1">1</span>:  defb <span class="st0">'Impreso con ATTR-T actual'</span>, <span class="re1">1</span><span class="nu0">3</span>, <span class="re1">1</span><span class="nu0">3</span>, <span class="re1">0</span>
linea2:  defb <span class="st0">'Esto es una prueba'</span>,<span class="re1">1</span><span class="nu0">3</span>,<span class="st0">'cambiando los atributos'</span>, <span class="re1">1</span><span class="nu0">3</span>, <span class="re1">1</span><span class="nu0">3</span>, <span class="re1">0</span>
&nbsp;
&nbsp;
END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 Con nuestra nueva rutina de PrintString trazaremos en pantalla 1 línea
con los atributos actuales seguida de 2 líneas con diferentes atributos.
 Nótese como RST 16 entiende e interpreta en las cadenas los códigos de
control como por ejemplo 13 (retorno de carro).
</p>

<p>
<br>

<img src="img/gfx1_attrt.png" class="mediacenter" alt=" Ejemplo que modifica ATTR-T "/>
<br>

</p>

<p>
 Nótese que dado lo habitual que puede ser llamar a ClearScreen y
ClearAttributes, podemos desarrollar una función ClearScreenAttributes
que realice ambas funciones en una misma llamada:
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Limpiar la pantalla con el patron de pixeles y atributos indicado.</span>
<span class="co1">; Entrada:  H = atributo, L = patron</span>
<span class="co1">;-----------------------------------------------------------------------</span>
ClearScreenAttrib:
  <span class="kw1">PUSH</span> <span class="kw2">DE</span>
  <span class="kw1">PUSH</span> <span class="kw2">BC</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>               <span class="co1">; A = el atributo</span>
  <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'            ; Nos guardamos el atributo en A'</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>               <span class="co1">; Cargamos en A el patron</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>          <span class="co1">; HL = Inicio del area de imagen</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Escribimos el valor de A en (HL)</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6385</span>          <span class="co1">; Apuntamos DE a 16385</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="re1">1</span><span class="nu0">92</span><span class="sy0">*</span><span class="nu0">32</span><span class="sy0">-</span><span class="re1">1</span>       <span class="co1">; Copiamos 6142 veces (HL) en (DE)</span>
  <span class="kw1">LDIR</span>
&nbsp;
  <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'            ; Recuperamos A (atributo) de A'</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>                <span class="co1">; Incrementamos HL y DE</span>
  <span class="kw1">INC</span> <span class="kw2">DE</span>                <span class="co1">; para entrar en area de atributos</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Almacenamos el atributo</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">24</span><span class="sy0">*</span><span class="nu0">32</span><span class="sy0">-</span><span class="re1">1</span>        <span class="co1">; Ahora copiamos 767 bytes</span>
  <span class="kw1">LDIR</span>
&nbsp;
  <span class="kw1">POP</span> <span class="kw2">BC</span>
  <span class="kw1">POP</span> <span class="kw2">DE</span>
  <span class="kw1">RET</span></pre>

<p>
 Por otra parte, cuando tratemos las fuentes de texto como sprites de
carácteres en baja resolución utilizaremos rutinas de impresión de
cadenas más rápidas (y con juegos de caracteres personalizados) al no
tener que interpretar éstas los diferentes códigos de control que se
pueden insertar en las mismas.
</p>

<p>
<br>

</p>

</div>

<h2 id="efectos-sobre-la-imagen-y-los-atributos">Efectos sobre la imagen y los atributos</h2>
<div class="level2">

<p>
 Ahora ya conocemos la organización de la zona de imagen y atributos y
sabemos (del capítulo sobre rutinas de SAVE/LOAD) cargar en ella datos
gráficos desde cinta o incluir los datos gráficos en nuestro propio
programa y volcarlos con instrucciones LDIR. Estamos pues en disposición
 de realizar pequeñas y sencillas rutinas de borrado de pantalla o de
aparición de los datos en la misma de diferentes formas, como por
ejemplo:
</p>
<ul class="fix-media-list-overlap">
<li> Efectos de fundido de los atributos de pantalla a negro.
</li>
<li> Efectos de aparición de imagen como
establecer todos los atributos a negro, copiar los datos gráficos y
hacer aparecer la imagen realizando una copia de los atributos desde una
 zona de atributos virtual con algún tipo de efecto (circular, desde los
 laterales, como un recuadro, etc).
</li>
<li> Desaparición de la imagen
manipulando los bits de pantalla (de izquierda a derecha, de arriba a
abajo, reduciendo estos bits a cero, etc).
</li>
<li> Inversión horizontal, vertical o de estado de los bits de los datos gráficos de pantalla.
</li>
<li> Zoom o reducción de alguna zona de pantalla.
</li>
<li> (etc…).
</li>
</ul>

<p>
 Por ejemplo, la siguiente rutina vacía el contenido de una pantalla
(preferentemente monocolor) haciendo una rotación de los píxeles de cada
 bloque de pantalla. Los bloques 0-15 verán sus píxeles rotados a la
izquierda y los bloques 16-31 a la derecha:
</p>
<pre class="code z80">  <span class="co1">; Fundido de los pixeles a cero con una cortinilla</span>
&nbsp;
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
Start:
&nbsp;
  <span class="co1">; Rellenamos la VRAM de pixeles copiando 6 KB de la ROM</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">0</span>
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="re1">1</span><span class="nu0">6384</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="nu0">6</span><span class="re1">1</span><span class="nu0">44</span>
  <span class="kw1">LDIR</span>
&nbsp;
  <span class="kw1">CALL</span> Wait_For_Keys_Pressed
  <span class="kw1">CALL</span> Wait_For_Keys_Released
  <span class="kw1">CALL</span> FadeScreen
&nbsp;
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Pressed:
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
  <span class="kw1">OR</span> <span class="nu0">224</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> Z, Wait_For_Keys_Pressed
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
Wait_For_Keys_Released:
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
  <span class="kw1">OR</span> <span class="nu0">224</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> NZ, Wait_For_Keys_Released
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Fundido de pantalla decrementando los pixeles de pantalla</span>
<span class="co1">;-----------------------------------------------------------------------</span>
FadeScreen:
   <span class="kw1">PUSH</span> <span class="kw2">AF</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                      <span class="co1">; Preservamos los registros</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">9</span>                      <span class="co1">; Repetiremos el bucle 9 veces</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">0</span>                      <span class="co1">; Nuestro contador de columna</span>
&nbsp;
fadegfx_loop<span class="re1">1</span>:
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span>                 <span class="co1">; Apuntamos HL a la zona de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">6</span><span class="re1">1</span><span class="nu0">44</span>                  <span class="co1">; Iteraciones bucle</span>
&nbsp;
fadegfx_loop2:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                   <span class="co1">; Cogemos el grupo de 8 pixeles</span>
&nbsp;
&nbsp;
   <span class="co1">;-- Actuamos sobre el valor de los pixeles --</span>
   <span class="kw1">CP</span> <span class="re1">0</span>                         <span class="co1">;</span>
   <span class="kw1">JR</span> Z, fadegfx_save           <span class="co1">; Si ya es cero, no hacemos nada</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                   ; Nos guardamos el dato en A'</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                      <span class="co1">; Pasamos el contador a A</span>
   <span class="kw1">CP</span> <span class="re1">1</span><span class="nu0">5</span>                        <span class="co1">; Comparamos A con 15</span>
   <span class="kw1">JR</span> NC, fadegfx_mayor<span class="re1">1</span><span class="nu0">5</span>       <span class="co1">; Si es mayor, saltamos</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                   ; Recuperamos los pixeles desde A'</span>
   <span class="kw1">RLA</span>                          <span class="co1">; Rotamos A a la izquierda</span>
   <span class="kw1">JR</span> fadegfx_save              <span class="co1">; Y guardamos el dato</span>
&nbsp;
fadegfx_mayor<span class="re1">1</span><span class="nu0">5</span>:
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                   ; Recuperamos los pixeles desde A'</span>
   <span class="kw1">SRL</span> <span class="kw2">A</span>                        <span class="co1">; Rotamos A a la derecha </span>
&nbsp;
   <span class="co1">;-- Fin actuacion sobre el valor de los pixeles --</span>
&nbsp;
fadegfx_save:
&nbsp;
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Almacenamos el atributo modificado</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                       <span class="co1">; Avanzamos puntero de memoria</span>
&nbsp;
   <span class="co1">; Incrementamos el contador y comprobamos si hay que resetearlo</span>
   <span class="kw1">INC</span> <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">CP</span> <span class="nu0">32</span>
   <span class="kw1">JR</span> NZ, fadegfx_continue
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">0</span>
&nbsp;
fadegfx_continue:
&nbsp;
   <span class="kw1">DEC</span> <span class="kw2">DE</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
   <span class="kw1">OR</span> <span class="kw2">E</span>
   <span class="kw1">JP</span> NZ, fadegfx_loop2      <span class="co1">; Hasta que DE == 0</span>
&nbsp;
   <span class="kw1">DJNZ</span> fadegfx_loop<span class="re1">1</span>        <span class="co1">; Repeticion 9 veces</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">POP</span> <span class="kw2">AF</span>                       <span class="co1">; Restauramos registros</span>
   <span class="kw1">RET</span>
&nbsp;
END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 El efecto sobre píxeles aleatorios en pantalla es el siguiente:
</p>

<p>
<br>

<img src="img/gfx1_fadeg.png" class="mediacenter" alt="Captura durante el fade de pixeles"/>
<br>

</p>

<p>
 Podemos cambiar la rutina para que realice diferentes efectos sobre los
 píxeles modificando el núcleo de la misma, identificado con el
comentario <em>Actuamos sobre el valor de los píxeles</em>.
</p>

<p>
 A continuación podemos ver la rutina de degradación de atributos que
vimos como un ejemplo en el capítulo dedicado a la pila. Este efecto
aplicado sobre una pantalla gráfica puede utilizarse como “fundido a
negro” de la misma. Podemos utilizar el esqueleto del programa anterior
como base para llamar a esta rutina:
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Fundido de pantalla decrementando tinta y papel en los atributos.</span>
<span class="co1">;-----------------------------------------------------------------------</span>
FadeAttributes:
   <span class="kw1">PUSH</span> <span class="kw2">AF</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                      <span class="co1">; Preservamos los registros</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">9</span>                      <span class="co1">; Repetiremos el bucle 9 veces</span>
&nbsp;
fadescreen_loop<span class="re1">1</span>:
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">6384</span><span class="sy0">+</span><span class="nu0">6</span><span class="re1">1</span><span class="nu0">44</span>            <span class="co1">; Apuntamos HL a la zona de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">768</span>                   <span class="co1">; Iteraciones bucle</span>
&nbsp;
   <span class="kw1">HALT</span>
   <span class="kw1">HALT</span>                         <span class="co1">; Ralentizamos el efecto</span>
&nbsp;
fadescreen_loop2:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                   <span class="co1">; Cogemos el atributo</span>
   <span class="kw1">AND</span> <span class="re1">1</span><span class="nu0">27</span>                      <span class="co1">; Eliminamos el bit de flash</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
&nbsp;
   <span class="kw1">AND</span> <span class="nu0">7</span>                        <span class="co1">; Extraemos la tinta (AND 00000111b)</span>
   <span class="kw1">JR</span> Z, fadescreen_ink_zero    <span class="co1">; Si la tinta ya es cero, no hacemos nada</span>
&nbsp;
   <span class="kw1">DEC</span> <span class="kw2">A</span>                        <span class="co1">; Si no es cero, decrementamos su valor</span>
&nbsp;
fadescreen_ink_zero:
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                   ; Nos hacemos una copia de la tinta en A'</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                      <span class="co1">; Recuperamos el atributo</span>
   <span class="kw1">SRA</span> <span class="kw2">A</span>
   <span class="kw1">SRA</span> <span class="kw2">A</span>                        <span class="co1">; Pasamos los bits de paper a 0-2</span>
   <span class="kw1">SRA</span> <span class="kw2">A</span>                        <span class="co1">; con 3 instrucciones de desplazamiento &gt;&gt;</span>
&nbsp;
   <span class="kw1">AND</span> <span class="nu0">7</span>                        <span class="co1">; Eliminamos el resto de bits</span>
   <span class="kw1">JR</span> Z, fadescreen_paper_zero  <span class="co1">; Si ya es cero, no lo decrementamos</span>
&nbsp;
   <span class="kw1">DEC</span> <span class="kw2">A</span>                        <span class="co1">; Lo decrementamos</span>
&nbsp;
fadescreen_paper_zero:
   <span class="kw1">SLA</span> <span class="kw2">A</span>
   <span class="kw1">SLA</span> <span class="kw2">A</span>                        <span class="co1">; Volvemos a color paper en bits 3-5</span>
   <span class="kw1">SLA</span> <span class="kw2">A</span>                        <span class="co1">; Con 3 instrucciones de desplazamiento &lt;&lt;</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>                      <span class="co1">; Guardamos el papel decrementado en A</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                   ; Recuperamos A'</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>                         <span class="co1">; A = A OR C  =  PAPEL OR TINTA</span>
&nbsp;
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Almacenamos el atributo modificado</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                       <span class="co1">; Avanzamos puntero de memoria</span>
&nbsp;
   <span class="kw1">DEC</span> <span class="kw2">DE</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
   <span class="kw1">OR</span> <span class="kw2">E</span>
   <span class="kw1">JP</span> NZ, fadescreen_loop2      <span class="co1">; Hasta que DE == 0</span>
&nbsp;
   <span class="kw1">DJNZ</span> fadescreen_loop<span class="re1">1</span>        <span class="co1">; Repeticion 9 veces</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">POP</span> <span class="kw2">AF</span>                       <span class="co1">; Restauramos registros</span>
   <span class="kw1">RET</span></pre>

<p>
<br>

<img src="img/fade.png" class="mediacenter" alt="Captura durante el fade de la pantalla"/>
<br>

</p>

<p>
 Rutinas más complejas pueden producir cortinillas y efectos mucho más
vistosos. En la revista Microhobby se publicaron muchos de estos efectos
 de zoom, desaparición de pantalla o inversión, dentro de la sección <em>Trucos</em>.
</p>

<p>
<br>

</p>

</div>

<h2 id="la-shadow-vram-de-los-modelos-de-128k">La Shadow VRAM de los modelos de 128K</h2>
<div class="level2">

<p>
 En el capítulo dedicado a la paginación de memoria en los modelos de
128KB se habló de la paginación de bloques de 16KB sobre el área entre
$C000 y $FFFF. El bloque de 16KB que almacena la videoram (el bloque 5,
o, como se le conoce técnicamente, <strong>RAM5</strong>) está normalmente mapeado sobre $4000.
</p>

<p>
<br>

<img src="img/pag_normal.png" class="mediacenter" alt=" Paginación 128K "/>
</p>
<div style="text-align: center;"><em>Paginación 128K</em>
</div>
<p>
<br>

</p>

<p>
 En los modelos de 128K, existe un segundo bloque de 16KB que podemos utilizar como VideoRAM (<strong>Shadow VRAM</strong>). El Z80 y la ULA nos permiten mapear <strong>RAM7</strong>
 sobre $C000-$FFFF, dejando la VideoRAM original sobre $4000. Más
interesante todavía, la ULA puede visualizar el contenido de RAM7 en
lugar del de RAM5 aunque no hayamos mapeado RAM7 en ningún sitio. Y
recordemos que también podemos mapear la VRAM estándar (RAM5) sobre
$C000, accediendo a ella a través de $C000 además de mediante $4000.
</p>

<p>
 El poder visualizar una VRAM aunque no esté mapeada y el poder mapear
tanto RAM5 como RAM7 sobre $C000 nos permite organizar el código de
nuestro programa para que siempre escriba sobre $C000, teniendo mapeada
en $C000 la pantalla que actualmente no esté visible.
</p>

<p>
 La utilidad principal de esta funcionalidad es la de poder generar un
cuadro de imagen o animación en una “pantalla virtual” (la pantalla
shadow) que no es visible, cambiando la visualización a esta pantalla
una vez compuesta la imagen actual. De esta forma es posible trabajar
con una pantalla completa sin que nos alcance el haz de electrones
durante su dibujado, especialmente en juegos que realicen scrolles de
todo el área de imagen.
</p>

<p>
 En el tiempo disponible tras un pulso VSYNC no hay tiempo material para
 actualizar los 6KB de una pantalla completa sin que el haz de
electrones alcance a nuestro programa conforme manipula la memoria, por
lo que esta técnica permitiría realizar ese tipo de acciones con el
siguiente proceso:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Mapeamos RAM7 sobre $C000.
</li>
<li> Visualizamos RAM5 (RAM7 no es visible).
</li>
<li> Trabajamos sobre $C000 (sobre RAM7). Los cambios en nuestra pantalla shadow no son visibles.
</li>
<li> Esperamos una interrupción (mediante HALT o mediante coordinación con la ISR de la ULA).
</li>
<li> Cambiamos la visualización a RAM7 (RAM5 deja de ser visible).
</li>
<li> Mapeamos ahora RAM5 sobre $C000.
</li>
<li> Trabajamos sobre $C000 (sobre RAM5). Los cambios en nuestra pantalla shadow no son visibles.
</li>
<li> Repetimos el proceso.
</li>
</ul>

<p>
<br>

</p>

<p>
 Con este mecanismo siempre trabajamos sobre $C000 pero los cambios que
realizamos sobre esta pantalla virtual no son perceptibles por el
usuario. Cambiando la visualización de la VRAM a nuestra pantalla actual
 tras una interrupción hacemos los cambios visibles de forma inmediata,
sin que el haz de electrones afecte a nuestro scroll o al dibujado de
sprites. La tasa de fotogramas por segundo ya no sería de 50 (no
podríamos generar 1 cuadro de imagen por interrupción) pero se evitaría
un posible molesto efecto de parpadeo o cortinilla.
</p>

<p>
 La desventaja de este sistema es que utilizamos $C000-$FFFF como
pantalla virtual con lo que perdemos 16KB efectivos de RAM así como la
posibilidad de paginar sobre $C000. Nos quedan así 16KB de memoria
(entre $8000 y $BFFF) para alojar el código de nuestro programa, los
datos gráficos, textos, etc. Esto puede ser una enorme limitación según
el tipo de juego o programa que estemos realizando.
</p>

<p>
 En realidad, si diseñamos adecuadamente nuestro programa, podemos
aprovechar más de 16KB, puesto que sólo necesitamos mapear RAM5 ó RAM7
en $C000 durante la generación de la pantalla virtual. Esto obliga a que
 los gráficos, fuentes, sprites y mapeados del juego deban estar
disponibles en $8000-$BFFF, pero una vez finalizada la generación de la
pantalla podemos volver a mapear RAM0 sobre $C000, volviendo a la lógica
 del juego que podría estar ubicada en ese bloque, junto al resto de
variables, imágenes o textos usados en los menúes, efectos sonoros,
músicas, etc.
</p>

<p>
 Como véis, se necesita tener muy controlada la ubicación de las
diferentes rutinas y variables y diseñar el juego para que mapee la
página adecuada en cada momento y salte a una rutina concreta sólo
cuando la rutina a la que hace referencia un CALL esté contenida en la
página mapeada.
</p>

<p>
 Se reseñó también, en el apartado <em>Particularidades del +2A/+3</em>
la existencia de unos modos extendidos de paginación que permitirían
ubicar la segunda VideoRAM (el bloque 7, o RAM7) sobre $4000,
permitiendo el alternar entre la visualización de RAM5 o de RAM7 sin
perder la memoria $C000-$FFFF como “Pantalla Virtual”:
</p>

<p>
<br>

<img src="img/pag_especial.png" class="mediacenter" alt=" Los modos de paginación especial del +2A / +3 "/>
</p>
<div style="text-align: center;"><em>Modos de paginación especial del +2A/+3</em>
</div>
<p>
<br>

</p>

<p>
 Como puede verse en la figura anterior, los modos Bit2 = 0, Bit1 = 1
(Bancos 4-5-6-3) y Bit2 = 1, Bit 1=1 (Bancos 4-7-6-3) del puerto $1FFD
permiten paginar cualquiera de las 2 videorams (RAM5 o RAM7) sobre
$4000.
</p>

<p>
 Pese a las posibilidades de “animación sin parpadeo” que proporcionan
estas técnicas, la utilización de cualquiera de las dos tiene una
desventaja clara además de la “pérdida” (durante el dibujado de la
pantalla shadow) de los 16KB $C000-$FFFF, y es la incompatibilidad con
modelos de 48K, requiriendo un modelo de 128Kb para paginar RAM7 o
incluso de un +2A/+3 para el uso de la paginación extendida. Si a los
16KB de RAM5 le restamos los 7KB de pantalla nos quedan otros 9KB
adicionales, pero con la particularidad de que ese bloque de memoria
está “compartido” con la ULA por lo que la velocidad de lectura,
escritura y ejecución efectiva de este bloque se puede ver reducida
hasta en un 25%.
</p>

<p>
<br>

</p>

</div>

<h2 id="en-el-proximo-capitulo">En el próximo capítulo</h2>
<div class="level2">

<p>
 En el siguiente capítulo trataremos el cálculo de posiciones en memoria
 a partir de coordenadas en alta y baja resolución, lo que será la base
del posicionamiento de Sprites en baja y alta resolución y fuentes de
texto.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/gfx1_vramtest.asm">Explorando el área de imagen de la VRAM</a>
</li>
<li><a href="src/gfx1_vramtest.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx1_attrtest.asm">Explorando el área de atributos de la VRAM</a>
</li>
<li><a href="src/gfx1_attrtest.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx_border.asm">Cambiando el color del borde desde ASM</a>
</li>
<li><a href="src/gfx_border.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx1_string.asm">Cambiando ATTR-T para rutinas de la ROM</a>
</li>
<li><a href="src/gfx1_string.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx1_fadeg.asm">Sencillo fundido de pixeles de pantalla</a>
</li>
<li><a href="src/gfx1_fadeg.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/06_fade.asm">Sencillo fundido de atributos de pantalla</a>
</li>
<li><a href="src/06_fade.tap">Tap del ejemplo anterior</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/zx_display.pdf"> ZX Display File Organization</a>, por Alvin Albrecht.
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a>.</div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a>.</div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a>.</div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a>.</div>
</li>
</ul>

<p>
<br>

</p>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="graficos-y-iicalculo-de-direcciones-y-coordenadas">Gráficos (y II): Cálculo de direcciones y coordenadas</h1>
<div class="level1">

<p>
 En el anterior capítulo exploramos la organización interna de los 6912
bytes de la videomemoria del Spectrum, separándo esta videomemoria en un
 área de 6144 bytes de <em>archivo de imagen</em> comenzando en la dirección 16384 y otros 768 bytes de <em>archivo de atributos</em> comenzando en la dirección 22528.
</p>

<p>
 La manipulación de dichas áreas de memoria nos permite el trazado de
gráficos en pantalla y la manipulación de los colores que tienen dichos
gráficos en el monitor. Esto es así porque este área de memoria es leída
 por el chip de la ULA 50 veces por segundo en sistemas de televisión
PAL (Europa y Australia) y 60 veces por segundo en sistemas NTSC
(América y Asia) para enviar la señal que el televisor convierte en una
imagen para nuestros ojos.
</p>

<p>
 Es necesario que la ULA refresque la pantalla de forma continuada y
regular ya que debe reflejar los cambios que los programas hagan en la
videomemoria, así cómo para refrescar el estado de los píxeles del
monitor (necesario por el funcionamiento de la tecnología CRT).
</p>

<p>
 Sabemos por el capítulo anterior que escribir en la videomemoria nos
permite trazar gráficos en pantalla. Hasta ahora hemos visto efectos
globales aplicados a toda la vram (borrados, fundidos, etc), pero
nuestro interés principal será, seguramente, el trazar gráficos con
precisión de bloque o de pixel en la pantalla.
</p>

<p>
 Para poder realizar esta tarea necesitamos relacionar las posiciones de
 memoria de la videoram con las coordenadas (x,y) de pantalla cuya
información gráfica representan. Necesitaremos pues programar rutinas de
 cálculo de direcciones en función de coordenadas de alta y baja
resolución. Sabemos cómo dibujar, pero no cómo calcular la dirección de
memoria donde hacerlo. Este es precisamente nuestro objetivo en esta
sección.
</p>

<p>
 Para empezar, estableceremos una terminología unánime a la que haremos
referencia a lo largo de todo el capítulo, con las siguientes
definiciones:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Resolución del área gráfica</strong>:
 El Spectrum dispone de una resolución de 256×192 píxeles cuyo estado se
 define en cada byte del área de imagen de la videomemoria.</div>
</li>
<li><div class="li"> <strong>Estado de un pixel</strong>:
 Cada byte del área de imagen contiene el estado de 8 píxeles, de tal
forma que cada uno de los bits de dicho byte pueden estar a 1 (pixel
encendido, se traza con el color de tinta) o a 0 (apagado, se traza con
el color del papel).</div>
</li>
<li><div class="li"> <strong>Resolución del área de atributos</strong>:
 El Spectrum tiene una resolución de color de 32×24 puntos, que se
mapean sobre la pantalla de forma que cada grupo de 8×8 píxeles del área
 gráfica tiene una correspondencia con un atributo del área de
atributos.</div>
</li>
<li><div class="li"> <strong>Atributo</strong>: Un
atributo define en los 8 bits de un byte el color de tinta y papel y el
estado de brillo y parpadeo de un bloque concreto de la pantalla.</div>
</li>
<li><div class="li"> <strong>Bloque o carácter</strong>:
Si dividimos la pantalla de 256×192 en 32×24 bloques de color, nos
quedan bloques de 8×8 píxeles que mantienen el mismo atributo de
pantalla. Estamos acostumbrados a trabajar con bloques ya que el
intérprete BASIC del Spectrum utiliza la fuente de la ROM de 8×8 en una
rejilla de bloques que coincide con la resolución de atributos. Podemos
pensar en los bloques como “posiciones de carácter”.</div>
</li>
<li><div class="li"> <strong>Scanline</strong>: Un
scanline es una línea normalmente horizontal de datos gráficos. Por
ejemplo, el scanline 0 de pantalla es la línea gráfica que va desde
(0,0) a (255,0), y que definen los 32 bytes de videomemoria que van
desde 16384 hasta 16415. También se puede hablar del scanline de un
sprite o de un carácter cuando nos referimos a una línea concreta de esa
 porción de gráfico.</div>
</li>
<li><div class="li"> <strong>Coordenadas (x,y)</strong>:
Se utiliza la nomenclatura (x,y) para definir la posición de un píxel en
 pantalla en función de su posición horizontal y vertical siendo (0,0)
la esquina superior izquierda de la misma y (255,191) la esquina
inferior derecha. Son, pues, “coordenadas en alta resolución”.</div>
</li>
<li><div class="li"> <strong>Coordenadas (c,f)</strong>:
Se utiliza la nomenclatura (c,f), de (columna,fila), para hacer
referencia a la posición de un bloque 8×8 en pantalla en función de su
posición horizontal y vertical siendo (0,0) la esquina superior
izquierda y (31,23) la esquina inferior derecha. Se conocen como
“coordenadas en baja resolución” o “coordenadas de bloque” o “de
carácter”.</div>
</li>
<li><div class="li"> <strong>Conversión (c,f) a (x,y)</strong>:
 Como cada bloque es de 8×8 píxeles, podemos convertir una coordenada en
 baja resolución a coordenadas de pixel como (x,y) = (8*c,8*f).
Asímismo, (c,f) = (x/8,y/8).</div>
</li>
<li><div class="li"> <strong>Tercio de pantalla</strong>:
 El área gráfica del Spectrum se divide en 3 áreas de 2KB de videoram
que almacenan la información de 256×64 píxeles. Estas áreas son
comunmente denominadas “tercios”.</div>
</li>
<li><div class="li"> <strong>Offset</strong> o <strong>Desplazamiento</strong>:
 Llamaremos offset o desplazamiento a la cantidad de bytes que tenemos
que avanzar desde una base (normalmente el inicio de la propia memoria o
 un punto de la misma) para llegar a una posición de memoria. Así, un
offset de 32 bytes desde 16384 referenciará a los 8 píxeles desde (0,1) a
 (7,1). En las rutinas que veremos, el offset estará calculado con $0000
 como la base, es decir, serán offsets absolutos (posiciones de
memoria).</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 Con estas definiciones, podemos hacer las siguientes afirmaciones:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> La pantalla del Spectrum tiene 192 scanlines horizontales de 256 píxeles cada uno.
</li>
<li> La pantalla del Spectrum se divide en 32×24 bloques o posiciones de caracteres.
</li>
<li> Un bloque o carácter tiene 8 scanlines de 8 píxeles cada uno (8×8).
</li>
<li> Cada byte de la videoram almacena el estado de 8 píxeles, por lo que un bloque se almacena en 8×8/8 = 8 bytes.
</li>
<li> Cada posición de bloque / carácter de la pantalla tiene asociado un atributo del área de atributos.
</li>
<li> Cada uno de los 3 tercios de la pantalla tiene 8 líneas de 32 caracteres.
</li>
</ul>

<p>
<br>

</p>

<p>
 Para aprovechar la información que trataremos en este capítulo es
imprescindible comprender a la perfección la organización interna de la
videomemoria que se detalló en el anterior capítulo.
</p>

<p>
 A modo de resumen, la estructura interna de estas 2 áreas de memoria es la siguiente:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>Área de imagen</strong>:</div>
<ul class="fix-media-list-overlap">
<li class="level2"> El área de imagen se divide en 3
tercios de pantalla de 2KB de memoria cada uno, que van de $4000 a $47FF
 (tercio superior), de $4800 a $4FFF (tercio central) y de $5000 a $57FF
 (tercio inferior).
</li>
<li class="level2"> Cada uno de los tercios comprende 8
líneas de 32 bloques horizontales (256×64 píxeles). Dentro de cada uno
de esos 2KB, tenemos, de forma lineal, 64 bloques de 32 bytes (256
píxeles) de información que representan cada scanline de esos 8 bloques.
</li>
<li class="level2"> Los primeros 32 bytes de dicho
bloque contienen la información del scanline 0 del bloque 0. Avanzando
de 32 en 32 bytes tenemos los datos del scanline 0 del bloque 1, el
scanline 0 del bloque 2, el scanline 0 del bloque 3, etc, hasta que
llegamos al scanline 7 del bloque 0. Los siguientes 32 bytes repiten el
proceso pero con el scanline 1 de cada bloque.
</li>
<li class="level2"> Tras los últimos 32 bytes de un
tercio, vienen los primeros 32 bytes del siguiente tercio, con la misma
organización, pero afectando a otra porción de la pantalla.
</li>
</ul>
</li>
</ul>

<p>
<br>

<img src="img/gfx2_tercios.png" class="mediacenter" alt=" Rellenando los tercios "/>
<br>

</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"><div class="li"> <strong>Area de atributos</strong>:</div>
<ul class="fix-media-list-overlap">
<li class="level2"> El área de atributos se encuentra en
 memoria inmediatamente después del área de imagen, por lo que empieza
en la posición de memoria 16384+6144 = 22528 ($5800).
</li>
<li class="level2"><div class="li"> Cada byte del área de atributos se denomina <em>atributo</em>
 y define el valor de color de tinta, papel, brillo y flash de un
carácter / bloque de la pantalla. Esto implica que el área de atributos
ocupa 32x24x1 = 768 bytes en memoria, por lo que empieza en 22528
($5800) y acaba en 23295 ($5AFF).</div>
</li>
<li class="level2"> Los diferentes bits de un atributo de carácter son: Bit 7 = FLASH, Bit 6 = BRIGHT, Bits 5-3 = PAPER, Bits 2-0 = INK.
</li>
<li class="level2"> Los valores de tinta y papel son un
valor de 0-7 que junto al brillo como bit más significativo componen un
índice (B-I-I-I) contra una paleta de colores interna definida en la
ULA, donde el 0 es el color negro y el 15 el blanco de brillo máximo.
</li>
<li class="level2"> La organización interna del área de
atributos es lineal: Los primeros 32 bytes desde $5800 se corresponden
con los atributos de la primera fila de bloques de la pantalla. Los
segundos 32 bytes, con la segunda fila, y así sucesivamente hasta los
últimos 32 bytes que se corresponden con los atributos de la fila 23. La
 organización de la zona de atributos no se ve pues relacionada con los
tercios de pantalla, tan sólo con la columna y fila (c,f) del bloque.
</li>
</ul>
</li>
</ul>

<p>
<br>

 Nuestro capítulo de hoy tiene los siguientes objetivos prioritarios:
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Cálculo de posiciones de atributo</strong>: Saber calcular la posición en memoria del atributo de una posición de carácter (c,f) o de un pixel (x,y).</div>
</li>
<li><div class="li"> <strong>Cálculo de posiciones de carácter (baja resolución)</strong>:
 Saber calcular la posición en memoria en que comienzan los datos
gráficos (pixel 0,0 del carácter) de un carácter o bloque de 8×8 píxeles
 referenciado como (c,f) o (x,y), asumiendo una resolución de 32×24
bloques en pantalla coincidiendo con las posiciones de carácter de texto
 estándar. </div>
</li>
<li><div class="li"> <strong>Cálculo de posiciones de pixel (alta resolución)</strong>: Saber calcular la posición en memoria de un pixel referenciado por (x,y).</div>
</li>
<li><div class="li"> <strong>Cálculo de posiciones diferenciales</strong>:
 Dada una dirección de memoria de un atributo, carácter o pixel, ser
capaz de modificar esta dirección para acceder a los elementos de la
izquierda, derecha, arriba o abajo.</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 Utilizaremos las rutinas que veremos a continuación para el
posicionamiento en pantalla de los elementos de nuestros juegos y
programas. En los próximos capítulos trabajaremos ya con sprites en baja
 y alta resolución, fuentes de texto, mapeados por bloques, etc.
</p>

<p>
<br>

</p>

</div>

<h2 id="calculo-de-posiciones-de-atributo">Cálculo de posiciones de atributo</h2>
<div class="level2">

<p>
 Durante el desarrollo de un programa gráfico o un juego necesitaremos
(ya sea como funciones independientes o dentro de rutinas de
sprites/gráficos más amplias) alguna de las siguientes rutinas:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Attribute_Offset_LR(c,f)</strong>
 : Dadas las coordenadas en baja resolución (columna,fila) de un bloque /
 carácter, debe devolver la dirección de memoria del atributo de dicho
bloque.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Attribute_Offset_HR(x,y)</strong>
 : Dadas las coordenadas en alta resolución (x,y) contenida en un bloque
 / carácter, debe devolver la dirección de memoria del atributo de dicho
 bloque.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Attribute_Coordinates_LR(offset)</strong>:
 Dada una dirección de memoria dentro del área de atributos, debe
devolver las coordenadas (c,f) en baja resolución del bloque al que está
 asociado.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Attribute_Coordinates_HR(offset)</strong>:
 Dada una dirección de memoria dentro del área de atributos, debe
devolver las coordenadas (x,y) en alta resolución del pixel superior
izquierdo del bloque al que está asociado.</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 Es importante comprobar antes de llamar a nuestras rutinas si estas
modifican algún registro o flag que necesitemos preservar. Podemos
modificar las rutinas para que realicen PUSH y POP de los registros
necesarios o hacer nosotros estos PUSH/POP en la rutina llamadora.
</p>

<p>
 Comencemos con las rutinas:
</p>

<p>
<br>

</p>

</div>

<h4 id="get_attribute_offset">Get_Attribute_Offset</h4>
<div class="level4">

<p>
 Una primera aproximación a la obtención de la dirección en memoria de
un atributo concreto (columna,fila) podría ser la utilización de una
tabla de 24 valores de 16 bits que alojara las direcciones de inicio en
memoria de los atributos del primer carácter de cada fila.
</p>

<p>
 De esta forma bastaría con utilizar el número de fila como índice en la
 tabla y sumar el número de columna para obtener la dirección de memoria
 de la celdilla de atributos de (c,f):
</p>
<div class="table-responsive sectionedit3"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Línea f </th><th class="col1"> Dirección en Hexadecimal </th><th class="col2"> En Decimal </th><th class="col3"> En Binario </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> $5800 </td><td class="col2"> 22528 </td><td class="col3"> 0101100000000000b </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> $5820 </td><td class="col2"> 22560 </td><td class="col3"> 0101100000100000b </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> $5840 </td><td class="col2"> 22592 </td><td class="col3"> 0101100001000000b </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> $5860 </td><td class="col2"> 22624 </td><td class="col3"> 0101100001100000b </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> $5880 </td><td class="col2"> 22656 </td><td class="col3"> 0101100010000000b </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1"> $58A0 </td><td class="col2"> 22688 </td><td class="col3"> 0101100010100000b </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 6 </td><td class="col1"> $58C0 </td><td class="col2"> 22720 </td><td class="col3"> 0101100011000000b </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 7 </td><td class="col1"> $58E0 </td><td class="col2"> 22752 </td><td class="col3"> 0101100011100000b </td>
	</tr>
	<tr class="row9">
		<td class="col0"> 8 </td><td class="col1"> $5900 </td><td class="col2"> 22784 </td><td class="col3"> 0101100100000000b </td>
	</tr>
	<tr class="row10">
		<td class="col0"> 9 </td><td class="col1"> $5920 </td><td class="col2"> 22816 </td><td class="col3"> 0101100100100000b </td>
	</tr>
	<tr class="row11">
		<td class="col0"> 10 </td><td class="col1"> $5940 </td><td class="col2"> 22848 </td><td class="col3"> 0101100101000000b </td>
	</tr>
	<tr class="row12">
		<td class="col0"> 11 </td><td class="col1"> $5960 </td><td class="col2"> 22880 </td><td class="col3"> 0101100101100000b </td>
	</tr>
	<tr class="row13">
		<td class="col0"> 12 </td><td class="col1"> $5980 </td><td class="col2"> 22912 </td><td class="col3"> 0101100110000000b </td>
	</tr>
	<tr class="row14">
		<td class="col0"> 13 </td><td class="col1"> $59A0 </td><td class="col2"> 22944 </td><td class="col3"> 0101100110100000b </td>
	</tr>
	<tr class="row15">
		<td class="col0"> 14 </td><td class="col1"> $59C0 </td><td class="col2"> 22976 </td><td class="col3"> 0101100111000000b </td>
	</tr>
	<tr class="row16">
		<td class="col0"> 15 </td><td class="col1"> $59E0 </td><td class="col2"> 23008 </td><td class="col3"> 0101100111100000b </td>
	</tr>
	<tr class="row17">
		<td class="col0"> 16 </td><td class="col1"> $5A00 </td><td class="col2"> 23040 </td><td class="col3"> 0101101000000000b </td>
	</tr>
	<tr class="row18">
		<td class="col0"> 17 </td><td class="col1"> $5A20 </td><td class="col2"> 23072 </td><td class="col3"> 0101101000100000b </td>
	</tr>
	<tr class="row19">
		<td class="col0"> 18 </td><td class="col1"> $5A40 </td><td class="col2"> 23104 </td><td class="col3"> 0101101001000000b </td>
	</tr>
	<tr class="row20">
		<td class="col0"> 19 </td><td class="col1"> $5A60 </td><td class="col2"> 23136 </td><td class="col3"> 0101101001100000b </td>
	</tr>
	<tr class="row21">
		<td class="col0"> 20 </td><td class="col1"> $5A80 </td><td class="col2"> 23168 </td><td class="col3"> 0101101010000000b </td>
	</tr>
	<tr class="row22">
		<td class="col0"> 21 </td><td class="col1"> $5AA0 </td><td class="col2"> 23200 </td><td class="col3"> 0101101010100000b </td>
	</tr>
	<tr class="row23">
		<td class="col0"> 22 </td><td class="col1"> $5AC0 </td><td class="col2"> 23232 </td><td class="col3"> 0101101011000000b </td>
	</tr>
	<tr class="row24">
		<td class="col0"> 23 </td><td class="col1"> $5AE0 </td><td class="col2"> 23264 </td><td class="col3"> 0101101011100000b </td>
	</tr>
</tbody></table></div>

<p>
<em>Direcciones del atributo en el carácter (0,f)</em>
<br>

<br>

</p>

<p>
 Así pues, podríamos tener una tabla de 16 bytes para indexarla con el
número de fila, que permitiría calcular la dirección de memoria como:
</p>
<pre class="code">dirección_atributo(c,f) = tabla_offsetY_LR[ f ] + c</pre>

<p>
 No obstante, existe una opción mucho más aconsejable en el caso de los
atributos como es el realizar el cálculo de la dirección destino en
lugar de un <em>lookup</em> en una tabla.
</p>

<p>
 Como ya vimos en el capítulo anterior, la dirección de un atributo concreto se puede calcular mediante la siguiente fórmula:
</p>
<pre class="code"> Direccion_Atributo(x_bloque,y_bloque) = 22528 + (f*32) + c </pre>

<p>
 Desde el inicio del área de atributos, avanzamos 32 bytes por fila
hasta posicionarnos en el bloque de 32 bytes que referencia a nuestro
bloque, y sumamos el número de columna.
</p>

<p>
 Implementando este cálculo en código máquina, obtendríamos la siguiente
 rutina (de la cual no haremos uso, ya que diseñaremos una versión mucho
 más óptima):
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Obtener la direccion de memoria del atributo del caracter</span>
<span class="co1">; (c,f) especificado mediante multiplicacion por 32.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   B = FILA,  C = COLUMNA</span>
<span class="co1">; Salida:    HL = Direccion del atributo</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Attribute_Offset_LR_SLOW:
   <span class="co1">; calcular dir_atributo como "inicio_attr + (32*f) + c"</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">B</span>         <span class="co1">; HL = "fila"</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>      <span class="co1">; HL = HL*2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>      <span class="co1">; HL = HL*4</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>      <span class="co1">; HL = HL*8</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>      <span class="co1">; HL = HL*16</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>      <span class="co1">; HL = HL*32</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">C</span>         <span class="co1">; DE = "columna"</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">DE</span>      <span class="co1">; HL = fila*32 + columna</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">22528</span>    <span class="co1">; Direccion de inicio de atributos</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">DE</span>      <span class="co1">; HL = 22528 + fila*32 + columna</span>
   <span class="kw1">RET</span></pre>

<p>
 El código que acabamos de ver es perfectamente funcional pero tiene ciertas desventajas:
</p>
<ul class="fix-media-list-overlap">
<li> Hace uso de prácticamente todo el
juego de registros, DE incluído (lo que nos implicaría realizar PUSHes y
 POPs en nuestra rutina externa o dentro de la misma).
</li>
<li> Tiene un coste de ejecución de 112 t-estados.
</li>
</ul>

<p>
 Veamos cómo podemos mejorar esta rutina: Si nos fijamos en la
representación en binario de la anterior tabla de direcciones, veremos
que todas ellas siguen un patrón común:
</p>
<div class="table-responsive sectionedit4"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Linea f </th><th class="col1"> Dirección en Hexadecimal </th><th class="col2"> En Decimal </th><th class="col3"> En Binario </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> $5800 </td><td class="col2"> 22528 </td><td class="col3"> <em>010110</em><strong>00000</strong>00000b </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> $5820 </td><td class="col2"> 22560 </td><td class="col3"> <em>010110</em><strong>00001</strong>00000b </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> $5840 </td><td class="col2"> 22592 </td><td class="col3"> <em>010110</em><strong>00010</strong>00000b </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> $5860 </td><td class="col2"> 22624 </td><td class="col3"> <em>010110</em><strong>00011</strong>00000b </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> $5880 </td><td class="col2"> 22656 </td><td class="col3"> <em>010110</em><strong>00100</strong>00000b </td>
	</tr>
	<tr class="row6">
		<td class="col0"> (…) </td><td class="col1"> (…) </td><td class="col2"> (…) </td><td class="col3"> (…) </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 21 </td><td class="col1"> $5AA0 </td><td class="col2"> 23200 </td><td class="col3"> <em>010110</em><strong>10101</strong>00000b </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 22 </td><td class="col1"> $5AC0 </td><td class="col2"> 23232 </td><td class="col3"> <em>010110</em><strong>10110</strong>00000b </td>
	</tr>
	<tr class="row9">
		<td class="col0"> 23 </td><td class="col1"> $5AE0 </td><td class="col2"> 23264 </td><td class="col3"> <em>010110</em><strong>10111</strong>00000b </td>
	</tr>
</tbody></table></div>
<ul class="fix-media-list-overlap">
<li> Los 6 bits más significativos de la
dirección son 010110, que es la parte de la dirección que provoca que
todas las posiciones estén entre $5800 y $5AFF.
</li>
<li> Los bits 5, 6, 7 y 8 se corresponden con la fila que queremos consultar.
</li>
<li> Los bits 0, 1, 2, 3 y 4 los
utilizaremos para acceder a a la columna deseada. En la tabla anterior
son siempre 0 porque estamos mostrando las direcciones de inicio de cada
 fila, es decir, de (0,f), por lo que estos bits 0-4 son 0.
</li>
</ul>

<p>
 La formación de la dirección destino queda pues así:
</p>

<p>
<br>

<img src="img/gfx2_calcattrib.png" class="mediacenter" alt=" Cálculo de la dirección de atributo "/>
</p>
<div style="text-align: center;"><em>Cálculo de la dirección de atributo (c,f)</em>
</div>
<p>
<br>

</p>

<p>
 La rutina de cálculo de la dirección del atributo a partir de
coordenadas de baja resolución se podría implementar, pues, de la
siguiente forma:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Attribute_Offset_LR: </span>
<span class="co1">; Obtener la direccion de memoria del atributo del caracter</span>
<span class="co1">; (c,f) especificado. Por David Webb.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   B = FILA,  C = COLUMNA</span>
<span class="co1">; Salida:    HL = Direccion del atributo</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Attribute_Offset_LR:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; Ponemos en A la fila (000FFFFFb)</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Desplazamos A 3 veces (A=A&gt;&gt;3) </span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; A = A AND 00000011 = los 2 bits mas</span>
                      <span class="co1">; altos de FILA (000FFFFFb -&gt; 000000FFb)</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>58         <span class="co1">; Ponemos los bits 15-10 como 010110b</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>            <span class="co1">; Lo cargamos en el byte alto de HL</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; Recuperamos de nuevo en A la FILA</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>              <span class="co1">; Nos quedamos con los 3 bits que faltan</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Los rotamos para colocarlos en su</span>
   <span class="kw1">RRCA</span>               <span class="co1">; ubicacion final (&lt;&lt;5 = &gt;&gt;3)</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>           <span class="co1">; Sumamos el numero de columna</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>            <span class="co1">; Lo colocamos en L</span>
   <span class="kw1">RET</span>                <span class="co1">; HL = 010110FFFFFCCCCCb </span></pre>

<p>
 La rutina realiza operaciones de bits para ubicar los datos de FILA,
COLUMNA y 010011b en las posiciones que requiere la dirección destino
final. Aconsejamos al lector revisar el capítulo dedicado a <em>Desplazamientos de memoria, bits y operaciones lógicas</em> para recordar el efecto de los desplazamientos realizados con operaciones como RRCA, SRA, SLA, RLC, etc.
</p>

<p>
 El coste de ejecución de esta rutina es de (RET aparte) 70 t-estados y
no hace uso de DE, lo que es un ahorro sustancial tanto en tiempo de
ejecución como en preservación de un registro muy utilizado.
</p>

<p>
 La salida de esta rutina se puede utilizar directamente para almacenar
en (HL) el atributo del caracter (c,f) cuya direccion hemos solicitado:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">10</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">1</span><span class="nu0">2</span>
   <span class="kw1">CALL</span> Get_Attribute_Offset_LR
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">85</span>             <span class="co1">; Brillo + Magenta sobre Cyan</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>           <span class="co1">; Establecemos el atributo de (12,10)</span></pre>

<p>
 La rutina no hace ningún tipo de comprobación del rango de COLUMNA y
FILA, por lo que si proporcionamos valores menores de cero o mayores de
31 o 23 respectivamente se devolverá una dirección de memoria fuera del
área de atributos.
</p>

<p>
 La versión para coordenadas en alta resolución de la anterior rutina (<strong>Get_Attribute_Offset_HR(x,y)</strong>)
 se implementa fácilmente mediante la conversión de las coordenadas
(x,y) en coordenadas (c,f) dividiendo x e y entre 8 para obtener las
coordenadas de baja resolución que corresponden al pixel que estamos
considerando.
</p>

<p>
 Para eso, las primeras líneas de la rutina deberían ser:
</p>
<pre class="code z80">   <span class="kw1">SRL</span> <span class="kw2">B</span>
   <span class="kw1">SRL</span> <span class="kw2">B</span>
   <span class="kw1">SRL</span> <span class="kw2">B</span>              <span class="co1">; B = B/8 -&gt; Ahora B es FILA</span>
&nbsp;
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>              <span class="co1">; C = C/8 -&gt; Ahora C es COLUMNA</span></pre>

<p>
 Una vez obtenido (c,f), el desarrollo de la rutina es el mismo que en el caso de Get_Attribute_Offset_LR(c,f):
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Attribute_Offset_HR: </span>
<span class="co1">; Obtener la direccion de memoria del atributo del caracter al</span>
<span class="co1">; que corresponde el pixel (x,y) especificado.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   B = Y,  C = X</span>
<span class="co1">; Salida:    HL = Direccion del atributo</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Attribute_Offset_HR:
   <span class="kw1">SRL</span> <span class="kw2">B</span>
   <span class="kw1">SRL</span> <span class="kw2">B</span>
   <span class="kw1">SRL</span> <span class="kw2">B</span>              <span class="co1">; B = B/8 -&gt; Ahora B es FILA</span>
&nbsp;
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>              <span class="co1">; C = C/8 -&gt; Ahora C es COLUMNA</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Desplazamos A 3 veces (A=A&gt;&gt;3)</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; A = A AND 00000011 = los 2 bits mas</span>
                      <span class="co1">; altos de FILA (000FFFFFb -&gt; 000000FFb)</span>
&nbsp;
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>58         <span class="co1">; Ponemos los bits 15-10 como 010110b</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>            <span class="co1">; Lo cargamos en el byte alto de HL</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; Recuperamos de nuevo en A la FILA</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>              <span class="co1">; Nos quedamos con los 3 bits que faltan</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Los rotamos para colocarlos en su</span>
   <span class="kw1">RRCA</span>               <span class="co1">; ubicacion final (&lt;&lt;5 = &gt;&gt;3)</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>           <span class="co1">; Sumamos el numero de columna</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>            <span class="co1">; Lo colocamos en L</span>
   <span class="kw1">RET</span>                <span class="co1">; HL = 010110FFFFFCCCCCb </span></pre>

<p>
 Hemos utilizado las instrucciones de desplazamiento SRL sobre los
registros B y C para dividir sus valores por 8 y convertir la dirección
(x,y) en una dirección (c,f), pudiendo aplicar así el algoritmo de
cálculo de dirección que ya conocemos.
</p>

<p>
<br>

</p>

</div>

<h4 id="get_attribute_coordinates">Get_Attribute_Coordinates</h4>
<div class="level4">

<p>
 La siguiente rutina nos proporciona, dada una dirección de memoria
apuntada por HL y dentro de la zona de atributos, la posición (c,f) que
corresponde a dicho carácter. Se basa en la descomposición de HL en los
campos que componen la dirección del atributo:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Attribute_Coordinates_LR</span>
<span class="co1">; Obtener las coordenadas de caracter que se corresponden a</span>
<span class="co1">; una direccion de memoria de atributo.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:    HL = Direccion del atributo</span>
<span class="co1">; Salida:     B = FILA,  C = COLUMNA</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Attribute_Coordinates_LR:
                      <span class="co1">; Descomponemos HL = 010110FF FFFCCCCCb </span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>            <span class="co1">; A = 010110FFb</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; A = bits 0, 1 de HL = 2 bits altos de F, CF=0</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>               <span class="co1">; Rotacion a izquierda 000000FFb -&gt; 000FF000b</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; B = 000FF000b</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">AND</span> <span class="nu0">224</span>            <span class="co1">; Nos quedamos con los 3 bits mas altos</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>              <span class="co1">; Rotacion a izquierda FFF00000b -&gt; 00000FFFb</span>
   <span class="kw1">OR</span> <span class="kw2">B</span>               <span class="co1">; A = A + B = 000FFFFFb</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; B = FILA</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">AND</span> <span class="nu0">3</span><span class="re1">1</span>             <span class="co1">; Nos quedamos con los 5 bits mas bajos</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>            <span class="co1">; C = COLUMNA</span>
&nbsp;
   <span class="kw1">RET</span></pre>

<p>
 De nuevo, el código no incluye ningún tipo de control sobre la
dirección que se le proporciona, que podría estar fuera de la zona de
atributos y le haría devolver valores en el rango 0-255 para B y para C
que, obviamente, no corresponden con la dirección entrada en HL.
</p>

<p>
 La rutina para trabajar con coordenadas en alta resolución (<strong>Get_Attribute_Coordinates_HR(x,y)</strong>)
 es esencialmente idéntica a su versión en baja resolución, salvo que
finaliza multiplicando B y C por 8 (mediante instrucciones de
desplazamiento a izquierda) para convertir las coordenadas (c,f) en
(x,y). Los valores (x,y) resultantes se corresponderán con el pixel
superior izquierdo del bloque apuntado por (c,f).
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Attribute_Coordinates_HR</span>
<span class="co1">; Obtener las coordenadas de pixel que se corresponden a</span>
<span class="co1">; una direccion de memoria de atributo.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:    HL = Direccion del atributo</span>
<span class="co1">; Salida:     B = y,  C = x</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Attribute_Coordinates_HR:
                      <span class="co1">; Descomponemos HL = 010110FF FFFCCCCCb </span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>            <span class="co1">; A = 010110FFb</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; A = bits 0, 1 de HL = 2 bits altos de F, CF=0</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>               <span class="co1">; Rotacion a izquierda 000000FFb -&gt; 000FF000b</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; B = 000FF000b</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">AND</span> <span class="nu0">224</span>            <span class="co1">; Nos quedamos con los 3 bits mas altos</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>               <span class="co1">; Rotacion a izquierda FFF00000b -&gt; 00000FFFb</span>
   <span class="kw1">OR</span> <span class="kw2">B</span>               <span class="co1">; A = A + B = 000FFFFFb</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; B = FILA</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">AND</span> <span class="nu0">3</span><span class="re1">1</span>             <span class="co1">; Nos quedamos con los 5 bits mas bajos</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>            <span class="co1">; C = COLUMNA</span>
&nbsp;
   <span class="kw1">SLA</span> <span class="kw2">C</span>
   <span class="kw1">SLA</span> <span class="kw2">C</span>
   <span class="kw1">SLA</span> <span class="kw2">C</span>              <span class="co1">; C = C*8</span>
&nbsp;
   <span class="kw1">SLA</span> <span class="kw2">B</span>
   <span class="kw1">SLA</span> <span class="kw2">B</span>
   <span class="kw1">SLA</span> <span class="kw2">B</span>              <span class="co1">; B = B*8</span>
&nbsp;
   <span class="kw1">RET</span></pre>

<p>
<br>

</p>

</div>

<h3 class="sectionedit5" id="calculo-de-posiciones-diferenciales-de-atributo">Cálculo de posiciones diferenciales de atributo</h3>
<div class="level3">

<p>
 Una vez calculada la posición de memoria de un atributo, puede
interesarnos (por ejemplo, en una rutina de impresión de Sprites) el
conocer la dirección de memoria del bloque inferior, superior, izquierdo
 o derecho sin necesidad de recalcular HL a partir de las coordenadas.
Por ejemplo, esto sería útil para imprimir los atributos de un sprite de
 Ancho X Alto caracteres sin recalcular la dirección de memoria para
cada atribuo.
</p>

<p>
 Asumiendo que HL contiene una dirección de atributo válida y que
tenemos verificado que nuestro sprite no tiene ninguno de sus caracteres
 fuera del área de pantalla, podemos modificar HL para movernos a
cualquiera de los atributos de alrededor. Para eso aprovecharemos la
linealidad del área de atributos incrementando o decrementando HL para
movernos a izquierda o derecha y sumando o restando 32 a HL para bajar o
 subir una línea:
</p>
<pre class="code z80">Atributo_derecha:
  <span class="kw1">INC</span> <span class="kw2">HL</span>            <span class="co1">; HL = HL + 1</span>
&nbsp;
Atributo_izquierda:
  <span class="kw1">DEC</span> <span class="kw2">HL</span>            <span class="co1">; HL = HL - 1</span>
&nbsp;
Atributo_abajo:
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="nu0">32</span>
  <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">DE</span>        <span class="co1">; HL = HL + 32 </span>
&nbsp;
Atributo_arriba:
  <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="sy0">-</span><span class="nu0">32</span>
  <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">DE</span>        <span class="co1">; HL = HL - 32 </span></pre>

<p>
 Si tenemos la necesidad de preservar el valor del registro DE y el
utilizarlo para sumar o restar 32 nos supone hacer un PUSH y POP del
mismo a la pila y queremos evitar esto, podemos sumar la parte baja y
después incrementar la parte alta si ha habido acarreo:
</p>
<pre class="code z80">Atributo_abajo_sin_usar_DE_2:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>           <span class="co1">; A = L</span>
  <span class="kw1">ADD</span> <span class="nu0">32</span>            <span class="co1">; Sumamos A = A + 32 . El Carry Flag se ve afectado.</span>
  <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>           <span class="co1">; Guardamos en L (L = L+32)</span>
  <span class="kw1">JR</span> NC, attrab_noinc
  <span class="kw1">INC</span> <span class="kw2">H</span>
attrab_noinc:       <span class="co1">; Ahora HL = (H+CF)*256 + (L+32) = HL + 32</span>
&nbsp;
&nbsp;
Atributo_arriba_sin_usar_DE:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>           <span class="co1">; A = L</span>
  <span class="kw1">SUB</span> <span class="nu0">32</span>            <span class="co1">; Restamos A = A - 32 . El Carry Flag se ve afectado.</span>
  <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>           <span class="co1">; Guardamos en L (L = L-32)</span>
  <span class="kw1">JR</span> NC, attrab_nodec
  <span class="kw1">DEC</span> <span class="kw2">H</span>
attrab_nodec:       <span class="co1">; Ahora HL = (H+CF)*256 + (L+32) = HL + 32</span></pre>

<p>
 Nótese que, como nos apunta Jaime Tejedor en los foros de Speccy.org, el código con salto…
</p>
<pre class="code z80">  <span class="kw1">JR</span> NC, attrab_noinc
  <span class="kw1">INC</span> <span class="kw2">H</span>
attrab_noinc:</pre>

<p>
 … es más rápido que la combinación de ADD y ADC para sumar 32 al byte bajo de HL y 0 + Acarreo al byte alto de HL:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>           <span class="co1">; Ponemos A a cero, no podemos usar un "XOR A"</span>
                    <span class="co1">; o un "OR A" porque afectariamos al Carry Flag.</span>
  <span class="kw1">ADC</span> <span class="kw2">H</span>             <span class="co1">; A = H + CarryFlag</span>
  <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>           <span class="co1">; H = H + CarryFlag</span>
                    <span class="co1">; Ahora HL = (H+CF)*256 + (L+32) = HL + 32</span></pre>

<p>
 Este código no utiliza DE pero se apoya en el registro A para los
cálculos. Si necesitamos preservar su valor, siempre podemos realizar un
 <strong>EX AF, AF</strong> antes y después de la ejecución de la rutina.
</p>

<p>
<br>

<br>

</p>

</div>

<h2 id="calculo-de-posiciones-de-caracteres">Cálculo de posiciones de caracteres</h2>
<div class="level2">

<p>
 Nuestro siguiente objetivo es el de conocer el mecanismo para trabajar
con gráficos de baja resolución o gráficos de bloque / carácter. Esto
nos permitirá dibujar gráficos de 8×8 píxeles (o de múltiplos de ese
tamaño) comenzando en posiciones de memoria de carácter, en nuestra
pantalla de 32×24 bloques de baja resolución.
</p>

<p>
 Para ello necesitamos calcular la dirección de inicio en videomemoria de la dirección de inicio del bloque.
</p>

<p>
 Las rutinas que tenemos que implementar son:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Char_Offset_LR(c,f)</strong>
 : Dadas las coordenadas en baja resolución (columna,fila) de un bloque /
 carácter, debe devolver la dirección de memoria de los 8 pixeles del
scanline 0 de dicho bloque.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Char_Offset_HR(x,y)</strong>
 : Dadas las coordenadas en alta resolución (x,y) de un bloque /
carácter, debe devolver la dirección de memoria de los 8 pixeles del
scanline 0 de dicho bloque.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Char_Coordinates_LR(offset)</strong>:
 Dada una dirección de memoria dentro del área de imagen, debe devolver
las coordenadas (c,f) en baja resolución del bloque al que está
asociada.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Char_Coordinates_HR(offset)</strong>:
 Dada una dirección de memoria dentro del área de imagen, debe devolver
las coordenadas (x,y) en alta resolución del pixel superior izquierdo
del bloque al que está asociada.</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 Nótese que podemos realizar las 2 primeras rutinas de forma que
devuelvan el offset calculado bien en el registro DE o bien en el
registro HL. Según utilicemos los registros en el código que llama a la
rutina, puede sernos más conveniente recibir el valor en uno u otro
registro. Si resulta necesario, podemos adaptar el código de las rutinas
 para que funcionen con uno u otro registro, o utilizar al final de la
misma (o tras el CALL) un <strong>EX HL, DE</strong> que devuelva el resultado en el registro que más nos interese.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit7" id="calculo-de-posiciones-de-caracteres-por-composicion">Cálculo de posiciones de caracteres por composición</h3>
<div class="level3">

<p>
 Utilizando técnicas de composición desde los bits de las coordenadas
vamos a calcular la dirección de inicio de cada “primera línea” de fila
de caracteres de la pantalla, es decir, el scanline 0 de cada fila de
bloques en baja resolución. Conociendo la posición inicial de dicha
línea podemos sumar el número de columna y posicionarnos en el inicio
del carácter (c,f) deseado, para trazar en él texto o un sprite de 8×8
(o múltiplos).
</p>

<p>
 Al igual que en el caso de las direcciones de atributo, es posible
componer la dirección de memoria de este “pixel 0” del “scanline 0” de
la fila f mediante descomposición de los bits de las coordenadas y su
recomposición en una dirección en memoria.
</p>

<p>
 Para encontrar la relación coordenadas/dirección comencemos viendo una
tabla con las direcciones de pantalla buscadas ya precalculadas:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit8"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Linea f </th><th class="col1"> Direccion (0,f) (HEX) </th><th class="col2"> (Decimal) </th><th class="col3"> (Binario) </th><th class="col4"> Tercio (0-2) </th><th class="col5"> Fila dentro del tercio </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> $4000 </td><td class="col2"> 16384 </td><td class="col3"> 0100000000000000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> $4020 </td><td class="col2"> 16416 </td><td class="col3"> 0100000000100000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 1 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> $4040 </td><td class="col2"> 16448 </td><td class="col3"> 0100000001000000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 2 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> $4060 </td><td class="col2"> 16480 </td><td class="col3"> 0100000001100000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 3 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> $4080 </td><td class="col2"> 16512 </td><td class="col3"> 0100000010000000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 4 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1"> $40A0 </td><td class="col2"> 16544 </td><td class="col3"> 0100000010100000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 5 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 6 </td><td class="col1"> $40C0 </td><td class="col2"> 16576 </td><td class="col3"> 0100000011000000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 6 </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 7 </td><td class="col1"> $40E0 </td><td class="col2"> 16608 </td><td class="col3"> 0100000011100000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 7 </td>
	</tr>
	<tr class="row9">
		<td class="col0"> 8 </td><td class="col1"> $4800 </td><td class="col2"> 18432 </td><td class="col3"> 0100100000000000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 0 </td>
	</tr>
	<tr class="row10">
		<td class="col0"> 9 </td><td class="col1"> $4820 </td><td class="col2"> 18464 </td><td class="col3"> 0100100000100000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 1 </td>
	</tr>
	<tr class="row11">
		<td class="col0"> 10 </td><td class="col1"> $4840 </td><td class="col2"> 18496 </td><td class="col3"> 0100100001000000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 2 </td>
	</tr>
	<tr class="row12">
		<td class="col0"> 11 </td><td class="col1"> $4860 </td><td class="col2"> 18528 </td><td class="col3"> 0100100001100000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 3 </td>
	</tr>
	<tr class="row13">
		<td class="col0"> 12 </td><td class="col1"> $4880 </td><td class="col2"> 18560 </td><td class="col3"> 0100100010000000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 4 </td>
	</tr>
	<tr class="row14">
		<td class="col0"> 13 </td><td class="col1"> $48A0 </td><td class="col2"> 18592 </td><td class="col3"> 0100100010100000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 5 </td>
	</tr>
	<tr class="row15">
		<td class="col0"> 14 </td><td class="col1"> $48C0 </td><td class="col2"> 18624 </td><td class="col3"> 0100100011000000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 6 </td>
	</tr>
	<tr class="row16">
		<td class="col0"> 15 </td><td class="col1"> $48E0 </td><td class="col2"> 18656 </td><td class="col3"> 0100100011100000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 7 </td>
	</tr>
	<tr class="row17">
		<td class="col0"> 16 </td><td class="col1"> $5000 </td><td class="col2"> 20480 </td><td class="col3"> 0101000000000000b </td><td class="col4"> 2 (10b) </td><td class="col5"> 0 </td>
	</tr>
	<tr class="row18">
		<td class="col0"> 17 </td><td class="col1"> $5020 </td><td class="col2"> 20512 </td><td class="col3"> 0101000000100000b </td><td class="col4"> 2 (10b) </td><td class="col5"> 1 </td>
	</tr>
	<tr class="row19">
		<td class="col0"> 18 </td><td class="col1"> $5040 </td><td class="col2"> 20544 </td><td class="col3"> 0101000001000000b </td><td class="col4"> 2 (10b) </td><td class="col5"> 2 </td>
	</tr>
	<tr class="row20">
		<td class="col0"> 19 </td><td class="col1"> $5060 </td><td class="col2"> 20576 </td><td class="col3"> 0101000001100000b </td><td class="col4"> 2 (10b) </td><td class="col5"> 3 </td>
	</tr>
	<tr class="row21">
		<td class="col0"> 20 </td><td class="col1"> $5080 </td><td class="col2"> 20608 </td><td class="col3"> 0101000010000000b </td><td class="col4"> 2 (10b) </td><td class="col5"> 4 </td>
	</tr>
	<tr class="row22">
		<td class="col0"> 21 </td><td class="col1"> $50A0 </td><td class="col2"> 20640 </td><td class="col3"> 0101000010100000b </td><td class="col4"> 2 (10b) </td><td class="col5"> 5 </td>
	</tr>
	<tr class="row23">
		<td class="col0"> 22 </td><td class="col1"> $50C0 </td><td class="col2"> 20672 </td><td class="col3"> 0101000011000000b </td><td class="col4"> 2 (10b) </td><td class="col5"> 6 </td>
	</tr>
	<tr class="row24">
		<td class="col0"> 23 </td><td class="col1"> $50E0 </td><td class="col2"> 20704 </td><td class="col3"> 0101000011100000b </td><td class="col4"> 2 (10b) </td><td class="col5"> 7 </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Examinemos (y marquemos) los bits de la representación binaria de la dirección para una selección de elementos de la tabla:
</p>
<div class="table-responsive sectionedit9"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Linea f </th><th class="col1"> Direccion (0,f) (HEX) </th><th class="col2"> (Decimal) </th><th class="col3"> (Binario) </th><th class="col4"> Tercio (0-2) </th><th class="col5"> Fila dentro del tercio </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> $4000 </td><td class="col2"> 16384 </td><td class="col3"> <strong>010</strong><em>00</em>000<strong>000</strong>00000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> $4020 </td><td class="col2"> 16416 </td><td class="col3"> <strong>010</strong><em>00</em>000<strong>001</strong>00000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 1 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> $4040 </td><td class="col2"> 16448 </td><td class="col3"> <strong>010</strong><em>00</em>000<strong>010</strong>00000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 2 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> $4060 </td><td class="col2"> 16480 </td><td class="col3"> <strong>010</strong><em>00</em>000<strong>011</strong>00000b </td><td class="col4"> 0 (00b) </td><td class="col5"> 3 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> (…) </td><td class="col1"> (…) </td><td class="col2"> (…) </td><td class="col3"> (…) </td><td class="col4"> (…) </td><td class="col5"> (…) </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 8 </td><td class="col1"> $4800 </td><td class="col2"> 18432 </td><td class="col3"> <strong>010</strong><em>01</em>000<strong>000</strong>00000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 0 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 9 </td><td class="col1"> $4820 </td><td class="col2"> 18464 </td><td class="col3"> <strong>010</strong><em>01</em>000<strong>001</strong>00000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 1 </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 10 </td><td class="col1"> $4840 </td><td class="col2"> 18496 </td><td class="col3"> <strong>010</strong><em>01</em>000<strong>010</strong>00000b </td><td class="col4"> 1 (01b) </td><td class="col5"> 2 </td>
	</tr>
	<tr class="row9">
		<td class="col0"> (…) </td><td class="col1"> (…) </td><td class="col2"> (…) </td><td class="col3"> (…) </td><td class="col4"> (…) </td><td class="col5"> (…) </td>
	</tr>
	<tr class="row10">
		<td class="col0"> 23 </td><td class="col1"> $50E0 </td><td class="col2"> 20704 </td><td class="col3"> <strong>010</strong><em>10</em>000<strong>111</strong>00000b </td><td class="col4"> 2 (10b) </td><td class="col5"> 7 </td>
	</tr>
</tbody></table></div>

<p>
 Lo primero que puede llamarnos la atención es lo siguiente:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"> Hay una relación directa entre
el byte alto de la dirección y el tercio en que está posicionada la
línea. Esta relación está marcada por los bits 3 y 4 del byte superior:
<ul class="fix-media-list-overlap">
<li class="level2"> Tercio superior (0, 00b) → Byte alto = $40 → Bits 3 y 4 = 00.
</li>
<li class="level2"> Tercio central (1, 01b) → Byte alto = $48 → Bits 3 y 4 = 01.
</li>
<li class="level2"> Tercio inferior (2, 10b) → Byte alto = $50 → Bits 3 y 4 = 10.
</li>
<li class="level2"> Conclusión: el número de tercio se
corresponde con los 2 bits superiores de la coordenada Y, de tal forma
que las fila (0,7) están en el tercio 00b, las filas 8-15 en el tercio
01b, y las 16-23 en el 10b.
</li>
</ul>
</li>
<li> Hay una relación directa entre el
número de fila dentro de cada tercio (0-7) y los 3 bits superiores (5-7)
 del byte bajo de la dirección.
</li>
<li> Los 3 bytes más significativos de la
 dirección son siempre 010b. Esta es la parte de la composición de la
dirección que ubica el offset en memoria en el rango de direcciones del
área de imagen de la videoram ($4000 a $57FF).
</li>
<li> Los 5 bytes menos significativos de
la dirección son siempre cero en la tabla. En realidad, representan a la
 columna (posición c de carácter dentro de los 32 bytes de datos
horizontales) pero al estar calculando direcciones de inicio de línea (c
 = 0 = 00000b), en nuestro caso son siempre cero.
</li>
</ul>

<p>
<br>

</p>

<p>
 Así pues, podemos componer la dirección en memoria del pixel (0,0) de un carácter (0,f) de la pantalla como:
</p>

<p>
<br>

<img src="img/gfx2_calcoffset_lr.png" class="mediacenter" alt=" Cálculo de la dirección de (0,f) "/>
</p>
<div style="text-align: center;"><em>Cálculo de la dirección del scanline 0 de (0,f)</em>
</div>
<p>
<br>

</p>

<p>
 A partir del anterior diagrama, se desarrollan las siguientes subrutinas:
</p>

<p>
<br>

</p>

</div>

<h4 id="get_line_offset">Get_Line_Offset</h4>
<div class="level4">

<p>
 Esta rutina devuelve en HL la dirección de memoria de una fila en baja
resolución. Esa dirección apunta a los 8 píxeles (0-7) del scanline 0 de
 la fila solicitada.
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Line_Offset_LR(f)</span>
<span class="co1">; Obtener la direccion de memoria de inicio de la fila f.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   B = FILA</span>
<span class="co1">; Salida:   HL = Direccion de memoria del caracter (0,f)</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Line_Offset_LR:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>         <span class="co1">; A = B, para extraer los bits de tercio</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>         <span class="co1">; A = A AND 00011000b</span>
                   <span class="co1">; A = estado de bits de TERCIO desde FILA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>      <span class="co1">; Sumamos $40 (2 bits superiores = 010)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>         <span class="co1">; Ya tenemos la parte alta calculada</span>
                   <span class="co1">; H = 010TT000</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>         <span class="co1">; Ahora calculamos la parte baja</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>           <span class="co1">; Nos quedamos con los bits más bajos de FILA</span>
                   <span class="co1">; que coinciden con FT (Fila dentro del tercio)</span>
   <span class="kw1">RRCA</span>            <span class="co1">; Ahora A = 00000NNNb  (donde N=FT)</span>
   <span class="kw1">RRCA</span>            <span class="co1">; Desplazamos A 3 veces</span>
   <span class="kw1">RRCA</span>            <span class="co1">; A = NNN00000b</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>         <span class="co1">; Lo cargamos en la parte baja de la direccion</span>
   <span class="kw1">RET</span>             <span class="co1">; HL = 010TT000NNN00000b</span></pre>

<p>
<br>

</p>

</div>

<h4 id="get_char_offset">Get_Char_Offset</h4>
<div class="level4">

<p>
 Como ya sabemos, la posición horizontal de un pixel dentro de una fila
sí que es lineal, a razón de 8 píxeles por columna, por lo que:
</p>
<pre class="code">OFFSET(c,f) = Direccion_Inicio(f) + c</pre>

<p>
 y también:
</p>
<pre class="code">OFFSET(x,y) = Direccion_Inicio(y/8) + (x/8)</pre>

<p>
 Así, una vez calculado el inicio de línea, basta sumar la columna para
obtener la dirección de memoria del scanline 0 del carácter en baja
resolución (c,f):
</p>

<p>
<br>

<img src="img/gfx2_calcoffset2_lr.png" class="mediacenter" alt=" Cálculo de la dirección de (c,f) "/>
</p>
<div style="text-align: center;"><em>Cálculo de la dirección del scanline 0 de (c,f)</em>
</div>
<p>
<br>

</p>

<p>
 El código con la columna añadida quedaría así:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Char_Offset_LR(c,f)</span>
<span class="co1">; Obtener la direccion de memoria del caracter (c,f) indicado.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   B = FILA,  C = COLUMNA</span>
<span class="co1">; Salida:   HL = Direccion de memoria del caracter (c,f)</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Char_Offset_LR:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>         <span class="co1">; A = B, para extraer los bits de tercio</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>         <span class="co1">; A = A AND 00011000b</span>
                   <span class="co1">; A = estado de bits de TERCIO desde FILA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>      <span class="co1">; Sumamos $40 (2 bits superiores = 010)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>         <span class="co1">; Ya tenemos la parte alta calculada</span>
                   <span class="co1">; H = 010TT000</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>         <span class="co1">; Ahora calculamos la parte baja</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>           <span class="co1">; Nos quedamos con los bits más bajos de FILA</span>
                   <span class="co1">; que coinciden con FT (Fila dentro del tercio)</span>
   <span class="kw1">RRCA</span>            <span class="co1">; Ahora A = 00000NNNb     (N=FT)</span>
   <span class="kw1">RRCA</span>            <span class="co1">; Desplazamos A 3 veces a la derecha</span>
   <span class="kw1">RRCA</span>            <span class="co1">; A = NNN00000b</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>        <span class="co1">; Sumamos COLUMNA -&gt; A = NNNCCCCCb</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>         <span class="co1">; Lo cargamos en la parte baja de la direccion</span>
   <span class="kw1">RET</span>             <span class="co1">; HL = 010TT000NNNCCCCCb</span></pre>

<p>
 Una rutina que deba trabajar con direcciones en alta resolución pero
que devuelva el offset del inicio del bloque que contiene el punto (x,y)
 deberá dividir B y C entre 8 en el punto de entrada de la rutina:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Char_Offset_HR(x,y)</span>
<span class="co1">; Obtener la direccion de memoria del caracter que contiene</span>
<span class="co1">; el pixel (x,y) indicado.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   B = Y,  C = X</span>
<span class="co1">; Salida:   HL = Direccion de memoria del caracter con (x,y)</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Char_Offset_HR:
   <span class="kw1">SRL</span> <span class="kw2">B</span>
   <span class="kw1">SRL</span> <span class="kw2">B</span>
   <span class="kw1">SRL</span> <span class="kw2">B</span>           <span class="co1">; B = B/8 -&gt; Ahora B es FILA</span>
&nbsp;
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>
   <span class="kw1">SRL</span> <span class="kw2">C</span>           <span class="co1">; C = C/8 -&gt; Ahora C es COLUMNA</span>
&nbsp;
   <span class="br0">(</span>...<span class="br0">)</span>           <span class="co1">; Resto de la rutina Get_Char_Offset_LR</span>
   <span class="kw1">RET</span></pre>

<p>
<br>

</p>

</div>

<h4 id="get_char_coordinates">Get_Char_Coordinates</h4>
<div class="level4">

<p>
 Nuestra siguiente subrutina tiene como objetivo el calcular la posición
 (c,f) en baja resolución de un carácter dado un offset en memoria que
almacene alguno de los 64 pixeles del mismo. Llamar a esta función con
la dirección de cualquiera de las 8 líneas de un carácter devolvería el
mismo par de coordenadas (c,f):
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Char_Coordinates_LR(offset)</span>
<span class="co1">; Obtener las coordenadas (c,f) que corresponden a una</span>
<span class="co1">; direccion de memoria de imagen en baja resolucion.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   HL = Direccion de memoria del caracter (c,f)</span>
<span class="co1">; Salida:    B = FILA, C = COLUMNA</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Char_Coordinates_LR:
&nbsp;
   <span class="co1">; HL = 010TT000 NNNCCCCCb -&gt; </span>
   <span class="co1">;    Fila = 000TTNNNb y Columna = 000CCCCCb</span>
                   <span class="co1">; Calculo de la fila:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>         <span class="co1">; A = H, para extraer los bits de tercio</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>         <span class="co1">; A = 000TT000b</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>         <span class="co1">; B = A = 000TT000b</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>         <span class="co1">; A = L, para extraer los bits de N (FT)</span>
   <span class="kw1">AND</span> <span class="sy0">$</span>E<span class="re1">0</span>         <span class="co1">; A = A AND 11100000b = NNN00000b</span>
   <span class="kw1">RLC</span> <span class="kw2">A</span>           <span class="co1">; Rotamos A 3 veces a la izquierda</span>
   <span class="kw1">RLC</span> <span class="kw2">A</span>
   <span class="kw1">RLC</span> <span class="kw2">A</span>           <span class="co1">; A = 00000NNNb</span>
   <span class="kw1">OR</span> <span class="kw2">B</span>            <span class="co1">; A = A OR B = 000TTNNNb</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>         <span class="co1">; B = A = 000TTNNNb</span>
&nbsp;
                   <span class="co1">; Calculo de la columna:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>         <span class="co1">; A = L, para extraer los bits de columna</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span>F         <span class="co1">; Nos quedamos con los ultimos 5 bits de L</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>         <span class="co1">; C = Columna</span>
   <span class="kw1">RET</span>             <span class="co1">; HL = 010TT000NNNCCCCCb</span></pre>

<p>
 Adaptar esta rutina a alta resolución (<strong>Get_Char_Coordinates_HR(x,y)</strong>) implicaría el multiplicar las coordenadas X e Y por 8, añadiendo el siguiente código inmediatamente antes del RET:
</p>
<pre class="code z80">   <span class="kw1">SLA</span> <span class="kw2">C</span>
   <span class="kw1">SLA</span> <span class="kw2">C</span>
   <span class="kw1">SLA</span> <span class="kw2">C</span>              <span class="co1">; C = C*8</span>
&nbsp;
   <span class="kw1">SLA</span> <span class="kw2">B</span>
   <span class="kw1">SLA</span> <span class="kw2">B</span>
   <span class="kw1">SLA</span> <span class="kw2">B</span>              <span class="co1">; B = B*8</span></pre>

<p>
 Si no queremos tener una rutina específica para esta operación, podemos
 llamar a la rutina en baja resolución y realizar los desplazamientos
(*8) a la salida de la misma.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit10" id="calculo-de-posiciones-diferenciales-de-caracter">Cálculo de posiciones diferenciales de carácter</h3>
<div class="level3">

<p>
<br>

<strong>Recorrer los 8 scanlines de un bloque</strong>
</p>

<p>
 Dada en HL la dirección del primer scanline de un bloque, podemos
avanzar a lo largo de los 7 scanlines del mismo bloque sumando “256” a
dicha dirección. Como sumar 256 equivale a incrementar la parte alta de
la dirección, podemos subir y bajar al scanline anterior y siguiente de
los 8 que componen el carácter mediante simples <strong>DEC H</strong> e <strong>INC H</strong>:
</p>
<pre class="code z80">Scanline_Arriba_HL:
  <span class="kw1">DEC</span> <span class="kw2">H</span>            <span class="co1">; H = H - 1  (HL = HL-255)</span>
&nbsp;
Scanline_Abajo_HL:
  <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; H = H + 1  (HL = HL-255)</span></pre>

<p>
 Este salto de 256 bytes será válido sólo dentro de los 8 scanlines de un mismo carácter.
</p>

<p>
<br>

<strong>Offset del carácter de la izquierda/derecha/arriba/abajo</strong>
</p>

<p>
 Dentro de las rutinas de impresión de sprites de más de un carácter es
probable que necesitemos movernos a los carácteres de alrededor de uno
dado (normalmente hacia la derecha y hacia abajo).
</p>

<p>
 Las siguientes rutinas no realizan control de la posición, por lo que
moverse en una dirección cuando estamos en el límite del eje vertical u
horizontal tendrá resultados diferentes de los esperados.
</p>

<p>
 Moverse <em>un carácter a derecha</em> o <em>izquierda</em> es sencillo
 dada la disposición lineal de las filas de caracteres. Estando en el
scanline 0 de un carácter, bastará con incrementar o decrementar la
posición de memoria actual:
</p>
<pre class="code z80">Caracter_Derecha_HL:
  <span class="kw1">INC</span> <span class="kw2">HL</span>            <span class="co1">; HL = HL + 1</span>
&nbsp;
Caracter_Izquierda_HL:
  <span class="kw1">DEC</span> <span class="kw2">HL</span>            <span class="co1">; HL = HL - 1</span></pre>

<p>
 Moverse un <em>carácter arriba</em> o <em>abajo</em> es más laborioso
ya que tenemos que tener en cuenta los cambios de tercios. Para ello,
basta con que recordemos la disposición de los bits de la dirección:
</p>
<div class="table-responsive sectionedit11"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bits = </th><th class="col1"> Dirección VRAM </th><th class="col2"> Bits de Tercio </th><th class="col3"> Bits de scanline </th><th class="col4"> Bits de Carácter-Y </th><th class="col5"> Bits de Columna </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> HL = </td><td class="col1"> 010 </td><td class="col2"> TT </td><td class="col3"> SSS </td><td class="col4"> NNN </td><td class="col5"> CCCCC </td>
	</tr>
</tbody></table></div>

<p>
 Así, para saltar al siguiente carácter tenemos que incrementar los 3
bits más altos de L (sumando 32). Esto provocará el avance de bloque en
bloque, pero debemos tener en cuenta el momento en que realizamos un
salto del bloque 7 al 8, y del 15 al 16, ya que entonces tenemos que
cambiar de tercio y poner NNN a 0.
</p>

<p>
 Podemos detectar fácilmente el paso de la fila 7 a la 8 y de la 15 a la
 16 ya que en ambos casos la “Fila dentro del Tercio” (NNN, bits 7, 6 y 5
 de la dirección) pasaría de 111b a 1000b, lo que provocaría que estos 3
 bits se quedaran a 0 y se activara el bit de CARRY.
</p>

<p>
 Es decir, cuando tenemos TT = 00b y NNN = 111b y queremos avanzar al
siguiente scanline, sumamos 32 (00100000b) con lo que provocamos NNN =
000b y Carry=1. Teniendo la variable “Fila dentro del Tercio” a 1, basta
 con que incrementemos TT sumando 00001000b (8) a la parte alta, lo que
sumaría 01b a los 2 bits de tercio TT:
</p>

<p>
 El código sería el siguiente:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>                     <span class="co1">; Cargamos A en L y le sumamos 32 para</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>                   <span class="co1">; incrementar "Bloque dentro del tercio"</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                     <span class="co1">; L = A</span>
   <span class="kw1">JR</span> NC, no_ajustar_H_abajob  <span class="co1">; Si esta suma produce acarreo, ajustar</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                     <span class="co1">; la parte alta sumando 8 a H (TT = TT + 1).</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">8</span>                    <span class="co1">; Ahora NNN=000b y TT se ha incrementado.</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>                     <span class="co1">; H = A</span>
no_ajustar_H_abajob
                               <span class="co1">; Ahora HL apunta al bloque de debajo.</span></pre>

<p>
 El procedimiento para subir un carácter es similar:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>                       <span class="co1">; Cargamos L en A</span>
   <span class="kw1">AND</span> <span class="nu0">224</span>                       <span class="co1">; A = A AND 11100000b</span>
   <span class="kw1">JR</span> NZ, no_ajustar_h_arribab   <span class="co1">; Si no es cero, no retrocedemos tercio</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                       <span class="co1">; Si es cero, ajustamos tercio (-1)</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>                         <span class="co1">; Decrementamos TT</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
no_ajustar_h_arribab:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>                       <span class="co1">; Decrementar NNN</span>
   <span class="kw1">SUB</span> <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                       <span class="co1">; NNN = NNN-1</span></pre>

<p>
 En forma de rutina:
</p>
<pre class="code z80">Caracter_Abajo_HL:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>                     <span class="co1">; Cargamos A en L y le sumamos 32 para</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>                   <span class="co1">; incrementar "Bloque dentro del tercio"</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                     <span class="co1">; L = A</span>
   <span class="kw1">RET</span> NC                      <span class="co1">; Si esta suma no produce acarreo, fin</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                     <span class="co1">; la parte alta sumando 8 a H (TT = TT + 1).</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">8</span>                    <span class="co1">; Ahora NNN=000b y TT se ha incrementado.</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>                     <span class="co1">; H = A</span>
   <span class="kw1">RET</span>
&nbsp;
Caracter_Arriba_HL:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>                       <span class="co1">; Cargamos L en A</span>
   <span class="kw1">AND</span> <span class="nu0">224</span>                       <span class="co1">; A = A AND 11100000b</span>
   <span class="kw1">JR</span> NZ, nofix_h_arribab        <span class="co1">; Si no es cero, no retrocedemos tercio</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                       <span class="co1">; Si es cero, ajustamos tercio (-1)</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>                         <span class="co1">; Decrementamos TT</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
nofix_h_arribab:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>                       <span class="co1">; Decrementar NNN</span>
   <span class="kw1">SUB</span> <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                       <span class="co1">; NNN = NNN-1</span>
   <span class="kw1">RET</span></pre>

<p>
 Con estas 2 subrutinas podemos subir y bajar carácter a carácter sin
tener que recalcular la dirección destino y haciendo uso sólo de A, H y
L. Hay que tener en cuenta, no obstante, que se no comprueban los
límites de la pantalla, por lo que no nos avisarán si pretendemos
“subir” más arriba de la línea 0 o “bajar” más abajo de la 23.
</p>

<p>
<br>

<br>

</p>

</div>

<h2 id="calculo-de-posiciones-de-pixeles">Cálculo de posiciones de píxeles</h2>
<div class="level2">

<p>
 Finalmente, en cuanto a coordenación, vamos a estudiar el cálculo de la
 dirección de memoria de un pixel (x,y) en alta resolución. La dirección
 en memoria obtenida tendrá la información gráfica de 8 píxeles (pues
cada byte almacena el estado de 8 píxeles horizontales consecutivos).
Debido a esto nuestra rutina no sólo deberá devolver el offset en
memoria sino un valor de posición relativa 0-7 que nos permita alterar
el pixel concreto solicitado.
</p>

<p>
 Nuestra rutina de cálculo de offset puede ser implementada mediante 2 aproximaciones:
</p>

<p>
<br>

</p>
<ol class="fix-media-list-overlap">
<li> Mediante cálculo de la posición de
memoria a partir de las coordenadas (x,y), utilizando operaciones de
descomposición y rotación de bits, como ya hemos visto en los apartados
anteriores.
</li>
<li> Mediante una tabla precalculada de
posiciones de memoria que almacene la dirección de inicio de cada línea
de pantalla, a la cual sumaremos el número de columna (x/8), obteniendo
así el offset de nuestro pixel.
</li>
</ol>

<p>
<br>

</p>

<p>
 Vamos a ver las 2 técnicas por separado con rutinas aplicadas a cada
uno de los métodos. Cada sistema, como veremos, tiene sus ventajas e
inconvenientes, resultando siempre ambos un balance entre el tiempo de
ejecución de una rutina y la ocupación en bytes en memoria entre código y
 datos de la misma.
</p>

<p>
 Las rutinas que tenemos que implementar son:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Pixel_Offset(x,y)</strong>
 : Dadas las coordenadas en alta resolución (x,y) de un pixel, debe
devolver la dirección de memoria que aloja el pixel y un indicador de la
 posición del pixel dentro de dicho byte (recordemos que cada dirección
de memoria contiene los datos de 8 píxeles lineales consecutivos),
utilizando descomposición y composición de bits.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Pixel_Coordinates(offset)</strong>: Dada una dirección de memoria dentro del área de imagen, debe devolver las coordenadas (x,y) del pixel al que está asociada.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Get_Pixel_Offset_LUT(x,y)</strong>
 : Dadas las coordenadas en alta resolución (x,y) de un pixel, debe
devolver la dirección de memoria que aloja dicho pixel mediante la
utilización de tablas de precálculo (Look Up Table, o LUT).</div>
</li>
</ul>

<p>
<br>

</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit13" id="calculo-de-posiciones-de-pixeles-mediante-composicion">Cálculo de posiciones de pixeles mediante composición</h3>
<div class="level3">

<p>
 Hasta ahora hemos visto rutinas que nos proporcionan la posición en
memoria de un bloque en baja resolución, pero en el caso que veremos
ahora tenemos una coordenada Y que se mueve de 0 a 191, por lo que la
posición en memoria puede corresponder a cualquiera de los 8 scanlines
de un bloque dado. Además, la coordenada X tampoco es un carácter por lo
 que el pixel resultante es el estado de un bit concreto de la dirección
 obtenida.
</p>

<p>
 Así pues, ¿cómo podemos calcular la dirección destino del pixel cuando
tratamos con coordenadas en alta resolución? Recuperemos para ello parte
 de nuestra tabla de direcciones de memoria en baja resolución:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit14"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Línea LowRes </th><th class="col1"> Línea HiRes </th><th class="col2"> Direccion (0,f) (HEX) </th><th class="col3"> (Decimal) </th><th class="col4"> (Binario) </th><th class="col5"> Tercio (0-2) </th><th class="col6"> Fila en el tercio </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> 0 </td><td class="col2"> $4000 </td><td class="col3"> 16384 </td><td class="col4"> <strong>010</strong><em>00</em>000<strong>000</strong>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> 8 </td><td class="col2"> $4020 </td><td class="col3"> 16416 </td><td class="col4"> <strong>010</strong><em>00</em>000<strong>001</strong>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 1 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> 16 </td><td class="col2"> $4040 </td><td class="col3"> 16448 </td><td class="col4"> <strong>010</strong><em>00</em>000<strong>010</strong>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 2 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> 24 </td><td class="col2"> $4060 </td><td class="col3"> 16480 </td><td class="col4"> <strong>010</strong><em>00</em>000<strong>011</strong>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 3 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> (…) </td><td class="col1"> (…) </td><td class="col2"> (…) </td><td class="col3"> (…) </td><td class="col4"> (…) </td><td class="col5"> (…) </td><td class="col6"> (…) </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Añadamos ahora las direcciones en alta resolución y veamos el estado de
 los diferentes bits de la coordenada Y y de la dirección de
videomemoria que le corresponde:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit15"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Coord. F </th><th class="col1"> Coord. Y </th><th class="col2"> Coord. Y (Binario) </th><th class="col3"> Direccion (0,y) (HEX) </th><th class="col4"> (Binario) </th><th class="col5"> Tercio (0-2) </th><th class="col6"> Fila en el tercio </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> 0 </td><td class="col2"> 00<em>000</em><strong>000</strong>b </td><td class="col3"> $4100 </td><td class="col4"> 01000<strong>000</strong><em>000</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 0 </td><td class="col1"> 1 </td><td class="col2"> 00<em>000</em><strong>001</strong>b </td><td class="col3"> $4200 </td><td class="col4"> 01000<strong>001</strong><em>000</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 0 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 0 </td><td class="col1"> 2 </td><td class="col2"> 00<em>000</em><strong>010</strong>b </td><td class="col3"> $4300 </td><td class="col4"> 01000<strong>010</strong><em>000</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 0 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 0 </td><td class="col1"> 3 </td><td class="col2"> 00<em>000</em><strong>011</strong>b </td><td class="col3"> $4400 </td><td class="col4"> 01000<strong>011</strong><em>000</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 0 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 0 </td><td class="col1"> 4 </td><td class="col2"> 00<em>000</em><strong>100</strong>b </td><td class="col3"> $4500 </td><td class="col4"> 01000<strong>100</strong><em>000</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 0 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 0 </td><td class="col1"> 5 </td><td class="col2"> 00<em>000</em><strong>101</strong>b </td><td class="col3"> $4600 </td><td class="col4"> 01000<strong>101</strong><em>000</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 0 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 0 </td><td class="col1"> 6 </td><td class="col2"> 00<em>000</em><strong>110</strong>b </td><td class="col3"> $4700 </td><td class="col4"> 01000<strong>110</strong><em>000</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 0 </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 0 </td><td class="col1"> 7 </td><td class="col2"> 00<em>000</em><strong>111</strong>b </td><td class="col3"> $4800 </td><td class="col4"> 01000<strong>111</strong><em>000</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 0 </td>
	</tr>
	<tr class="row9">
		<td class="col0"> 1 </td><td class="col1"> 8 </td><td class="col2"> 00<em>001</em><strong>000</strong>b </td><td class="col3"> $4020 </td><td class="col4"> 01000<strong>000</strong><em>001</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 1 </td>
	</tr>
	<tr class="row10">
		<td class="col0"> 1 </td><td class="col1"> 9 </td><td class="col2"> 00<em>001</em><strong>001</strong>b </td><td class="col3"> $4120 </td><td class="col4"> 01000<strong>001</strong><em>001</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 1 </td>
	</tr>
	<tr class="row11">
		<td class="col0"> 1 </td><td class="col1"> 10 </td><td class="col2"> 00<em>001</em><strong>010</strong>b </td><td class="col3"> $4220 </td><td class="col4"> 01000<strong>010</strong><em>001</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 1 </td>
	</tr>
	<tr class="row12">
		<td class="col0"> 1 </td><td class="col1"> 11 </td><td class="col2"> 00<em>001</em><strong>011</strong>b </td><td class="col3"> $4320 </td><td class="col4"> 01000<strong>011</strong><em>001</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 1 </td>
	</tr>
	<tr class="row13">
		<td class="col0"> 1 </td><td class="col1"> 12 </td><td class="col2"> 00<em>001</em><strong>100</strong>b </td><td class="col3"> $4420 </td><td class="col4"> 01000<strong>100</strong><em>001</em>00000b </td><td class="col5"> 0 (00b) </td><td class="col6"> 1 </td>
	</tr>
	<tr class="row14">
		<td class="col0"> (…) </td><td class="col1"> (…) </td><td class="col2"> (…) </td><td class="col3"> (…) </td><td class="col4"> (…) </td><td class="col5"> (…) </td><td class="col6"> (…) </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Como puede verse, la diferencia entre la composición de baja resolución
 y la de alta resolución es la modificación de los 3 bits menos
significativos de la parte alta de la dirección, que son un reflejo de
los 3 bits bajos de la coordenada Y.
</p>

<p>
 Si examinamos en binario la coordenada Y, vemos que ésta se puede
descomponer en 2 bits de Tercio de Pantalla, 3 bits de Fila Dentro del
Tercio (FT o N en los ejemplos) y 3 bits de Scanline Dentro Del Carácter
 (S):
</p>

<p>
<br>

<img src="img/gfx2_coordy.png" class="mediacenter" alt=" Descomposición de la coordenada Y "/>
<br>

</p>

<p>
 Por otra parte, ya sabemos que C es X / 8, por lo que ya tenemos todos
los componentes para realizar nuestra rutina de cálculo de dirección de
memoria.
</p>

<p>
<br>

<img src="img/gfx2_coordx.png" class="mediacenter" alt=" Descomposición de la coordenada X "/>
<br>

</p>

<p>
 Así pues, la composición final de la dirección de memoria del pixel (x,y) se define de la siguiente forma:
</p>

<p>
<br>

<img src="img/gfx2_calcoffset3_hr.png" class="mediacenter" alt=" Cálculo de la dirección de (x,y) "/>
</p>
<div style="text-align: center;"><em>Cálculo de la dirección del pixel (x,y)</em>
</div>
<p>
<br>

</p>

<p>
 No obstante, recordemos que esta dirección de memoria obtenida hace
referencia a 8 píxeles, por lo que necesitamos obtener además la
información del número de bit con el que se corresponde nuestro pixel,
que podemos extraer del resto de la división entre 8 de la coordenada X
(P = X AND 7).
</p>

<p>
 La rutina resultante es similar a la vista en baja resolución con la
descomposición de la coordenada Y en el “número de scanline” (0-7) y la
“fila dentro del tercio (0-7)”:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Pixel_Offset_HR(x,y)</span>
<span class="co1">; Obtener la direccion de memoria del pixel (x,y).</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   B = Y,  C = X</span>
<span class="co1">; Salida:   HL = Direccion de memoria del caracter con (x,y)</span>
<span class="co1">;            A = Posicion del pixel (0-7) en el byte.</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Pixel_Offset_HR:
&nbsp;
   <span class="co1">; Calculo de la parte alta de la direccion:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>                       <span class="co1">; A = 00000SSSb</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>                     <span class="co1">; Lo guardamos en H</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                     <span class="co1">; Recuperamos de nuevo Y</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>                         <span class="co1">; Rotamos para asi obtener el tercio</span>
   <span class="kw1">AND</span> <span class="nu0">24</span>                      <span class="co1">; con un AND 00011000b -&gt; 000TT000b</span>
   <span class="kw1">OR</span> <span class="kw2">H</span>                        <span class="co1">; H = H OR A = 00000SSSb OR 000TT000b</span>
   <span class="kw1">OR</span> <span class="nu0">64</span>                       <span class="co1">; Mezclamos H con 01000000b (vram)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>                     <span class="co1">; Establecemos el "H" definitivo </span>
&nbsp;
   <span class="co1">; Calculo de la parte baja de la direccion:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                     <span class="co1">; A = coordenada X</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>                         <span class="co1">; Rotamos para obtener CCCCCb</span>
   <span class="kw1">AND</span> <span class="nu0">3</span><span class="re1">1</span>                      <span class="co1">; A = A AND 31 = 000CCCCCb</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                     <span class="co1">; L = 000CCCCCb</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                     <span class="co1">; Recuperamos de nuevo Y</span>
   <span class="kw1">RLA</span>                         <span class="co1">; Rotamos para obtener NNN</span>
   <span class="kw1">RLA</span>
   <span class="kw1">AND</span> <span class="nu0">224</span>                     <span class="co1">; A = A AND 11100000b</span>
   <span class="kw1">OR</span> <span class="kw2">L</span>                        <span class="co1">; L = NNNCCCCC</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                     <span class="co1">; Establecemos el "L" definitivo</span>
&nbsp;
   <span class="co1">; Finalmente, calcular posicion relativa del pixel:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                      <span class="co1">; Recuperamos la coordenada X</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>                        <span class="co1">; AND 00000111 para obtener pixel</span>
                                <span class="co1">; A = 00000PPP</span>
   <span class="kw1">RET</span></pre>

<p>
 Esta rutina de 118 t-estados nos devuelve el valor de la dirección
calculado en HL y la posición relativa del pixel dentro del byte:
</p>
<div class="table-responsive sectionedit16"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Valor de A </th><th class="col1"> 7 </th><th class="col2"> 6 </th><th class="col3"> 5 </th><th class="col4"> 4 </th><th class="col5"> 3 </th><th class="col6"> 2 </th><th class="col7"> 1 </th><th class="col8"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Posición del pixel<br>
desde la izquierda </td><td class="col1"> +7 </td><td class="col2"> +6 </td><td class="col3"> +5 </td><td class="col4"> +4 </td><td class="col5"> +3 </td><td class="col6"> +2 </td><td class="col7"> +1 </td><td class="col8"> +0 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> Posición del pixel<br>
dentro del byte (Bit) </td><td class="col1"> 0 </td><td class="col2"> 1 </td><td class="col3"> 2 </td><td class="col4"> 3 </td><td class="col5"> 4 </td><td class="col6"> 5 </td><td class="col7"> 6 </td><td class="col8"> 7 </td>
	</tr>
</tbody></table></div>

<p>
 Esta posición relativa del pixel nos sirve para 2 cosas:
</p>

<p>
 Por una parte, cuando realicemos rutinas de impresión de sprites con
movimiento pixel a pixel, este valor nos puede servir para tratar los
sprites (rotarlos) de cara a su impresión en posiciones de byte.
</p>

<p>
 Por otra parte, si necesitamos activar (PLOT, bit=1), desactivar
(UNPLOT, b=0) o testear el estado del pixel (x,y), podremos utilizar
este valor “<strong>posición del pixel</strong>” para generar una <strong>máscara de pixel</strong>.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit17" id="obtencion-y-uso-de-la-mascara-de-pixel">Obtención y uso de la Máscara de Pixel</h3>
<div class="level3">

<p>
 Nuestra rutina de coordenación nos devuelve en HL la dirección de
memoria que contiene el pixel (x,y) y en A la posición relativa del
pixel dentro de dicha dirección.
</p>

<p>
 Para poder modificar el pixel exacto al que hacen referencia la pareja de datos HL y A resulta necesario convertir A en una “<strong>máscara de pixel</strong>” que nos permita manipular la memoria con sencillas operaciones lógicas sin afectar al estado de los demás píxeles.
</p>

<p>
 Esta “máscara de pixel” tiene activo el bit 8-pixel ya que el pixel 0
es el pixel de más a la izquierda de los 8, es decir, el bit 7 de la
dirección:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit18"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bit activo </th><th class="col1"> 7 </th><th class="col2"> 6 </th><th class="col3"> 5 </th><th class="col4"> 4 </th><th class="col5"> 3 </th><th class="col6"> 2 </th><th class="col7"> 1 </th><th class="col8"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Pixel </td><td class="col1"> 0 </td><td class="col2"> 1 </td><td class="col3"> 2 </td><td class="col4"> 3 </td><td class="col5"> 4 </td><td class="col6"> 5 </td><td class="col7"> 6 </td><td class="col8"> 7 </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 La máscara que debemos generar, en función del valor de A, es:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit19"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Valor de A </th><th class="col1"> Máscara de pixel </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> 10000000b </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> 01000000b </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> 00100000b </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> 00010000b </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> 00001000b </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1"> 00000100b </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 6 </td><td class="col1"> 00000010b </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 7 </td><td class="col1"> 00000001b </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 La porción de código que hace esta conversión es la siguiente:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>         <span class="co1">; Cargamos A (posicion de pixel) en B</span>
   <span class="kw1">INC</span> <span class="kw2">B</span>           <span class="co1">; Incrementamos B (para pasadas del bucle)</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>           <span class="co1">; A = 0</span>
   <span class="kw1">SCF</span>             <span class="co1">; Set Carry Flag (A=0, CF=1)</span>
pix_rotate_bit:
   <span class="kw1">RRA</span>             <span class="co1">; Rotamos A a la derecha B veces</span>
   <span class="kw1">DJNZ</span> pix_rotate_bit</pre>

<p>
 La rutina pone A a cero y establece el Carry Flag a 1, por lo que la
primera ejecución de RRA (que siempre se realizará) ubica el 1 del CF en
 el bit 7 de A. A continuación el DJNZ que se realiza “B” veces mueve
ese bit a 1 a la derecha (también “B” veces) dejando A con el valor
adecuado según la tabla que acabamos de ver.
</p>

<p>
<br>

<img src="img/rra.png" class="mediacenter" alt=" Instrucción RRA "/>
<br>

</p>

<p>
 En formato de rutina:
</p>
<pre class="code z80"><span class="co1">;--------------------------------------------------------</span>
: Relative_to_Mask: Convierte una posicion <span class="kw2">de</span> pixel
<span class="co1">;                   relativa en una mascara de pixel.</span>
<span class="co1">; IN:  A = Valor relativo del pixel (0,7)</span>
<span class="co1">; OUT: A = Pixel Mask (128-1)</span>
<span class="co1">; CHANGES: B, F</span>
<span class="co1">;--------------------------------------------------------</span>
Relative_to_Mask:
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>         <span class="co1">; Cargamos A (posicion de pixel) en B</span>
   <span class="kw1">INC</span> <span class="kw2">B</span>           <span class="co1">; Incrementamos B (para pasadas del bucle)</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>           <span class="co1">; A = 0</span>
   <span class="kw1">SCF</span>             <span class="co1">; Set Carry Flag (A=0, CF=1)</span>
pix_rotate_bit:
   <span class="kw1">RRA</span>             <span class="co1">; Rotamos A a la derecha B veces</span>
   <span class="kw1">DJNZ</span> pix_rotate_bit
   <span class="kw1">RET</span></pre>

<p>
 Mediante esa máscara podemos activar (PLOT), desactivar (UNPLOT) y testear (TEST) el estado del pixel en cuestión:
</p>
<pre class="code z80"><span class="co1">; Activar el pixel apuntado por HL usando la máscara A</span>
Plot_Pixel_HL:
  <span class="kw1">OR</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">; Desactivar el pixel apuntado por HL usando la máscara A</span>
Unplot_Pixel_HL:
  <span class="kw1">CPL</span> <span class="kw2">A</span>
  <span class="kw1">AND</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">; Testear el pixel apuntado por HL usando la máscara A</span>
Test_Pixel_HL:
  <span class="kw1">AND</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
  <span class="kw1">RET</span></pre>

<p>
 La anterior rutina de PLOT funciona realizando un OR entre la máscara
de pixel y el estado de actual de la memoria, y luego escribiendo el
resultado de dicho OR en la videoram. De esta forma, sólo alteramos el
pixel sobre el que queremos escribir.
</p>

<p>
 Explicándolo con un ejemplo, supongamos que queremos escribir en el
pixel (3,0) de la pantalla y ya hay píxeles activos en (0,0) y (7,0):
</p>
<pre class="code">Pixeles activos en (16384) = 10000001
Máscara de pixel           = 00010000</pre>

<p>
 Si ejecutaramos un simple “LD (HL), A”, el resultado de la operación
eliminaría los 2 píxeles activos que ya teníamos en memoria:
</p>
<pre class="code">Pixeles activos en (16384) = 10000001
Máscara de pixel A         = 00010000
OPERACION (HL)=A           = LD (HL), A
Resultado en (16384)       = 00010000</pre>

<p>
 Mediante el OR entre la máscara de pixel y la videomemoria conseguimos
alterar el estado de (3,0) sin modificar los píxeles ya existentes:
</p>
<pre class="code">Pixeles activos en (16384) = 10000001
Máscara de pixel A         = 00010000
OPERACION A = A OR (HL)    = OR (HL)
Resultado en A             = 10010001
OPERACION (HL)=A           = LD (HL), A
Resultado en (16384)       = 10010001</pre>

<p>
 Si en lugar de un OR hubieramos complementado A y hubieramos hecho un AND, habríamos puesto a 0 el bit (y por tanto el pixel):
</p>
<pre class="code">Pixeles activos en (16384) = 10000001
Máscara de pixel A         = 00010000
OPERACION A = CPL(A)       = 11101111
OPERACION A = A OR (HL)    = AND (HL)
Resultado en A             = 10000001
OPERACION (HL)=A           = LD (HL), A
Resultado en (16384)       = 10000001</pre>

<p>
 El cálculo de memoria y la escritura de un pixel quedaría pues de la siguiente forma:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">1</span><span class="nu0">27</span>                   <span class="co1">; X = 127</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">95</span>                    <span class="co1">; Y = 95</span>
  <span class="kw1">CALL</span> Get_Pixel_Offset_HR    <span class="co1">; Calculamos HL y A</span>
  <span class="kw1">OR</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                     <span class="co1">; OR de A y (HL)</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                  <span class="co1">; Activamos pixel</span></pre>

<p>
 La primera pregunta que nos planteamos es, si es imprescindible
disponer de una máscara de pixel para dibujar o borrar píxeles, ¿por qué
 no incluir este código de rotación de A  directamente en la rutina de
coordenación? La respuesta es, “depende de para qué vayamos a utilizar
la rutina”.
</p>

<p>
 Si la rutina va a ser utilizada principalmente para trazar píxeles,
resultará conveniente incorporar al final de Get_Pixel_Offset_HR() el
cálculo de la máscara, y devolver en A dicha máscara en lugar de la
posición relativa del pixel.
</p>

<p>
 Pero lo normal en el desarrollo de programas y juegos es que utilicemos
 la rutina de coordenación para obtener la posición inicial en la que
comenzar a trazar sprites, bloques (del mapeado), fuentes de texto,
marcadores. En ese caso es absurdo emplear “ciclos de reloj” adicionales
 para el cálculo de una máscara que sólo se utiliza en el trazado de
puntos. En esas circunstancias resulta mucho más útil disponer de la
posición relativa del pixel, para, como ya hemos comentado, conocer la
cantidad de bits que necesitamos rotar estos datos gráficos antes de su
trazado.
</p>

<p>
 Por ese motivo, no hemos agregado esta pequeña porción de código a la
rutina de Get_Pixel_Offset, siendo el programador quien debe decidir en
qué formato quiere obtener la salida de la rutina.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit20" id="la-rutina-de-la-rom-pixel-address">La rutina de la ROM PIXEL-ADDRESS</h3>
<div class="level3">

<p>
 Curiosamente, los usuarios de Spectrum tenemos disponible en la memoria ROM una rutina parecida, llamada <strong>PIXEL-ADDRESS</strong>
 (o PIXEL-ADD), utilizada por las rutinas POINT y PLOT de la ROM (y de
BASIC). La rutina está ubicada en $22AA y su código es el siguiente:
</p>
<pre class="code z80"><span class="co1">; THE 'PIXEL ADDRESS' SUBROUTINE</span>
<span class="co1">; This subroutine is called by the POINT subroutine and by the PLOT</span>
<span class="co1">; command routine. Is is entered with the co-ordinates of a pixel in</span>
<span class="co1">; the BC register pair and returns with HL holding the address of the</span>
<span class="co1">; display file byte which contains that pixel and A pointing to the</span>
<span class="co1">; position of the pixel within the byte.</span>
<span class="co1">;</span>
<span class="co1">; IN: (C,B) = (X,Y)</span>
<span class="co1">; OUT: HL = address, A = pixel relative position in (HL)</span>
&nbsp;
<span class="sy0">$</span>22AA PIXEL<span class="sy0">-</span><span class="kw1">ADD</span>
    <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="sy0">$</span>AF               <span class="co1">; Test that the y co-ordinate (in</span>
    <span class="kw1">SUB</span>   <span class="kw2">B</span>                   <span class="co1">; B) is not greater than 175.</span>
    <span class="kw1">JP</span>    <span class="kw2">C</span>,24F9,REPORT<span class="sy0">-</span><span class="kw2">B</span>
    <span class="kw1">LD</span>    <span class="kw2">B</span>,<span class="kw2">A</span>                 <span class="co1">; B now contains 175 minus y.</span>
&nbsp;
<span class="sy0">$</span>22B<span class="re1">1</span> PIXEL_ADDRESS_B:        <span class="co1">; Entramos aqui para saltarnos la limitacion</span>
                              <span class="co1">; hacia las 2 ultimas lineas de pantalla.</span>
&nbsp;
    <span class="kw1">AND</span>   <span class="kw2">A</span>                   <span class="co1">; A holds b7b6b5b4b3b2b1b0,</span>
    <span class="kw1">RRA</span>                       <span class="co1">; the bite of B. And now</span>
                              <span class="co1">; 0b7b6b5b4b3b2b1.</span>
    <span class="kw1">SCF</span>
    <span class="kw1">RRA</span>                       <span class="co1">; Now 10b7b6b5b4b3b2.</span>
    <span class="kw1">AND</span>   <span class="kw2">A</span>
    <span class="kw1">RRA</span>                       <span class="co1">; Now 010b7b6b5b4b3.</span>
    <span class="kw1">XOR</span>   <span class="kw2">B</span>
    <span class="kw1">AND</span>   <span class="sy0">$</span>F8                 <span class="co1">; Finally 010b7b6b2b1b0, so that</span>
    <span class="kw1">XOR</span>   <span class="kw2">B</span>                   <span class="co1">; H becomes 64 + 8*INT (B/64) +</span>
    <span class="kw1">LD</span>    <span class="kw2">H</span>,<span class="kw2">A</span>                 <span class="co1">; B (mod 8), the high byte of the</span>
    <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">C</span>                 <span class="co1">; pixel address. C contains X.</span>
    <span class="kw1">RLCA</span>                      <span class="co1">; A starts as c7c6c5c4c3c2c1c0.</span>
    <span class="kw1">RLCA</span>
    <span class="kw1">RLCA</span>                      <span class="co1">; And is now c2c1c0c7c6c5c4c3.</span>
    <span class="kw1">XOR</span>   <span class="kw2">B</span>
    <span class="kw1">AND</span>   <span class="sy0">$</span>C7
    <span class="kw1">XOR</span>   <span class="kw2">B</span>                   <span class="co1">; Now c2c1b5b4b3c5c4c3.</span>
    <span class="kw1">RLCA</span>
    <span class="kw1">RLCA</span>                      <span class="co1">; Finally b5b4b3c7c6c5c4c3, so</span>
    <span class="kw1">LD</span>    <span class="kw2">L</span>,<span class="kw2">A</span>                 <span class="co1">; that L becomes 32*INT (B(mod</span>
    <span class="kw1">LD</span>    <span class="kw2">A</span>,<span class="kw2">C</span>                 <span class="co1">; 64)/8) + INT(x/8), the low byte.</span>
    <span class="kw1">AND</span>   <span class="sy0">$</span><span class="re1">0</span><span class="nu0">7</span>                 <span class="co1">; A holds x(mod 8): so the pixel</span>
    <span class="kw1">RET</span>                       <span class="co1">; is bit (A - 7) within the byte.</span></pre>

<p>
 Esta rutina tiene una serie de ventajas: Entrando por $22B1 tenemos 23
instrucciones (107 t-estados) que realizan el cálculo de la dirección de
 memoria además de la posición del pixel dentro del byte al que apunta
dicha dirección. La rutina está ubicada en ROM, por lo que ahorramos
esta pequeña porción de espacio en nuestro programa. Además, no usa la
pila, no usa registros adicionales a B, C, HL y A, y no altera los
valores de B y C durante el cálculo.
</p>

<p>
 Nótese que aunque la rutina está ubicada en $22AA y se entra con los
valores (x,y) en C y B, el principio de la rutina está diseñado para
evitar que PLOT y POINT puedan acceder a las 2 últimas filas (16 últimos
 píxeles) de la pantalla. Para saltarnos esta limitación entramos
saltando con un CALL a $22B1 con la coordenada X en el registro C y la
coordenada Y en los registros A y B:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>coord_x<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>coord_y<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">CALL</span> <span class="sy0">$</span>22B<span class="re1">1</span></pre>

<p>
 De esta forma no sólo nos saltamos la limitación de acceso a las 2
últimas líneas de la pantalla sino que podemos especificar las
coordenadas empezando (0,0) en la esquina superior izquierda, con el
sistema tradicional de coordenadas, en contraposición al PLOT de BASIC
(y de la ROM), donde se comienza a contar la altura como Y = 0 en la
parte inferior de la pantalla (empezando en 191-16=175).
</p>

<p>
 Veamos un ejemplo de uso de la rutina de coordenación de la ROM:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo de uso de pixel-address (ROM)</span>
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
PIXEL_ADDRESS <span class="kw3">EQU</span> <span class="sy0">$</span>22B<span class="re1">1</span>
&nbsp;
entrada:
&nbsp;
  <span class="co1">; Imprimimos un solo pixel en (0,0)</span>
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">0</span>                <span class="co1">; X = 0</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>                <span class="co1">; Y = 0</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                <span class="co1">; A = Y = 0</span>
  <span class="kw1">CALL</span> PIXEL_ADDRESS     <span class="co1">; HL = direccion (0,0)</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">28</span>              <span class="co1">; A = 10000000b (1 pixel).</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>             <span class="co1">; Imprimimos el pixel</span>
&nbsp;
  <span class="co1">; Imprimimos 8 pixeles en (255,191)</span>
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="nu0">255</span>              <span class="co1">; X = 255</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span><span class="nu0">9</span><span class="re1">1</span>              <span class="co1">; Y = 191</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                <span class="co1">; A = Y = 191</span>
  <span class="kw1">CALL</span> PIXEL_ADDRESS
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>              <span class="co1">; A = 11111111b (8 pixeles)</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
  <span class="co1">; Imprimimos 4 pixeles en el centro de la pantalla</span>
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">1</span><span class="nu0">27</span>              <span class="co1">; X = 127</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">95</span>               <span class="co1">; Y = 95</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                <span class="co1">; A = Y = 95</span>
  <span class="kw1">CALL</span> PIXEL_ADDRESS
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">7</span><span class="re1">0</span>              <span class="co1">; A = 10101010b (4 pixeles)</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
loop:                    <span class="co1">; Bucle para no volver a BASIC y que</span>
  <span class="kw1">jr</span> loop                <span class="co1">; no se borren la 2 ultimas lineas</span>
&nbsp;
END <span class="nu0">5</span><span class="re1">0000</span></pre>

<p>
 La ejecución del anterior programa nos dejará la siguiente información gráfica en pantalla:
</p>

<p>
<br>

<img src="img/gfx2_pixeladd.png" class="mediacenter" alt=" Ejemplo: rutina de la ROM pixelADD "/>
<br>

</p>

<p>
 Nótese que la rutina de la ROM nos devuelve en A la posición relativa
del pixel cuyas coordenadas hemos proporcionado, por lo que podemos
convertir A en una <strong>máscara de pixel</strong> a la salida de la
rutina encapsulando PIXEL-ADDRESS en una rutina “propia” que haga ambas
operaciones, a cambio de 2 instrucciones extras (un CALL y un RET
adicionales):
</p>
<pre class="code z80">PIXEL_ADDRESS <span class="kw3">EQU</span> <span class="sy0">$</span>22B<span class="re1">1</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
<span class="co1">; Rutina que encapsula a PIXEL_ADDRESS calculando pix-mask.</span>
<span class="co1">; IN: (C,B) = (X,Y)</span>
<span class="co1">; OUT: HL = address, A = pixel mask</span>
<span class="co1">;----------------------------------------------------------</span>
PIXEL_ADDRESS_MASK:
   <span class="kw1">CALL</span> PIXEL_ADDRESS   <span class="co1">; Llamamos a la rutina de la ROM</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>              <span class="co1">; Cargamos A (posicion de pixel) en B</span>
   <span class="kw1">INC</span> <span class="kw2">B</span>                <span class="co1">; Incrementamos B (para pasadas del bucle)</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>                <span class="co1">; A = 0</span>
   <span class="kw1">SCF</span>                  <span class="co1">; Set Carry Flag (A=0, CF=1)</span>
pix_rotate_bit:
   <span class="kw1">RRA</span>                  <span class="co1">; Rotamos A a la derecha B veces</span>
   <span class="kw1">DJNZ</span> pix_rotate_bit
   <span class="kw1">RET</span></pre>

<p>
<br>

<br>

</p>

</div>

<h3 class="sectionedit21" id="calculo-de-posiciones-de-pixeles-mediante-tabla">Cálculo de posiciones de pixeles mediante tabla</h3>
<div class="level3">

<p>
 Hasta ahora hemos visto cómo calcular la dirección de memoria de un
pixel (x,y) mediante descomposición de las coordenadas y composición de
la dirección destino utilizando operaciones lógicas y de desplazamiento.
</p>

<p>
 La alternativa a este método es la utilización de una <strong>Look Up Table</strong> (LUT), una tabla de valores precalculados mediante la cual obtener la dirección destino dada una variable concreta.
</p>

<p>
 En nuestro caso, crearíamos una Lookup Table (LUT) que se indexaría
mediante la coordenada Y, de tal modo que la dirección destino de un
pixel X,Y sería:
</p>
<pre class="code">DIRECCION_DESTINO  = Tabla_Offsets_Linea[Y] + (X/8)
PIXEL_EN_DIRECCION = Resto(X/8) = X AND 7</pre>

<p>
 La tabla de offsets de cada inicio de línea tendría 192 elementos de 2
bytes (tamaño de una dirección), por lo que ocuparía en memoria 384
bytes. A cambio de esta “elevada” ocupación en memoria, podemos obtener
rutinas más rápidas que las de composición de las coordenadas.
</p>

<p>
 A continuación se muestra la tabla de offsets precalculados:
</p>
<pre class="code">Scanline_Offsets:
  DW 16384, 16640, 16896, 17152, 17408, 17664, 17920, 18176
  DW 16416, 16672, 16928, 17184, 17440, 17696, 17952, 18208
  DW 16448, 16704, 16960, 17216, 17472, 17728, 17984, 18240
  DW 16480, 16736, 16992, 17248, 17504, 17760, 18016, 18272
  DW 16512, 16768, 17024, 17280, 17536, 17792, 18048, 18304
  DW 16544, 16800, 17056, 17312, 17568, 17824, 18080, 18336
  DW 16576, 16832, 17088, 17344, 17600, 17856, 18112, 18368
  DW 16608, 16864, 17120, 17376, 17632, 17888, 18144, 18400
  DW 18432, 18688, 18944, 19200, 19456, 19712, 19968, 20224
  DW 18464, 18720, 18976, 19232, 19488, 19744, 20000, 20256
  DW 18496, 18752, 19008, 19264, 19520, 19776, 20032, 20288
  DW 18528, 18784, 19040, 19296, 19552, 19808, 20064, 20320
  DW 18560, 18816, 19072, 19328, 19584, 19840, 20096, 20352
  DW 18592, 18848, 19104, 19360, 19616, 19872, 20128, 20384
  DW 18624, 18880, 19136, 19392, 19648, 19904, 20160, 20416
  DW 18656, 18912, 19168, 19424, 19680, 19936, 20192, 20448
  DW 20480, 20736, 20992, 21248, 21504, 21760, 22016, 22272
  DW 20512, 20768, 21024, 21280, 21536, 21792, 22048, 22304
  DW 20544, 20800, 21056, 21312, 21568, 21824, 22080, 22336
  DW 20576, 20832, 21088, 21344, 21600, 21856, 22112, 22368
  DW 20608, 20864, 21120, 21376, 21632, 21888, 22144, 22400
  DW 20640, 20896, 21152, 21408, 21664, 21920, 22176, 22432
  DW 20672, 20928, 21184, 21440, 21696, 21952, 22208, 22464
  DW 20704, 20960, 21216, 21472, 21728, 21984, 22240, 22496</pre>

<p>
 En hexadecimal (para ver la relación entre los aumentos de líneas y el de scanlines y bloques):
</p>
<pre class="code">Scanline_Offsets:
  DW $4000, $4100, $4200, $4300, $4400, $4500, $4600, $4700
  DW $4020, $4120, $4220, $4320, $4420, $4520, $4620, $4720
  DW $4040, $4140, $4240, $4340, $4440, $4540, $4640, $4740
  DW $4060, $4160, $4260, $4360, $4460, $4560, $4660, $4760
  DW $4080, $4180, $4280, $4380, $4480, $4580, $4680, $4780
  DW $40A0, $41A0, $42A0, $43A0, $44A0, $45A0, $46A0, $47A0
  DW $40C0, $41C0, $42C0, $43C0, $44C0, $45C0, $46C0, $47C0
  DW $40E0, $41E0, $42E0, $43E0, $44E0, $45E0, $46E0, $47E0
  DW $4800, $4900, $4A00, $4B00, $4C00, $4D00, $4E00, $4F00
  DW $4820, $4920, $4A20, $4B20, $4C20, $4D20, $4E20, $4F20
  DW $4840, $4940, $4A40, $4B40, $4C40, $4D40, $4E40, $4F40
  DW $4860, $4960, $4A60, $4B60, $4C60, $4D60, $4E60, $4F60
  DW $4880, $4980, $4A80, $4B80, $4C80, $4D80, $4E80, $4F80
  DW $48A0, $49A0, $4AA0, $4BA0, $4CA0, $4DA0, $4EA0, $4FA0
  DW $48C0, $49C0, $4AC0, $4BC0, $4CC0, $4DC0, $4EC0, $4FC0
  DW $48E0, $49E0, $4AE0, $4BE0, $4CE0, $4DE0, $4EE0, $4FE0
  DW $5000, $5100, $5200, $5300, $5400, $5500, $5600, $5700
  DW $5020, $5120, $5220, $5320, $5420, $5520, $5620, $5720
  DW $5040, $5140, $5240, $5340, $5440, $5540, $5640, $5740
  DW $5060, $5160, $5260, $5360, $5460, $5560, $5660, $5760
  DW $5080, $5180, $5280, $5380, $5480, $5580, $5680, $5780
  DW $50A0, $51A0, $52A0, $53A0, $54A0, $55A0, $56A0, $57A0
  DW $50C0, $51C0, $52C0, $53C0, $54C0, $55C0, $56C0, $57C0
  DW $50E0, $51E0, $52E0, $53E0, $54E0, $55E0, $56E0, $57E0</pre>

<p>
 La tabla ha sido generada mediante el siguiente script en python:
</p>
<pre class="code python">$ cat specrows.<span class="me1">py</span>
<span class="co1">#!/usr/bin/python</span>
&nbsp;
<span class="kw1">print</span> <span class="st0">"Scanline_Offsets:"</span>
<span class="kw1">for</span> tercio <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">)</span>:
   <span class="kw1">for</span> caracter <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">8</span><span class="br0">)</span>:
      <span class="kw1">print</span> <span class="st0">"  DW"</span><span class="sy0">,</span>
      <span class="kw1">for</span> scanline <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">8</span><span class="br0">)</span>:
         <span class="co1"># Componer direccion como 010TTSSSNNN00000</span>
         base <span class="sy0">=</span> <span class="nu0">16384</span>
         direccion <span class="sy0">=</span> base + <span class="br0">(</span>tercio * <span class="nu0">2048</span><span class="br0">)</span>
         direccion <span class="sy0">=</span> direccion + <span class="br0">(</span>scanline * <span class="nu0">256</span><span class="br0">)</span>
         direccion <span class="sy0">=</span> direccion + <span class="br0">(</span>caracter * <span class="nu0">32</span><span class="br0">)</span>
         <span class="kw1">print</span> <span class="kw2">str</span><span class="br0">(</span>direccion<span class="br0">)</span><span class="sy0">,</span>
         <span class="kw1">if</span> scanline<span class="sy0">!=</span><span class="nu0">7</span>: <span class="kw1">print</span> <span class="st0">","</span><span class="sy0">,</span>
      <span class="kw1">print</span></pre>

<p>
 La tabla de valores DW estaría incorporada en nuestro programa y por
tanto pasaría a formar parte del “binario final”, incluyendo en este
aspecto la necesidad de carga desde cinta.
</p>

<p>
 Si por algún motivo no queremos incluir la tabla en el listado, podemos
 generarla en el arranque de nuestro programa en alguna posición de
memoria libre o designada a tal efecto mediante la siguiente rutina:
</p>
<pre class="code z80"><span class="co1">;--------------------------------------------------------</span>
<span class="co1">; Generar LookUp Table de scanlines en memoria.</span>
<span class="co1">; Rutina por Derek M. Smith (2005).</span>
<span class="co1">;--------------------------------------------------------</span>
&nbsp;
Scanline_Offsets <span class="kw3">EQU</span> <span class="sy0">$</span>F9<span class="re1">00</span>
&nbsp;
Generate_Scanline_Table:
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="sy0">$</span>4<span class="re1">000</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, Scanline_Offsets
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span><span class="nu0">92</span>
&nbsp;
genscan_loop:
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">E</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">D</span>           <span class="co1">; Guardamos en (HL) (tabla)</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>               <span class="co1">; el valor de DE (offset)</span>
&nbsp;
   <span class="co1">; Recorremos los scanlines y bloques en un bucle generando las</span>
   <span class="co1">; sucesivas direccione en DE para almacenarlas en la tabla. </span>
   <span class="co1">; Cuando se cambia de caracter, scanline o tercio, se ajusta:</span>
   <span class="kw1">INC</span> <span class="kw2">D</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">JR</span> NZ, genscan_nextline
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, genscan_nextline
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
&nbsp;
genscan_nextline:
   <span class="kw1">DJNZ</span> genscan_loop
   <span class="kw1">RET</span></pre>

<p>
 La anterior rutina ubicará en memoria una tabla con el mismo contenido que las ya vistas en formato DW.
</p>

<p>
<br>

</p>

</div>

<h4 id="get_pixel_offset_lut">Get_Pixel_Offset_LUT</h4>
<div class="level4">

<p>
 Una vez tenemos generada la tabla (ya sea en memoria o pregenerada en
el código de nuestro programa), podemos indexar dicha tabla mediante la
coordenada Y y sumar la coordenada X convertida en columna para obtener
la dirección de memoria del pixel solicitado, y la posición relativa del
 mismo en el byte:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Pixel_Offset_LUT_HR(x,y):</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   B = Y,  C = X</span>
<span class="co1">; Salida:   HL = Direccion de memoria del pixel (x,y)</span>
<span class="co1">;            A = Posicion relativa del pixel en el byte</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Pixel_Offset_LUT_HR:
   <span class="kw1">LD</span> <span class="kw2">DE</span>, Scanline_Offsets   <span class="co1">; Direccion de nuestra LUT</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">B</span>                   <span class="co1">; L = Y</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>                <span class="co1">; HL = HL * 2 = Y * 2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">DE</span>                <span class="co1">; HL = (Y*2) + ScanLine_Offset</span>
                             <span class="co1">; Ahora Offset = [HL]</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Cogemos el valor bajo de la direccion en A</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Cogemos el valor alto de la direccion en H</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                   <span class="co1">; HL es ahora Direccion(0,Y)</span>
                             <span class="co1">; Ahora sumamos la X, para lo cual calculamos CCCCC</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                   <span class="co1">; Calculamos columna</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>                       <span class="co1">; A = A&gt;&gt;3 = ???CCCCCb</span>
   <span class="kw1">AND</span> <span class="nu0">3</span><span class="re1">1</span>                    <span class="co1">; A = 000CCCCB</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">L</span>                  <span class="co1">; HL = HL + C</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                   <span class="co1">; Recuperamos la coordenada (X)</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>                     <span class="co1">; A = Posicion relativa del pixel</span>
   <span class="kw1">RET</span>                       <span class="co1">; HL = direccion destino</span></pre>

<p>
 Veamos un ejemplo de utilización de las anteriores rutinas:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo de uso de LUT</span>
  ORG <span class="nu0">5</span><span class="re1">0000</span>
&nbsp;
entrada:
&nbsp;
  <span class="kw1">CALL</span> Generate_Scanline_Table
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span><span class="nu0">9</span><span class="re1">1</span>
&nbsp;
loop_draw:
  <span class="kw1">PUSH</span> <span class="kw2">BC</span>                <span class="co1">; Preservamos B (por el bucle)</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">1</span><span class="nu0">27</span>              <span class="co1">; X = 127, Y = B</span>
&nbsp;
  <span class="kw1">CALL</span> Get_Pixel_Offset_LUT_HR
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">28</span>
  <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>             <span class="co1">; Imprimimos el pixel</span>
&nbsp;
  <span class="kw1">POP</span> <span class="kw2">BC</span>
  <span class="kw1">DJNZ</span> loop_draw
&nbsp;
loop:                    <span class="co1">; Bucle para no volver a BASIC y que</span>
  <span class="kw1">JR</span> loop                <span class="co1">; no se borren la 2 ultimas lineas</span></pre>

<p>
 Y su salida en pantalla:
</p>

<p>
<br>

<img src="img/gfx2_lut.png" class="mediacenter" alt=" Salida de ejemplo del programa gfx2_lut "/>
<br>

</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit22" id="optimizando-la-lectura-a-traves-de-tablas">Optimizando la lectura a través de tablas</h3>
<div class="level3">

<p>
 El coste de ejecución de la rutina <strong>Get_Pixel_Offset_LUT_HR</strong>
 es de 117 t-estados, demasiado elevada por culpa de las costosas (en
términos temporales) instrucciones de 16 bits, sobre todo teniendo en
cuenta que hemos empleado 384 bytes de memoria en nuestra tabla.
</p>

<p>
 Una ingeniosa solución a este problema consiste en dividir la tabla de
192 direcciones de 16 bits en 2 tablas de 192 bytes cada una que
almacenen la parte alta de la dirección en la primera de las tablas y la
 parte baja de la dirección en la segunda, de tal forma que:
</p>
<pre class="code">H = Tabla_Parte_Alta[Y]
L = Tabla_Parte_Baja[Y]</pre>

<p>
 Si realizamos esta división y colocamos en memoria las tablas de forma
que estén alineadas en una dirección múltiplo de 256, el mecanismo de
acceso a la tabla será mucho más rápido.
</p>

<p>
 La ubicación de las tablas en memoria en una dirección X múltiplo de 256 tendría el siguiente aspecto:
</p>
<pre class="code">Sea una Direccion_XX divisible por 256:

Direccion_XX hasta Direccion_XX+191
  -&gt; Partes bajas de las direcciones de pantalla

Direccion_XX+256 hasta Direccion_XX+447
  -&gt; Partes altas de las direcciones de pantalla.</pre>

<p>
 El paso de una tabla a otra se realizará incrementando o decrementando
la parte alta del registro de 16 bits (INC H o DEC H), gracias al hecho
de que son 2 tablas múltiplos de 256 y consecutivas en memoria.
</p>

<p>
 Veamos primero la rutina para generar la tabla separando las partes
altas y bajas y alineando ambas a una dirección múltiplo de 256:
</p>
<pre class="code z80"><span class="co1">;----------------------------------------------------------</span>
<span class="co1">; Generar LookUp Table de scanlines en memoria en 2 tablas.</span>
<span class="co1">;</span>
<span class="co1">; En Scanline_Offsets (divisible por 256) </span>
<span class="co1">;    -&gt; 192 bytes de las partes bajas de la direccion.</span>
<span class="co1">;</span>
<span class="co1">; En Scanline_Offsets + 256 (divisible por 256)</span>
<span class="co1">;    -&gt; 192 bytes de las partes altas de la direccion.</span>
<span class="co1">;</span>
<span class="co1">; Rutina por Derek M. Smith (2005).</span>
<span class="co1">;----------------------------------------------------------</span>
&nbsp;
Scanline_Offsets <span class="kw3">EQU</span> <span class="nu0">64</span><span class="re1">000</span>        <span class="co1">; Divisible por 256</span>
&nbsp;
Generate_Scanline_Table_Aligned:
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="sy0">$</span>4<span class="re1">000</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, Scanline_Offsets
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span><span class="nu0">92</span>
&nbsp;
genscan_loop:
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">E</span>        <span class="co1">; Escribimos parte baja</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>             <span class="co1">; Saltamos a tabla de partes altas</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">D</span>        <span class="co1">; Escribimos parte alta</span>
   <span class="kw1">DEC</span> <span class="kw2">H</span>             <span class="co1">; Volvemos a tabla de partes bajas</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>             <span class="co1">; Siguiente valor</span>
&nbsp;
   <span class="co1">; Recorremos los scanlines y bloques en un bucle generando las</span>
   <span class="co1">; sucesivas direccione en DE para almacenarlas en la tabla. </span>
   <span class="co1">; Cuando se cambia de caracter, scanline o tercio, se ajusta:</span>
   <span class="kw1">INC</span> <span class="kw2">D</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">JR</span> NZ, genscan_nextline
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, genscan_nextline
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
&nbsp;
genscan_nextline:
   <span class="kw1">DJNZ</span> genscan_loop
   <span class="kw1">RET</span></pre>

<p>
 En el ejemplo anterior, tendremos entre 64000 y 64191 los 192 valores
bajos de la dirección, y entre 64256 y 64447 los 192 valores altos de la
 dirección. Entre ambas tablas hay un hueco de 256-192=64 bytes sin usar
 que debemos saltar para poder alinear la segunda tabla en un múltiplo
de 256.
</p>

<p>
 Estos 64 bytes no se utilizan en la rutina de generación ni (como
veremos a continuación) en la de cálculo, por lo que podemos
aprovecharlos para ubicar variables de nuestro programa, tablas
temporales, etc, y así no desperdiciarlos.
</p>

<p>
 Si necesitaramos reservar espacio en nuestro programa para después
generar la tabla sobre él, podemos hacerlo mediante las directivas de
preprocesado del ensamblador ORG (Origen) y DS (Define Space). Las
siguientes líneas (ubicadas al final del fichero de código) reservan en
nuestro programa un array de 448 bytes de longitud y tamaño cero
alineado en una posición múltiplo de 256:
</p>
<pre class="code z80">ORG <span class="nu0">64</span><span class="re1">000</span>
&nbsp;
Scanline_Offsets:
   DS <span class="nu0">448</span>, <span class="re1">0</span></pre>

<p>
 También podemos incluir las 2 tablas “inline” en nuestro programa, y
además sin necesidad de conocer la dirección de memoria en que están
(por ejemplo, embedidas dentro del código del programa en la siguiente
dirección múltiplo de 256 disponible) aprovechando el soporte de macros
del ensamblador PASMO:
</p>
<pre class="code">; Macro de alineacion para PASMO
align   macro value
       if $ mod value
       ds value - ($ mod value)
       endif
       endm

align 256

Scanline_Offsets:
LUT_Scanlines_LO:
  DB $00, $00, $00, $00, $00, $00, $00, $00, $20, $20, $20, $20
  DB $20, $20, $20, $20, $40, $40, $40, $40, $40, $40, $40, $40
  DB $60, $60, $60, $60, $60, $60, $60, $60, $80, $80, $80, $80
  DB $80, $80, $80, $80, $A0, $A0, $A0, $A0, $A0, $A0, $A0, $A0
  DB $C0, $C0, $C0, $C0, $C0, $C0, $C0, $C0, $E0, $E0, $E0, $E0
  DB $E0, $E0, $E0, $E0, $00, $00, $00, $00, $00, $00, $00, $00
  DB $20, $20, $20, $20, $20, $20, $20, $20, $40, $40, $40, $40
  DB $40, $40, $40, $40, $60, $60, $60, $60, $60, $60, $60, $60
  DB $80, $80, $80, $80, $80, $80, $80, $80, $A0, $A0, $A0, $A0
  DB $A0, $A0, $A0, $A0, $C0, $C0, $C0, $C0, $C0, $C0, $C0, $C0
  DB $E0, $E0, $E0, $E0, $E0, $E0, $E0, $E0, $00, $00, $00, $00
  DB $00, $00, $00, $00, $20, $20, $20, $20, $20, $20, $20, $20
  DB $40, $40, $40, $40, $40, $40, $40, $40, $60, $60, $60, $60
  DB $60, $60, $60, $60, $80, $80, $80, $80, $80, $80, $80, $80
  DB $A0, $A0, $A0, $A0, $A0, $A0, $A0, $A0, $C0, $C0, $C0, $C0
  DB $C0, $C0, $C0, $C0, $E0, $E0, $E0, $E0, $E0, $E0, $E0, $E0

Free_64_Bytes:
  DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  DB 0, 0, 0, 0

LUT_Scanlines_HI:
  DB $40, $41, $42, $43, $44, $45, $46, $47, $40, $41, $42, $43
  DB $44, $45, $46, $47, $40, $41, $42, $43, $44, $45, $46, $47
  DB $40, $41, $42, $43, $44, $45, $46, $47, $40, $41, $42, $43
  DB $44, $45, $46, $47, $40, $41, $42, $43, $44, $45, $46, $47
  DB $40, $41, $42, $43, $44, $45, $46, $47, $40, $41, $42, $43
  DB $44, $45, $46, $47, $48, $49, $4A, $4B, $4C, $4D, $4E, $4F
  DB $48, $49, $4A, $4B, $4C, $4D, $4E, $4F, $48, $49, $4A, $4B
  DB $4C, $4D, $4E, $4F, $48, $49, $4A, $4B, $4C, $4D, $4E, $4F
  DB $48, $49, $4A, $4B, $4C, $4D, $4E, $4F, $48, $49, $4A, $4B
  DB $4C, $4D, $4E, $4F, $48, $49, $4A, $4B, $4C, $4D, $4E, $4F
  DB $48, $49, $4A, $4B, $4C, $4D, $4E, $4F, $50, $51, $52, $53
  DB $54, $55, $56, $57, $50, $51, $52, $53, $54, $55, $56, $57
  DB $50, $51, $52, $53, $54, $55, $56, $57, $50, $51, $52, $53
  DB $54, $55, $56, $57, $50, $51, $52, $53, $54, $55, $56, $57
  DB $50, $51, $52, $53, $54, $55, $56, $57, $50, $51, $52, $53
  DB $54, $55, $56, $57, $50, $51, $52, $53, $54, $55, $56, $57</pre>

<p>
 Finalmente, veamos si ha merecido la pena el cambio a 2 tablas analizando la nueva rutina de cálculo de dirección:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Pixel_Offset_LUT_2(x,y):</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   B = Y,  C = X</span>
<span class="co1">; Salida:   HL = Direccion de memoria del pixel (x,y)</span>
<span class="co1">;            A = Posicion relativa del pixel en el byte</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Pixel_Offset_LUT_2:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                     <span class="co1">; Ponemos en A la X</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>                         <span class="co1">; A = ???CCCCC</span>
   <span class="kw1">AND</span> <span class="nu0">3</span><span class="re1">1</span>                      <span class="co1">; A = 000CCCCCb</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">B</span>                     <span class="co1">; B = coordenada Y</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, Scanline_Offsets<span class="sy0">/</span><span class="nu0">256</span>  <span class="co1">; Parte alta de la dir de tabla</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                 <span class="co1">; A = columna + tabla_baja[linea]</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>                       <span class="co1">; saltamos a la siguiente tabla</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                  <span class="co1">; cargamos en H la parte alta</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                     <span class="co1">; cargamos en L la parte baja</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                     <span class="co1">; Recuperamos la coordenada (X)</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>                       <span class="co1">; A = Posicion relativa del pixel</span>
   <span class="kw1">RET</span></pre>

<p>
 El coste de ejecución de esta rutina es de 77 t-estados, incluyendo el
RET, la conversión de “X” en “Columna” y la obtención de la posición
relativa del pixel.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit23" id="calculos-contra-tablas">Cálculos contra Tablas</h3>
<div class="level3">

<p>
 Como casi siempre en código máquina, nos vemos forzados a elegir entre
velocidad y tamaño: las rutinas basadas en tablas son generalmente más
rápidas al evitar muchos cálculos, pero a cambio necesitamos ubicar en
memoria dichas tablas. Por contra, las rutinas basadas en cálculos
ocupan mucho menos tamaño en memoria pero requieren más tiempo de
ejecución.
</p>

<p>
 Debemos elegir uno u otro sistema en función de las necesidades y
requerimientos de nuestro programa: si disponemos de poca memoria libre y
 el tiempo de cálculo individual es suficiente, optaremos por la rutina
de composición. Si, por contra, la cantidad de memoria libre no es un
problema y sí que lo es el tiempo de cálculo, usaremos las rutinas
basadas en tablas.
</p>

<p>
 Los programadores debemos muchas veces determinar si una rutina es
crítica o no según la cantidad de veces que se ejecute en el “bucle
principal” y el porcentaje de tiempo que su ejecución supone en el
programa.
</p>

<p>
 Por ejemplo, supongamos una rutina de impresión de sprites de 3×3
bloques: aunque el tiempo de dibujado de los sprites en sí de un juego
sea crítico, el posicionado en pantalla para cada sprite sólo se realiza
 una vez (para su esquina superior izquierda) frente a toda la porción
de código que debe imprimir los 9 caracteres (9*8 bytes en pantalla) más
 sus atributos, con sus correspondientes rotaciones si el movimiento es
pixel a pixel. El movimiento entre los diferentes bloques del sprite se
realiza normalmente de forma diferencial. Probablemente, invertir
“tiempo” para optimizar o “memoria” para tener tablas de precalculo sea
más aconsejable en el cuerpo de la rutina de sprites o en tablas de
sprites pre-rotados que en la coordenación en sí misma.
</p>

<p>
 La diferencia entre rutinas de tablas y de cálculos se resume en la siguiente tabla:
</p>
<div class="table-responsive sectionedit24"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Rutina </th><th class="col1"> Tiempo de ejecución </th><th class="col2 leftalign"> Bytes rutina  </th><th class="col3"> Bytes adicionales </th><th class="col4"> Tamaño Total </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Cálculo </td><td class="col1"> 118 t-estados </td><td class="col2 leftalign"> 32  </td><td class="col3"> Ninguno </td><td class="col4"> 32 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> Tablas </td><td class="col1"> 77 t-estados </td><td class="col2"> 17 GetOffset + 32 GenLUT </td><td class="col3"> 448 (384 si aprovechamos<br>
los 64 entre tablas) </td><td class="col4"> 443 - 487 bytes </td>
	</tr>
</tbody></table></div>

<p>
<br>
<br>

</p>

</div>

<h3 class="sectionedit25" id="calculo-de-posiciones-de-posiciones-diferenciales-de-pixel">Cálculo de posiciones de posiciones diferenciales de pixel</h3>
<div class="level3">

<p>
 Los cálculos de las posiciones de píxeles en alta resolución son
“costosos” por lo que a la hora de dibujar sprites, líneas, círculos o
cualquier otra primitiva gráfica, lo normal es realizar el cálculo de
una posición inicial y moverse diferencialmente respecto a la misma.
</p>

<p>
 Para eso se utilizan rutinas de posicionamiento diferencial como las
que ya vimos en los atributos o en baja resolución que nos permitan
movernos a cualquiera de los 8 píxeles de alrededor de la dirección HL y
 posición de pixel que estamos considerando.
</p>

<p>
<br>

<strong>Offset del pixel de la izquierda/derecha</strong>
</p>

<p>
 En el caso de la coordenación por caracteres (baja resolución), nos
bastaba con decrementar o incrementar HL para ir al carácter siguiente o
 anterior. En este caso, debemos tener en cuenta que cada byte contiene 8
 píxeles, por lo que se hace necesaria una máscara de pixel para
referenciar a uno u otro bit dentro del byte apuntado por HL.
</p>

<p>
 Teniendo una máscara de pixel en A, las rutinas de cálculo del pixel a
la izquierda y a la derecha del pixel actual se basarían en la ROTACIÓN
de dicha máscara comprobando las situaciones especiales en las 2
situaciones especiales que se pueden presentar:
</p>
<ul class="fix-media-list-overlap">
<li> El pixel se encuentra en 10000000b y queremos acceder al pixel de la izquierda.
</li>
<li> El pixel se encuentra en 00000001b y queremos acceder al pixel de la derecha.
</li>
</ul>

<p>
 En esos casos se podría utilizar el incremento y decremento de la posición de HL:
</p>
<pre class="code z80"><span class="co1">; HL = Direccion de pantalla base</span>
<span class="co1">; A = Mascara de pixeles</span>
&nbsp;
Pixel_Izquierda_HL_Mask:
  <span class="kw1">RLC</span> <span class="kw2">A</span>            <span class="co1">; Rotamos A a la izquierda</span>
  <span class="kw1">RET</span> NC           <span class="co1">; Si no se activa el carry flag, volvemos</span>
  <span class="kw1">DEC</span> <span class="kw2">L</span>            <span class="co1">; Si se activa, hemos pasado de 10000000b</span>
  <span class="kw1">RET</span>              <span class="co1">; a 00000001b y ya podemos alterar HL</span>
&nbsp;
Pixel_Derecha_HL_Mask:
  <span class="kw1">RRC</span> <span class="kw2">A</span>            <span class="co1">; Rotamos A a la derecha</span>
  <span class="kw1">RET</span> NC           <span class="co1">; Si no se activa el carry flag, volvemos</span>
  <span class="kw1">INC</span> <span class="kw2">L</span>            <span class="co1">; Si se activa, hemos pasado de 00000001b</span>
  <span class="kw1">RET</span>              <span class="co1">; a 10000000b y ya podemos alterar HL</span></pre>

<p>
 Son apenas 4 instrucciones, lo que resulta en un cálculo
significativamente más rápido que volver a llamar a la rutina de
coordenación original.
</p>

<p>
 Nótese cómo en lugar de utilizar <strong>DEC HL</strong> o <strong>INC HL</strong> (6 t-estados), realizamos un <strong>DEC L</strong> o <strong>INC L</strong>
 (4 t-estados), ya que dentro de un mismo scanline de pantalla no hay
posibilidad de, moviendo a derecha o izquierda, variar el valor del byte
 alto de la dirección (siempre y cuando no excedamos los límites de la
pantalla por la izquierda o por la derecha). De esta forma ahorramos 2
valiosos ciclos de reloj en una operación que suele realizarse en el
bucle más interno de las rutinas de impresión de sprites.
</p>

<p>
 Si en lugar de una máscara de pixel tenemos en A la posición relativa (0-7), podemos utilizar el siguiente código:
</p>
<pre class="code z80"><span class="co1">; HL = Direccion de pantalla base</span>
<span class="co1">; A = Posicion relativa del pixel (0=Pixel de la izquierda)</span>
&nbsp;
Pixel_Derecha_HL_Rel:
  <span class="kw1">INC</span> <span class="kw2">A</span>            <span class="co1">; Incrementamos A</span>
  <span class="kw1">AND</span> <span class="nu0">7</span>            <span class="co1">; Si A=8 -&gt; A=0</span>
  <span class="kw1">RET</span> NZ           <span class="co1">; Si no es cero, hemos acabado</span>
  <span class="kw1">INC</span> <span class="kw2">L</span>            <span class="co1">; Si se activa, hemos pasado al byte</span>
  <span class="kw1">RET</span>              <span class="co1">; siguiente -&gt; alterar HL</span>
&nbsp;
Pixel_Izquierda_HL_Rel:
  <span class="kw1">DEC</span> <span class="kw2">A</span>            <span class="co1">; Decrementamos A</span>
  <span class="kw1">RET</span> P            <span class="co1">; Si no hay overflow (A de 0 a 255), fin</span>
  <span class="kw1">AND</span> <span class="nu0">7</span>            <span class="co1">; 11111111b -&gt; 00000111b</span>
  <span class="kw1">DEC</span> <span class="kw2">L</span>            <span class="co1">; Hemos pasado al byte siguiente -&gt;</span>
  <span class="kw1">RET</span>              <span class="co1">; alteramos HL</span></pre>

<p>
 Recordemos que ninguna de estas rutinas contempla los líneas izquierdo y derecho de la pantalla.
</p>

<p>
<br>

<strong>Offset del pixel del scanline de arriba/abajo</strong>
</p>

<p>
 Moverse un scanline arriba o abajo requiere código adicional, como ya
vimos en el apartado de coordenadas de caracteres, para detectar tanto
los cambios de tercios como los cambios de caracteres.
</p>
<div class="table-responsive sectionedit26"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bits = </th><th class="col1"> Dirección VRAM </th><th class="col2"> Bits de Tercio </th><th class="col3"> Bits de scanline </th><th class="col4"> Bits de Carácter-Y </th><th class="col5"> Bits de Columna </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> HL = </td><td class="col1"> 010 </td><td class="col2"> TT </td><td class="col3"> SSS </td><td class="col4"> NNN </td><td class="col5"> CCCCC </td>
	</tr>
</tbody></table></div>

<p>
 Primero debemos detectar si estamos en el último scanline del carácter,
 ya que avanzar 1 scanline implicaría poner SSS a 000 e incrementar NNN
(carácter dentro del tercio). Al incrementar NNN (carácter dentro del
tercio) tenemos que verificar también si NNN pasa de 111 a 1000 lo que
supone un cambio de tercio:
</p>

<p>
 El código para incrementar HL hacia el siguiente scanline horizontal
detectando los saltos de tercio y de carácter sería el siguiente:
</p>
<pre class="code z80"><span class="co1">; Avanzamos HL 1 scanline:</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>                       <span class="co1">; Incrementamos HL en 256 (siguiente scanline)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                     <span class="co1">; Cargamos H en A</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>                       <span class="co1">; Si despues del INC H los 3 bits son 0,</span>
                               <span class="co1">; es porque era 111b y ahora 1000b.</span>
   <span class="kw1">JR</span> NZ, nofix_abajop         <span class="co1">; Si no es cero, hemos acabado (solo INC H).</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>                     <span class="co1">; Es cero, hemos pasado del scanline 7 de un</span>
                               <span class="co1">; caracter al 0 del siguiente: ajustar NNN</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>                   <span class="co1">; Ajustamos NNN (caracter dentro de tercio += 1)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                     <span class="co1">; Ahora hacemos la comprobacion de salto de tercio</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, nofix_abajop          <span class="co1">; Si esta suma produce acarreo, habria que ajustar</span>
                               <span class="co1">; tercio, pero ya lo hizo el INC H (111b -&gt; 1000b)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                     <span class="co1">; Si no produce acarreo, no hay que ajustar</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>                       <span class="co1">; tercio, por lo que restamos el bit TT que sumo</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>                     <span class="co1">; el INC H inicial.</span>
&nbsp;
nofix_abajop:
   <span class="co1">; HL contiene ahora la direccion del siguiente scanline</span>
   <span class="co1">; ya sea del mismo caracter o el scanline 0 del siguiente.</span></pre>

<p>
 Y para retroceder HL en 1 scanline, usando la misma técnica:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>                       <span class="co1">; Comprobamos scanline</span>
   <span class="kw1">JR</span> Z, Anterior_SL_DEC       <span class="co1">; Si es cero, hay salto de caracter</span>
   <span class="kw1">DEC</span> <span class="kw2">H</span>                       <span class="co1">; No es cero, basta HL = HL - 256</span>
   <span class="kw1">RET</span>                         <span class="co1">; Hemos acabado (solo INC H).</span>
Anterior_SL_DEC:               <span class="co1">; Hay que ir de caracter 000b a 111b</span>
   <span class="kw1">DEC</span> <span class="kw2">H</span>                       <span class="co1">; Decrementamos H</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>                     <span class="co1">; Ajustamos NNN (caracter en tercio -=1)</span>
   <span class="kw1">SUB</span> <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span> <span class="kw2">C</span>                       <span class="co1">; Si se produjo carry, no hay que ajustar</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                     <span class="co1">; Se produjo carry, ajustamos el tercio</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">8</span>                    <span class="co1">; por el DEC H inicial.</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span></pre>

<p>
 Veamos este mismo código en forma de subrutina, aprovechando con RET la
 posibilidad de evitar los saltos hacia el final de las rutinas:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Siguiente_Scanline_HL:</span>
<span class="co1">; Obtener la direccion de memoria del siguiente scanline dada</span>
<span class="co1">; en HL la direccion del scanline actual, teniendo en cuenta</span>
<span class="co1">; saltos de caracter y de tercio.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   HL = Direccion del scanline actual</span>
<span class="co1">; Salida:    HL = Direccion del siguiente scanline</span>
<span class="co1">;-------------------------------------------------------------</span>
Siguiente_Scanline_HL:
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RET</span> NZ
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span> <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span>             <span class="co1">; Devolvemos en HL el valor ajustado</span></pre>

<p>
 La rutina para retroceder al scanline superior es de similar factura,
con una pequeña reorganización del código para evitar el salto con JR:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Anterior_Scanline_HL:</span>
<span class="co1">; Obtener la direccion de memoria del anterior scanline dada</span>
<span class="co1">; en HL la direccion del scanline actual, teniendo en cuenta</span>
<span class="co1">; saltos de caracter y de tercio.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   HL = Direccion del scanline actual</span>
<span class="co1">; Salida:    HL = Direccion del anterior scanline</span>
<span class="co1">;-------------------------------------------------------------</span>
Anterior_Scanline_HL:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">DEC</span> <span class="kw2">H</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RET</span> NZ
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">SUB</span> <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span> NC
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span>             <span class="co1">; Devolvemos en HL el valor ajustado</span></pre>

<p>
 Siguiente_Scanline_HL será especialmente útil en el desarrollo de
rutinas de impresión de Sprites, aunque lo normal es que incluyamos el
código “inline” dentro de dichas rutinas, para ahorrar los ciclos de
reloj usandos en un CALL+RET.
</p>

<p>
<br>
<br>

</p>

</div>

<h2 id="otras-rutinas">Otras rutinas</h2>
<div class="level2">

<p>
<br>

</p>

</div>

<h3 class="sectionedit28" id="rutinas-cruzadas-y-de-proposito-general">Rutinas cruzadas y de propósito general</h3>
<div class="level3">

<p>
 En el libro “<em>Lenguaje Máquina Avanzado para ZX Spectrum</em>” de <em>David Webb</em>
 encontramos 3 rutinas útiles de propósito general para obtener el
offset en el área de imagen dada una dirección de atributo o viceversa.
</p>

<p>
 La primera subrutina obtiene la dirección del atributo que corresponde a una dirección de pantalla especificada:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Attr_Offset_From_Image (DF-ATT):</span>
<span class="co1">;</span>
<span class="co1">; Entrada:  HL = Direccion de memoria de imagen.</span>
<span class="co1">; Salida:   DE = Direccion de atributo correspondiente a HL.</span>
<span class="co1">;-------------------------------------------------------------</span>
Attr_Offset_From_Image:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">L</span>
   <span class="kw1">RET</span></pre>

<p>
 La segunda realiza el proceso inverso: obtiene la dirección del archivo
 de imagen dada una dirección de atributo. Esta dirección se corresponde
 con la dirección de los 8 píxeles del primer scanline del carácter.
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Image_Offset_From_Attr (ATT_DF):</span>
<span class="co1">;</span>
<span class="co1">; Entrada:  HL = Direccion de memoria de atributo.</span>
<span class="co1">; Salida:   DE = Direccion de imagen correspondiente a HL.</span>
<span class="co1">;-------------------------------------------------------------</span>
Image_Offset_From_Attr:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">L</span>
   <span class="kw1">RET</span></pre>

<p>
 La tercera es una combinación de localización de offset de imagen, de atributo, y el valor del atributo:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Get_Char_Data(c,f) (LOCATE):</span>
<span class="co1">;</span>
<span class="co1">; Entrada:  B = FILA, C = COLUMNA</span>
<span class="co1">; Salida:   DE = Direccion de atributo.</span>
<span class="co1">;           HL = Direccion de imagen.</span>
<span class="co1">;           A = Atributo de (C,F)</span>
<span class="co1">;-------------------------------------------------------------</span>
Get_Char_Data:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">SET</span> <span class="nu0">6</span>, <span class="kw2">H</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>
   <span class="kw1">RET</span></pre>

<p>
 Llamando a la anterior rutina con unas coordenadas (c,f) en C y B
obtenemos la dirección de memoria de imagen (HL) y de atributo (DE) de
dicho carácter, así como el valor del atributo en sí mismo (A).
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/gfx2_pixeladd.asm">Ejemplo de uso de PIXEL-ADD (ROM)</a>
</li>
<li><a href="src/gfx2_pixeladd.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx2_lut.asm">Ejemplo de uso de Look Up Tables</a>
</li>
<li><a href="src/gfx2_lut.tap">Tap del ejemplo anterior</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/zx_display.pdf">ZX Display File Organization</a>, por Alvin Albrecht.
</li>
<li><div class="li"> <a href="https://wiki.speccy.org/programacion/ensamblador/calculo-coordenadas" title="programacion:ensamblador:calculo-coordenadas"> Cálculo de direcciones de pantalla a partir de coordenadas</a> (por Metalbrain).</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a>.</div>
</li>
<li><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/z80time.txt" class="urlextern" title="external/www.ticalc.org/pub/text/z80/z80time.txt">Tiempos de ejecución y tamaños</a> de las instrucciones del Z80 (ver z80time.txt).</div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a>.</div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a>.</div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a>.</div>
</li>
</ul>

<p>
<br>

</p>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="graficos-y-iiisprites-y-graficos-en-baja-resolucion-bloques">Gráficos (y III): Sprites y Gráficos en baja resolución (bloques)</h1>
<div class="level1">

<p>
 En este capítulo crearemos rutinas específica de impresión de sprites
de 8×8 píxeles en posiciones exáctas de carácter (gráficos de bloques) y
 la extenderemos a la impresión de sprites de 16×16 píxeles (2×2
bloques). Además de estas rutinas de tamaños específicos, analizaremos
una rutina más genérica que permita imprimir sprites de tamaños
múltiples del anterior (16×16, 24×16, etc).
</p>

<p>
 El capítulo hará uso intensivo de los algoritmos de cálculo de
direcciones de memoria a partir de coordenadas y del movimiento relativo
 descritos en 2 anteriores capítulos, aunque las rutinas mostradas a
continuación podrían ser directamente utilizadas incluso sin
conocimientos sobre la organización de la videomemoria del Spectrum.
</p>

<p>
 Estudiaremos también los métodos de impresión sobre pantalla:
transferencia directa, operaciones lógicas y uso de máscaras, y la
generación de los datos gráficos y de atributos a partir de la imagen
formada en un editor de sprites.
</p>

<p>
<br>

</p>

</div>

<h2 id="teoria-sobre-el-trazado-de-sprites">Teoría sobre el trazado de sprites</h2>
<div class="level2">

<p>
 Comencemos con las definiciones básicas de la terminología que se usará en este capítulo.
</p>

<p>
<br>

 <strong>Sprite</strong>: Se utiliza el término anglosajón <em>sprite</em>
 (traducido del inglés: “duendecillo”) para designar en un juego o
programa a cualquier gráfico que tenga movimiento. En el caso del
Spectrum, que no tiene como otros sistemas hardware dedicado a la
impresión de Sprites, aplicamos el término a cualquier <strong>mapa de bits</strong> (del inglés <em>bitmap</em>)
 que podamos utilizar en nuestros programas: el gráfico del personaje
protagonista, los de los enemigos, los gráficos de cualquier item o
incluso las propias fuentes de texto de los marcadores.
</p>

<p>
<br>

<img src="img/gfx3_sprite.png" class="mediacenter" alt=" Sprite de Spectrum, 16x16 "/>
<br>

</p>

<p>
<br>

 <strong>Editor de Sprites</strong>: Los sprites se diseñan en editores
de sprites, que son aplicaciones diseñadas para crear Sprites teniendo
en cuenta la máquina destino para la que se crean. Por ejemplo, un
editor de Sprites para Spectrum tomará en cuenta, a la hora de aplicar
colores, el sistema de tinta/papel en bloques de 8×8 píxeles y no nos
permitirá dibujar colores saltándonos dicha limitación que después
existirá de forma efectiva en el hardware destino.
</p>

<p>
<br>

<img src="img/gfx3_sevenup.png" class="mediacenter" alt=" Editor de Sprites SevenuP "/>
<br>

</p>

<p>
 Estos programas gráficos tratan los sprites como pequeños rectángulos
(con o sin zonas transparentes en ellos) del ancho y alto deseado y se
convierten en mapas de bits (una matriz de píxeles activos o no activos
agrupados) que se almacenan en los programas como simples ristras de
bytes, preparados para ser volcados en la pantalla con <em>rutinas de impresión de sprites</em>.
</p>

<p>
<br>

<img src="img/gfx3_sprite_bitmap.png" class="mediacenter" alt=" Sprite de Spectrum convertido a bitmap y a ristra de bits "/>
</p>
<div style="text-align: center;"><em>Sprite en editor de sprites, su bitmap, y su conversión a datos binarios.</em>
</div>
<p>
<br>

</p>

<p>
<br>

 <strong>Rutinas de impresión de Sprites</strong>: son rutinas que
reciben como parámetro la dirección en memoria del Sprite y sus
Atributos y las coordenadas (x,y) destino, y vuelcan esta información
gráfica en la pantalla.
</p>

<p>
<br>

 <strong>Sprite Set</strong>: Normalmente todos los Sprites de un juego se agrupan en un “<strong>sprite set</strong>” (o “<strong>tile set</strong>”),
 que es una imagen rectangular o un array lineal que almacena todos los
datos gráficos del juego de forma que la rutina de impresión de Sprites
pueda volcar uno de ellos mediante unas coordenadas origen y un ancho y
alto (caso del tileset rectangular) o mediante un identificador dentro
del array de sprites (caso del tileset lineal).
</p>

<p>
 El sistema de sprites en formato rectangular suele ser utilizado en
sistemas más potentes que el Spectrum, permitiendo además sprites de
diferentes tamaños en el mismo tileset. Las rutinas que imprimen estos
sprites a lo largo del juego requieren como parámetros, además de la
posición (x,y) de destino, una posición (x,y) de origen y un ancho y
alto para “extraer” cada sprite de su “pantalla origen” y volcarlo a la
pantalla destino.
</p>

<p>
<br>

<img src="img/pacman_simonowen.png" class="mediacenter" alt=" Sprite set de Pacman (coloreado por Simon Owen) "/>
</p>
<div style="text-align: center;"><em>Sprite set de Pacman -© NAMCO- coloreado por Simon Owen<br>
para la versión SAM. Gráficos en formato rectangular.<br>
Las rutinas de impresión requieren<br>
coordenadas (xorg,yorg).</em>
</div>
<p>
<br>

</p>

<p>
 En el caso del Spectrum, nos interesa mucho más el sistema de
almacenamiento lineal dentro de un “vector” de datos, ya que normalmente
 agruparemos todos los sprites de un mismo tamaño en un mismo array.
Podremos disponer de diferentes arrays para elementos de diferentes
tamaños. Cuando queramos hacer referencia a uno de los sprites de dicho
array, lo haremos con un identificador numérico (0-N) que indicará el
número de sprite que queremos dibujar comenzando desde arriba y
designando al primero como 0.
</p>

<p>
<br>

<img src="img/gfx3_tilesetsk.png" class="mediacenter" alt=" Sprite set de Sokoban "/>
</p>
<div style="text-align: center;"><em>Parte del sprite set de Sokoban: gráficos en formato<br>
lineal vertical. Las rutinas de impresión<br>
requieren un identificador de sprite (0-NumSprites).</em>
</div>
<p>
<br>

</p>

<p>
 En un juego donde todos los sprites son de 16×16 y los fondos están
formados por sprites o tiles de 8×8, se podría tener un “array” para los
 sprites, otro para los fondos, y otro para las fuentes de texto.
Durante el desarrollo del bucle del programa llamaremos a la rutina de
impresión de sprites pasando como parámetro el array de sprites, el
ancho y alto del sprite, y el identificador del sprite que queremos
dibujar.
</p>

<p>
<br>

 <strong>Frame</strong> (fotograma): El “sprite set” no sólo suele
alojar los diferentes gráficos de cada personaje o enemigo de un juego,
sino que además se suelen alojar todos los <em>frames</em> (fotogramas) de animación de cada personaje. En sistemas más modernos se suele tener un <em>frameset</em>
 (un array de frames) por cada personaje, y cada objeto del juego tiene
asociado su frameset y su estado actual de animación y es capaz de
dibujar el frame que le corresponde.<br>
En el Spectrum, por limitaciones de memoria y código, lo normal es tener
 todo en un mismo spriteset, y tener almacenados los identificadores de
animación de un personaje en lugar de su frameset. Así, sabremos que
nuestro personaje andando hacia la derecha tiene una animación que
consta de los frames (por ejemplo) 10, 11 y 12 dentro del spriteset.
</p>

<p>
<br>

 <strong>Tiles</strong>: Algunos bitmaps, en lugar de ser llamados “sprites”, reciben el nombre de <em>tiles</em>
 (“bloques”). Normalmente esto sucede con bitmaps que no van a tener
movimiento, que se dibujan en posiciones exáctas de carácter, y/o que no
 tienen transparencia. Un ejemplo de tiles son los “bloques” que forman
los escenarios y fondos de las pantallas cuando son utilizados para
componer un mapa de juego en base a la repetición de los mismos. Los
tiles pueden ser impresos con las mismas rutinas de impresión de Sprites
 (puesto que son bitmaps), aunque normalmente se diseñan rutinas
específicas para trazar este tipo de bitmaps aprovechando sus
características (no móviles, posición de carácter, no transparencia),
con lo que dichas rutinas se pueden optimizar. Como veremos en el
próximo capítulo, los tiles se utilizan normalmente para componer el
área de juego mediante un <strong>tilemap</strong> (mapa de tiles):
</p>

<p>
<br>

<img src="img/gfx3_tilemap.png" class="mediacenter" alt=" Tilemaps "/>
</p>
<div style="text-align: center;"><em>Tilemap: componiendo un mapa en pantalla<br>
a partir de tiles de un tileset/spriteset + mapa.</em>
</div>
<p>
<br>

</p>

<p>
<br>

 <strong>Máscaras de Sprites</strong>: Finalmente, cabe hablar de las <em>máscaras de sprites</em>,
 que son bitmaps que contienen un contorno del sprite de forma que se
define qué parte del Sprite original debe sobreescribir el fondo y qué
parte del mismo debe de ser transparente.
</p>

<p>
<br>

<img src="img/gfx3_masks.png" class="mediacenter" alt=" Sprite, Máscara y aplicación sobre el fondo "/>
</p>
<div style="text-align: center;"><em>Un Sprite y su máscara aplicados sobre el fondo.</em>
</div>
<p>
<br>

</p>

<p>
 Las máscaras son necesarias para saber qué partes del sprite son
transparentes: sin ellas habría que testear el estado de cada bit para
saber si hay que “dibujar” ese pixel del sprite o no. Gracias a la
máscara, basta un AND entre la máscara y el fondo y un OR del sprite
para dibujar de una sóla vez 8 píxeles sin realizar testeos individuales
 de bits.
</p>

<p>
<br>

</p>

</div>

<h2 id="diseno-de-una-rutina-de-impresion-de-sprites">Diseño de una rutina de impresión de sprites</h2>
<div class="level2">

<p>
 En microordenadores como el Spectrum existe un vínculo especial entre
los “programadores” y los “diseñadores gráficos”, ya que estos últimos
deben diseñar los sprites teniendo en cuenta las limitaciones del
Spectrum y a veces hacerlo tal y como los programadores los necesitan
para su rutina de impresión de Sprites o para salvar las limitaciones de
 color del Spectrum o evitar colisiones de atributos entre personajes y
fondos.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit4" id="el-diseno-grafico-del-sprite">El diseño gráfico del Sprite</h3>
<div class="level3">

<p>
 El diseñador gráfico y el programador deben decidir el tamaño y características de los Sprites y  el “<strong>formato para el sprite origen</strong>” a la hora de exportar los bitmaps como “datos binarios” para su volcado en pantalla.
</p>

<p>
 A la hora de crear una rutina de impresión de sprites tenemos que tener
 en cuenta el formato del Sprite de Origen. Casi se podría decir que más
 bien, la rutina de impresión de sprites debemos escribirla o adaptarla
al formato de sprites que vayamos a utilizar en el juego.
</p>

<p>
 Dicho formato puede ser:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Sprite con atributos de color (multicolor) o sin atributos de color (monocolor).
</li>
<li class="level1 node"> Si el sprite tiene atributos de color, los atributos pueden ir:
<ul class="fix-media-list-overlap">
<li class="level2"> En un array de atributos aparte del array de datos gráficos.
</li>
<li class="level2"><div class="li"> En el mismo array de datos gráficos, pero detrás del último de los sprites (linealmente, igual que los sprites), como: <em>sprite0,sprite1,atributos0,atributos1</em>.</div>
</li>
<li class="level2"><div class="li"> En el mismo array de datos gráficos, pero el atributo de un sprite va detrás de dicho sprite en el vector, intercalado: <em>sprite0,atributos0,sprite1,atributos1</em>.</div>
</li>
</ul>
</li>
<li class="level1 node"> Sprite que altere o no altere el fondo:
<ul class="fix-media-list-overlap">
<li class="level2"> Si no debe alterarlo, se tiene que
decidir si será mediante impresión por operación lógica o si será
mediante máscaras (y dibujar y almacenar estas).
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>

<p>
 Además, hay que tener las herramientas para el dibujado y la conversión
 de los bitmaps o spritesets en código, en el formato que hayamos
decidido. Más adelante en el capítulo profundizaremos en ambos temas: la
 organización en memoria del Sprite (o del Spriteset completo) y las
herramientas de dibujo y conversión.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit5" id="la-creacion-de-la-rutina-de-impresion">La creación de la rutina de impresión</h3>
<div class="level3">

<p>
 Dadas las limitaciones en velocidad de nuestro querido procesador Z80A,
 el realizar una rutina de impresión de sprites en alta resolución
rápida es una tarea de complejidad media/alta que puede marcar la
diferencia entre un juego bueno y un juego malo, especialmente conforme
aumenta el número de sprites en pantalla y por tanto, el parpadeo de los
 mismos si la rutina no es suficientemente buena.
</p>

<p>
 La complejidad de las rutinas que veremos concretamente en este
capítulo será de un nivel más asequible puesto que vamos a trabajar con
posiciones de carácter en baja resolución y además crearemos varias
rutinas específicas y una genérica.
</p>

<p>
 Para crear estas rutinas necesitamos conocer la teoría relacionada con:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> El cálculo de posición en memoria de las coordenadas (c,f) en las que vamos a dibujar el Sprite.
</li>
<li> El dibujado de cada scanline del sprite en pantalla, ya sea con LD/LDIR o con operaciones lógicas tipo OR/XOR.
</li>
<li> El avance a través del sprite para acceder a otros scanlines del mismo.
</li>
<li> El avance diferencial en pantalla
para movernos hacia la derecha (por cada bloque de anchura del sprite), y
 hacia abajo (por cada scanline de cada bloque y por cada bloque de
altura del sprite).
</li>
<li> El cálculo de posición en memoria de atributos del bloque (0,0) del sprite.
</li>
<li> El avance diferencial en la zona de atributos para imprimir los atributos de los sprites de más de 1×1 bloques.
</li>
</ul>

<p>
<br>

</p>

<p>
 Gracias a los 2 últimos capítulos del curso y a nuestros conocimientos
en ensamblador, ya tenemos los mecanismos para dar forma a la rutina
completa.
</p>

<p>
 Diseñaremos rutinas de impresión de sprites en baja resolución de 1×1
bloques (8×8 píxeles), 2×2 bloques (16×16 píxeles) y NxM bloques. Las 2
primeras rutinas, específicas para un tamaño concreto, serán más óptimas
 y eficientes que la última, que tendrá que adecuarse a cualquier tamaño
 de sprite y por lo tanto no podrá realizar optimizaciones basadas en el
 conocimiento previo de ciertos datos.
</p>

<p>
 Por ejemplo, cuando sea necesario multiplicar algún registro por el
valor del ancho del sprite, en el caso de la rutina de 1×1 no será
necesario multiplicar y en el caso de la rutina de 2×2 podremos hacer
uso de 1 desplazamiento a izquierda, pero la rutina de propósito general
 tendrá que realizar la multiplicación por medio de un bucle de sumas.
Así, imprimir un sprite de 2×2 con su rutina específica será mucho más
rápido que imprimir el mismo sprite con la genérica.
</p>

<p>
 Aunque trataremos de optimizar las rutinas en la medida de lo posible,
se va a intentar no realizar optimizaciones que hagan la rutina ilegible
 para el lector. Las rutinas genéricas que veremos hoy serán rápidas
pero siempre podrán optimizarse más mediante trucos y técnicas al
alcance de los programadores con más experiencia. Es labor del
programador avanzado el adaptar estas rutinas a cada juego para
optimizarlas al máximo en la medida de lo posible.
</p>

<p>
 En este sentido, en alguna de las rutinas utilizaremos variables en
memoria para alojar datos de entrada o datos temporales o intermedios.
Aunque acceder a la memoria es “lenta” comparada con tener los datos
guardados en registros, cuando comenzamos a manejar muchos parámetros de
 entrada (y de trabajo) en una rutina y además hay que realizar cálculos
 con ellos, es habitual que agotemos los registros disponibles, más
todavía teniendo en cuenta la necesidad de realizar dichos cálculos. En
muchas ocasiones se acaba realizando uso de la pila con continuos PUSHes
 y POPs destinados a guardar valores y recuperarlos posteriormente a
realizar los cálculos o en ciertos puntos de la rutina.
</p>

<p>
 Las instrucciones <strong>PUSH</strong> y <strong>POP</strong> toman 11 y 10 t-estados respectivamente, mientras que escribir o leer un valor de 8 bits en memoria (<strong>LD (NN), A</strong> y <strong>LD A, (NN)</strong>) requiere 13 t-estados y escribir o leer un valor de 16 bits toma 20 t-estados (<strong>LD (NN), rr</strong> y <strong>LD rr, (NN)</strong>) con la excepción de <strong>LD (NN), HL</strong> que cuesta 16 t-estados.
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit6"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Instrucción </th><th class="col1"> Tiempo en t-estados </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> PUSH rr </td><td class="col1"> 11 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> PUSH IX o PUSH IY </td><td class="col1"> 16 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> POP rr </td><td class="col1"> 10 </td>
	</tr>
	<tr class="row4">
		<td class="col0"> POP IX o POP IY </td><td class="col1"> 14 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> LD (NN), A </td><td class="col1"> 13 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> LD A, (NN) </td><td class="col1"> 13 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> LD rr, (NN) </td><td class="col1"> 20 </td>
	</tr>
	<tr class="row8">
		<td class="col0"> LD (NN), rr </td><td class="col1"> 20 </td>
	</tr>
	<tr class="row9">
		<td class="col0"> LD (NN), HL </td><td class="col1"> 16 </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Aunque es una diferencia apreciable, no siempre podemos obtener una
“linealidad” de uso de la pila que requiera 1 POP por cada PUSH, por lo
que en ocasiones se hace realmente cómodo y útil el aprovechar variables
 de memoria para diseñar las rutinas.
</p>

<p>
 En nuestro caso utilizaremos algunas variables de memoria para
facilitar la lectura de las rutinas: serán más sencillas de seguir y más
 intuitivas a costa de algunos ciclos de reloj. No deja de ser cierto
también que los programadores en ocasiones nos obsesionamos por utilizar
 sólo registros y acabamos realizando combinaciones de intercambios de
valores en registros y PUSHes/POPs que acaban teniendo más coste que la
utilización de variables de memoria.
</p>

<p>
 El programador profesional tendrá que adaptar cada rutina a cada caso
específico de su programa y en este proceso de optimización podrá (o no)
 sustituir dichas variables de memoria por combinaciones de código que
eviten su uso, aunque no siempre es posible dado el reducido juego de
registros del Z80A.
</p>

<p>
 Finalmente, recordar que las rutinas que veremos en este capítulo
pueden ser ubicadas en memoria y llamadas desde BASIC. Una vez
ensambladas y POKEadas en memoria, podemos hacer uso de ellas utilizando
 POKE para establecer los parámetros de llamada y RANDOMIZE USR
DIR_RUTINA para ejecutarlas. A lo largo de la vida de revistas como
Microhobby se publicaron varios paquetes de rutinas de gestión de
Sprites en ensamblador que utilizan este método y que estaban pensadas
para ser utilizadas tanto desde código máquina como desde BASIC.
</p>

<p>
<br>

</p>

</div>

<h2 id="organizacion-de-los-sprites-en-memoria">Organización de los sprites en memoria</h2>
<div class="level2">

<p>
 Como ya hemos visto, una vez diseñados los diferentes sprites de
nuestro juego hay que agruparlos en un formato que después, convertidos a
 datos binarios, pueda interpretar nuestra rutina de impresión.
</p>

<p>
 Hay 4 decisiones principales que tomar al respecto:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Formato de organización del tileset (lineal o en forma de matriz/imagen).
</li>
<li> Formato de almacenamiento de cada tile (por bloques, por scanlines).
</li>
<li> Formato de almacenamiento de los atributos (después de los sprites, intercalados con ellos).
</li>
<li> Formato de almacenamiento de las máscaras de los sprites si las hubiera.
</li>
</ul>

<p>
<br>

</p>

<p>
 El <strong>formato de organización del tileset</strong> no debería
requerir mucho tiempo de decisión: la organización del tileset en
formato lineal es mucho más eficiente para las rutinas de impresión de
sprites que el almacenamiento en una “imagen” rectangular. Teniendo
todos los sprites (o tiles) en un único vector, podemos hacer referencia
 a cualquier bloque, tile, sprite o cuadro de animación mediante un
identificador numérico.
</p>

<p>
 De esta forma, el “bloque 0” puede ser un bloque vacío, el bloque “1”
el primer fotograma de animación de nuestro personaje, etc.
</p>

<p>
 Donde sí debemos tomar decisiones importantes directamente relacionadas
 con el diseño de la rutina de impresión de Sprites es en la
organización en memoria de los datos gráficos del sprite y sus atributos
 (y la máscara si la hubiera). El <strong>formato de almacenamiento</strong> de los <strong>tiles</strong>, los <strong>atributos</strong> y los datos de <strong>máscara</strong> definen la exportación de los datos desde el editor de Sprites y cómo debe de trabajar la rutina de impresión.
</p>

<p>
 Veamos con un ejemplo práctico las distintas opciones de que
disponemos. Para ello vamos a definir un ejemplo basado en 2 sprites de
16×8 pixeles (2 bloques de ancho y 1 de alto, para simplificar).
Marcaremos cada scanline de cada bloque con una letra que representa el
valor de 8 bits con el estado de los 8 píxeles, de forma que podamos
estudiar las posibilidades existentes.
</p>

<p>
 Así, los 16 píxeles de la línea superior del sprite (2 bytes), los
vamos a identificar como “A1” y “B1”. Los siguientes 16 píxeles
(scanline 2 del sprite y de cada uno de los 2 bloques), serán los bytes
“C1” y “D1”, y así sucesivamente.
</p>
<pre class="code">Datos gráficos Sprite 1:
| A1 | B1 |
| C1 | D1 |
| E1 | F1 |
| G1 | H1 |
| I1 | J1 |
| K1 | L1 |
| M1 | N1 |
| O1 | P1 |

Atributos Sprite 1:
| S1_Attr1 | S1_Attr2 |</pre>

<p>
 Y:
</p>
<pre class="code">Datos gráficos Sprite 2:
| A2 | B2 |
| C2 | D2 |
| E2 | F2 |
| G2 | H2 |
| I2 | J2 |
| K2 | L2 |
| M2 | N2 |
| O2 | P2 |

Atributos Sprite 1:
| S2_Attr1 | S2_Attr2 |</pre>

<p>
 Al organizar los datos gráficos y de atributos en disco, podemos hacerlo de 2 formas:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Utilizando 2 arrays</strong>:
 uno con los datos gráficos y otro con los atributos, organizando la
información horizontal por scanlines del sprite. Todos los datos
gráficos o de atributo de un mismo sprite son consecutivos en memoria y
el “salto” se hace al acabar cada scanline completo del sprite (no de
cada bloque). La rutina de impresión recibe como parámetro la dirección
de inicio de ambas tablas y traza primero los gráficos y después los
atributos.</div>
</li>
</ul>
<pre class="code">Tabla_Sprites:
  DB A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1
  DB L1, M1, N1, O1, P1, A2, B2, C2, D2, E2, F2
  DB G2, H2, I2, J2, K2, L2, M2, N2, O2, P2

Tabla_Atributos:
  DB S1_Attr1, S1_Attr2, S2_Attr1, S2_Attr2</pre>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Utilizando un único array</strong>:
 Se intercalan los atributos dentro del array de gráficos, detrás de
cada Sprite. La rutina de impresión calculará en el array el inicio del
sprite a dibujar y encontrará todos los datos gráficos de dicho sprite
seguidos a partir de este punto. Al acabar de trazar los datos gráficos,
 nos encontramos directamente en el vector con los datos de atributo del
 sprite que estamos tratando.</div>
</li>
</ul>
<pre class="code">Tabla_Sprites:
  DB A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1
  DB L1, M1, N1, O1, P1, S1_Attr1, S1_Attr2, A2
  DB B2, C2, D2, E2, F2, G2, H2, I2, J2, K2, L2
  DB M2, N2, O2, P2, S2_Attr1, S2_Attr2</pre>

<p>
 Finalmente, no debemos olvidarnos de que si utilizamos máscaras de
sprite también deberemos incluirlas en nuestro “array de datos” (o
sprite set). El dónde ubicar cada scanline de la máscara depende, de
nuevo, de nuestra rutina de impresión. Una primera aproximación sería
ubicar cada byte de máscara antes o después de cada dato del sprite,
para que podamos realizar las pertinentes operaciones lógicas entre la
máscara, el fondo y el sprite.
</p>

<p>
 Si denominamos “XX” a los datos de la máscara del sprite 1 y “YY” a los
 datos de máscara del sprite 2, nuestra tabla de datos en memoria
quedaría de la siguiente forma:
</p>
<pre class="code">; Formato: Una única tabla:
Tabla_Sprites:
  DB XX, A1, XX, B1, XX, C1, XX, D1, XX, E1, XX, F1, XX, G1
  DB XX, H1, XX, I1, XX, J1, XX, K1, XX, L1, XX, M1, XX, N1
  DB XX, O1, XX, P1, S1_Attr1, S1_Attr2
  DB YY, A2, YY, B2, YY, C2, YY, D2, YY, E2, YY, F2, YY, G2
  DB YY, H2, YY, I2, YY, J2, YY, K2, YY, L2, YY, M2, YY, N2
  DB YY, O2, YY, P2, S2_Attr1, S2_Attr2

; Formato: Dos tablas:
Tabla_Sprites:
  DB XX, A1, XX, B1, XX, C1, XX, D1, XX, E1, XX, F1, XX, G1
  DB XX, H1, XX, I1, XX, J1, XX, K1, XX, L1, XX, M1, XX, N1
  DB XX, O1, XX, P1, YY, A2, YY, B2, YY, C2, YY, D2, YY, E2
  DB YY, F2, YY, G2, YY, H2, YY, I2, YY, J2, YY, K2, YY, L2
  DB YY, M2, YY, N2, YY, O2, YY, P2

Tabla_Atributos:
  DB S1_Attr1, S1_Attr2, S2_Attr1, S2_Attr2</pre>

<p>
<br>

</p>

<p>
 Para las rutinas que crearemos como ejemplo utilizaremos el <strong>formato lineal horizontal mediante 2 tablas</strong>,
 una con los gráficos y otra con los atributos de dichos gráficos. En
las rutinas con máscara, intercalaremos los datos de máscara antes de
cada dato del sprite, como acabamos de ver. Es el formato más sencillo
para la generación de los gráficos y para los cálculos en las rutinas, y
 por tanto el elegido para mostrar rutinas comprensibles por el lector.
</p>

<p>
 Sería posible también almacenar la información del sprite por columnas
(formato lineal vertical), lo cual requeriría rutinas diferentes de las
que vamos a ver en este capítulo.
</p>

<p>
 A continuación hablaremos sobre el editor de Sprites SevenuP y veremos
de una forma gráfica el formato de organización lineal-horizontal de
datos en memoria, y cómo un gráfico de ejemplo se traduce de forma
efectiva en un array de datos con el formato deseado.
</p>

<p>
<br>

</p>

</div>

<h2 id="conversion-de-datos-graficos-a-codigos-dibujables">Conversion de datos graficos a códigos dibujables</h2>
<div class="level2">

<p>
 Para diseñar los sprites de nuestro juego necesitaremos utilizar un
editor de Sprites. Existen editores de sprites nativos en el Spectrum,
pero esa opción nos podría resultar realmente incómoda por usabilidad y
gestión de los datos (se tendría que trabajar en un emulador o la
máquina real y los datos sólo se podrían exportar a cinta o a TAP/TZX).
</p>

<p>
 Lo ideal es utilizar un Editor de Sprites nativo de nuestra plataforma
cruzada de desarrollo que permita el dibujado en un entorno cómodo y la
exportación de los datos a código “.asm” (ristras de DBs) que incluir
directamente en nuestro ensamblador.
</p>

<p>
 Nuestra elección principal para esta tarea es <strong>SevenuP</strong>, de <em>metalbrain</em>.
 Nos decantamos por SevenuP por su clara orientación al dibujo “al
pixel” y sus opciones para el programador, especialmente el sistema de
exportación de datos a C y ASM y la gestión de máscaras y frames de
animación. Además, SevenuP funciona bajo múltiples Sistemas Operativos,
siendo la versión para Microsoft Windows emulable también en
implementaciones como WINE de GNU/Linux.
</p>

<p>
 Para el propósito de este capítulo (y, en general durante el proceso de
 creación de un juego), dibujaremos en SevenuP nuestro spriteset con los
 sprites distribuídos verticalmente (cada sprite debajo del anterior).
Crearemos un nuevo “sprite” con <em>File → New</em> e indicaremos el
ancho de nuestro sprite en pixels y un valor para la altura que nos
permita alojar suficientes sprites en nuestro tileset.
</p>

<p>
<br>

<img src="img/gfx3_sevenup_vertical.png" class="mediacenter" alt=" SevenuP "/>
<br>

</p>

<p>
 Por ejemplo, para guardar la información de 10 sprites de 16×16
crearíamos un nuevo sprite de 16×160 píxeles. Si nos vemos en la
necesidad de ampliar el sprite para alojar más sprites podremos “cortar”
 los datos gráficos, crear una imagen nueva con un tamaño superior y
posteriormente pegar los datos gráficos cortados. La documentación de
SevenUp explica cómo copiar y pegar:
</p>
<pre class="code">Modo de Selección 1:
====================

Set Pixel/Reset Pixel
El botón izquierdo pone los pixels a 1.
El botón derecho pone los pixels a 0.
Atajo de teclado: 1


Modo de Selección 2:
====================

Toggle Pixel/Select Zone
El botón izquierdo cambia el valor de los pixels entre 0 y 1.
El botón derecho controla la selección. Para seleccionar una zona,
se hace click-derecho en una esquina, click-derecho en la opuesta y ya
tenemos una porción seleccionada. La zona seleccionada será algo mas
brillante que la no seleccionada y las rejillas (si están presentes)
se verán azules. Ahora los efectos solo afectarán a la zona seleccionada,
y se puede copiar esta zona para pegarla donde sea o para usarla como
patrón en el relleno con textura. Un tercer click-derecho quita la
selección. Atajo de teclado: 2


Copy
Copia la zona seleccionada (o el gráfico completo si no hay zona seleccionada)
a la memoria intermedia para ser pegada (en el mismo gráfico o en otro) o para
ser usada como textura de relleno. Atajo de teclado: CTRL+C.

Paste
Activa/desactiva el modo de pegado, que pega el gráico de la memoria intermedia
a la posición actual del ratón al pulsar el botón izquierdo. Los atributos solo
se pegan si el pixel de destino tiene la misma posición dentro del carácter que
la fuente de la copia. Con el botón derecho se cancela el modo de pegado. Atajo
de teclado: CTRL+V.</pre>

<p>
 Otra opción es trabajar con un fichero .sev por cada sprite del juego,
aprovechando así el soporte para “fotogramas” de SevenuP. No obstante,
suele resultar más cómodo mantener todos los sprites en un único fichero
 con el que trabajar ya que podemos exportar todo con una única
operación y nos evita tener que “mezclar” las múltiples exportaciones de
 cada fichero individual.
</p>

<p>
 Mediante el ratón (estando en modo 1) podemos activar y desactivar
píxeles y cambiar el valor de tinta y papel de cada recuadro del Sprite.
 El menú de máscara nos permite definir la máscara de nuestros sprites,
alternando entre la visualización del sprite y la de la máscara.
</p>

<p>
 El menú de efectos nos permite ciertas operaciones básicas con el
sprite como la inversión, rotación, efecto espejo horizontal o vertical,
 rellenado, etc.
</p>

<p>
 Es importante que guardemos el fichero en formato .SEV pues es el que
nos permitirá realizar modificaciones en los gráficos del programa y una
 re-exportación a ASM si fuera necesario.
</p>

<p>
 Antes de exportar los datos a ASM, debemos definir las opciones de exportación en <em>File → Output Options</em>:
</p>

<p>
<br>

<img src="img/gfx3_opciones_export_su.png" class="mediacenter" alt=" Opciones de exportación de SevenuP"/>
<br>

</p>

<p>
 Este menú permite especificar diferentes opciones de exportación:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Data outputted</strong>:
Permite seleccionar si queremos exportar sólo los gráficos, sólo los
atributos, o los dos, primero gráficos y luego atributos o primero
atributos y luego gráficos.</div>
</li>
<li><div class="li"> <strong>Mask Before Graph</strong>: Si activamos esta opción, cada byte del sprite irá precedido en el array por su byte de máscara correspondiente.</div>
</li>
<li class="level1 node"><div class="li"> <strong>Sort priority</strong>:
 Esta importantísima opción determina el orden de la exportación,
indicando a SevenuP qué orden / prioridad debe de seguir al recorrer el
gráfico para exportar los valores. Las diferentes opciones para
priorizar son:</div>
<ul class="fix-media-list-overlap">
<li class="level2"> X Char: Coordenada X de bloque. Prioriza el recorrer el sprite horizontalmente aunque pasemos a otro bloque del mismo.
</li>
<li class="level2"> Char line: Scanline horizontal de
bloque. Prioriza acabar los datos del bloque actual horizontalmente
antes de pasar al siguiente elemento.
</li>
<li class="level2"> Y Char: Coordenada Y de bloque. Prioriza el recorrer el bloque actual verticalmente antes de bajar al siguiente.
</li>
<li class="level2"> Mask: Prioriza el valor de máscara del byte actual sobre el resto de elementos.
</li>
</ul>
</li>
<li><div class="li"> <strong>Interleave</strong>: Permite definir la forma en que se intercalan gráficos y atributos en el sprite.</div>
</li>
</ul>

<p>
 Veamos las opciones que debemos especificar de forma predeterminada
para exportar los datos de nuestro set de sprites en el formato adecuado
 para las rutinas utilizadas en este capítulo:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li class="level1 node"> Múltiples sprites en formato vertical sin máscara y sin atributos en 1 array:
<ul class="fix-media-list-overlap">
<li class="level2"> Sort Priorities: X char, Char line, Y char
</li>
<li class="level2"> Data Outputted: Gfx
</li>
<li class="level2"> Mask: No
</li>
</ul>
</li>
<li class="level1 node"> Múltiples sprites en formato vertical sin máscara y con atributos en 1 array:
<ul class="fix-media-list-overlap">
<li class="level2"> Sort Priorities: X char, Char line, Y char
</li>
<li class="level2"> Data Outputted: Gfx+Attr
</li>
<li class="level2"> Mask: No
</li>
</ul>
</li>
<li class="level1 node"> Múltiples sprites en formato vertical sin máscara y con atributos en 2 arrays:
<ul class="fix-media-list-overlap">
<li class="level2"> Sort Priorities: X char, Char line, Y char
</li>
<li class="level2"> Data Outputted: Primero exportamos Gfx y luego Attr
</li>
<li class="level2"> Mask: No
</li>
</ul>
</li>
<li class="level1 node"> Múltiples sprites en formato vertical con máscara intercalada y con atributos:
<ul class="fix-media-list-overlap">
<li class="level2"> Sort Priorities: Mask, X char, Char line, Y char
</li>
<li class="level2"> Data Outputted: Gfx+Attr
</li>
<li class="level2"> Mask: Yes, before graphic
</li>
</ul>
</li>
<li class="level1 node"> Múltiples sprites en formato vertical con máscara intercalada y con atributos en 2 arrays:
<ul class="fix-media-list-overlap">
<li class="level2"> Sort Priorities: Mask, X char, Char line, Y char
</li>
<li class="level2"> Data Outputted: Primero exportamos Gfx y luego Attr
</li>
<li class="level2"> Mask: Yes, before graphic
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>

<p>
 Tras establecer las opciones adecuadas para el gráfico en cuestión, seleccionamos <em>File → Export Data:</em> para generar un fichero de texto de extensión .asm con los datos en el formato elegido.
</p>

<p>
 Veamos un ejemplo bastante claro de las posibilidades de exportación
utilizando dos sprites de 2×2 bloques (16×16) con valores binarios
fácilmente identificables para cada uno de los 8 bloques que forman
estos 2 sprites de 16×16:
</p>

<p>
<br>

<img src="img/gfx3_spriteprueba.png" class="mediacenter" alt=" Sprite de prueba para exports "/>
<br>

</p>

<p>
 El spriteset es, pues, de 16×32 píxeles, o lo que es lo mismo, 2 sprites de 2×2 bloques colocados verticalmente.
</p>

<p>
 Hemos rellenado cada “bloque” del spriteset con un patrón de píxeles
diferente que sea claramente identificable en su conversión a valor
numérico, de forma que los 8 scanlines de cada bloque tienen el mismo
valor, pero que a su vez es diferente de los valores de los demás
bloques:
</p>
<pre class="code">------------
| 1  | 128 |  &lt;-- Bloques 1 y 2 de Sprite 1
------------
| 2  |  64 |  &lt;-- Bloques 3 y 4 de Sprite 1
------------
| 4  |  32 |  &lt;-- Bloques 1 y 2 de Sprite 2
------------
| 8  |  16 |  &lt;-- Bloques 3 y 4 de Sprite 2
------------</pre>

<p>
 Veamos el resultado de la exportación del Sprite con diferentes opciones:
</p>

<p>
<br>

<br>

<strong>Multiples sprites en formato vertical sin máscara y sin atributos:</strong>
</p>

<p>
 Marcamos en “Data Outputted” la opción “Gfx”, de forma que no se
exporten los atributos. Asímismo, definimos como “Sort Priority” el
orden “X char, Char line, Y Char”. Esto da prioridad a los scanlines
completos (Char Line) sobre la coordenada Y de cada carácter (Y Char),
por lo que tendremos un scanline de cada carácter en nuestro export,
avanzando hacia abajo en nuestros 2 sprites:
</p>
<pre class="code">;Sort Priorities: X char, Char line, Y char
;Data Outputted:  Gfx
;Interleave:      Sprite
;Mask:            No

Sprite_Sin_Atributos:
	DEFB	  1,128,  1,128,  1,128,  1,128
	DEFB	  1,128,  1,128,  1,128,  1,128
	DEFB	  2, 64,  2, 64,  2, 64,  2, 64
	DEFB	  2, 64,  2, 64,  2, 64,  2, 64
	DEFB	  4, 32,  4, 32,  4, 32,  4, 32
	DEFB	  4, 32,  4, 32,  4, 32,  4, 32
	DEFB	  8, 16,  8, 16,  8, 16,  8, 16
	DEFB	  8, 16,  8, 16,  8, 16,  8, 16</pre>

<p>
<br>

<br>

<strong>Multiples sprites en formato vertical sin máscara y con atributos al final:</strong>
</p>

<p>
 Si marcamos la opción “Data Outputted” = “Gfx + Attr”, obtendremos el siguiente export:
</p>
<pre class="code">;Sort Priorities: X char, Char line, Y char
;Data Outputted:  Gfx+Attr
;Interleave:      Sprite
;Mask:            No

Sprite_con_atributos:
	DEFB	  1,128,  1,128,  1,128,  1,128
	DEFB	  1,128,  1,128,  1,128,  1,128
	DEFB	  2, 64,  2, 64,  2, 64,  2, 64
	DEFB	  2, 64,  2, 64,  2, 64,  2, 64
	DEFB	  4, 32,  4, 32,  4, 32,  4, 32
	DEFB	  4, 32,  4, 32,  4, 32,  4, 32
	DEFB	  8, 16,  8, 16,  8, 16,  8, 16
	DEFB	  8, 16,  8, 16,  8, 16,  8, 16
	DEFB	 57, 58, 59, 60, 61, 62, 57, 56</pre>

<p>
 El array de datos resultante es esencialmente igual al anterior, salvo
que se añaden los 8 bytes de atributos (2 sprites de 16×16 = 2×2 bytes
por cada sprite = 8 bytes de atributo).
</p>

<p>
<br>

<br>

<strong>Multiples sprites en formato vertical con máscara y con atributos al final:</strong>
</p>

<p>
 Con las mismas opciones que en el caso anterior, pero activando la
opción “Mask Before Graph” y subiendo la prioridad de la máscara al
máximo obtenemos el siguiente array de datos:
</p>
<pre class="code">;Sort Priorities: Mask, X char, Char line, Y char
;Data Outputted:  Gfx+Attr
;Interleave:      Sprite
;Mask:            Yes, before graphic

Sprite_con_mascara_y_atributos:
	DEFB	254,  1,127,128,254,  1,127,128
	DEFB	254,  1,127,128,254,  1,127,128
	DEFB	254,  1,127,128,254,  1,127,128
	DEFB	254,  1,127,128,254,  1,127,128
	DEFB	253,  2,191, 64,253,  2,191, 64
	DEFB	253,  2,191, 64,253,  2,191, 64
	DEFB	253,  2,191, 64,253,  2,191, 64
	DEFB	253,  2,191, 64,253,  2,191, 64
	DEFB	251,  4,223, 32,251,  4,223, 32
	DEFB	251,  4,223, 32,251,  4,223, 32
	DEFB	251,  4,223, 32,251,  4,223, 32
	DEFB	251,  4,223, 32,251,  4,223, 32
	DEFB	247,  8,239, 16,247,  8,239, 16
	DEFB	247,  8,239, 16,247,  8,239, 16
	DEFB	247,  8,239, 16,247,  8,239, 16
	DEFB	247,  8,239, 16,247,  8,239, 16
	DEFB	 57, 58, 59, 60, 61, 62, 57, 56</pre>

<p>
 En este export, hemos habilitado el uso de máscaras y el byte de
máscara de cada scanline aparece justo antes del byte de datos del
mismo. Los atributos permanecen al final del array.
</p>

<p>
<br>

<br>

<strong>Multiples sprites en formato vertical separando GFX y ATTR en 2 tablas:</strong>
</p>

<p>
 Podemos obtener la información del Sprite en 2 tablas separadas
realizando 2 exportaciones con las anteriores configuraciones que hemos
visto: bastará con realizar la primera como <em>Outputted Data = Gfx</em> y la segunda como <em>Outputted Data = Attr</em>, marcando la opción de <em>Append Data</em> para no sobreescribir el fichero destino en el segundo export.
</p>

<p>
 De esta forma, utilizando como ejemplo una exportación de datos sin
máscara, el fichero resultante tendrá el siguiente contenido:
</p>
<pre class="code">;Sort Priorities: X char, Char line, Y char
;Data Outputted:  Gfx
;Interleave:      Sprite
;Mask:            No

Sprites:
	DEFB	  1,128,  1,128,  1,128,  1,128
	DEFB	  1,128,  1,128,  1,128,  1,128
	DEFB	  2, 64,  2, 64,  2, 64,  2, 64
	DEFB	  2, 64,  2, 64,  2, 64,  2, 64
	DEFB	  4, 32,  4, 32,  4, 32,  4, 32
	DEFB	  4, 32,  4, 32,  4, 32,  4, 32
	DEFB	  8, 16,  8, 16,  8, 16,  8, 16
	DEFB	  8, 16,  8, 16,  8, 16,  8, 16


;Sort Priorities: X char, Char line, Y char
;Data Outputted:  Attr
;Interleave:      Sprite
;Mask:            No

Atributos:
	DEFB	 57, 58, 59, 60, 61, 62, 57, 56</pre>

<p>
<br>

</p>

<p>
 Como puede verse, SevenuP nos permite realizar la exportación tal y
como la necesitemos en
nuestras rutinas de impresión. Nosotros utilizaremos principalmente los 3
 formatos que acabamos de ver, pero otras rutinas pueden necesitar de
otra organización diferente, la cual podemos lograr alterando estos
parámetros.
</p>

<p>
 Aconsejamos al lector la lectura del fichero README de SevenuP para conocer todas sus funciones y la forma de utilizarlas.
</p>

<p>
 Por otra parte, si no nos resultase cómodo trabajar con SevenuP como
editor, podemos utilizarlo simplemente como exportador de datos. Basta
con utilizar un programa de dibujo clásico (xpaint, kpaint, MSPaint,
PaintShop Pro, o incluso The GIMP o Photoshop) y dibujar nuestros
sprites en formato tileset vertical. Debemos utilizar los colores de la
paleta del Spectrum y las mismas restricciones que nos encontraríamos
con el sistema de atributos del Spectrum (celdillas de 8×8, 16 colores,
etc.). El fichero final debe guardarse preferentemente como PNG sin
compresión.
</p>

<p>
 Después, utilizaremos la opción de importación de SevenuP (<em>File → Import</em>)
 para convertir la imagen de color “real” a un mapa de bits ya editable
en SevenuP. Con la imagen importada en SevenuP, y tras realizar los
retoques que consideremos oportunos, realizamos una exportación a código
 ASM con los parámetros de configuración de exportación correctos para
nuestra rutina de impresión de Sprites.
</p>

<p>
<br>

</p>

</div>

<h2 id="paso-de-parametros-a-las-rutinas">Paso de parámetros a las rutinas</h2>
<div class="level2">

<p>
 Al programar esta rutina, y cualquiera de las que veremos en este
capítulo, debemos decidir cómo pasar los parámetros de entrada a la
misma, ya que en estas rutinas manejaremos bastantes parámetros y en
alguno de los casos no tendremos suficientes registros libres para
establecerlos antes del CALL.
</p>

<p>
 En este sentido, podemos utilizar para el paso de los parámetros, las siguientes posibilidades:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Registros de 8 y 16 bits, allá donde
 sea posible, especialmente en rutinas con pocos parámetros de entrada y
 que sean llamadas en el programa en momentos críticos o gran cantidad
de veces.
</li>
<li> La Pila: realizando PUSH de los
parámetros de entrada en un orden concreto. La rutina, en su punto
inicial, hará POP de dichos valores en los registros adecuados. Tiene la
 ventaja de que podemos ir recuperando los valores conforme los vayamos
necesitando y tras haber realizado cálculos con los parámetros
anteriores que nos hayan dejado libres registros para los siguientes
cálculos.
</li>
<li><div class="li"> El Stack del Calculador: Este método permite que programa BASIC puedan llamar a nuestras subrutinas en ensamblador mediante <em>DEF FN</em>. Su principal desventaja es la lentitud y la no portabilidad a otros Sistemas.</div>
</li>
<li class="level1 node"> Variables de memoria: podemos
establecer los valores de entrada en variables de memoria con LD y
recuperarlos dentro de la rutina también con instrucciones de carga LD.
Esta técnica tiene una desventaja: la “lentitud” del acceso a memoria
para lectura y escritura, pero también tiene sustanciales ventajas:
<ul class="fix-media-list-overlap">
<li class="level2"> Los registros quedan libres para realizar todo tipo de operaciones.
</li>
<li class="level2"> No tenemos que preservar los valores
 de los parámetros de entrada al realizar operaciones con los registros,
 y podemos recuperarlos en cualquier otro punto de la rutina para
realizar nuevos cálculos.
</li>
<li class="level2"> Nos permite llamar a las rutinas
desde BASIC, estableciendo los parámetros con POKE y después realizando
el RANDOMIZE USR direccion_rutina.
</li>
</ul>
</li>
</ul>

<p>
<br>

</p>

<p>
 Lo normal en rutinas de este tipo sería utilizar en la medida de lo
posible el paso mediante registros (programa en ASM puro) o mediante la
pila (programas en C y ASM), pero en nuestros ejemplos utilizaremos el
último método: paso de variables en direcciones de memoria, con el
objetivo de que las rutinas puedan llamarse desde BASIC y para que sean
lo suficientemente sencillas de leer para que cada programador pueda
adaptar la entrada de una rutina concreta a las necesidades de su
programa utilizando otro de los métodos de paso de parámetros descrito.
</p>

<p>
 Es habitual incluso que en los programas ni siquiera se le pase a las
rutinas las direcciones origen de Sprites y Atributos sino que dichas
direcciones estén “hardcodeadas” dentro del código de la rutina,
utilizando un único array de tiles y otro de atributos con unas
direcciones concretas y exactas. Este podría ser un paso básico de
optimización que evitaría carga y paso de parámetros y nos permitiría
recuperar direcciones de origen de los arrays en cualquier punto de la
rutina.
</p>

<p>
 Por otra parte, el paso de parámetros es sólo un pequeño porcentaje del
 tiempo total de la rutina: el interés de optimización residirá en la
impresión del sprite en sí, ya que esta recogida de parámetros se
realiza una sola vez por sprite independientemente del número de bloques
 que lo compongan (en cuyo dibujado será donde realicemos el mayor gasto
 de tiempo).
</p>

<p>
<br>

</p>

</div>

<h2 id="trazado-de-sprites-de-8x8">Trazado de Sprites de 8x8</h2>
<div class="level2">

<p>
 Comencemos con la primera rutina de impresión de sprites: trazaremos un
 sprite de 8×8 píxeles (1 bloque) en una dirección de baja resolución
(c,f) de la pantalla. Este tipo de Sprite es parecido a lo que en BASIC
se denomina “UDG” (User Defined Graphic), pero sin las limitaciones en
el número de UDGs posibles a definir.
</p>

<p>
 El sprite a utilizar como “modelo” para desarrollar la rutina y para un
 posterior ejemplo de aplicación de la misma será el siguiente:
</p>

<p>
<br>

<img src="img/gfx3_cara8x8.png" class="mediacenter" alt=" Cara 8x8 "/>
<br>

</p>

<p>
 El bitmap con el que se corresponde este sprite y los valores binarios de los scanlines son los siguientes:
</p>
<pre class="code"> Pixeles     Binario    Decimal
--------------------------------
---***--  =  00011100  =  28
--*****-  =  00111110  =  62
-**-*-**  =  01101011  =  107
-*******  =  01111111  =  127
-*-***-*  =  01011101  =  93
-**---**  =  01100011  =  99
--*****-  =  00111110  =  62
---***--  =  00011100  =  28</pre>

<p>
 Efectivamente, si exportamos el sprite en SevenuP con los parámetros “X
 Char, Char line, Y Char, Mask”, y exportando por un lado el gráfico y
por otro los atributos, obtenemos el siguiente fichero fuente:
</p>
<pre class="code">; SevenuP (C) Copyright 2002-2006 by Jaime Tejedor Gomez, aka Metalbrain

;GRAPHIC DATA:
;Pixel Size:      (  8,   8) - (1,   1)
;Sort Priorities: Char line

cara_gfx:
  DEFB  28, 62,107,127, 93, 99, 62, 28

cara_attrib:
  DEFB  56</pre>

<p>
<br>

</p>

</div>

<h3 class="sectionedit11" id="sobreescribiendo-el-fondo-impresion-con-ld">Sobreescribiendo el fondo (impresión con LD)</h3>
<div class="level3">

<p>
 La primera de las rutinas que veremos realizará transferencias directas
 de datos entre el origen (el sprite) y el destino (la pantalla).
</p>

<p>
 Para nuestra rutina utilizaremos el siguiente esquema de paso de parámetros:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit12"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Dirección </th><th class="col1"> Parámetro </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 50000 </td><td class="col1"> Dirección de la tabla de Sprites </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 50002 </td><td class="col1"> Dirección de la tabla de Atributos </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 50004 </td><td class="col1"> Coordenada X en baja resolución </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 50005 </td><td class="col1"> Coordenada Y en baja resolución </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 50006 </td><td class="col1"> Numero de sprite a dibujar (0-N) </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 El pseudocódigo de la rutina es el siguiente:
</p>
<pre class="code">; Recoger parametros de entrada
; Calcular posicion origen (array sprites) en DE como
;     direccion = base_sprites + (NUM_SPRITE*8)
; Calcular posicion destino (pantalla) en DE con X e Y

; Repetir 8 veces:
;    Dibujar scanline (DE) -&gt; (HL)
;    Incrementar scanline del sprite (DE).
;    Bajar a siguiente scanline en pantalla (HL).

; Si base_atributos == 0 -&gt; RET
; Calcular posicion origen de los atributos array_attr+NUM_SPRITE en HL.
; Calcular posicion destino en area de atributos en DE.
; Copiar (HL) en (DE)</pre>

<p>
 La rutina debe de comenzar calculando la direcciones origen y destino para las transferencias de datos.
</p>

<p>
 La dirección origen es el primer scanline del sprite a dibujar. Dada
una tabla de sprites 8×8 en formato vertical, y teniendo en cuenta que
cada sprite 8×8 ocupa 8 bytes (1 byte por cada scanline, 8 scanlines),
nos posicionaremos en el sprite correcto “saltando” 8 bytes por cada
sprite que haya antes del sprite que buscamos:
</p>
<pre class="code">DIR_MEMORIA_GFX = DIR_BASE_SPRITES + (NUM_SPRITE_A_DIBUJAR * 8)</pre>

<p>
 La dirección destino en pantalla la calculamos a partir de las
coordenadas C, F (x/8,y/8) con las técnicas que vimos en el capítulo
anterior; en este caso, mediante coordenación en baja resolución.
</p>

<p>
 Una vez tenemos la dirección origen y destino para los gráficos,
realizamos un bucle de 8 iteraciones (por haber 8 scanlines) que haga lo
 siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> Copiamos el byte apuntado por DE (scanline de sprite) a la dirección apuntada por HL (pantalla).
</li>
<li> Incrementamos DE (siguiente scanline del sprite).
</li>
<li> Cambiamos HL para que apunte en pantalla al scanline de debajo del actual (sumando 1 a la parte alta).
</li>
</ul>

<p>
 Tras las 8 iteraciones tendremos el gráfico completo dibujado en pantalla, y faltará el procesado de los atributos.
</p>

<p>
 La misma rutina que vamos a crear servirá para dibujar gráficos con
atributos o sin atributos. Nos puede interesar el dibujado de gráficos
sin atributos en juegos monocolor donde los atributos de fondo ya están
establecidos en pantalla y no sea necesario re-escribirlos, ahorrando
ciclos de reloj al no realizar esta tarea sin efectos en pantalla.
Nótese que aunque no dibujemos los atributos de un sprite, esto no
quiere decir que no tendrá color en pantalla: si no modificamos los
atributos de una posición (c,f), el sprite que dibujemos en esas
coordenadas adoptará los colores de tinta y papel que ya tenía esa
posición de pantalla.
</p>

<p>
 En lugar de crear 2 rutinas diferentes, una que imprima un sprite con
atributos y otra que lo haga sin ellos, vamos a utilizar en este
capítulo una única rutina indicando en el parámetro de la dirección de
atributos si queremos dibujarlos o no. La rutina comprobará si la
dirección de atributos es 0 (basta con comprobar su parte alta) y si es
así, saldrá con un RET sin realizar los cálculos de atributos (dirección
 origen, destino, y dibujado).
</p>

<p>
 Utilizaremos este sistema de comprobación (DIR_ATTR==0) para evitar la
necesidad de crear 2 rutinas diferentes, aunque en un juego lo normal
será que adaptemos la rutina al caso concreto y exacto (SIN o CON
atributos) para evitar la comprobación de DIR_ATTR=0 y cualquier otro
código no necesario.
</p>

<p>
 Continuemos: Si DIR_ATRIBUTOS (50002) no es cero, se utilizará dicha
dirección y el número del sprite para calcular la posición del único
atributo que tenemos que trazar en pantalla (sprite 8×8 = 1 único
atributo). Como cada sprite tiene un atributo de 1 byte, esta dirección
origen será:
</p>
<pre class="code">DIR_MEMORIA_ATTR = DIR_BASE_ATTRIBS + NUM_SPRITE_A_DIBUJAR</pre>

<p>
 Es decir, saltamos 1 byte (un atributo) por cada sprite 8×8 (1 bloque=1
 atributo) para posicionarnos en el atributo del sprite DS_NUMSPR.
</p>

<p>
 La dirección destino en el área de atributos se calcula con las rutinas
 que vimos en el capítulo anterior, y la transferencia destino se
realiza con instrucciones de carga.
</p>

<p>
 Los cálculos y la transferencia de atributos los haremos usando HL como
 puntero origen y DE como puntero destino, ya que necesitamos realizar
ADDs de 16 bits para calcular la dirección origen del atributo y el
único registo que soporta esta operación como destino es HL.
</p>

<p>
 Hemos asumido que nuestra rutina trabaja con una tabla de sprites en
formato vertical, pero en nuestro ejemplo tenemos un único sprite. Esto
no importa porque tener un único sprite es un subcaso de la tabla de
sprites donde NUM_SPRITE=0, por lo que las mismas rutinas nos sirven si
les solicitamos imprimir el sprite número “0”.
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; DrawSprite_8x8_LD:</span>
<span class="co1">; Imprime un sprite de 8x8 pixeles con o sin atributos.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion   Parametro</span>
<span class="co1">; 50000       Direccion de la tabla de Sprites</span>
<span class="co1">; 50002       Direccion de la tabla de Atribs  (0=no atributos)</span>
<span class="co1">; 50004       Coordenada X en baja resolucion</span>
<span class="co1">; 50005       Coordenada Y en baja resolucion</span>
<span class="co1">; 50006       Numero de sprite a dibujar (0-N) </span>
<span class="co1">;-------------------------------------------------------------</span>
DrawSprite_8x8_LD:
&nbsp;
   <span class="co1">; Guardamos en BC la pareja (x,y) -&gt; B=COORD_Y y C=COORD_X</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>           <span class="co1">; Ya tenemos la parte alta calculada (010TT000)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>           <span class="co1">; Ahora calculamos la parte baja</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>              <span class="co1">; A = NNN00000b</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>          <span class="co1">; Sumamos COLUMNA -&gt; A = NNNCCCCCb</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>           <span class="co1">; Lo cargamos en la parte baja de la direccion</span>
                     <span class="co1">; DE contiene ahora la direccion destino.</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*8)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>           <span class="co1">; HL = DS_NUMSPR</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 4</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 8 = DS_NUMSPR * 8</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>        <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 8)</span>
                     <span class="co1">; HL contiene la direccion de inicio en el sprite</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>         <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="co1">;;; Dibujar 8 scanlines (DE) -&gt; (HL) y bajar scanline</span>
   <span class="co1">;;; Incrementar scanline del sprite (DE)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>          <span class="co1">; 8 scanlines -&gt; 8 iteraciones</span>
&nbsp;
drawsp8x8_loopLD:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Tomamos el dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Incrementamos puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; Incrementamos puntero en pantalla (scanline+=1)</span>
   <span class="kw1">DJNZ</span> drawsp8x8_loopLD
&nbsp;
   <span class="co1">;;; En este punto, los 8 scanlines del sprite estan dibujados.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>              <span class="co1">; Recuperamos la posicion de memoria del </span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; scanline inicial donde empezamos a dibujar</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">L</span>            <span class="co1">; BC = HL - 8</span>
&nbsp;
   <span class="co1">;;; Considerar el dibujado de los atributos (Si DS_ATTRIBS=0 -&gt; RET)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>              <span class="co1">; A = 0</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">H</span>           <span class="co1">; A = 0 + H = H</span>
   <span class="kw1">RET</span> Z              <span class="co1">; Si H = 0, volver (no dibujar atributos)</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Obtenemos dir de atributo a partir de</span>
   <span class="kw1">RRCA</span>               <span class="co1">; dir de zona de imagen.</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Nos evita volver a obtener X e Y</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; y hacer el calculo completo de la </span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58             <span class="co1">; direccion en zona de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">C</span>            <span class="co1">; DE tiene el offset del attr de HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>  <span class="co1">; Cogemos el numero de sprite a dibujar</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+DS_NUMSPR = Origen de atributo</span>
&nbsp;
   <span class="co1">;;; Copiar (HL) en (DE) -&gt; Copiar atributo de sprite a pantalla</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Mas rapido que LDI (7+7 vs 16 t-estados)</span>
   <span class="kw1">RET</span>                <span class="co1">; porque no necesitamos incrementar HL y DE </span></pre>

<p>
 Al respecto del código de la rutina, caben destacar las siguientes consideraciones:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> Nótese que en la rutina se emplean las subrutinas <em>Get_Char_Offset_LR</em> y <em>Attr_Offset_From_Image</em>
 con el código de las mismas embebido dentro de la rutina principal.
Esto se hace con el objetivo de evitar los correspondientes CALLs y RET y
 para poder personalizarlas (en este caso, están modificadas para
devolver la dirección calculada en DE en lugar de en HL, por
requerimientos del código de DrawSprite_8x8).</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> Para realizar la transferencia de
datos entre el sprite (apuntado por DE) y la pantalla (apuntada por HL)
hemos utilizado 2 instrucciones de transferencia LD usando A como
registro intermedio en lugar de utilizar una instrucción <strong>LDI</strong>. Más adelante veremos el por qué de esta elección.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> Como ya vimos en el capítulo anterior, para avanzar o retroceder el puntero HL en pantalla, en lugar de utilizar <strong>DEC HL</strong> o <strong>INC HL</strong> (6 t-estados), realizamos un <strong>DEC L</strong> o <strong>INC L</strong>
 (4 t-estados). Esto es posible porque dentro de un mismo scanline de
pantalla no varía el valor del byte alto de la dirección. Esta pequeña
optimización no podemos realizarla con el puntero de datos del Sprite
porque no tenemos la certeza de que esté dentro de una página de 256
bytes y que, por lo tanto, alguno de los incrementos del puntero deba
modificar la parte alta del mismo.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> La rutina que hemos visto, por
simplicar el código, utiliza un bucle de 8 iteraciones para dibujar los 8
 scanlines. Esto ahorra espacio (ocupación de la rutina) pero implica un
 testeo del contador y salto por cada iteración (excepto en la última).
En una rutina crítica, si tenemos suficiente espacio libre, y si
conocemos de antemano el número de iteraciones exacto de un bucle, lo
óptimo sería <strong>desenrollar el bucle</strong>, es decir, repetir 8 veces el código de impresión. De este modo evitamos el <strong>LD B, 8</strong> y el <strong>DJNZ bucle</strong>.</div>
</li>
</ul>

<p>
 En el caso de nuestra rutina de ejemplo, cambiaríamos…
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>          <span class="co1">; 8 scanlines</span>
&nbsp;
drawsp8x8_loopLD:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Tomamos el dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Incrementamos puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; Incrementamos puntero en pantalla (scanline+=1)</span>
   <span class="kw1">DJNZ</span> drawsp8x8_loopLD</pre>

<p>
 … por:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Scanline 0</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Scanline 1</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Scanline 2</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Scanline 3</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Scanline 4</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Scanline 5</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Scanline 6</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Scanline 7</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="co1">;;;INC H         ; no es necesario el ultimo INC H</span></pre>

<p>
 Nótese cómo al desenrollar el bucle ya no es necesario el último <strong>INC H</strong> para avanzar al siguiente scanline de pantalla. El <strong>INC DE</strong>
 sí que es necesario ya que tenemos que avanzar en el sprite al primero
de los atributos (aunque este INC también podría realizarse después del
código de comprobación de la dirección de atributo, evitando hacerlo si
no queremos imprimirlos).
</p>

<p>
 Al no ser necesario el <strong>INC H</strong>, en la versión desenrollada del bucle tenemos que cambiar la resta de HL - 8 por HL - 7:
</p>
<pre class="code z80">   <span class="co1">;;; En este punto, los 8 scanlines del sprite estan dibujados.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">7</span>              <span class="co1">; Recuperamos la posicion de memoria del</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; scanline inicial donde empezamos a dibujar</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">L</span>            <span class="co1">; BC = HL - 7</span></pre>

<p>
 Lo normal es desenrollar sólo aquellas rutinas lo suficiente críticas e
 importantes como para compensar el mayor espacio en memoria con un
menor tiempo de ejecución. En esta rutina evitaríamos la pérdida de
ciclos de reloj en el establecimiento del contador, en el testeo de
condición de salida y en el salto, a cambio de una mayor ocupación de
espacio tras el ensamblado.
</p>

<p>
 Una rutina de impresión de sprites de tamaños fijos (8×8, 16×16, 8×16,
etc) en la que conocemos el número de iteraciones verticales y
horizontales para la impresión es uno de los casos típicos en los que
usaremos esta técnica. Si la rutina fuera para sprites de tamaño
variable (NxM), no podríamos aplicarla porque necesitamos los bucles de N
 y M iteraciones que no podemos sustituir de antemano.
</p>

<p>
 El programa de ejemplo que veremos a continuación utiliza la rutina
anterior (no incluída en el listado) para imprimir el sprite de ejemplo
8×8 que hemos visto:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo impresion sprites 8x8</span>
  ORG <span class="nu0">32768</span>
&nbsp;
DS_SPRITES  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">0000</span>
DS_ATTRIBS  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">2</span>
DS_COORD_X  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">4</span>
DS_COORD_Y  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">5</span>
DS_NUMSPR   <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">6</span>
&nbsp;
  <span class="kw1">CALL</span> ClearScreen_Pattern
&nbsp;
  <span class="co1">; Establecemos los parametros de entrada a la rutina</span>
  <span class="co1">; Los 2 primeros se pueden establecer una unica vez</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cara_gfx
  <span class="kw1">LD</span> <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cara_attrib
  <span class="kw1">LD</span> <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">5</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">8</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
  <span class="kw1">CALL</span> DrawSprite_8x8_LD
&nbsp;
loop:
  <span class="kw1">JR</span> loop
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;--------------------------------------------------------------------</span>
<span class="co1">; ClearScreen_Pattern</span>
<span class="co1">; Limpia la pantalla con patrones de pixeles alternados</span>
<span class="co1">;--------------------------------------------------------------------</span>
ClearScreen_Pattern:
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span><span class="nu0">9</span><span class="re1">1</span>                   <span class="co1">; Numero de lineas a rellenar</span>
&nbsp;
cs_line_loop:
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">CALL</span> <span class="sy0">$</span>22B<span class="re1">1</span>                  <span class="co1">; ROM (Pixel-Address)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="re1">1</span>
   <span class="kw1">JR</span> Z, cs_es_par
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">7</span><span class="re1">0</span>
   <span class="kw1">JR</span> cs_pintar
&nbsp;
cs_es_par:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">85</span>
&nbsp;
cs_pintar:
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">B</span>                     <span class="co1">; Salvar el contador del bucle</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">32</span>                    <span class="co1">; Imprimir 32 bytes</span>
&nbsp;
cs_x_loop:
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>
   <span class="kw1">DJNZ</span> cs_x_loop
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">D</span>                     <span class="co1">; Recuperamos el contador externo</span>
   <span class="kw1">DJNZ</span> cs_line_loop           <span class="co1">; Repetimos 192 veces</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;--------------------------------------------------------------------</span>
<span class="co1">;SevenuP (C) Copyright 2002-2006 by Jaime Tejedor Gomez, aka Metalbrain</span>
<span class="co1">;GRAPHIC DATA:</span>
<span class="co1">;Pixel Size:      (  8,   8) - (1,   1)</span>
<span class="co1">;Sort Priorities: Char line</span>
<span class="co1">;--------------------------------------------------------------------</span>
&nbsp;
cara_gfx:
  DEFB  <span class="nu0">28</span>, <span class="nu0">62</span>,<span class="re1">10</span><span class="nu0">7</span>,<span class="re1">1</span><span class="nu0">27</span>, <span class="nu0">93</span>, <span class="nu0">99</span>, <span class="nu0">62</span>, <span class="nu0">28</span>
&nbsp;
cara_attrib:
  DEFB  <span class="nu0">56</span>
&nbsp;
&nbsp;
<span class="co1">;--------------------------------------------------------------------</span>
DrawSprite_8x8_LD:
  <span class="co1">;;; codigo de la rutina...</span></pre>

<p>
 El resultado de la ejecución del anterior programa es el siguiente:
</p>

<p>
<br>

<img src="img/gfx3_sprite8x8_1.png" class="mediacenter" alt=" Salida del ejemplo anterior "/>
<br>

</p>

<p>
<br>

<strong>Transferencia por LDI vs LD+INC</strong>
<br>

</p>

<p>
 En nuestra rutina de impresión hemos utilizado instrucciones de carga
entre memoria para transferir bytes desde la dirección apuntada por DE
(el origen; el Sprite) a la dirección apuntada por HL (el destino; la
pantalla).
</p>

<p>
 Para trazar los píxeles en pantalla podríamos haber utilizado la
instrucción LDI, que con 16 t-estados realiza una transferencia de 1
byte entre la dirección de memoria apuntada por HL (origen) y la
apuntada por DE (destino), y además incrementa HL y DE.
</p>

<p>
 El bucle principal de impresión de nuestro programa es el siguiente:
</p>
<pre class="code z80">drawsp8x8_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; A = (DE) = leer dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; (HL) = A = escribir dato a la pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementamos DE (puntero sprite)</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>              <span class="co1">; Incrementamos scanline HL (HL+=256)</span>
   <span class="kw1">DJNZ</span> drawsp8x8_loop</pre>

<p>
 Las instrucciones antes del DJNZ tienen un coste de ejecución de 7, 7, 6 y 4 t-estados respectivamente (empezando por el <strong>LD A, (DE)</strong> y acabando por el <strong>INC H</strong>). Esto suma un total de 24 t-estados por cada byte transferido.
</p>

<p>
 Si invertimos el uso de los punteros y utilizamos HL como puntero al
Sprite (origen) y DE como puntero a pantalla (destino), el bucle
anterior podría haberse reescrito de la siguiente forma:
</p>
<pre class="code z80">drawsp8x8_loop:
   <span class="kw1">LDI</span>                <span class="co1">; Copia (HL) en (DE) y HL++ DE++</span>
   <span class="kw1">INC</span> <span class="kw2">D</span>              <span class="co1">; Sumamos 256 (+1=257)</span>
   <span class="kw1">DEC</span> <span class="kw2">E</span>              <span class="co1">; Restamos 1 (+=256)</span>
   <span class="kw1">DJNZ</span> drawsp8x8_loop</pre>

<p>
 Aunque es un formato más compacto, el coste de ejecución es el mismo (16+4+4 = 24 t-estados).
</p>

<p>
 Entre las 2 posibles formas de realizar la impresión (LD+INC vs LDI),
utilizaremos la primera porque, como veremos a continuación, la
impresión de sprites mediante operaciones lógicas o mediante máscaras no
 permite el uso de LDI y utilizar la primera técnica hace todas las
rutinas muy similares entre sí y por lo tanto podremos aplicar en todas
cualquier mejora u optimización de una forma más rápida y sencilla.
</p>

<p>
 Además, LDI decrementa el registro BC tras las transferencia, por lo
que si lo utilizamos en un bucle tenemos que tener en cuenta que cada
LDI puede alterar el valor de BC y por tanto del contador de iteraciones
 del bucle, lo cual es otro motivo para elegir LD+INC vs LDI.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit13" id="respetando-el-fondo-impresion-con-or">Respetando el fondo (impresión con OR)</h3>
<div class="level3">

<p>
 Veamos una ampliación del Sprite de 8×8 del ejemplo anterior impreso sobre un fondo no plano:
</p>

<p>
<br>

<img src="img/gfx3_sprite8x8_2.png" class="mediacenter" alt=" Ampliación del Sprite de 8x8 "/>
<br>

</p>

<p>
 Nótese cómo la impresión del sprite no ha respetado el fondo en los
píxeles a cero del mismo: al establecer el valor del byte en pantalla
con un LD, hemos establecido a cero en pantalla los bits que estaban a
cero en el sprite sin respetar el valor que hubiera en videoram para
dichos bits.
</p>
<pre class="code">Ejemplo:

Valor en Videomemoria (HL):     10101010
Valor en el sprite - reg. A:    00111110
Operación:                      LD (HL), A
Resultado en VRAM:              00111110</pre>

<p>
 La primera de las soluciones a este problema es la de escribir los
píxeles con una operación lógica OR entre el scanline y el valor actual
en memoria. Con la operación OR mezclaremos los bits de ambos elementos:
</p>
<pre class="code">Ejemplo:

Valor en Videomemoria (HL):     10101010
Valor en el sprite - reg. A:    00111110
Operación:                      LD + OR/XOR
Resultado en VRAM:              10111110</pre>

<p>
 La operación OR nos permitirá respetar el fondo en aquellos juegos en
que los sprites no tengan zonas a 0 dentro del contorno del mismo (que,
como veremos más adelante, no es el caso de nuestro pequeño sprite).
</p>

<p>
 Para modificar la rutina de impresión de Sprites de forma que utilice
OR (u otra operación lógica con otras aplicaciones como XOR), sólo
necesitamos añadir la correspondiente instrucción lógica entre A y el
contenido de la memoria:
</p>

<p>
 Cambiamos el bucle de impresión…
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>             <span class="co1">; 8 scanlines -&gt; 8 iteraciones</span>
&nbsp;
drawsp8x8_loopLD:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Tomamos el dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Incrementamos puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; Incrementamos puntero en pantalla</span>
   <span class="kw1">DJNZ</span> drawsp8x8_loopLD</pre>

<p>
 por:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>             <span class="co1">; 8 scanlines -&gt; 8 iteraciones</span>
&nbsp;
drawsp8x8_loop_or:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>          <span class="co1">; Tomamos el dato del sprite</span>
   <span class="kw1">OR</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>             <span class="co1">; NUEVO: Hacemos un OR del scanline con el fondo</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>          <span class="co1">; Establecemos el valor del OR en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>              <span class="co1">; Incrementamos puntero en sprite (DE+=1)</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>               <span class="co1">; Incrementamos puntero en pantalla (HL+=256)</span>
   <span class="kw1">DJNZ</span> drawsp8x8_loop_or</pre>

<p>
 A continuación, el código fuente completo de la rutina de impresión de 8×8 con operación lógica OR:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; DrawSprite_8x8_OR:</span>
<span class="co1">; Imprime un sprite de 8x8 pixeles con o sin atributos.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion   Parametro</span>
<span class="co1">; 50000       Direccion de la tabla de Sprites</span>
<span class="co1">; 50002       Direccion de la tabla de Atribs  (0=no atributos)</span>
<span class="co1">; 50004       Coordenada X en baja resolucion</span>
<span class="co1">; 50005       Coordenada Y en baja resolucion</span>
<span class="co1">; 50006       Numero de sprite a dibujar (0-N) </span>
<span class="co1">;-------------------------------------------------------------</span>
DrawSprite_8x8_OR:
&nbsp;
   <span class="co1">; Guardamos en BC la pareja (x,y) -&gt; B=COORD_Y y C=COORD_X</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>           <span class="co1">; Ya tenemos la parte alta calculada (010TT000)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>           <span class="co1">; Ahora calculamos la parte baja</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>              <span class="co1">; A = NNN00000b</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>          <span class="co1">; Sumamos COLUMNA -&gt; A = NNNCCCCCb</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>           <span class="co1">; Lo cargamos en la parte baja de la direccion</span>
                     <span class="co1">; DE contiene ahora la direccion destino.</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*8)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>           <span class="co1">; HL = DS_NUMSPR</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 4</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 8 = DS_NUMSPR * 8</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>        <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 8)</span>
                     <span class="co1">; HL contiene la direccion de inicio en el sprite</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>         <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="co1">;;; Dibujar 8 scanlines (DE) -&gt; (HL) y bajar scanline</span>
   <span class="co1">;;; Incrementar scanline del sprite (DE)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>          <span class="co1">; 8 scanlines -&gt; 8 iteraciones</span>
&nbsp;
drawsp8x8_loop_or:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Tomamos el dato del sprite</span>
   <span class="kw1">OR</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>          <span class="co1">; NUEVO: Hacemos un OR del scanline con el fondo</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Incrementamos puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; Incrementamos puntero en pantalla (scanline+=1)</span>
   <span class="kw1">DJNZ</span> drawsp8x8_loop_or
&nbsp;
   <span class="co1">;;; En este punto, los 8 scanlines del sprite estan dibujados.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>              <span class="co1">; Recuperamos la posicion de memoria del </span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; scanline inicial donde empezamos a dibujar</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">L</span>            <span class="co1">; BC = HL - 8</span>
&nbsp;
   <span class="co1">;;; Considerar el dibujado de los atributos (Si DS_ATTRIBS=0 -&gt; RET)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>              <span class="co1">; A = 0</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">H</span>           <span class="co1">; A = 0 + H = H</span>
   <span class="kw1">RET</span> Z              <span class="co1">; Si H = 0, volver (no dibujar atributos)</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Obtenemos dir de atributo a partir de</span>
   <span class="kw1">RRCA</span>               <span class="co1">; dir de zona de imagen.</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Nos evita volver a obtener X e Y</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; y hacer el calculo completo de la </span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58             <span class="co1">; direccion en zona de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">C</span>            <span class="co1">; DE tiene el offset del attr de HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>  <span class="co1">; Cogemos el numero de sprite a dibujar</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+DS_NUMSPR = Origen de atributo</span>
&nbsp;
   <span class="co1">;;; Copiar (HL) en (DE) -&gt; Copiar atributo de sprite a pantalla</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Mas rapido que LDI (7+7 vs 16 t-estados)</span>
   <span class="kw1">RET</span>                <span class="co1">; porque no necesitamos incrementar HL y DE </span></pre>

<p>
 (Nótese que el bucle de impresión de scanlines también puede, y debería, ser desenrollado).
</p>

<p>
 Veamos qué ha ocurrido con los píxeles del fondo y la operación lógica OR:
</p>

<p>
<br>

<img src="img/gfx3_sprite8x8_or_1.png" class="mediacenter" alt=" Sprite 8x8 impreso con OR "/>
<br>

</p>

<p>
 Ampliando el sprite…
</p>

<p>
<br>

<img src="img/gfx3_sprite8x8_or_2.png" class="mediacenter" alt=" Ampliación del Sprite de 8x8 con OR "/>
<br>

</p>

<p>
 ¿Qué ha ocurrido con el sprite? ¿Por qué le faltan los “ojos” y hay un
pixel activo en medio de la “boca”? Sencillamente, porque mediante el OR
 hemos impreso el sprite respetando el valor a 1 de los píxeles del
fondo cuando el mismo pixel estaba a 0 en nuestro sprite. Eso ha hecho
que alrededor de nuestro “personaje” no se haya borrado el fondo, ya que
 los píxeles a cero de nuestro sprite se convierten en “transparentes”.
Por desgracia, eso también hace que los ojos del personaje sean
transparentes en lugar de estar a cero. En el caso del ejemplo anterior,
 los “ojos” del personaje coinciden con 2 píxeles de pantalla activos
por lo que la operación OR los deja a 1. Lo mismo ocurre con el pixel en
 el centro de la boca, que se corresponde con un pixel activo en la
pantalla.
</p>

<p>
 En tal caso, ¿qué hacemos para imprimir nuestro sprite respetando el
fondo pero que a su vez podamos disponer de zonas que no sean
transparentes?
</p>

<p>
 La respuesta es: mediante <strong>máscaras</strong>.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit14" id="impresion-8x8-usando-mascaras">Impresión 8x8 usándo máscaras</h3>
<div class="level3">

<p>
 Como hemos visto, las operaciones con OR nos permiten respetar el fondo
 pero a su vez provocan zonas transparentes en nuestro sprite. En
sistemas más modernos se utiliza un “color transparente” (que suele ser
unas componentes concretas de color con un tono específico de rosa
fucsia). En el caso del Spectrum, el color reside en los atributos y no
en los sprites en sí, por lo que no podemos utilizar un “color
transparencia”.
</p>

<p>
 La solución para respetar el fondo y sólo tener transparencias en los
sprites en las zonas que nosotros deseemos es la utilización de
máscaras.
</p>

<p>
 La máscara es un bitmap del mismo tamaño que el sprite al que está
asociada. Tiene un contorno similar al del sprite, donde colocamos a 1
todos los pixeles del fondo que necesitamos respetar (zonas
transparentes) y a 0 todos los píxeles que se transferirán desde el
sprite (píxeles opacos o píxeles del sprite) y que deben de ser borrados
 del fondo.
</p>

<p>
 A la hora de dibujar el sprite en pantalla, se realiza un AND entre el
valor del pixel y el valor del fondo (de los 8 píxeles, en el caso del
Spectrum), con lo cual “borramos” del fondo todos aquellos píxeles a
cero en la máscara. Después se realiza un OR del Sprite en el resultado
del anterior AND, activando los píxeles del Sprite.
</p>

<p>
 De esta forma, podemos respetar todos los píxeles del fondo alrededor
de la figura del personaje, así como algunas zonas de mismo que podamos
querer que sean transparentes, mientras que borramos todos aquellos
píxeles de pantalla que deben de ser reemplazados por el sprite.
</p>

<p>
 Apliquemos una máscara a nuestro ejemplo anterior. Al hacer el AND
entre la máscara y el fondo (paso 1.-), eliminamos el entramado de
pixeles de pantalla, con lo que al imprimir nuestro sprite con el OR
(paso 2.-), los ojos y el centro de la boca serán de nuevo píxeles no
activos:
</p>

<p>
<br>

<img src="img/gfx3_mask8x8.png" class="mediacenter" alt=" Aplicando máscara "/>
<br>

</p>

<p>
 El resultado es que los ojos y la boca del sprite, que en la máscara
están a 0, son borrados del fondo y por lo tanto no se produce el efecto
 de “transparencia” que presentaba el dibujado con OR.
</p>

<p>
 No obstante, nuestro sprite sigue teniendo un problema relacionado con
el sistema de atributos del Spectrum, y es que los píxeles de nuestro
personaje se “confunden” con los del fondo en los contornos del sprite,
ya que todos tendrán idéntico color si están dentro de una misma celda
8×8. Para evitar esto, lo ideal sería disponer de un “borde” alrededor
del mismo.
</p>

<p>
 Podemos aprovechar la máscara (no en nuestro sprite de 8×8, pero sí en
sprites de mayores dimensiones), para dotar de un “reborde” a nuestra
figura y que los píxeles del sprite no se confundan con los del fondo.
Basta con hacer el contorno en la máscara más grande que el contorno del
 sprite, de esta forma, los bytes de contorno “extra” de la máscara
borrarán fondo alrededor del Sprite, con lo que no se producirá la
“confusión” con el fondo.
</p>

<p>
 La siguiente imagen ilustra lo que acabamos de comentar:
</p>

<p>
<br>

<img src="img/gfx3_bordes.png" class="mediacenter" alt=" Aplicando bordes mediante máscara "/>
<br>

</p>

<p>
 Así pues, con la máscara podemos conseguir 2 cosas:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Evitar transparencias en el interior
 de nuestro Sprite: bastará con que la máscara sea una copia del
contorno del sprite, pero “relleno”, por lo que todos los pixeles del
sprite serán transferidos dentro de dicho contorno.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Conseguir un contorno de pixeles “a
cero” alrededor de nuestro Sprite, un borde que lo haga visualmente más
identificable y no mezcle sus píxeles con los de la pantalla. Para eso,
basta con que el contorno del sprite en la máscara sea ligeramente más
grande que el del sprite.
</li>
</ul>

<p>
<br>

</p>

<p>
 Por contra, el uso de máscaras tiene también desventajas:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> El uso de máscaras requiere utilizar
 el doble de memoria para el spriteset gráfico (no para el de
atributos), ya que por cada byte del sprite necesitamos el
correspondiente byte de máscara.
</li>
</ul>
<ul class="fix-media-list-overlap">
<li> Las rutinas de impresión con
máscaras son más lentas que sin ellas, porque tienen que recoger datos
de la máscara, realizar operaciones lógicas entre los datos de la misma y
 el fondo, y realizar incrementos adicionales del puntero al sprite
(DE).
</li>
</ul>

<p>
<br>

</p>

<p>
 La rutina de impresión de máscaras tiene ahora que recoger un dato
extra por cada byte del sprite: la máscara que se corresponde con ese
byte. Para no utilizar un puntero de memoria adicional en un array de
máscara, lo ideal es exportar cada byte de máscara junto al byte del
sprite correspondiente, de forma que podamos recoger ambos valores
usando el mismo puntero (DE en nuestro caso). Para eso habría que
exportar el Sprite como <em>Mask, X Char, Char line, Y Char</em> y activando “Mask before graphic”.
</p>

<p>
 El pseudocódigo de la nueva rutina <strong>DrawSprite_8x8_MASK</strong> sería el siguiente:
</p>
<pre class="code">Pseudocódigo de la rutina:

; Recoger parametros
; Calcular posicion destino en HL con X e Y
; Calcular posicion origen en DE base_sprites + (frame*8*2) (*2 -&gt; por la mascara)

; Repetir 8 veces:
;    Coger dato de mascara
;    AND del byte de mascara con el byte actual de fondo.
;    Coger dato de scanline del sprite (DE++)
;    Dibujar scanline en pantalla como un OR sobre el resultado del AND.
;    Incrementar scanline sprite/mascara en DE.
;    Bajar a siguiente scanline en pantalla.</pre>

<p>
 La rutina completa sería:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; DrawSprite_8x8_MASK:</span>
<span class="co1">; Imprime un sprite de 8x8 pixeles + mascara con o sin atributos.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion   Parametro</span>
<span class="co1">; 50000       Direccion de la tabla de Sprites</span>
<span class="co1">; 50002       Direccion de la tabla de Atribs  (0=no atributos)</span>
<span class="co1">; 50004       Coordenada X en baja resolucion</span>
<span class="co1">; 50005       Coordenada Y en baja resolucion</span>
<span class="co1">; 50006       Numero de sprite a dibujar (0-N) </span>
<span class="co1">;-------------------------------------------------------------</span>
DrawSprite_8x8_MASK:
&nbsp;
   <span class="co1">; Guardamos en BC la pareja (x,y) -&gt; B=COORD_Y y C=COORD_X</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>           <span class="co1">; Ya tenemos la parte alta calculada (010TT000)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>           <span class="co1">; Ahora calculamos la parte baja</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>              <span class="co1">; A = NNN00000b</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>          <span class="co1">; Sumamos COLUMNA -&gt; A = NNNCCCCCb</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>           <span class="co1">; Lo cargamos en la parte baja de la direccion</span>
                     <span class="co1">; DE contiene ahora la direccion destino.</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*16)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>           <span class="co1">; HL = DS_NUMSPR</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 4</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 8</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 16 = DS_NUMSPR * 16</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>        <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 16)</span>
                     <span class="co1">; HL contiene la direccion de inicio en el sprite</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>         <span class="co1">; Intercambiamos DE y HL para el OR</span>
&nbsp;
   <span class="co1">;;; Dibujar 8 scanlines (DE) -&gt; (HL) + bajar scanline y avanzar en SPR</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
&nbsp;
drawspr8x8m_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos un byte del sprite (el byte de mascara)</span>
   <span class="kw1">AND</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>         <span class="co1">; A = A AND (HL)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; Nos guardamos el valor del AND</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente byte (el dato grafico)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos el byte grafico</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>             <span class="co1">; A = A OR C = A OR (MASK AND FONDO)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Imprimimos el dato tras aplicar operaciones logicas</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente dato del sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; Incrementamos puntero en pantalla (siguiente scanline)</span>
   <span class="kw1">DJNZ</span> drawspr8x8m_loop
&nbsp;
   <span class="co1">;;; En este punto, los 8 scanlines del sprite estan dibujados.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>              <span class="co1">; Recuperamos la posicion de memoria del </span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; scanline inicial donde empezamos a dibujar</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">L</span>            <span class="co1">; BC = HL - 8</span>
&nbsp;
   <span class="co1">;;; Considerar el dibujado de los atributos (Si DS_ATTRIBS=0 -&gt; RET)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>              <span class="co1">; A = 0</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">H</span>           <span class="co1">; A = 0 + H = H</span>
   <span class="kw1">RET</span> Z              <span class="co1">; Si H = 0, volver (no dibujar atributos)</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Obtenemos dir de atributo a partir de</span>
   <span class="kw1">RRCA</span>               <span class="co1">; dir de zona de imagen.</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Nos evita volver a obtener X e Y</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; y hacer el calculo completo de la </span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58             <span class="co1">; direccion en zona de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">C</span>            <span class="co1">; DE tiene el offset del attr de HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>  <span class="co1">; Cogemos el numero de sprite a dibujar</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+DS_NUMSPR = Origen de atributo</span>
&nbsp;
   <span class="co1">;;; Copiar (HL) en (DE) -&gt; Copiar atributo de sprite a pantalla</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Mas rapido que LDI (7+7 vs 16 t-estados)</span>
   <span class="kw1">RET</span>                <span class="co1">; porque no necesitamos incrementar HL y DE </span></pre>

<p>
 La rutina que acabamos de ver presenta los siguientes cambios respecto a las rutinas con LD y OR:
</p>
<ul class="fix-media-list-overlap">
<li> La primera modificación es el
cálculo de la dirección de origen. Antes cada sprite ocupaba 8 bytes por
 lo que teníamos que calcular la dirección origen en el array de Sprites
 así:
</li>
</ul>
<pre class="code">DIR_MEMORIA_GFX = DIR_BASE_SPRITES + (NUM_SPRITE_A_DIBUJAR * 8)</pre>

<p>
 Pero ahora cada sprite tiene por cada byte gráfico un byte de máscara,
ocupando 16 bytes en lugar de 8. El cálculo debe adaptarse pues a:
</p>
<pre class="code">DIR_MEMORIA_GFX = DIR_BASE_SPRITES + (NUM_SPRITE_A_DIBUJAR * 16)</pre>

<p>
 El código para el cálculo agrega un “<strong>ADD HL, HL</strong>” adicional para esta tarea:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>           <span class="co1">; HL = DS_NUMSPR</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 4</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 8</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 16 = DS_NUMSPR * 16</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>        <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 16)</span>
                     <span class="co1">; HL contiene la direccion de inicio en el sprite</span></pre>
<ul class="fix-media-list-overlap">
<li> La segunda modificación principal en
 la rutina es la impresión de cada dato del sprite en sí. En nuestros
sprites con máscara cada bloque de 8 píxeles (1 byte) viene precedido
del byte de la máscara, por lo que debemos recoger ésta, hacer el AND de
 la máscara con el fondo, incrementar DE, recoger el dato gráfico y
hacer el OR de éste con el resultado anterior:
</li>
</ul>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
drawspr8x8m_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos un byte del sprite (el byte de mascara)</span>
   <span class="kw1">AND</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>         <span class="co1">; A = A AND (HL)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; Nos guardamos el valor del AND</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente byte (el dato grafico)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos el byte grafico</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>             <span class="co1">; A = A OR C = A OR (MASK AND FONDO)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Imprimimos el dato tras aplicar operaciones logicas</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente dato del sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; Incrementamos puntero en pantalla (siguiente scanline)</span>
   <span class="kw1">DJNZ</span> drawspr8x8m_loop</pre>

<p>
 No olvidemos que el bucle de operación lógica de la máscara e impresión
 del scanline puede, como en los anteriores casos, ser desenrollado.
</p>

<p>
 Veamos su aplicación en el ejemplo de nuestro pequeño sprite sonriente. En SevenuP, activamos la máscara en <em>Mask → Use Mask</em> y cambiamos al modo “Ver máscara” con <em>Mask → View Mask</em>. Podemos volver al modo de visualización de sprite de nuevo con <em>Mask → View Mask</em>.
</p>

<p>
 En el módo de visualización de máscara, podemos generar la máscara de
nuestro sprite produciendo una versión invertida del mismo. Para
ayudarnos en esa tarea, SevenuP nos muestra con diferentes colores el
estado de los píxeles del sprite, e incluso tiene una opción de “<em>AutoMask</em>” que generará una máscara básica como inversión del sprite para comenzar a trabajar con ella:
</p>

<p>
<br>

<img src="img/gfx3_mask_1.png" class="mediacenter" alt=" La máscara de nuestro pequeño Sprite "/>
</p>
<div style="text-align: center;"><em>La máscara de nuestro pequeño Sprite en SevenuP</em>
</div>
<p>
<br>

</p>

<p>
 En la anterior imagen, tenemos en “negro” los píxeles a respetar en el
fondo, y en blanco y amarillo (dentro de la imagen) los píxeles a
borrar. SevenuP nos marca en diferente color los píxeles a cero de la
máscara que coinciden con los del sprite.
</p>

<p>
 Exportando a ASM este sprite con los parámetros de Prioridad: <em>Mask, X Char, Char line, Y Char</em> y activando “Mask before graphic” obtenemos los siguientes array de datos (con 2 exportaciones por separado de Gfx y Attr):
</p>
<pre class="code">;GRAPHIC DATA:
;Sort Priorities:      Mask, X Char, Char line, Y Char
;Con ancho=1, aparece: Mask, Char line
;Data Outputted:  Gfx+Attr
;Interleave:      Sprite
;Mask:            Yes, before graphic

cara_gfx:
   DEFB   227, 28, 193, 62, 128, 107, 128, 127
   DEFB   128, 93, 128, 99, 193,  62, 227, 28

cara_attrib:
   DEFB   56</pre>

<p>
 Veamos el resultado del mismo ejemplo que hemos usado hasta ahora
(fondo con patrón de píxeles alternados), pero con la rutina de
impresión con máscaras. El código es igual a los 2 ejemplos anteriores,
pero llamando a DrawSprite_8x8_MASK:
</p>

<p>
<br>

<img src="img/gfx3_mask_2.png" class="mediacenter" alt=" Impresión del Sprite con máscara "/>
<br>

</p>

<p>
 Ampliando la anterior captura de pantalla en la zona del sprite,
podemos apreciar que los ojos y la boca de nuestro personaje ya se
visualizan correctamente:
</p>

<p>
<br>

<img src="img/gfx3_mask_3.png" class="mediacenter" alt=" Ampliación del sprite impreso con máscara "/>
<br>

</p>

<p>
 Nuestro pequeño sprite se vería mucho mejor con un reborde vacío
alrededor, ya que hay píxeles del fondo pegados a nuestro personaje. Por
 desgracia, en un sprite de 8×8 como el nuestro apenas nos queda espacio
 para este reborde en la máscara, pero se podría haber aplicado si el
sprite fuera de mayores dimensiones.
</p>

<p>
 Un apunte final sobre los ejemplos que hemos visto: nótese que estamos
llamando a todas las rutinas asignando DS_NUMSPR=0, para imprimir el
“primer” (y único sprite en nuestro caso) del spriteset. El Spriteset
podría tener hasta 255 sprites dispuestos verticalmente (con sus
máscaras intercaladas) y esta misma rutina, sin modificaciones, nos
serviría para dibujar cualquiera de ellos variando DS_NUMSPR.
</p>

<p>
<br>

</p>

</div>

<h2 id="trazado-de-sprites-de-16x16">Trazado de Sprites de 16x16</h2>
<div class="level2">

<p>
<br>

</p>

</div>

<h3 class="sectionedit16" id="impresion-16x16-con-transferencia-por-ld">Impresión 16x16 con Transferencia por LD</h3>
<div class="level3">

<p>
 La impresión de sprites de 16×16 sin máscaras es esencialmente idéntica
 a la de 8×8, ajustando las funciones que hemos visto hasta ahora a las
nuevas dimensiones del sprite:
</p>

<p>
<br>

<img src="img/gfx3_sevenup.png" class="mediacenter" alt=" Sprite de 16x16 pixeles (2x2 caracteres)"/>
<br>

<br>

</p>
<ul class="fix-media-list-overlap">
<li> El cálculo de la dirección origen en
 el sprite cambia, ya que ahora cada scanline ocupa 2 bytes y no 1, y
tenemos 2 bloques de altura en el sprite y no uno. Antes calculábamos la
 dirección origen como BASE+(DS_NUMSPR*8), pero ahora tendremos que
avanzar 8*2*2=32 bytes por cada sprite en los sprites sin máscara. El
cálculo quedaría como BASE+(DS_NUMSPR*32).
</li>
<li><div class="li"> Para multiplicar DS_NUMSPR por 32
vamos a utilizar desplazamientos a la derecha de un pseudo-registro de
16 bits formado por A y L en lugar de utilizar sumas sucesivas <strong>ADD HL, HL</strong>. Esta técnica requiere menos ciclos de reloj para su ejecución.</div>
</li>
<li> La impresión de datos debe imprimir
todo un scanline horizontal del Sprite (2 bytes) antes de avanzar al
siguiente scanline de pantalla.
</li>
<li> El avance al siguiente scanline
cambia ligeramente, ya que necesitamos incrementar HL (concretamente, L)
 para poder imprimir el segundo byte horizontal.
</li>
<li> El bucle vertical es de 16 iteraciones en lugar de 8, ya que el sprite tiene 2 caracteres verticales.
</li>
<li> El cálculo de la dirección origen en
 los atributos cambia, ya que ahora tenemos 4 bytes de atributos por
cada sprite. Así, la posición ya no se calcula como BASE+(DS_NUMSPR*1)
sino como BASE+(DS_NUMSPR*4).
</li>
<li> La impresión de los atributos también cambia, ya que ahora hay que imprimir 4 atributos (2×2 bloques) en lugar de sólo 1.
</li>
</ul>

<p>
 El pseudocódigo de la rutina que tenemos que programar sería el siguiente:
</p>
<pre class="code">; Recoger parametros de entrada
; Calcular posicion origen (array sprites) en DE como
;     direccion = base_sprites + (NUM_SPRITE*32)
; Calcular posicion destino (pantalla) en HL con X e Y

; Repetir 8 veces:
;    Dibujar byte (DE) -&gt; (HL), trazando el scanline del 1er bloque
;    Incrementar HL y DE
;    Dibujar byte (DE) -&gt; (HL), trazando el scanline del 2o bloque
;    Incrementar DE
;    Bajar a siguiente scanline en pantalla (HL), sumando 256 (INC H/DEC L).

; Avanzar puntero de pantalla (HL) a la posicion de la segunda
; fila de bloques a trazar

; Repetir 8 veces:
;    Dibujar byte (DE) -&gt; (HL), trazando el scanline del 1er bloque
;    Incrementar HL y DE
;    Dibujar byte (DE) -&gt; (HL), trazando el scanline del 2o bloque
;    Incrementar DE
;    Bajar a siguiente scanline en pantalla (HL), sumando 256 (INC H/DEC L).

; Si base_atributos == 0 -&gt; RET
; Calcular posicion origen de los atributos array_attr+(NUM_SPRITE*4) en HL.
; Calcular posicion destino en area de atributos en DE.

; Dibujar los atributos (2 filas de 2 atributos, 4 bytes en total):
  ; Copiar (HL) en (DE)
  ; Incrementar HL y DE
  ; Copiar (HL) en (DE)
  ; Incrementar HL
  ; Avanzar a la siguiente línea de atributos en pantalla (DE+=32)
  ; Copiar (HL) en (DE)
  ; Incrementar HL y DE
  ; Copiar (HL) en (DE)</pre>

<p>
 El código completo de la rutina de impresión en 2×2 quedaría, pues, como sigue:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; DrawSprite_16x16_LD:</span>
<span class="co1">; Imprime un sprite de 16x16 pixeles con o sin atributos.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion   Parametro</span>
<span class="co1">; 50000       Direccion de la tabla de Sprites</span>
<span class="co1">; 50002       Direccion de la tabla de Atribs  (0=no atributos)</span>
<span class="co1">; 50004       Coordenada X en baja resolucion</span>
<span class="co1">; 50005       Coordenada Y en baja resolucion</span>
<span class="co1">; 50006       Numero de sprite a dibujar (0-N) </span>
<span class="co1">;-------------------------------------------------------------</span>
DrawSprite_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_LD:
&nbsp;
   <span class="co1">; Guardamos en BC la pareja (x,y) -&gt; B=COORD_Y y C=COORD_X</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>           <span class="co1">; Lo guardamos para luego, lo usaremos para</span>
                     <span class="co1">; calcular la direccion del atributo</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*32)</span>
   <span class="co1">;;; Multiplicamos con desplazamientos, ver los comentarios.</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="re1">0</span>           <span class="co1">; AL = DS_NUMSPR*256</span>
   <span class="kw1">SRL</span> <span class="kw2">A</span>             <span class="co1">; Desplazamos a la derecha para dividir por dos</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*128</span>
   <span class="kw1">RRA</span>               <span class="co1">; Rotamos, ya que el bit que salio de L al CF fue 0</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*64</span>
   <span class="kw1">RRA</span>               <span class="co1">; Rotamos, ya que el bit que salio de L al CF fue 0</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*32</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>           <span class="co1">; HL = DS_NUMSPR*32</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>        <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 32)</span>
                     <span class="co1">; HL contiene la direccion de inicio en el sprite</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>         <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="co1">;;; Repetir 8 veces (primeros 2 bloques horizontales):</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
&nbsp;
drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_loop<span class="re1">1</span>:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>              <span class="co1">; Incrementar puntero en pantalla</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Bloque 2: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementar puntero en sprite</span>
&nbsp;
   <span class="kw1">INC</span> <span class="kw2">H</span>              <span class="co1">; Hay que sumar 256 para ir al siguiente scanline</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>              <span class="co1">; pero hay que restar el INC L que hicimos.</span>
   <span class="kw1">DJNZ</span> drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_loop<span class="re1">1</span>
&nbsp;
   <span class="co1">; Avanzamos HL 1 scanline (codigo de incremento de HL en 1 scanline)</span>
   <span class="co1">; desde el septimo scanline de la fila Y+1 al primero de la Y+2</span>
&nbsp;
   <span class="co1">;;;INC H           ; No hay que hacer INC H, lo hizo en el bucle</span>
   <span class="co1">;;;LD A, H         ; No hay que hacer esta prueba, sabemos que</span>
   <span class="co1">;;;AND 7           ; no hay salto (es un cambio de bloque)</span>
   <span class="co1">;;;JR NZ, drawsp16_nofix_abajop</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, drawsp<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
&nbsp;
drawsp<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop:
&nbsp;
   <span class="co1">;;; Repetir 8 veces (segundos 2 bloques horizontales):</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
&nbsp;
drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_loop2:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>              <span class="co1">; Incrementar puntero en pantalla</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Bloque 2: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementar puntero en sprite</span>
&nbsp;
   <span class="kw1">INC</span> <span class="kw2">H</span>              <span class="co1">; Hay que sumar 256 para ir al siguiente scanline</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>              <span class="co1">; pero hay que restar el INC L que hicimos.</span>
   <span class="kw1">DJNZ</span> drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_loop2
&nbsp;
   <span class="co1">;;; En este punto, los 16 scanlines del sprite estan dibujados.</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">BC</span>             <span class="co1">; Recuperamos el offset del primer scanline</span>
&nbsp;
   <span class="co1">;;; Considerar el dibujado de los atributos (Si DS_ATTRIBS=0 -&gt; RET)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>              <span class="co1">; A = 0</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">H</span>           <span class="co1">; A = 0 + H = H</span>
   <span class="kw1">RET</span> Z              <span class="co1">; Si H = 0, volver (no dibujar atributos)</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Obtenemos dir de atributo a partir de</span>
   <span class="kw1">RRCA</span>               <span class="co1">; dir de zona de imagen.</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Nos evita volver a obtener X e Y</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; y hacer el calculo completo de la </span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58             <span class="co1">; direccion en zona de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">C</span>            <span class="co1">; DE tiene el offset del attr de HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>  <span class="co1">; Cogemos el numero de sprite a dibujar</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+DS_NUMSPR</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+DS_NUMSPR*2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+DS_NUMSPR*3</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+HL=(DS_NUMSPR*4) = Origen de atributo</span>
&nbsp;
   <span class="kw1">LDI</span>
   <span class="kw1">LDI</span>                <span class="co1">; Imprimimos las 2 primeras filas de atributo</span>
&nbsp;
   <span class="co1">;;; Avance diferencial a la siguiente linea de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>            <span class="co1">; A = L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">3</span><span class="re1">0</span>          <span class="co1">; Sumamos A = A + 30 mas los 2 INCs de LDI.</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>            <span class="co1">; Guardamos en L (L = L+30 + 2 por LDI=L+32)</span>
   <span class="kw1">JR</span> NC, drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_attrab_noinc
   <span class="kw1">INC</span> <span class="kw2">D</span>
drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_attrab_noinc:
   <span class="kw1">LDI</span>
   <span class="kw1">LDI</span>
   <span class="kw1">RET</span>                <span class="co1">; porque no necesitamos incrementar HL y DE </span></pre>

<p>
<br>

 Lo primero que nos llama la atención de la rutina es la forma de
multiplicar por 32 el valor de DS_NUMSPR. Una primera aproximación de
multiplicación de HL = NUM_SPR * 32 podría ser aumentar el número de
sumas <strong>ADD HL, HL</strong> tal y como se realizan en las rutinas de 8×8:
</p>
<pre class="code z80">   <span class="co1">;;; Multiplicar DS_SPRITES por 32 con sumas</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>           <span class="co1">; H = 0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>           <span class="co1">; HL = DS_NUMSPR</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 2 </span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 4</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 8</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 16 </span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>        <span class="co1">; HL = HL * 32</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>        <span class="co1">; HL = DS_SPRITES + (DS_NUMSPR * 32)</span></pre>

<p>
 Esta porción de código tarda 11 t-estados por cada ADD de 16 bits, más 7 t-estados de <strong>LD H, 0</strong>, más 4 de <strong>LD L, A</strong>, lo que da un total de 77 t-estados para realizar la multiplicación.
</p>

<p>
 La técnica empleada en el listado, proporcionada por <strong>metalbrain</strong>,
 implica cargar el valor de DS_NUMSPR en la parte alta de un registro de
 16 bits (con lo que el registro tendría el valor de DS_NUMSPR*256, como
 si lo hubieramos desplazado 8 veces a la izquierda), y después realizar
 desplazamientos de 16 bits a la derecha, dividiendo este valor por 2 en
 cada desplazamiento. Con un desplazamiento, obtenemos en el registro el
 valor DS_NUMSPR * 128, con otro desplazamiento DS_NUMSPR * 64, y con
otro más DS_NUMSPR * 32.
</p>

<p>
 Los desplazamientos los tenemos que realizar con el registro A (mas
rápidos), por lo que utilizaremos el par de registros A + L para
realizar la operación y finalmente cargar el resultado en HL:
</p>
<pre class="code z80">   <span class="co1">;;; Multiplicar DS_SPRITES por 32 con desplazamientos &gt;&gt;</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="re1">0</span>           <span class="co1">; AL = DS_NUMSPR*256</span>
   <span class="kw1">SRL</span> <span class="kw2">A</span>             <span class="co1">; Desplazamos a la derecha para dividir por dos</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*128</span>
   <span class="kw1">RRA</span>               <span class="co1">; Rotamos, ya que el bit que salio de L al CF fue 0</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*64</span>
   <span class="kw1">RRA</span>               <span class="co1">; Rotamos, ya que el bit que salio de L al CF fue 0</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*32</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>           <span class="co1">; HL = DS_NUMSPR*32</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>        <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 32)</span>
                     <span class="co1">; HL contiene la direccion de inicio en el sprite</span></pre>

<p>
 Esta porción de código tiene un coste de 11 (ADD) + 8 + 8 + 8 (RR) + 4 +
 4 + 4 (RRA) + 7 + 4 (LD) = 58 t-estados, 29 ciclos de reloj menos que
la rutina con ADD.
</p>

<p>
 Si tuvieramos que multiplicar por 64 (realizar un RRA/RL menos), el
coste sería todavía menor: 12 t-estados menos con un total de 46
t-estados. En el caso de las rutinas de 8×8, resultaba más rápido
realizar la multiplicación por medio de sumas que por desplazamientos,
con un coste total de 55 t-estados.
</p>

<p>
 Otra parte interesante de la rutina de dibujado de sprites está en la
impresión de los datos gráficos. En esta ocasión hay que imprimir 2
bytes horizontales en cada scanline, y sumar 256 para avanzar a la
siguiente línea de pantalla. Esto nos obliga a decrementar HL en 1
unidad (con <strong>DEC L</strong>) para compensar el avance horizontal
utilizado para posicionarnos en el lugar de dibujado del segundo bloque
del sprite. Tras esto, ya podemos hacer el avance de scanline con un
simple <strong>INC H</strong> (HL=HL+256).
</p>

<p>
 Una vez finalizado el bucle de 8 iteraciones que imprime los datos de
los 2 bloques de la fila 1 del sprite, debemos avanzar al siguiente
scanline de pantalla (8 más abajo de la posicion Y inicial) para trazar
los 2 bloques restantes (los bloques “de abajo”). Para ello se ha
insertado el código de “<em>Siguiente_Scanline_HL</em>” dentro de la rutina (evitando el CALL y el RET). La instrucción inicial <strong>INC H</strong> de la rutina que vimos en el capítulo anterior no es necesaria porque la ejecuta la última iteración del bucle anterior.
</p>

<p>
 Tras ajustar HL tenemos que dibujar los 2 últimos bloques del sprite, con un bucle similar al que dibujó los 2 primeros.
</p>

<p>
 Nótese que hemos dividido la impresión de los 16 scanlines en 2 bucles
(1 para cada fila de caracteres). Cada una de las 2 filas a dibujar está
 dentro de una posición de carácter y para avanzar un scanline basta con
 incrementar la parte alta de la dirección, pero para pasar de un bloque
 al siguiente el código es diferente.
</p>

<p>
 El bucle podría haber sido de 16 iteraciones utilizando la rutina
genérica de “Avanzar HL en 1 scanline” (que funciona tanto para avanzar
dentro de un carácter como para avanzar del fin de un carácter al
siguiente), y habría tenido el siguiente aspecto:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span><span class="nu0">6</span>           <span class="co1">; 16 iteraciones</span>
&nbsp;
drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>              <span class="co1">; Incrementar puntero en pantalla</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Bloque 2: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>              <span class="co1">; Decrementamos el avance realizado</span>
&nbsp;
   <span class="co1">; Avanzamos HL 1 scanline (codigo de incremento de HL en 1 scanline)</span>
   <span class="co1">;;;INC H           ; No hay que hacer INC H, lo hizo en el bucle</span>
   <span class="co1">;;;LD A, H         ; No hay que hacer esta prueba, sabemos que</span>
   <span class="co1">;;;AND 7           ; no hay salto (es un cambio de bloque)</span>
   <span class="co1">;;;JR NZ, drawsp16_nofix_abajop</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, drawsp<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
drawsp<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop:
&nbsp;
   <span class="kw1">DJNZ</span> drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_loop</pre>

<p>
 Este código es más pequeño en tamaño que el uso de 2 bucles, pero
estamos efectuando un JR innecesario en 14 de las 16 iteraciones, ya que
 sólo se debe chequear el caracter/tercio en el salto de un bloque de
pantalla al siguiente, que sólo ocurre 1 vez en el caso de un sprite de
2×2  bloques impreso en posiciones de carácter. Además, en la última
iteración es innecesario incrementar y ajustar HL, por lo que son ciclos
 de reloj que se malgastan.
</p>

<p>
 Finalmente, a la hora de escribir los atributos cambia el cálculo de la
 posición origen (ahora es DS_NUMSPR*4, cuya multiplicación realizamos
en base a 4 sumas), así como la copia de los 4 bytes, ya que hay que
imprimir los 2 primeros (LDI + LDI), avanzar DE hasta la siguiente “fila
 de atributos”, y copiar los 2 siguientes (con otras 2 instrucciones
LDI).
</p>

<p>
 Veamos la ejecución de la rutina con un sencillo ejemplo… Primero
dibujamos en SevenuP el pequeño personaje de 2×2 bloques con el que
abríamos este apartado y lo exportamos a ASM:
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">;ASM source file created by SevenuP v1.20</span>
<span class="co1">;GRAPHIC DATA:</span>
<span class="co1">;Pixel Size:      ( 16,  64)</span>
<span class="co1">;Char Size:       (  2,   8)</span>
<span class="co1">;Sort Priorities: X char, Char line, Y char</span>
<span class="co1">;Mask:            No</span>
<span class="co1">;-----------------------------------------------------------------------</span>
&nbsp;
bicho_gfx:
   DEFB    <span class="nu0">8</span>,<span class="re1">1</span><span class="nu0">28</span>,  <span class="nu0">4</span>, <span class="nu0">64</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="nu0">7</span>,<span class="nu0">224</span>
   DEFB   <span class="re1">1</span><span class="nu0">5</span>, <span class="nu0">8</span><span class="re1">0</span>, <span class="re1">1</span><span class="nu0">5</span>, <span class="nu0">8</span><span class="re1">0</span>, <span class="re1">1</span><span class="nu0">5</span>,<span class="nu0">24</span><span class="re1">0</span>,  <span class="nu0">7</span>,<span class="nu0">224</span>
   DEFB    <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">1</span>, <span class="nu0">64</span>,  <span class="re1">0</span>, <span class="nu0">32</span>,  <span class="nu0">2</span>,  <span class="re1">0</span>
   DEFB  <span class="re1">10</span><span class="nu0">4</span>, <span class="nu0">22</span>,<span class="re1">11</span><span class="nu0">2</span>, <span class="re1">1</span><span class="nu0">4</span>, <span class="nu0">56</span>, <span class="nu0">28</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
&nbsp;
bicho_attrib:
   DEFB   <span class="nu0">7</span><span class="re1">0</span>, <span class="nu0">7</span><span class="re1">1</span>, <span class="nu0">67</span>,  <span class="nu0">3</span></pre>

<p>
 A continuación, imprimimos el sprite mediante la siguiente porción de código:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">HL</span>, bicho_gfx
  <span class="kw1">LD</span> <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, bicho_attrib
  <span class="kw1">LD</span> <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">3</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">8</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">CALL</span> DrawSprite_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_LD</pre>

<p>
 Este es el aspecto del sprite impreso en pantalla sobre la trama de píxeles alternos que estamos utilizando hasta el momento:
</p>

<p>
<br>

<img src="img/gfx3_sprite16x16_1.png" class="mediacenter" alt=" Sprite 16x16 impreso en pantalla (sin máscara)"/>
<br>

</p>

<p>
 Ampliando la zona de pantalla con el sprite:
</p>

<p>
<br>

<img src="img/gfx3_sprite16x16_2.png" class="mediacenter" alt=" Ampliación del sprite 16x16 (sin máscara)"/>
<br>

</p>

<p>
<br>

<br>

</p>

</div>

<h3 class="sectionedit17" id="impresion-16x16-usando-operaciones-logicas">Impresión 16x16 usándo operaciones lógicas</h3>
<div class="level3">

<p>
 Podemos convertir la anterior rutina fácilmente en una rutina de impresión con operaciones lógicas añadiendo el <strong>OR (HL)</strong> (o el XOR) antes de la escritura del dato en pantalla.
</p>

<p>
 Simplemente, reemplazaríamos las diferentes operaciones de transferencia cambiando:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>              <span class="co1">; Incrementar puntero en pantalla</span></pre>

<p>
 por:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">OR</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>            <span class="co1">; Realizamos operación lógica</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>              <span class="co1">; Incrementar puntero en pantalla</span></pre>

<p>
 El resto de la rutina es esencialmente idéntico a la versión con transferencias de datos LD.
</p>

<p>
<br>

<br>

</p>

</div>

<h3 class="sectionedit18" id="impresion-16x16-usando-mascaras">Impresión 16x16 usándo máscaras</h3>
<div class="level3">

<p>
 La rutina para dibujar sprites de 16×16 (2×2) con transparencia usando
máscaras también sería una mezcla entre la rutina de 8×8 con máscara y a
 la de 16×16 sin máscara, con el siguiente cambio:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> El cálculo de la dirección origen en
 el sprite cambia, ya que ahora cada scanline ocupa 4 bytes (2 del
sprite y 2 de la máscara) y no 2, y tenemos 2 bloques de altura en el
sprite y no uno. Como tenemos el doble de datos gráficos por cada
sprite, si antes habíamos calculado la dirección origen como
BASE+(DS_NUMSPR*32), ahora tendremos que calcularla como
BASE+(DS_NUMSPR*64). Esta circunstancia nos ahorra un desplazamiento del
 pseudoregistro “AL” hacia la derecha (evitamos un <strong>RRA</strong> + <strong>RR L</strong>), lo que nos permite hacer la operación de multiplicación con sólo 46 t-estados:</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 El código quedaría de la siguiente forma:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; DrawSprite_16x16_MASK:</span>
<span class="co1">; Imprime un sprite de 16x16 pixeles + mascara con o sin atributos.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion   Parametro</span>
<span class="co1">; 50000       Direccion de la tabla de Sprites</span>
<span class="co1">; 50002       Direccion de la tabla de Atribs  (0=no atributos)</span>
<span class="co1">; 50004       Coordenada X en baja resolucion</span>
<span class="co1">; 50005       Coordenada Y en baja resolucion</span>
<span class="co1">; 50006       Numero de sprite a dibujar (0-N) </span>
<span class="co1">;-------------------------------------------------------------</span>
DrawSprite_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_MASK:
&nbsp;
   <span class="co1">; Guardamos en BC la pareja (x,y) -&gt; B=COORD_Y y C=COORD_X</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>           <span class="co1">; Lo guardamos para luego, lo usaremos para</span>
                     <span class="co1">; calcular la direccion del atributo</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*64)</span>
   <span class="co1">;;; Multiplicamos con desplazamientos, ver los comentarios.</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="re1">0</span>           <span class="co1">; AL = DS_NUMSPR*256</span>
   <span class="kw1">SRL</span> <span class="kw2">A</span>             <span class="co1">; Desplazamos a la derecha para dividir por dos</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*128</span>
   <span class="kw1">RRA</span>               <span class="co1">; Rotamos, ya que el bit que salio de L al CF fue 0</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*64</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>           <span class="co1">; HL = DS_NUMSPR*64</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>        <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 64)</span>
                     <span class="co1">; HL contiene la direccion de inicio en el sprite</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>         <span class="co1">; Intercambiamos DE y HL para las OP LOGICAS</span>
&nbsp;
   <span class="co1">;;; Dibujar 8 scanlines (DE) -&gt; (HL) + bajar scanline y avanzar en SPR</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
&nbsp;
drawspr<span class="re1">1</span>6m_loop<span class="re1">1</span>:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos un byte del sprite (el byte de mascara)</span>
   <span class="kw1">AND</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>         <span class="co1">; A = A AND (HL)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; Nos guardamos el valor del AND</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente byte (el dato grafico)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos el byte grafico</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>             <span class="co1">; A = A OR C = A OR (MASK AND FONDO)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Imprimimos el dato tras aplicar operaciones logicas</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente dato del sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>            <span class="co1">; Avanzamos al segundo bloque en pantalla</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos un byte del sprite (el byte de mascara)</span>
   <span class="kw1">AND</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>         <span class="co1">; A = A AND (HL)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; Nos guardamos el valor del AND</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente byte (el dato grafico)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos el byte grafico</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>             <span class="co1">; A = A OR C = A OR (MASK AND FONDO)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Imprimimos el dato tras aplicar operaciones logicas</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente dato del sprite</span>
&nbsp;
   <span class="kw1">DEC</span> <span class="kw2">L</span>            <span class="co1">; Volvemos atras del valor que incrementamos</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; Incrementamos puntero en pantalla (siguiente scanline)</span>
   <span class="kw1">DJNZ</span> drawspr<span class="re1">1</span>6m_loop<span class="re1">1</span>
&nbsp;
   <span class="co1">; Avanzamos HL 1 scanline (codigo de incremento de HL en 1 scanline)</span>
   <span class="co1">; desde el septimo scanline de la fila Y+1 al primero de la Y+2</span>
&nbsp;
   <span class="co1">;;;INC H           ; No hay que hacer INC H, lo hizo en el bucle</span>
   <span class="co1">;;;LD A, H         ; No hay que hacer esta prueba, sabemos que</span>
   <span class="co1">;;;AND 7           ; no hay salto (es un cambio de bloque)</span>
   <span class="co1">;;;JR NZ, drawsp16_nofix_abajop</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">JR</span> NZ, drawsp<span class="re1">1</span>6m_nofix_abajop
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, drawsp<span class="re1">1</span>6m_nofix_abajop
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
drawsp<span class="re1">1</span>6m_nofix_abajop:
&nbsp;
   <span class="co1">;;; Repetir 8 veces (segundos 2 bloques horizontales):</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
&nbsp;
drawspr<span class="re1">1</span>6m_loop2:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos un byte del sprite (el byte de mascara)</span>
   <span class="kw1">AND</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>         <span class="co1">; A = A AND (HL)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; Nos guardamos el valor del AND</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente byte (el dato grafico)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos el byte grafico</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>             <span class="co1">; A = A OR C = A OR (MASK AND FONDO)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Imprimimos el dato tras aplicar operaciones logicas</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente dato del sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>            <span class="co1">; Avanzamos al segundo bloque en pantalla</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos un byte del sprite (el byte de mascara)</span>
   <span class="kw1">AND</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>         <span class="co1">; A = A AND (HL)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>          <span class="co1">; Nos guardamos el valor del AND</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente byte (el dato grafico)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Obtenemos el byte grafico</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>             <span class="co1">; A = A OR C = A OR (MASK AND FONDO)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Imprimimos el dato tras aplicar operaciones logicas</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Avanzamos al siguiente dato del sprite</span>
&nbsp;
   <span class="kw1">DEC</span> <span class="kw2">L</span>            <span class="co1">; Volvemos atras del valor que incrementamos</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; Incrementamos puntero en pantalla (siguiente scanline)</span>
   <span class="kw1">DJNZ</span> drawspr<span class="re1">1</span>6m_loop2
&nbsp;
   <span class="co1">;;; En este punto, los 16 scanlines del sprite estan dibujados.</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">BC</span>             <span class="co1">; Recuperamos el offset del primer scanline</span>
&nbsp;
   <span class="co1">;;; Considerar el dibujado de los atributos (Si DS_ATTRIBS=0 -&gt; RET)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>              <span class="co1">; A = 0</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">H</span>           <span class="co1">; A = 0 + H = H</span>
   <span class="kw1">RET</span> Z              <span class="co1">; Si H = 0, volver (no dibujar atributos)</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Obtenemos dir de atributo a partir de</span>
   <span class="kw1">RRCA</span>               <span class="co1">; dir de zona de imagen.</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Nos evita volver a obtener X e Y</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; y hacer el calculo completo de la </span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58             <span class="co1">; direccion en zona de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">C</span>            <span class="co1">; DE tiene el offset del attr de HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>  <span class="co1">; Cogemos el numero de sprite a dibujar</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+DS_NUMSPR</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+DS_NUMSPR*2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+DS_NUMSPR*3</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = HL+HL=(DS_NUMSPR*4) = Origen de atributo</span>
&nbsp;
   <span class="kw1">LDI</span>
   <span class="kw1">LDI</span>                <span class="co1">; Imprimimos las 2 primeras filas de atributo</span>
&nbsp;
   <span class="co1">;;; Avance diferencial a la siguiente linea de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>            <span class="co1">; A = L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">3</span><span class="re1">0</span>          <span class="co1">; Sumamos A = A + 30 mas los 2 INCs de LDI.</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>            <span class="co1">; Guardamos en L (L = L+30 + 2 por LDI=L+32)</span>
   <span class="kw1">JR</span> NC, drawsp<span class="re1">1</span>6m_attrab_noinc
   <span class="kw1">INC</span> <span class="kw2">D</span>
drawsp<span class="re1">1</span>6m_attrab_noinc:
   <span class="kw1">LDI</span>
   <span class="kw1">LDI</span>
   <span class="kw1">RET</span>                <span class="co1">; porque no necesitamos incrementar HL y DE </span></pre>

<p>
 Datos a destacar sobre el código:
</p>
<ul class="fix-media-list-overlap">
<li> Al igual que en el caso de la rutina
 con LD y con OR, el bucle de 16 iteraciones de la rutina de impresión
con máscaras, se debería desenrollar si el trazado de sprites es una
rutina prioritaria en nuestro programa (que suele ser el caso,
especialmente en juegos). No obstante, hay que tener en cuenta que
desenrollar estos 2 bucles supone añadir a la rutina 14 veces el tamaño
de cada iteración (hay 16 iteraciones, en el código hay 2 de ellas
repetidas 8 veces, por lo que en desenrollamiento añadiría 14 veces el
código de impresión). Esto puede suponer un problema cuando los
programas son grandes y nos acercamos a los límites de la memoria del
Spectrum.
</li>
</ul>

<p>
 Probemos la rutina con un spriteset de múltiples sprites de 2×2 bloques con su máscara:
</p>

<p>
<br>

<img src="img/gfx3_sevenup_vertical.png" class="mediacenter" alt=" Sprites a exportar "/>
<br>

</p>

<p>
 Exportados con los parámetros adecuados, nos queda el siguiente resultado en forma de array:
</p>
<pre class="code">;-----------------------------------------------------------------------
; ASM source file created by SevenuP v1.20
; SevenuP (C) Copyright 2002-2006 by Jaime Tejedor Gomez, aka Metalbrain
;GRAPHIC DATA:
;Pixel Size:      ( 16,  64)
;Char Size:       (  2,   8)
;Sort Priorities: Mask, X char, Char line, Y char
;Data Outputted:  Gfx+Attr
;Mask:            Yes, before graphic
;-----------------------------------------------------------------------

bicho_gfx:
 DEFB	247,  8,127,128,251,  4,191, 64, 255,  0,255,  0,248,  7, 31,224
 DEFB	240, 15, 15, 80,240, 15, 15, 80, 240, 15, 15,240,248,  7, 31,224
 DEFB	255,  0,255,  0,254,  1,191, 64, 255,  0,223, 32,253,  2,255,  0
 DEFB	151,104,233, 22,143,112,241, 14, 199, 56,227, 28,255,  0,255,  0
 DEFB	251,  4,191, 64,255,  0,255,  0, 248,  7, 31,224,240, 15, 15, 80
 DEFB	240, 15, 15, 80,240, 15, 15,240, 248,  7, 31,224,255,  0,255,  0
 DEFB	255,  0,255,  0,254,  1,191, 64, 255,  0,255,  0,253,  2,223, 32
 DEFB	247,  8,255,  0,241, 14,143,112, 248,  7,135,120,255,  0,255,  0
 DEFB	253,  2,223, 32,255,  0,255,  0, 252,  3, 15,240,248,  7,  7,168
 DEFB	248,  7,  7,168,248,  7,  7,248, 252,  3, 15,240,255,  0,255,  0
 DEFB	255,  0,255,  0,254,  1,191, 64, 255,  0,255,  0,254,  1,191, 64
 DEFB	255,  0,255,  0,253,  2, 31,224, 250,  5, 15,240,255,  0,255,  0
 DEFB	254,  1,239, 16,253,  2,223, 32, 255,  0,255,  0,252,  3, 15,240
 DEFB	248,  7,  7,168,248,  7,  7,168, 248,  7,  7,248,252,  3, 15,240
 DEFB	255,  0,255,  0,254,  1,191, 64, 255,  0,223, 32,253,  2,255,  0
 DEFB	151,104,233, 22,143,112,241, 14, 199, 56,227, 28,255,  0,255,  0

bicho_attrib:
 DEFB 70, 71, 67,  3, 70, 71, 67,  3, 70, 71,  3, 67, 70, 71,  3, 67</pre>

<p>
 La siguiente captura muestra la impresión de uno de los sprites de 2×2
bloques del tileset usando su correspondiente máscara sobre nuestro
fondo de píxeles alternos:
</p>

<p>
<br>

<img src="img/gfx3_spr16x16_mask.png" class="mediacenter" alt=" Sprite 16x16 con máscara sobre fondo alterno "/>
<br>

</p>

<p>
 En ella, resulta evidente el problema del <strong>colour clash</strong> o <strong>colisión de atributos</strong>.
</p>

<p>
<br>

<img src="img/gfx3_spr16x16_mask2.png" class="mediacenter" alt=" Zoom del sprite 16x16 con máscara sobre fondo alterno "/>
<br>

</p>

<p>
 Por desgracia, debido a las características de color en baja resolución
 del Spectrum, el uso de máscaras con sprites multicolor sobre fondos
con patrones provoca este tipo de resultados. Los sprites multicolor con
 máscara deben utilizarse en otras circunstancias / formatos de juego.
</p>

<p>
 Por ejemplo, si el juego fuera monocolor y no imprimieramos los
atributos del sprite, el resultado sería mucho más agradable a la vista:
</p>

<p>
<br>

<img src="img/gfx3_16x16_mask3.png" class="mediacenter" alt=" Sprite 16x16 impreso sin atributos "/>
<br>

</p>

<p>
 El resultado en esta ocasión es mucho mejor, aunque este sprite sigue
necesitando claramente un reborde generado vía máscara para una
impresión mucho más agradable a la vista, aún en un fondo tan
“desfavorable” como es este patrón de píxeles alternos.
</p>

<p>
 Y es que, como vamos a ver a continuación, cada técnica de impresión tiene una situación de aplicación válida.
</p>

<p>
<br>

</p>

</div>

<h2 id="tecnicas-de-impresion-adecuadas-a-cada-tipo-de-juego">Técnicas de impresión adecuadas a cada tipo de juego</h2>
<div class="level2">

<p>
 Hemos visto en este capítulo 3 técnicas diferentes de impresión de Sprites, las cuales nos dan 4 posibilidades:
</p>

<p>
<br>

<br>

<strong>Impresión con transferencia (LD/LDI):</strong>
</p>

<p>
La impresión por transferencia directa de datos (sprite → pantalla) es
adecuada para juegos con movimiento “bloque a bloque” (en baja
resolución), donde todos los sprites (y el mapa de juego) se mueven en
la rejilla de 32×24 bloques del Spectrum (juegos de puzzle, rogue-likes,
 juegos basados en mapas de bloques, etc).
</p>

<p>
<br>

<img src="img/gfx3_impld.png" class="mediacenter" alt=" Juegos adecuados para impresión por transferencia "/>
</p>
<div style="text-align: center;"><em>Tetris, Plotting, Maziacs y Boulder Dash</em>
</div>
<p>
<br>

</p>

<p>
 En estos juegos no suele ser necesario tener transparecia con el fondo
(al ser plano) y no coinciden 2 sprites en la misma cuadrícula (si lo
hacen, es, por ejemplo, para recoger un objeto).
</p>

<p>
<br>

<br>

<strong>Impresión por operación lógica OR:</strong>
</p>

<p>
 La impresión por OR es adecuada en juegos donde el personaje no tenga
pixeles a cero dentro de su contorno, de forma que no se vean píxeles
del fondo en el interior de nuestro personaje, alterando el sprite.
</p>

<p>
 La segunda opción (y la más habitual) es su uso en juegos donde (sea
como sea el personaje del jugador) el fondo sea plano (sin tramas) y el
color del mismo sea idéntico al color de PAPER de los sprites del juego.
 De esta forma nos podemos mover en el juego sin causar colisión de
atributos con el fondo (ya que no tiene pixeles activos y el PAPER del
fondo es igual al PAPER de nuestro Sprite) y podemos ubicar en la
pantalla objetos multicolor en posiciones de carácter que no provoquen
colisión de atributos con nuestro personaje o si la provocan sea
imperceptible (elemento muy ajustado a tamaño de carácter) o durante un
período de tiempo mínimo (recogida de un objeto).
</p>

<p>
<br>

<img src="img/gfx3_impor.png" class="mediacenter" alt=" Juegos adecuados para impresión por OR "/>
</p>
<div style="text-align: center;"><em>Manic Miner, Dizzy, Dynamite Dan y Fred</em>
</div>
<p>
<br>

</p>

<p>
<br>

<br>

<strong>Impresión por operación lógica XOR:</strong>
</p>

<p>
 Más que juegos adecuados para esta técnica, podemos hablar más bien de
sprites adecuados para ella. Nos referimos a los cursores, que suelen
ser dibujados con XOR para no confundirse con el fondo (permitiendo una
visión “inversa” del mismo sobre el sprite) y para poder ser borrados
con otra operación XOR.
</p>

<p>
<br>

<br>

<strong>Impresión con máscaras:</strong>
</p>

<p>
 Por norma general, las rutinas de impresión de sprites con máscara se
utilizan principalmente en juegos monocolor donde todo el área de juego
(fondo incluído) y los personajes comparten el mismo atributo de
pantalla. De esta forma, la impresión del sprite no cambia el color de
los píxeles del fondo que caen dentro de su recuadro y además nos
ahorramos la impresión de los atributos, puesto que se realiza
rellenando los atributos del área de juego una única vez durante el
dibujado inicial de la pantalla.
</p>

<p>
 Una segunda opción es que el fondo sea multicolor y nuestro personaje
se imprima sin atributos, adaptandose el personaje al color del fondo
sin cambiar éste. En la captura de abajo tenemos al personaje principal
de <em>Target: Renegade</em> adoptando los atributos de las posiciones de pantalla donde es dibujado.
</p>

<p>
<br>

<img src="img/gfx3_impmask.png" class="mediacenter" alt=" Juegos adecuados para impresión por máscara "/>
</p>
<div style="text-align: center;"><em>H.A.T.E., Arkanoid, Rick Dangerous y Target: Renegade</em>
</div>
<p>
<br>

</p>

<p>
<br>

 Así pues, a la hora de realizar un juego, deberemos elegir la técnica más adecuada al tipo de juego que vamos a programar.
</p>

<p>
<br>

</p>

</div>

<h2 id="rutina-generica-trazado-de-sprites-multicaracter">Rutina genérica trazado de Sprites multicarácter</h2>
<div class="level2">

<p>
 Nuestro siguiente paso sería el de crear una rutina de sprites que
sirva para cualquier resolución de bloques de un sprite, a la que además
 de los parámetros anteriores se le tendría que añadir el ancho y alto
del sprite.
</p>

<p>
 Como no conocemos de antemano las dimensiones del sprite, todos los
cálculos de dirección de origen de datos gráficos y de atributos se
deben de basar en multiplicaciones realizadas con bucles. El bucle
basado en el número de scanlines (<em>ALTO_en_pixeles</em> iteraciones) no se puede desenrollar y cada una de las transferencias de datos tiene que realizarse también en un bucle de <em>ANCHO_en_caracteres</em>
 iteraciones. Además, como necesitamos realizar varios bucles,
utilizaremos más registros y por lo tanto nos veremos en la necesidad de
 alojar valores en la pila o en variables temporales o incluso de
recuperar parámetros más de una vez dentro de la rutina.
</p>

<p>
 La rutina resultante es mucho menos óptima y rápida que cualquier
rutina específica de 8×8, 8×16, 16×8, 16×16, etc. Si tenemos
predefinidos todos los tamaños de los sprites de nuestro juego es
recomendable utilizar estas rutinas específicas en lugar de una rutina
genérica.
</p>

<p>
 La rutina que crearemos permitirá la impresión de sprites de cualquier
tamaño con la única restricción que Ancho * Alto en caracteres no supere
 el valor de 255, por ejemplo, se podría imprimir un sprite de 15×16 o
16×15 bloques.
</p>

<p>
 La rutina, al ser genérica, y para que pueda ser legible por el lector,
 no es especialmente eficiente: debido a la necesidad de realizar
multiplicaciones de 16 bits, se utilizan los registros HL, DE y BC y nos
 vemos obligados a hacer continuos PUSHes y POPs de estos registros, así
 como a apoyarnos en variables de memoria. La rutina podría ser
optimizada en cuanto a algoritmo y/o en cuanto a reordenación de código y
 uso de shadow-registers para tratar de ganar todos los t-estados
posibles.
</p>

<p>
 Incluso una opción mucho más recomendable sería crear tantas rutinas
específicas como tamaños de sprites tengamos en nuestro juego y hacer
una rutina “maestra” (un <em>wrapper</em>) que llame a una u otra según
el tamaño del Sprite que estemos solicitando imprimir. Un par de
comprobaciones sobre el ancho y el alto del Sprite y saltos
condicionales con un CALL final a la rutina adecuada resultará muchísimo
 más óptimo que la rutina que vamos a examinar:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; DrawSprite_MxN_LD:</span>
<span class="co1">; Imprime un sprite de MxN pixeles con o sin atributos.</span>
<span class="co1">; Maximo, 16x15 / 15x16 bloques de ancho x alto caracteres.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion   Parametro</span>
<span class="co1">; 50000       Direccion de la tabla de Sprites</span>
<span class="co1">; 50002       Direccion de la tabla de Atribs  (0=no atributos)</span>
<span class="co1">; 50004       Coordenada X en baja resolucion</span>
<span class="co1">; 50005       Coordenada Y en baja resolucion</span>
<span class="co1">; 50006       Numero de sprite a dibujar (0-N) </span>
<span class="co1">; 50010       Ancho del sprite en caracteres</span>
<span class="co1">; 50011       Alto del sprite en caracteres </span>
<span class="co1">;-------------------------------------------------------------</span>
DrawSprite_MxN_LD:
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*ANCHO*ALTO) </span>
&nbsp;
   <span class="co1">;;;; Multiplicamos ancho por alto (en bloques)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_WIDTH<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_HEIGHT<span class="br0">)</span>
   <span class="kw1">RLCA</span>               <span class="co1">; Multiplicamos por 8, necesitamos</span>
   <span class="kw1">RLCA</span>               <span class="co1">; la altura en pixeles (FILAS*8)</span>
   <span class="kw1">RLCA</span>               <span class="co1">; Y la guardamos porque la necesitaremos:</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawsp_height<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
   <span class="co1">;;; Multiplicamos Ancho_bloques * Alto_pixeles:</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>              <span class="co1">; A = 0</span>
drawsp_mul<span class="re1">1</span>:
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>           <span class="co1">; A = A + C   (B veces)  = B*C</span>
   <span class="kw1">DJNZ</span> drawsp_mul<span class="re1">1</span>   <span class="co1">; B veces -&gt; A = A*C = Ancho * Alto</span>
                      <span class="co1">; Ahora A = Ancho*Alto (maximo 255!!!)</span>
&nbsp;
   <span class="co1">;;; Multiplicamos DS_NUMSPR por (Ancho_bloques*Alto_pixeles)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; Repetimos Ancho * Alto veces</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">H</span>            <span class="co1">; HL = 0</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>            <span class="co1">; DE = DS_NUMSPR</span>
drawsp_mul2:
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">DE</span>         <span class="co1">; HL = HL+DS_NUMSPR</span>
   <span class="kw1">DJNZ</span> drawsp_mul2   <span class="co1">; Sumamos HL+DE B veces = DS_NUMSPR*B</span>
&nbsp;
                      <span class="co1">; guardamos el valor de ancho*alto_pixeles*NUMSPR</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawsp_width_by_height<span class="br0">)</span>, <span class="kw2">HL</span>
&nbsp;
   <span class="co1">;;; Calculamos direccion origen copia en el sprite</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR*ANCHO*ALTO)</span>
                      <span class="co1">; HL contiene la direccion de inicio en el sprite</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>     <span class="co1">; B = Y,  C = X</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>            <span class="co1">; Lo guardamos para luego, lo usaremos para</span>
                      <span class="co1">; calcular la direccion del atributo</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>          <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
&nbsp;
   <span class="co1">;;; Bucle de impresión vertical</span>
                      <span class="co1">; Recogemos de nuevo la altura en pixeles</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>drawsp_height<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>            <span class="co1">; Contador del bucle exterior del bucle</span>
&nbsp;
drawsp_yloop:
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">B</span>            <span class="co1">; Nos guardamos el contador</span>
&nbsp;
   <span class="co1">;;; Bucle de impresion horizontal</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_WIDTH<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>            <span class="co1">; Guardamos en pila inicio de scanline</span>
                      <span class="co1">; para poder volver a el luego</span>
drawsp_xloop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>              <span class="co1">; Incrementar puntero en pantalla</span>
   <span class="kw1">DJNZ</span> drawsp_xloop
   <span class="kw1">POP</span> <span class="kw2">HL</span>             <span class="co1">; Recuperamos de pila inicio de scanline</span>
&nbsp;
   <span class="co1">;;; Avanzamos al siguiente scanline de pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">JR</span> NZ, drawspNM_nofix
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, drawspNM_nofix
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
drawspNM_nofix:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">C</span>
   <span class="kw1">DJNZ</span> drawsp_yloop  <span class="co1">; Repetimos "alto_en_pixeles" veces</span>
&nbsp;
   <span class="co1">;;; Aqui hemos dibujado todo el sprite, vamos a los attributos</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">BC</span>             <span class="co1">; Recuperamos el offset del primer scanline</span>
&nbsp;
   <span class="co1">;;; Considerar el dibujado de atributos (Si DS_ATTRIBS=0 -&gt; RET)</span>
   <span class="kw1">LD</span>  <span class="kw2">A</span>,<span class="br0">[</span>DS_ATTRIBS<span class="sy0">+</span><span class="re1">1</span><span class="br0">]</span>     <span class="co1">; para obtener la parte alta de la direccion</span>
   <span class="kw1">OR</span>  <span class="kw2">A</span>                    <span class="co1">; para comprobar si es 0</span>
   <span class="kw1">RET</span> Z                    <span class="co1">; Si H = 0, volver (no dibujar atributos)</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>            <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Obtenemos dir de atributo a partir de</span>
   <span class="kw1">RRCA</span>               <span class="co1">; dir de zona de imagen.</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Nos evita volver a obtener X e Y</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>              <span class="co1">; y hacer el calculo completo de la </span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58             <span class="co1">; direccion en zona de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">C</span>            <span class="co1">; DE tiene el offset del attr de HL</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>            <span class="co1">; Guardamos una copia</span>
&nbsp;
   <span class="co1">; Recuperamos el valor de ancho_caracteres * alto_en_pixeles * NUMSPR</span>
   <span class="co1">; para ahorrarnos repetir otra vez dos multiplicaciones:</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>drawsp_width_by_height<span class="br0">)</span>
&nbsp;
   <span class="co1">;;; HL = ANCHO_BLOQUES*ALTO_PIXELES*NUMSPR</span>
   <span class="co1">;;; El Alto lo necesitamos en BLOQUES, no en píxeles-&gt; dividir /8</span>
   <span class="kw1">SRL</span> <span class="kw2">H</span>     <span class="co1">; Desplazamos H a la derecha</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>      <span class="co1">; Rotamos L a la derecha introduciendo CF</span>
   <span class="kw1">SRL</span> <span class="kw2">H</span>     <span class="co1">;</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>      <span class="co1">;</span>
   <span class="kw1">SRL</span> <span class="kw2">H</span>     <span class="co1">;</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>      <span class="co1">; Resultado : HL = HL &gt;&gt; 3 = HL / 8</span>
&nbsp;
   <span class="co1">;;;; HL = ANCHO_BLOQUES*ALTO_BLOQUES*NUMSPR</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">L</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">H</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = Base_Atributos + (DS_NUMSPR*ALTO*ANCHO)</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">DE</span>             <span class="co1">; Recuperamos direccion destino</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_HEIGHT<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
&nbsp;
   <span class="co1">;;; Bucle impresion vertical de atributos</span>
drawsp_attyloop:
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">B</span>
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>            <span class="co1">; Guardamos inicio de linea de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_WIDTH<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
&nbsp;
   <span class="co1">;;; Bucle impresion horizontal de atributos</span>
drawsp_attxloop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>         <span class="co1">; Leer atributo del sprite</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribir atributo</span>
   <span class="kw1">INC</span> <span class="kw2">E</span>
   <span class="kw1">DJNZ</span>  drawsp_attxloop
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">DE</span>             <span class="co1">; Recuperamos inicio de linea de atributos</span>
&nbsp;
   <span class="co1">;;; Avance diferencial a la siguiente linea de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> NC, drawsp_attrab_noinc
   <span class="kw1">INC</span> <span class="kw2">D</span>
drawsp_attrab_noinc:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">C</span>
   <span class="kw1">DJNZ</span> drawsp_attyloop
&nbsp;
   <span class="kw1">RET</span>
&nbsp;
drawsp_height          DB <span class="re1">0</span>
drawsp_width_by_height DW <span class="re1">0</span></pre>

<p>
 Nótese que pese al uso extensivo de registros y memoria, todavía
podemos realizar algunas optimizaciones, como la de “reaprovechar” el
cálculo de Ancho*Alto*NUMSPR realizado al principio de la rutina
(gráficos) para los cálculos del final (atributos). Como la
multiplicación inicial tiene Alto en píxeles y lo necesitamos en
Caracteres, dividimos el registro HL por 8 mediante instrucciones de
desplazamiento que afecten a su parte baja y su parte alta.
</p>

<p>
 La anterior rutina sería llamada de la siguiente forma para imprimir nuestro ya conocido sprite de 2×2 bloques:
</p>
<pre class="code z80">  ORG <span class="nu0">32768</span>
&nbsp;
DS_SPRITES  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">0000</span>
DS_ATTRIBS  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">2</span>
DS_COORD_X  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">4</span>
DS_COORD_Y  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">5</span>
DS_NUMSPR   <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">6</span>
DS_WIDTH    <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">0010</span>
DS_HEIGHT   <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">0011</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, bicho_gfx
  <span class="kw1">LD</span> <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, bicho_attrib
  <span class="kw1">LD</span> <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">3</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">8</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">2</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_WIDTH<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">2</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_HEIGHT<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
  <span class="kw1">CALL</span> DrawSprite_MxN_LD
  <span class="kw1">RET</span></pre>

<p>
 La rutina anterior trabaja mediante transferencia de datos sprite →
pantalla. Para realizar una operación lógica, bastará modificar el bucle
 horizontal de impresión y añadir el correspondiente OR / XOR contra
(HL).
</p>

<p>
 La rutina para trabajar con máscaras implicar modificar el bucle
principal para gestionar los datos de la máscara y modificar también las
 multiplicaciones iniciales de parámetros (*2 en el caso de los datos
gráficos, sin modificación en los atributos).
</p>

<p>
<br>

</p>

</div>

<h2 id="borrado-de-sprites-y-restauracion-del-fondo">Borrado de Sprites y Restauración del fondo</h2>
<div class="level2">

<p>
 Una vez vistas las rutinas de impresión, hay que tratar el tema del
borrado de los sprites de pantalla. El proceso de movimiento y animación
 implica el borrado del Sprite de su anterior posición (o en la actual
si sólo cambia el fotograma) y el redibujado del mismo.
</p>

<p>
 Hay diferentes técnicas de borrado de sprites, en las que profundizaremos cuando tratemos las <em>Animaciones</em>, pero podemos distinguir inicialmente las 4 siguientes:
</p>

<p>
<br>

<br>

<strong>Borrado de sprite por sobreimpresión:</strong>
</p>

<p>
 Se utiliza con rutinas de impresión sin transparencia y se basa en
imprimir otro sprite encima del que queremos borrar. Ese otro sprite
puede ser, en juegos de fondo plano, un tile totalmente vacío con los
colores o patrones del fondo (un “<em>blanco</em>”) de forma que eliminemos el sprite y recuperemos el fondo que había en esa posición antes de imprimirlo.
</p>

<p>
 En juegos de fondo monocolor (típicamente fondo negro) se suele
reservar el bloque 0 del SpriteSet para alojar un “bloque vacío” de
fondo que sirva de tile con el que sobreescribir con LDs una posición de
 sprite para borrarlo.
</p>

<p>
<br>

<br>

<strong>Borrado de sprite por borrado de atributos:</strong>
</p>

<p>
 En juegos con fondo plano (ejemplo: fondo totalmente negro) y
movimiento a bloques, podemos borrar un sprite que está sobre el fondo
simplemente cambiando los atributos de las celdillas de pantalla a
borrar a tinta y papel del color del fondo. Por ejemplo, en un fondo
negro, se podría borrar un sprite de 16×16 pixeles con 4 simples
operaciones de escritura de atributo de color tinta=papel=negros. Cuando
 otro sprite sea dibujado sobre nuestro “sprite borrado”, si se hace con
 una operación de transferencia eliminará todo rastro gráfico del Sprite
 anterior.
</p>

<p>
 Si el juego no tiene movimiento por bloques, aún podemos aprovechar esta técnica mediante el sistema descrito por <em>TrueVideo</em>
 en los foros de Speccy.org: utilizando una tabla de 32×24 bytes que
represente el estado de ocupación de las celdillas de pantalla.
</p>

<p>
 Citando a TrueVideo:
</p>
<pre class="code">El buffer al que me refiero puedes verlo como una segunda capa de atributos,
que es la forma más fácil de implementar. Es una zona de memoria de
32x24 = 768 bytes (como el area de atributos) en la que se marcan los caracteres
ocupados en cada momento.

Algunas pistas para implementarlo:

- cuando vayas a imprimir un caracter consulta primero su entrada en el buffer.
Si está libre puedes volcar el gráfico directamente con LD (HL),A... porque es
más rápido y sabes *seguro* que puedes machacar lo que haya en pantalla. Si por
el contrario está ocupado (o sea, hay otro sprite en esa posición) sabes que tienes
que imprimir mezclando para preservar el fondo (p.e. con XOR). De esta forma tu
rutina de impresión imprimirá siempre de la forma más rápida posible, excepto en
los caracteres que se superpongan.

- con este método puedes borrar pintando atributos en lugar de volcar blancos con
toda seguridad, sin riesgo a que se vea basura, porque la rutina de impresión de
caracteres sabe en todo momento cuándo mezclar y cuándo no.

- es importante elegir con cabeza la dirección en memoria del buffer. Teniendo en
cuenta que el área de atributos de la pantalla empieza en $5800, si el buffer lo
sitúas p.e. en $xx00 (donde xx es la dirección que tu quieras de la parte alta)
entonces puedes moverte de una zona a otra cambiando sólo la parte alta del
registro. En general es buena idea usar siempre la dirección de atributos como
base para todos tus cálculos: a partir de una dirección de atributos puedes calcular
fácilmente la dirección del archivo de pantalla.. y también enlazar con otros bufferes
propios de forma rápida. Por el contrario al trabajar con coordenadas (por decir algo)
los cálculos para referenciar los buffers (de atributos o propios) son más costosos.

La ventaja de todo esto es que, a cambio de mantener ese buffer, nos aseguramos de
que borramos siempre muy rápido e imprimimos "lento" sólo cuando es estrictamente
necesario.</pre>

<p>
<br>

<br>

<strong>Borrado (e impresión) con XOR</strong>
</p>

<p>
 Cuando un sprite ha sido dibujado con la operación XOR, podemos
borrarlo realizando otra impresión en la misma posición mediante la
misma operación. Esto es así porque la operación XOR es reversible.
</p>

<p>
 Veamos la tabla de verdad de la operación XOR:
</p>
<div class="table-responsive sectionedit22"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Bit Pantalla </th><th class="col1"> Bit Sprite </th><th class="col2"> XOR </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0 centeralign">  0  </td><td class="col1 centeralign">  0  </td><td class="col2 centeralign">  0  </td>
	</tr>
	<tr class="row2">
		<td class="col0 centeralign">  0  </td><td class="col1 centeralign">  1  </td><td class="col2 centeralign">  1  </td>
	</tr>
	<tr class="row3">
		<td class="col0 centeralign">  1  </td><td class="col1 centeralign">  0  </td><td class="col2 centeralign">  1  </td>
	</tr>
	<tr class="row4">
		<td class="col0 centeralign">  1  </td><td class="col1 centeralign">  1  </td><td class="col2 centeralign">  0  </td>
	</tr>
</tbody></table></div>

<p>
 A continuación tenemos un ejemplo de cómo restaurar el fondo gracias a XOR:
</p>
<pre class="code">Impresión del sprite con XOR:
-----------------------------
Fondo:    01010101
Sprite:   00111000
Tras XOR: 01101101


Recuperación del fondo con XOR:
-------------------------------
Fondo:    01101101
Sprite:   00111000
Tras XOR: 01010101   &lt;-- Valor original de la pantalla</pre>

<p>
 La impresión de un sprite con XOR produce una especie de “negativo” del
 Sprite en la pantalla allá donde haya píxeles de fondo activos, por lo
que esto, unido a la facilidad de borrado, lo hace ideal para la
impresión de cursores y punteros.
</p>

<p>
<br>

<br>

<strong>Almacenamiento en buffer temporal</strong>
</p>

<p>
 La última solución es la más costosa en términos de memoria y de
instrucciones, pero nos permite restaurar el estado del fondo sea cual
sea el número de sprites impresos y las características de este.
</p>

<p>
 La técnica consiste en almacenar el contenido de los datos gráficos y
de atributo del fondo en un array de memoria temporal antes de volcar el
 sprite sobre la pantalla.
</p>

<p>
 Podríamos realizar una función específica para esta tarea (recuperar
una porción de fondo, o lo que es lo mismo, crear un sprite tomando los
datos de la pantalla); sería una modificación de las rutinas de
impresión donde el origen sería la pantalla y el destino el array. No
obstante, esto no es eficiente porque estaríamos realizando las
operaciones de cálculo de posiciones 2 veces: una al salvaguardar el
contenido del fondio y otra, más tarde, al llamar a la función de
dibujado del Sprite.
</p>

<p>
 Para evitar esto, podemos adaptar las rutinas de impresión para que
salvaguarden el fondo en nuestro array temporal antes de escribir los
datos en pantalla.
</p>

<p>
 Como tenemos ya utilizados DE y HL para la transferencia del Sprite,
necesitamos un registro de 16 bits adicional. En este caso utilizaremos
el registro IX para apuntar al array temporal.
</p>

<p>
 Podemos modificar cualquiera de las rutinas para recuperar el fondo
antes de escribir el sprite. Tomemos como ejemplo el esqueleto de la
rutina de impresión de 8×8 y veamos las instrucciones que habría que
añadir para salvaguardar el fondo en un array temporal externo. No
reproduciremos la totalidad de la rutina reducir la extensión del
listado:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; DrawSprite_8x8_Restore:</span>
<span class="co1">; Imprime un sprite de 8x8 pixeles salvaguardando el fondo</span>
<span class="co1">; en la direccion de memoria indicada por (50008).</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion   Parametro</span>
<span class="co1">; 50000       Direccion de la tabla de Sprites</span>
<span class="co1">; 50002       Direccion de la tabla de Atribs  (0=no atributos)</span>
<span class="co1">; 50004       Coordenada X en baja resolucion</span>
<span class="co1">; 50005       Coordenada Y en baja resolucion</span>
<span class="co1">; 50006       Numero de sprite a dibujar (0-N) </span>
<span class="co1">; 50008       Direccion del array temporal para el fondo</span>
<span class="co1">;-------------------------------------------------------------</span>
DS_TEMPBUF <span class="kw3">EQU</span> <span class="nu0">5</span><span class="re1">000</span><span class="nu0">8</span>
&nbsp;
   <span class="co1">;;; Recogida de datos y parametros</span>
   <span class="br0">(</span>...<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="br0">(</span>DS_TEMPBUF<span class="br0">)</span>
   <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
   <span class="co1">;;; Bucle de impresion del Sprite:</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>          <span class="co1">; 8 scanlines</span>
&nbsp;
drawsp8x8_loopLD:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>       <span class="co1">; NUEVO: Leemos el valor actual del fondo</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">IX</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; NUEVO: Lo almacenamos en el array temporal</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>           <span class="co1">; NUEVO: Incrementamos IX (puntero array fondo)</span>
&nbsp;
                    <span class="co1">; Ya podemos imprimir el sprite</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Tomamos el dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>           <span class="co1">; Incrementamos puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>            <span class="co1">; Incrementamos puntero en pantalla (scanline+=1)</span>
   <span class="kw1">DJNZ</span> drawsp8x8_loopLD
&nbsp;
   <span class="br0">(</span>...<span class="br0">)</span>
   <span class="co1">;;; Impresion de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; NUEVO: Leemos el atributo actual</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">IX</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; NUEVO: Lo guardamos en el array temporal</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>       <span class="co1">; Ya podemos imprimir el atributo</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span></pre>

<p>
 El registro IX no es especialmente rápido (10 t-estados el <strong>INC IX</strong> y 19 t-estados el <strong>LD (IX), A</strong> o <strong>LD (IX+0), A</strong>, pero es más rápido utilizarlo que escribir y ejecutar una rutina adicional para almacenar el fondo.
</p>

<p>
 Cuando necesitemos borrar el sprite, bastará con recuperar el fondo que
 había antes de imprimirlo, es decir, volcar el contenido del buffer
temporal en la posición del sprite a borrar. Para realizar este volcado
podemos llamar a una de las funciones de volcado de Sprites basada en
transferencias ya que el buffer del fondo en memoria se corresponde con
un spriteset de 1 sólo elemento (DS_NUMSPR=0), sin máscara. Las rutinas
impresión de 8×8, 16×16 o genéricas basadas en LD servirían para
recuperar el contenido del fondo usando como origen el buffer temporal
donde lo hemos almacenado.
</p>

<p>
 Si tenemos más de un Sprite y hemos almacenado el fondo de cada uno de
ellos en un array diferente, debemos restaurar todos los fondos en orden
 inverso al que se haya realizado la impresión. Veamos por qué:
</p>

<p>
 Supongamos que imprimimos un sprite (y almacenamos el fondo). Al
imprimir el segundo sprite en la misma posición que el anterior o en una
 posición cercana, almacenaríamos como fondo de este segundo sprite
parte del anterior sprite impreso. Si recuperamos los fondos en orden
inverso al impreso, nos aseguramos de que el último fondo recuperado
será el del sprite 1, que es el correcto.
</p>

<p>
 No olvidemos que las operaciones de borrado y reimpresión deben de ser
lo más rápidas posibles para evitar parpadeos debidos a que el ojo
humano pueda ver el momento del borrado si la ULA refresca la pantalla
tras el “restore” del fondo y antes del dibujado del nuevo sprite.
</p>

<p>
<br>

</p>

</div>

<h2 id="optimizar-las-rutinas">Optimizar las rutinas</h2>
<div class="level2">

<p>
<br>

<strong>Adaptación de las rutinas al juego</strong>
</p>

<p>
 Las rutinas que hemos visto en este apartado y en los siguientes no
son, con diferencia, las versiones más óptimas posibles que un
programador avanzado podría crear. Es imprescindible que adaptemos las
rutinas al juego que vamos a crear eliminando todas aquellas partes de
la misma que no sean necesarias.
</p>

<p>
 Por ejemplo, si nuestro juego va a imprimir sprites sin atributos sobre
 un fondo monocolor con los atributos ya establecidos, lo más normal
sería modificar las subrutinas y eliminar todo rastro de la gestión y
cálculo de los atributos, no requiriendo siquiera establecer la
dirección de atributo a cero y el código que hace esta comprobación. Con
 esto ahorramos espacio en memoria (de instrucciones eliminadas) y
tiempo de ejecución (de comprobaciones innecesarias).
</p>

<p>
<br>

<strong>Adaptación de los parámetros de entrada</strong>
</p>

<p>
 Por otra parte, si no tenemos intención de llamar a estas funciones
desde BASIC, lo más óptimo sería eliminar el paso de parámetros por
variables de memoria y utilizar registros y/o pila allá donde sea
posible, puesto que estas operaciones son más rápidas que los acceso a
memoria.
</p>

<p>
 No obstante, nótese que las 2 variables que más tiempo cuesta de
establecer y de leer (DS_SPRITES y DS_ATTRIBS) se pueden establecer como
 constantes (y no como variables) directamente dentro de la rutina de
impresión. Eso quiere decir que si tenemos un único tileset, podríamos
cambiar partes de la rutina, como:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span></pre>

<p>
 por:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">BC</span>, Tabla_Sprites</pre>

<p>
 Establecer BC a un valor inmediato (<strong>LD BC, NN</strong>) tiene un coste de 10 t-estados, frente a los 20 t-estados que cuesta establecerlo desde una posición de memoria (<strong>LD BC, (NN)</strong>).
 De esta forma evitamos cargar desde memoria las direcciones de los
tilesets y también tener que establecerlos al inicio del programa.
</p>

<p>
<br>

<strong>Deshabilitar las interrupciones</strong>
</p>

<p>
 Si nuestra rutina de dibujado de interrupciones es crítica, puede que
nos resulte necesario en algunas circunstancias realizar un <strong>DI</strong> (Disable Interrupts) al principio de la misma y un <strong>EI</strong> (Enable Interrupts) al acabar, para evitar que una interrupción del Z80 sea lanzada durante la ejecución de la misma.
</p>

<p>
 Normalmente no deberíamos requerir de esta operación porque lo normal
es estar sincronizado con las interrupciones y realizar el redibujado de
 los sprites en la ISR o al volver de la ISR de atención a la ULA.
</p>

<p>
 No obstante, si no estamos sincronizados con las interrupciones o si
estamos usando IM1, es un dato interesante que nos puede evitar la
ejecución de código ISR en medio de la ejecución de la rutina.
</p>

<p>
 Trataremos este tema con más detalle en el capítulo dedicado a <em>Animaciones</em>, en el apartado sobre <em>Evitar Flickering o Parpadeos</em>.
</p>

<p>
<br>

<br>

<strong>Uso de la pila para acceso a datos</strong>
</p>

<p>
 Una opción realmente ingeniosa para optimizar el acceso al sprite sería
 la de utilizar la pila para realizar operaciones de lectura de 2 bytes
del sprite con una única instrucción (POP).
</p>

<p>
 Apuntando SP a nuestro sprite, un simple <strong>POP DE</strong> carga
en E y D (en ese orden) los 2 bytes apuntados por SP e incrementa la
dirección contenida en DE en 2 unidades, por lo que realizamos 2
operaciones de lectura y 2 incrementos (de 16 bits) en 1 byte de código y
 10 t-estados, frente a los 7+7+6+6 = 26 t-estados que cuestan las
operaciones LD+INC por separado. Eso implica leer en E y D dos bytes de
datos del sprite o el byte de máscara y un byte de datos.
</p>

<p>
 Como desventaja, debemos deshabilitar las interrupciones con <strong>DI</strong> al principio del programa y habilitarlas de nuevo antes del RET con <strong>EI</strong>
 ya que no podemos permitir la ejecución de una ISR estando SP apuntando
 al Sprite. Un “RST” o “CALL” (así como un PUSH) ejecutado con SP
apuntando al Sprite provocaría la corrupción del mismo al introducirse
en la pila la dirección de memoria del RET o RETI para la ISR.
</p>

<p>
 Veamos el pseudocódigo de una rutina que use la pila de esta forma:
</p>
<pre class="code">; DI
; Calcular dirección destino en pantalla
; Calcular dirección origen de sprite
; Guardar estado anterior pila
; Establecer direccion Sprite en SP en dir sprite

; Bucle de N scanlines:
;   Recuperar datos del sprite con POP

; Calcular e imprimir atributos

; Recuperar puntero de pila
; EI
; RET</pre>

<p>
 A continuación vamos a ver una versión “reducida” (sin impresión de
atributos, y con un bucle de 16 iteraciones sin desenrollar) de
DrawSprite_16x16 que utiliza la pila para recuperar los datos del sprite
 mediante <strong>POP DE</strong>. Esto implica la lectura de 2 bytes en
 una sóla instrucción y el doble incremento de DE para apuntar a los 2
siguientes elementos.
</p>

<p>
 En la rutina guardaremos el valor de SP en una variable temporal, antes
 de modificarlo, para poder recuperarlo antes del RET. Una vez calculada
 la dirección de origen del sprite a dibujar, realizaremos la copia de
SP en DS_TEMP_SP (variable de memoria) y cargaremos el valor de HL en
SP:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; DrawSprite_16x16_LD_STACK_no_attr:</span>
<span class="co1">; Imprime un sprite de 16x16 pixeles sin atributos </span>
<span class="co1">; usando la pila para obtener datos del sprite.</span>
<span class="co1">;-------------------------------------------------------------</span>
&nbsp;
DS_TEMP_SP  DW <span class="re1">0</span>           <span class="co1">; Variable temporal donde alojar SP</span>
&nbsp;
DrawSprite_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_LD_STACK_no_attr:
&nbsp;
   <span class="co1">;;; Deshabilitar interrupciones (vamos a cambiar SP).</span>
   <span class="kw1">DI</span>
&nbsp;
   <span class="co1">; Guardamos en BC la pareja (x,y) -&gt; B=COORD_Y y C=COORD_X</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>
&nbsp;
    <span class="co1">;;; Guardamos el valor actual y correcto de SP</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_TEMP_SP<span class="br0">)</span>, <span class="kw2">SP</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL:</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="re1">0</span>           <span class="co1">; AL = DS_NUMSPR*256</span>
   <span class="kw1">SRL</span> <span class="kw2">A</span>             <span class="co1">; Desplazamos a la derecha para dividir por dos</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*128</span>
   <span class="kw1">RRA</span>               <span class="co1">; Rotamos, ya que el bit que salio de L al CF fue 0</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*64</span>
   <span class="kw1">RRA</span>               <span class="co1">; Rotamos, ya que el bit que salio de L al CF fue 0</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>              <span class="co1">; AL = DS_NUMSPR*32</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>           <span class="co1">; HL = DS_NUMSPR*32</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>        <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 32)</span>
                     <span class="co1">; HL contiene la direccion de inicio en el sprite</span>
&nbsp;
   <span class="co1">;;; Establecemos el valor de SP apuntando al sprite</span>
   <span class="kw1">LD</span> <span class="kw2">SP</span>, <span class="kw2">HL</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>         <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="co1">;;; Repetir 8 veces (primeros 2 bloques horizontales):</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span><span class="nu0">6</span>
&nbsp;
drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_stack_loop:
   <span class="kw1">POP</span> <span class="kw2">DE</span>             <span class="co1">; Recuperamos 2 bytes del sprite</span>
                      <span class="co1">; Y ademas no hace falta sumar 2 a DE</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">E</span>         <span class="co1">; Ahora imprimimos los 2 bytes en pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">D</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>
&nbsp;
   <span class="co1">; Avanzamos HL 1 scanline (codigo de incremento de HL en 1 scanline)</span>
   <span class="co1">; desde el septimo scanline de la fila Y+1 al primero de la Y+2</span>
&nbsp;
   <span class="kw1">INC</span> <span class="kw2">H</span>              <span class="co1">; Siguiente scanline           </span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>            <span class="co1">; Ajustar tercio/bloque si necesario</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">JR</span> NZ, drawsp<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, drawsp<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
&nbsp;
drawsp<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop:
   <span class="kw1">DJNZ</span> drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_stack_loop
&nbsp;
   <span class="co1">;;; En este punto, los 16 scanlines del sprite estan dibujados.</span>
&nbsp;
   <span class="co1">;;; Recuperamos el valor de SP</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DS_TEMP_SP<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">SP</span>, <span class="kw2">HL</span>
&nbsp;
   <span class="kw1">EI</span>                  <span class="co1">; Habilitar de nuevo interrupciones</span>
   <span class="kw1">RET</span></pre>

<p>
 Al igual que en el caso de las rutinas anteriores, si desenrollamos el
bucle de 16 iteraciones en 2 bucles de 8, podemos utilizar <strong>INC H</strong> dentro de los bucles y el código de <em>Scanline_Abajo_HL</em> entre ambos. El bucle convertido en dos quedaría de la siguiente forma:
</p>
<pre class="code z80">drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_stack_loop<span class="re1">1</span>:
   <span class="kw1">POP</span> <span class="kw2">DE</span>             <span class="co1">; Recuperamos 2 bytes del sprite</span>
                      <span class="co1">; Y ademas no hace falta sumar 2 a DE</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">E</span>         <span class="co1">; Ahora imprimimos los 2 bytes en pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>              <span class="co1">; de la parte superior del Sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">D</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_stack_loop<span class="re1">1</span>
&nbsp;
   <span class="co1">; Avanzamos HL 1 scanline (codigo de incremento de HL en 1 scanline)</span>
   <span class="co1">; desde el septimo scanline de la fila Y+1 al primero de la Y+2</span>
   <span class="co1">; No hay que comprobar si (H &amp; $07) == 0 porque sabemos que lo es</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">32</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, drawsp<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
drawsp<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>,<span class="nu0">8</span>
drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_stack_loop2:
   <span class="kw1">POP</span> <span class="kw2">DE</span>             <span class="co1">; Recuperamos 2 bytes del sprite</span>
                      <span class="co1">; Y ademas no hace falta sumar 2 a DE</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">E</span>         <span class="co1">; Ahora imprimimos los 2 bytes en pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>              <span class="co1">; de la parte inferior del Sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">D</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawsp<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_stack_loop2</pre>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/gfx3_sprite8x8.asm">Impresión de Sprite 8x8 sin máscara y sin OR</a>
</li>
<li><a href="src/gfx3_sprite8x8.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx3_sprite8x8_or.asm">Impresión de Sprite 8x8 sin máscara y con OR</a>
</li>
<li><a href="src/gfx3_sprite8x8_or.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx3_sprite8x8_mask.asm">Impresión de Sprite 8x8 con máscara</a>
</li>
<li><a href="src/gfx3_sprite8x8_mask.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx3_sprite16x16.asm">Impresión de Sprite 16x16 sin máscara</a>
</li>
<li><a href="src/gfx3_sprite16x16.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx3_sprite16x16_mask.asm">Impresión de Sprite 16x16 con máscara</a>
</li>
<li><a href="src/gfx3_sprite16x16_mask.tap">Tap del ejemplo anterior</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="http://metalbrain.speccy.org/" class="urlextern" title="http://metalbrain.speccy.org">Web de SevenuP</a> (por metalbrain).</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a>.</div>
</li>
<li><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/z80time.txt" class="urlextern" title="external/www.ticalc.org/pub/text/z80/z80time.txt">Tiempos de ejecución y tamaños</a> de las instrucciones del Z80.</div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a>.</div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a>.</div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a>.</div>
</li>
</ul>

<p>
<br>

</p>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="graficos-y-ivfuentes-de-texto">Gráficos (y IV): Fuentes de texto</h1>
<div class="level1">

<p>
 En prácticamente cualquier programa o juego nos encontraremos con la
necesidad de imprimir en pantalla texto y datos numéricos en diferentes
posiciones de pantalla: los menúes, los nombres de los niveles, los
marcadores y puntuaciones, etc.
</p>

<p>
 La impresión de fuentes de texto es una aplicación directa de las
rutinas de impresión de sprites en baja resolución 00103que creamos en
el capítulo anterior. Cada carácter es un sprite de 8×8 píxeles a
dibujar en coordenadas (c,f) de baja resolución.
</p>

<p>
 Crearemos una rutina de impresión de caracteres y, basada en esta, una
rutina de impresión de cadenas, con la posibilidad de añadir códigos de
control y de formato, e impresión de datos numéricos o variables
decimales, hexadecimales, binarias y de cadena.
</p>

<p>
 Aprovechando la rutina de escaneo de teclado de la ROM, analizaremos
también una rutina de INPUT de datos para nuestros programas en
ensamblador basados en texto (aventuras, juegos de gestión, etc).
</p>

<p>
 Finalmente, examinaremos una fuente de texto de 4×8 píxeles que nos
permitirá una resolución en pantalla de 64 columnas de caracteres en
pantalla.
</p>

<p>
<br>

<br>

</p>

</div>

<h2 id="fuentes-de-texto-8x8">Fuentes de texto 8x8</h2>
<div class="level2">

<p>
 Si creamos un juego gráfico de caracteres como un tileset de sprites de
 8×8 píxeles cada uno conteniendo una letra del alfabeto, podemos
utilizar las rutinas de impresión de sprites de 8×8 para trazar en
pantalla cualquier carácter (visto como un sprite de 1×1 bloques).
</p>

<p>
<br>

<img src="img/gfx4_sevenup01.png" class="mediacenter" alt=" Parte de un charset en SevenuP"/>
</p>
<div style="text-align: center;"><em>Parte de un tileset de caracteres en SevenuP</em>
</div>
<p>
<br>

</p>

<p>
 Ubicando las letras en el spriteset con el mismo orden que el código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> (empezando por el espacio, código 32, como sprite cero), podemos utilizar el código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> de la letra a imprimir como número de sprite dentro del tileset.
</p>

<p>
<br>

<a href="img/gfx4_asciiwikipedia.png" class="media" title="cursos:ensamblador:gfx4_asciiwikipedia.png"><img src="img/gfx4_asciiwikipedia.png" class="mediacenter" alt=""></a>
</p>
<div style="text-align: center;"><em>Los 95 caracteres imprimibles (96 en el Spectrum) del código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>.<br>
Fuente: Wikipedia</em>
</div>
<p>
<br>

</p>

<p>
 Podríamos diseñar una fuente de 256 caracteres en el editor de Sprites,
 pero se requerirían 256*8 = 4096 bytes (4KB!) para almacenar los datos
en memoria. En realidad, no es necesario crear 256 caracteres en el
editor, puesto que en el Spectrum:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> Los primeros 31 códigos <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> son códigos de control.</div>
</li>
<li><div class="li"> Los códigos <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> del 128 al 143 son los UDGs predefinidos e imprimibles.</div>
</li>
<li><div class="li"> Los códigos <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> del 144 al 164 son los UDGs programables en modo 48K (del 144 al 162 en modo 128K)</div>
</li>
<li><div class="li"> Los códigos <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> del 165 al 255 son los códigos de control (<em>tokens</em>) de las instrucciones de BASIC en modo 48K (del 163 al 255 en modo 128K).</div>
</li>
</ul>

<p>
<br>

<img src="img/gfx4_zxcharset.png" class="mediacenter" alt=" Juego de caracteres del Spectrum 32-164"/>
</p>
<div style="text-align: center;"><em>Códigos <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> en el Spectrum desde el 32 al 164<br>
Fuente: Wikipedia</em>
</div>
<p>
<br>

</p>

<p>
 Como hay un total de 96 caracteres de texto imprimibles (desde el 32 al
 127), para disponer de un juego de caracteres suficiente con
minúsculas, mayúsculas, signos de puntuación y dígitos nos bastaría con
una fuente de 96 sprites de 8 bytes cada uno, es decir, un total de 768
bytes.
</p>

<p>
 Podemos agregar “caracteres” adicionales para disponer de códigos de
control que nos permitan imprimir vocales con acentos, eñes, cedilla
(ç), etc. Al definir los textos de nuestro programa habría que utilizar
estos códigos de control en formato numérico (DB) intercalados con el
texto <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> (“España” = DB “Espa”, codigo_enye, “a”).
</p>

<p>
 Si tenemos problemas de espacio en nuestro programa también podemos
utilizar un set de caracteres más reducido que acaben en el <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> 'Z' (<abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>
 90), lo que nos dejaría un charset con números, signos de puntuación y
letras mayúsculas (sin minúsculas). El espacio ocupado por este
spriteset sería de 90-32=58 caracteres, es decir, 464 bytes.
</p>

<p>
 Por otra parte, no es necesario exportar los atributos de la fuente ya
que lo normal es utilizar un atributo determinado para todos los
caracteres de la misma, aunque nada nos impide dotar de diferente color a
 cada letra si así lo deseamos y exportar también los datos de atributo.
 En este capítulo sólo exportaremos los gráficos puesto que utilizaremos
 un atributo común para todos los elementos de la fuente, o cambios de
formato (tinta y papel) manuales allá donde sea necesario.
</p>

<p>
 Sea cual sea el tamaño de nuestro SpriteSet (desde el juego reducido de
 58 caracteres hasta el set completo de 256, pasando por el estándar de
96), podemos imprimir caracteres de dicha fuente con las rutinas de
impresión de 8×8 del capítulo anterior.
</p>

<p>
 Para los ejemplos de este capítulo utilizaremos una fuente
personalizada de texto de 64 caracteres (signos de puntuación, dígitos
numéricos y letras mayúsculas, incluídas 5 vocales con acentos) dibujada
 por Javier Vispe y convertida a código con SevenuP:
</p>

<p>
<br>

<img src="img/gfx4_charset1.png" class="mediacenter" alt=" Fuente de ejemplo "/>
<br>

</p>

<p>
 Exportando los datos en SevenuP en formato <em>X Char, Char Line, Y Char</em> como <em>Gfx only</em>, obtenemos el siguiente fichero .asm:
</p>
<pre class="code z80"><span class="co1">; ASM source file created by SevenuP v1.20</span>
<span class="co1">; SevenuP (C) Copyright 2002-2006 by Jaime Tejedor Gomez, aka Metalbrain</span>
&nbsp;
<span class="co1">;GRAPHIC DATA:</span>
<span class="co1">;Pixel Size:      (  8, 512)</span>
<span class="co1">;Char Size:       (  1,  64)</span>
<span class="co1">;Sort Priorities: Char X, Char line, Y char</span>
<span class="co1">;Data Outputted:  Gfx</span>
<span class="co1">;Interleave:      Sprite</span>
&nbsp;
charset<span class="re1">1</span>:
   DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,   <span class="re1">0</span>, <span class="nu0">24</span>, <span class="nu0">24</span>, <span class="nu0">24</span>, <span class="nu0">24</span>,  <span class="re1">0</span>, <span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB   <span class="re1">0</span>,<span class="re1">10</span><span class="nu0">8</span>,<span class="re1">10</span><span class="nu0">8</span>, <span class="nu0">72</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
   DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
   DEFB  <span class="nu0">56</span>,  <span class="re1">0</span>, <span class="nu0">76</span>, <span class="nu0">56</span>,<span class="re1">110</span>,<span class="re1">1</span><span class="nu0">96</span>,<span class="re1">1</span><span class="nu0">22</span>,  <span class="re1">0</span>,   <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="re1">1</span><span class="nu0">2</span>,  <span class="nu0">8</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
   DEFB   <span class="re1">0</span>, <span class="nu0">24</span>,  <span class="re1">0</span>, <span class="nu0">48</span>, <span class="nu0">48</span>, <span class="nu0">48</span>, <span class="nu0">24</span>,  <span class="re1">0</span>,   <span class="re1">0</span>, <span class="nu0">24</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,   <span class="re1">0</span>, <span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">26</span>,<span class="re1">1</span><span class="nu0">26</span>, <span class="nu0">24</span>, <span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="re1">1</span><span class="nu0">2</span>,  <span class="nu0">8</span>,   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">26</span>,<span class="re1">1</span><span class="nu0">26</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
   DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>, <span class="nu0">56</span>, <span class="nu0">56</span>,  <span class="re1">0</span>,   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="nu0">6</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="nu0">24</span>, <span class="nu0">48</span>, <span class="nu0">96</span>,  <span class="re1">0</span>
   DEFB <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">6</span>,<span class="nu0">2</span><span class="re1">1</span><span class="nu0">4</span>,<span class="nu0">23</span><span class="re1">0</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,  <span class="nu0">28</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">24</span>, <span class="nu0">28</span>, <span class="nu0">28</span>, <span class="nu0">28</span>, <span class="nu0">28</span>,  <span class="re1">0</span>
   DEFB <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>, <span class="nu0">28</span>,<span class="re1">11</span><span class="nu0">2</span>,<span class="nu0">254</span>,<span class="nu0">254</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>, <span class="re1">1</span><span class="nu0">2</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB  <span class="re1">1</span><span class="nu0">2</span>,  <span class="re1">0</span>, <span class="nu0">6</span><span class="re1">0</span>,<span class="re1">10</span><span class="nu0">8</span>,<span class="nu0">254</span>,<span class="nu0">254</span>, <span class="re1">1</span><span class="nu0">2</span>,  <span class="re1">0</span>, <span class="nu0">254</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="nu0">252</span>, <span class="re1">1</span><span class="nu0">4</span>,<span class="nu0">254</span>,<span class="nu0">252</span>,  <span class="re1">0</span>
   DEFB  <span class="nu0">6</span><span class="re1">0</span>,  <span class="re1">0</span>,<span class="nu0">224</span>,<span class="nu0">252</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>, <span class="nu0">254</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">4</span>, <span class="nu0">28</span>, <span class="nu0">28</span>, <span class="nu0">56</span>, <span class="nu0">56</span>,  <span class="re1">0</span>
   DEFB <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">24</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">26</span>,  <span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">26</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB   <span class="re1">0</span>,  <span class="re1">0</span>, <span class="nu0">24</span>, <span class="nu0">24</span>,  <span class="re1">0</span>, <span class="nu0">24</span>, <span class="nu0">24</span>,  <span class="re1">0</span>, <span class="re1">11</span><span class="nu0">8</span>,  <span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="nu0">254</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>
   DEFB <span class="nu0">246</span>,  <span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="nu0">252</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="nu0">254</span>,<span class="nu0">254</span>,  <span class="re1">0</span>,  <span class="re1">1</span><span class="nu0">2</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="nu0">48</span>, <span class="nu0">56</span>, <span class="nu0">56</span>, <span class="nu0">56</span>, <span class="nu0">56</span>,  <span class="re1">0</span>
   DEFB <span class="re1">11</span><span class="nu0">8</span>,  <span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">98</span>,  <span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB   <span class="re1">0</span>, <span class="nu0">24</span>,  <span class="re1">0</span>, <span class="nu0">24</span>, <span class="nu0">24</span>, <span class="nu0">24</span>, <span class="nu0">24</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>
   DEFB <span class="nu0">252</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">252</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="nu0">252</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB <span class="nu0">252</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="nu0">252</span>,  <span class="re1">0</span>, <span class="nu0">254</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="nu0">252</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="nu0">254</span>,<span class="nu0">254</span>,  <span class="re1">0</span>
   DEFB <span class="nu0">254</span>,  <span class="re1">0</span>,<span class="nu0">224</span>,<span class="nu0">252</span>,<span class="nu0">224</span>,<span class="nu0">224</span>,<span class="nu0">224</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB <span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,  <span class="nu0">56</span>,  <span class="re1">0</span>, <span class="nu0">56</span>, <span class="nu0">56</span>, <span class="nu0">56</span>, <span class="nu0">56</span>, <span class="nu0">56</span>,  <span class="re1">0</span>
   DEFB   <span class="nu0">6</span>,  <span class="re1">0</span>,  <span class="nu0">6</span>,  <span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,<span class="nu0">22</span><span class="re1">0</span>,<span class="nu0">248</span>,<span class="nu0">252</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>
   DEFB <span class="nu0">224</span>,  <span class="re1">0</span>,<span class="nu0">224</span>,<span class="nu0">224</span>,<span class="nu0">224</span>,<span class="nu0">254</span>,<span class="nu0">254</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,<span class="nu0">254</span>,<span class="nu0">254</span>,<span class="nu0">2</span><span class="re1">1</span><span class="nu0">4</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>
   DEFB <span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,<span class="nu0">246</span>,<span class="nu0">254</span>,<span class="nu0">222</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB <span class="nu0">252</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="nu0">252</span>,<span class="re1">1</span><span class="nu0">92</span>,<span class="re1">1</span><span class="nu0">92</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">252</span>,<span class="re1">1</span><span class="nu0">22</span>,  <span class="re1">0</span>
   DEFB <span class="nu0">252</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="nu0">252</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">26</span>,  <span class="re1">0</span>,<span class="nu0">224</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="nu0">6</span>,<span class="nu0">254</span>,<span class="nu0">252</span>,  <span class="re1">0</span>
   DEFB <span class="nu0">254</span>,  <span class="re1">0</span>, <span class="nu0">56</span>, <span class="nu0">56</span>, <span class="nu0">56</span>, <span class="nu0">56</span>, <span class="nu0">56</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">24</span>,  <span class="re1">0</span>
   DEFB <span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">238</span>,<span class="re1">1</span><span class="nu0">24</span>, <span class="nu0">56</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="re1">1</span><span class="nu0">98</span>,<span class="nu0">2</span><span class="re1">1</span><span class="nu0">4</span>,<span class="nu0">254</span>,<span class="re1">10</span><span class="nu0">8</span>,  <span class="re1">0</span>
   DEFB <span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">24</span>, <span class="nu0">56</span>,<span class="re1">1</span><span class="nu0">24</span>,<span class="nu0">238</span>,<span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>, <span class="re1">1</span><span class="nu0">98</span>,  <span class="re1">0</span>,<span class="nu0">238</span>,<span class="re1">1</span><span class="nu0">24</span>, <span class="nu0">56</span>, <span class="nu0">56</span>, <span class="nu0">56</span>,  <span class="re1">0</span>
   DEFB <span class="nu0">254</span>,  <span class="re1">0</span>, <span class="nu0">28</span>, <span class="nu0">56</span>,<span class="re1">11</span><span class="nu0">2</span>,<span class="nu0">254</span>,<span class="nu0">254</span>,  <span class="re1">0</span>,  <span class="nu0">6</span><span class="re1">0</span>,<span class="re1">10</span><span class="nu0">2</span>,<span class="nu0">2</span><span class="re1">1</span><span class="nu0">9</span>,<span class="re1">1</span><span class="nu0">33</span>,<span class="re1">1</span><span class="nu0">33</span>,<span class="nu0">2</span><span class="re1">1</span><span class="nu0">9</span>,<span class="re1">10</span><span class="nu0">2</span>, <span class="nu0">6</span><span class="re1">0</span>
   DEFB   <span class="re1">0</span>,  <span class="re1">0</span>, <span class="nu0">96</span>, <span class="nu0">48</span>, <span class="nu0">24</span>, <span class="re1">1</span><span class="nu0">2</span>,  <span class="nu0">6</span>,  <span class="re1">0</span>,  <span class="nu0">24</span>,  <span class="re1">0</span>, <span class="nu0">24</span>, <span class="nu0">48</span>, <span class="nu0">96</span>,<span class="re1">10</span><span class="nu0">2</span>, <span class="nu0">6</span><span class="re1">0</span>,  <span class="re1">0</span>
   DEFB  <span class="nu0">6</span><span class="re1">0</span>,  <span class="re1">0</span>, <span class="nu0">7</span><span class="re1">0</span>, <span class="re1">1</span><span class="nu0">2</span>, <span class="nu0">24</span>,  <span class="re1">0</span>, <span class="nu0">24</span>,  <span class="re1">0</span>,   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">26</span></pre>

<p>
<br>

</p>

</div>

<h3 class="sectionedit3" id="printchar_8x8">PrintChar_8x8</h3>
<div class="level3">

<p>
 La rutina de impresión de caracteres debe de recoger el código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> a dibujar y realizar el cálculo para posicionar un puntero “origen” dentro del tileset contra el <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>
 correspondiente. También debe calcular la dirección destino en la
pantalla en base a las coordenadas en baja resolución. Una vez trazado
el carácter, establecerá el atributo del mismo con el valor contenido en
 FONT_ATTRIB.
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; PrintChar_8x8:</span>
<span class="co1">; Imprime un caracter de 8x8 pixeles de un charset.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; -----------------------------------------------------</span>
<span class="co1">; FONT_CHARSET = Direccion de memoria del charset.</span>
<span class="co1">; FONT_X       = Coordenada X en baja resolucion (0-31)</span>
<span class="co1">; FONT_Y       = Coordenada Y en baja resolucion (0-23)</span>
<span class="co1">; FONT_ATTRIB  = Atributo a utilizar en la impresion.</span>
<span class="co1">; Registro A   = ASCII del caracter a dibujar.</span>
<span class="co1">;-------------------------------------------------------------</span>
PrintChar_8x8:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>FONT_X<span class="br0">)</span>      <span class="co1">; B = Y,  C = X</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'           ; Nos guardamos el caracter en A'</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>              <span class="co1">; DE contiene ahora la direccion destino.</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*8)</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'           ; Recuperamos el caracter a dibujar de A'</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = BC + HL = FONT_CHARSET + (A * 8)</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>          <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="co1">;;; Dibujar 7 scanlines (DE) -&gt; (HL) y bajar scanline (y DE++)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">7</span>            <span class="co1">; 7 scanlines a dibujar</span>
&nbsp;
drawchar8_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementamos puntero en caracter</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>              <span class="co1">; Incrementamos puntero en pantalla (scanline+=1)</span>
   <span class="kw1">DJNZ</span> drawchar8_loop
&nbsp;
   <span class="co1">;;; La octava iteracion (8o scanline) aparte, para evitar los INCs</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>            <span class="co1">; Recuperamos el valor inicial de HL</span>
   <span class="kw1">SUB</span> <span class="nu0">7</span>              <span class="co1">; Restando los 7 "INC H"'s realizados</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
                      <span class="co1">; Tenemos A = H</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">L</span>
&nbsp;
   <span class="co1">;;; Escribir el atributo en memoria</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribimos el atributo en memoria</span>
   <span class="kw1">RET</span></pre>

<p>
 La rutina es muy parecida a las que ya vimos en el capítulo anterior
para impresión de sprites 8×8, pero eliminando el cálculo del atributo
origen al establecerlo desde la variable FONT_ATTRIB.
</p>

<p>
 Además, hemos semi-desenrollado el bucle de impresión para hacer 7
iteraciones y después escribir el último scanline fuera del bucle. De
esta forma evitamos el INC DE + INC H que se realizaría para el último
scanline y que es innecesario. De nuevo, desenrollar totalmente el bucle
 sería lo más óptimo, ya que evitaríamos el “LD B, 7” y el “DJNZ”.
</p>

<p>
 La impresión se realiza por transferencia, pero podemos convertirla en impresión por operación lógica cambiando los:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Establecemos el valor en videomemoria</span></pre>

<p>
 Por:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>       <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">OR</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>          <span class="co1">; Hacemos OR entre dato y pantalla</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Establecemos el valor en videomemoria</span></pre>

<p>
 Para llamar a nuestra nueva rutina establecemos los valores de
impresión en las variables de memoria y realizamos el CALL
correspondiente. Aunque en esta rutina podríamos utilizar el paso por
registros, vamos a emplear paso de parámetros por variables de memoria
por 2 motivos:
</p>
<ul class="fix-media-list-overlap">
<li> Para que sean utilizables desde BASIC.
</li>
<li> Para crear un sistema de coordenadas
 de texto X, Y y de atributos que nos permita, como veremos más adelante
 en el capítulo, gestionar la impresión de texto de una manera más
cómoda.
</li>
</ul>

<p>
 Nótese que nuestro set de caracteres empieza en el <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> 32 (espacio) el cual se corresponde con el sprite 0 (sprite en blanco). En teoría, la rutina debería restar 32 a cada código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> recibido en el registro A para encontrar el identificador de sprite correcto en el tileset.
</p>

<p>
 En lugar de realizar una resta en cada impresión, podemos establecer el
 valor de FONT_CHARSET a la dirección del array menos 256 (32*8), con lo
 que cuando se calcule la dirección origen usando el <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> real estaremos accediendo al sprite correcto.
</p>

<p>
 Así, asignando a FONT_CHARSET el valor de “charset1-256”, cuando solicitemos imprimir el <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>
 32, estaremos accediendo realmente a charset1-256+(32*8) =
charset1-256+256 = charset1. De esta forma no necesitamos restar 32 a
ningun carácter <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> para que la rutina imprima el carácter correspondiente real a un valor <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>.
</p>

<p>
 El código de asignación de variables iniciales y llamada a la función sería pues similar al siguiente:
</p>
<pre class="code z80">  <span class="co1">;;; Establecimiento de valores iniciales</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, charset<span class="re1">1</span><span class="sy0">-</span><span class="nu0">256</span>        <span class="co1">; Saltamos los 32 caracteres iniciales</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>, <span class="kw2">HL</span>      <span class="co1">; Establecemos el valor del charset</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>        <span class="co1">; Color amarillo sobre negro</span>
&nbsp;
  <span class="co1">;;; Impresion de un caracter "X" en 15,8  </span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">5</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">8</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">'X'</span>
  <span class="kw1">CALL</span> PrintChar_8x8         <span class="co1">; Imprimimos el caracter</span></pre>

<p>
 Nótese que PrintChar_8x8 modifica registros y no los preserva, por lo
que si tenemos que salvaguardar el valor de algún registro, debemos
realizar PUSH antes de llamar a la función y POP al volver de ella.
</p>

<p>
 El siguiente ejemplo (donde se ha omitido el código de las funciones ya
 vistas hasta ahora) muestra el charset 8×8 de 64 caracteres en
pantalla, en un bucle de 4 líneas de 16 caracteres cada una:
</p>
<pre class="code z80">  <span class="co1">; Visualizacion del charset de ejemplo</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
  <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
  <span class="kw1">CALL</span> ClearScreenAttrib     <span class="co1">; Borramos la pantalla</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, charset<span class="re1">1</span><span class="sy0">-</span><span class="nu0">256</span>        <span class="co1">; Saltamos los 32 caracteres iniciales</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>             <span class="co1">; Empezamos en (0,1)</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>        <span class="co1">; Color amarillo sobre negro</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="nu0">32</span>                   <span class="co1">; Empezamos en caracter 32</span>
&nbsp;
  <span class="co1">;;; Bucle vertical</span>
  <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="nu0">4</span>
&nbsp;
bucle_y:
&nbsp;
  <span class="co1">;;; Bucle horizontal</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">1</span><span class="nu0">6</span>                   <span class="co1">; Imprimimos 16 caracteres horiz</span>
&nbsp;
bucle_x:
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_X<span class="br0">)</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; X = X + 1</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
  <span class="kw1">PUSH</span> <span class="kw2">BC</span>
  <span class="kw1">PUSH</span> <span class="kw2">DE</span>                     <span class="co1">; Preservamos registros</span>
  <span class="kw1">CALL</span> PrintChar_8x8          <span class="co1">; Imprimimos el caracter "C"</span>
  <span class="kw1">POP</span> <span class="kw2">DE</span>
  <span class="kw1">POP</span> <span class="kw2">BC</span>
&nbsp;
  <span class="kw1">INC</span> <span class="kw2">C</span>                       <span class="co1">; Siguiente caracter</span>
  <span class="kw1">DJNZ</span> bucle_x                <span class="co1">; Repetir 16 veces</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_Y<span class="br0">)</span>              <span class="co1">; Siguiente linea:</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>
  <span class="kw1">INC</span> <span class="kw2">A</span>                       <span class="co1">; Y = Y + 2</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; X = 0</span>
&nbsp;
  <span class="kw1">DEC</span> <span class="kw2">E</span>
  <span class="kw1">JR</span> NZ, bucle_y              <span class="co1">; Repetir 4 veces (16*4=64 caracteres)</span>
&nbsp;
loop:
  <span class="kw1">JR</span> loop
  <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
FONT_CHARSET   DW    <span class="re1">0</span>
FONT_ATTRIB    DB    <span class="nu0">56</span>       <span class="co1">; Negro sobre gris</span>
FONT_X         DB    <span class="re1">0</span>
FONT_Y         DB    <span class="re1">0</span>
<span class="co1">;-------------------------------------------------------------</span></pre>

<p>
<br>

</p>

</div>

<h3 class="sectionedit4" id="printstring_8x8">PrintString_8x8</h3>
<div class="level3">

<p>
 Nuestro siguiente objetivo es el de poder agrupar diferentes caracteres
 en una cadena y diseñar una función que permita imprimir toda la cadena
 mediante llamadas consecutivas a PrintChar_8x8.
</p>

<p>
 Definiremos las cadenas de texto como ristras de códigos <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> acabadas en un byte 0 (valor 0, no <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> '0'):
</p>
<pre class="code z80">cadena  DB   <span class="st0">"EJEMPLO DE CADENA"</span>, <span class="re1">0</span></pre>

<p>
 El pseudocódigo de la rutina sería el siguiente:
</p>
<pre class="code">Pseudocódigo de la rutina:

; Recoger parametros

; Repetir:
;    Coger caracter actual de la cadena (apuntado por HL).
;    Si el caracter es 0, fin de la cadena (salir)
;    Incrementar HL para apuntar al siguiente caracter.
;    Imprimir el carácter llamando a PrintChar_8x8
;    Ajustar coordenada X en FONT_X
;    Ajustar coordenada Y en FONT_Y   </pre>

<p>
 Es extremadamente importante acabar la cadena con un cero para que la
rutina pueda ejecutar su condición de salida. Si no se define la cadena
correctamente, se continuará imprimiendo todo aquello apuntado por HL
hasta encontrar un valor cero en memoria.
</p>

<p>
 Veamos el código de la rutina:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; PrintString_8x8:</span>
<span class="co1">; Imprime una cadena de texto de un charset de fuente 8x8.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; -----------------------------------------------------</span>
<span class="co1">; FONT_CHARSET = Direccion de memoria del charset.</span>
<span class="co1">; FONT_X       = Coordenada X en baja resolucion (0-31)</span>
<span class="co1">; FONT_Y       = Coordenada Y en baja resolucion (0-23)</span>
<span class="co1">; FONT_ATTRIB  = Atributo a utilizar en la impresion.</span>
<span class="co1">; Registro HL  = Puntero a la cadena de texto a imprimir.</span>
<span class="co1">;                Debe acabar en </span>
<span class="co1">;-------------------------------------------------------------</span>
PrintString_8x8:
&nbsp;
   <span class="co1">;;; Bucle de impresion de caracter</span>
pstring8_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Leemos un caracter de la cadena</span>
   <span class="kw1">OR</span> <span class="kw2">A</span>
   <span class="kw1">RET</span> Z                     <span class="co1">; Si es 0 (fin de cadena) volver</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; Siguiente caracter en la cadena</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                   <span class="co1">; Salvaguardamos HL</span>
   <span class="kw1">CALL</span> PrintChar_8x8        <span class="co1">; Imprimimos el caracter</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperamos HL</span>
&nbsp;
   <span class="co1">;;; Ajustamos coordenadas X e Y</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_X<span class="br0">)</span>            <span class="co1">; Incrementamos la X</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>                     <span class="co1">; pero comprobamos si borde derecho</span>
   <span class="kw1">CP</span> <span class="nu0">3</span><span class="re1">1</span>                     <span class="co1">; X &gt; 31?</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, pstring8_noedgex    <span class="co1">; No, se puede guardar el valor</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_Y<span class="br0">)</span>            <span class="co1">; Cogemos coordenada Y</span>
   <span class="kw1">CP</span> <span class="nu0">23</span>                     <span class="co1">; Si ya es 23, no incrementar</span>
   <span class="kw1">JR</span> NC, pstring8_noedgey   <span class="co1">; Si es 23, saltar</span>
&nbsp;
   <span class="kw1">INC</span> <span class="kw2">A</span>                     <span class="co1">; No es 23, cambiar Y</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
pstring8_noedgey:
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Guardamos la coordenada Y</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>                     <span class="co1">; Y ademas hacemos A = X = 0</span>
&nbsp;
pstring8_noedgex
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Almacenamos el valor de X</span>
   <span class="kw1">JR</span> pstring8_loop</pre>

<p>
 La anterior rutina sería llamada como en el siguiente ejemplo:
</p>
<pre class="code z80">  <span class="co1">;;; Prueba de impresion de cadenas:</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, charset<span class="re1">1</span><span class="sy0">-</span><span class="nu0">256</span>          <span class="co1">; Saltamos los 32 caracteres iniciales</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">64</span><span class="sy0">+</span><span class="nu0">3</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">5</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">CALL</span> PrintString_8x8
  <span class="kw1">RET</span>
&nbsp;
cadena DB <span class="st0">"PRUEBA DE IMPRESION DE TEXTO DE UNA CADENA LARGA."</span>, <span class="re1">0</span></pre>

<p>
 Y el resultado en pantalla es:
</p>

<p>
<br>

<img src="img/gfx4_pstring.png" class="mediacenter" alt=" Impresion de cadenas "/>
<br>

</p>

<p>
 La forma más óptima de programar la rutina de impresión consistiría en
integrar el código de PrintChar_8x8 dentro de PrintString_8x8 evitando
el recálculo de offset en pantalla en cada carácter. Se utilizaría DE
como puntero en la fuente y HL como puntero en pantalla. Una vez
calculada la posición inicial en pantalla para el primer carácter se
variaría HL apropiadamente, incrementandolo en 1 para avances hacia la
derecha tras la impresión de un carácter. Los retornos de carro se
realizarían restando 31 a L y ejecutando <em>Caracter_Abajo_HL</em>. De
esta forma se evitaría no sólo el CALL y RET contra PrintChar_8x8 sino
que tampoco habría que realizar el continuo cálculo de la posición
destino. Después habría que trazar los atributos repitiendo el proceso
desde el inicio de la cadena.
</p>

<p>
 Normalmente no se suele imprimir texto durante el desarrollo del juego
(al menos no en el bucle principal de juego), por lo que puede no ser
necesario llegar a este extremo de optimización a cambio de una mayor
ocupación de las rutinas en memoria.
</p>

<p>
 Si vamos a utilizar la impresión de cadenas en la introducción del
juego o programa, los menúes, la descripción de las fases, los créditos,
 la pausa o los mensajes entre nivel y nivel o el final del juego,
probablemente será suficiente con la rutina que acabamos de ver.
</p>

<p>
 Las cadenas de texto que se puedan usar en el bucle principal del
programa deberían imprimirse como Sprites, y los valores numéricos como
impresión tipo “PrintChar_8x8” de cada uno de sus dígitos, realizando
sólo una conversión numérica del número de dígitos realmente necesario.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit5" id="impresion-de-valores-numericos">Impresión de valores numéricos</h3>
<div class="level3">

<p>
 Hemos visto hasta ahora cómo imprimir cadenas de texto <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>,
 pero en muchas ocasiones nos veremos en la necesidad de imprimir el
valor numérico contenido por un registro o una variable de memoria.
</p>

<p>
 Para poder realizar esta impresión necesitamos rutinas que conviertan un valor numérico en una representación <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>, la cual imprimiremos luego con PrintString_8x8. Según la base de conversión, necesitaremos las siguientes rutinas:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Bin2String</strong> : Convierte el valor numérico de un registro o variable en una cadena <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> con la representación binaria (unos y ceros) de dicho valor (base=2).</div>
</li>
<li><div class="li"> <strong>Hex2String</strong> : Convierte el valor numérico de un registro o variable en una cadena <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> con la representación en hexadecimal (2 o 4 dígitos del 0 a la F) de dicho valor (base=16).</div>
</li>
<li><div class="li"> <strong>Int2String</strong> : Convierte el valor numérico sin signo de un registro o variable en una cadena <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> con la representación decimal (N dígitos 0-9) de dicho valor (base=10).</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 El parámetro de entrada a las rutinas será L para valores de 8 bits o
HL para valores de 16 bits, y todas las rutinas utilizarán un área
temporal de memoria para escribir en ella la cadena resultante de la
conversión:
</p>
<pre class="code z80"><span class="co1">;;; Espacio de almacenamiento de las rutinas de conversion:</span>
&nbsp;
conv2string DS <span class="re1">1</span><span class="nu0">8</span></pre>

<p>
 Las rutinas acabarán el proceso de conversión agregrando un 0 (END OF
STRING) tras los ASCIIs obtenidos, con el objetivo de que la cadena
pueda ser directamente impresa con las funciones vistas hasta ahora.
</p>

<p>
 De esta forma, para imprimir en pantalla en formato Decimal el valor de 8 bits del registro A, haríamos lo siguiente:
</p>
<pre class="code z80">   <span class="co1">;;; Guardar en L el valor a convertir y llamar a rutina</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">CALL</span> Dec2String_8
&nbsp;
   <span class="co1">;;; Imprimir la cadena resultante de la conversion:</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> PrintString_8x8</pre>

<p>
 Veamos las diferentes rutinas:
</p>

<p>
<br>

<br>

</p>

</div>

<h4 id="bin2stringconversion-a-representacion-binaria">Bin2String: Conversión a representación binaria</h4>
<div class="level4">

<p>
 La conversión de un valor numérico a una representación binaria se basa
 en testear el estado de cada uno de los bits del registro “parámetro” y
 almacenar en la cadena destino apuntada por DE un valor <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> '0' ó '1' según el resultado del testeo.
</p>

<p>
 En lugar de ejecutar 8 ó 16 comparaciones con el comando BIT,
utilizaremos la rotación a la derecha del registro parámetro de forma
que el bit a comprobar sea desplazado al Carry Flag y podamos testear su
 valor con un <strong>JR NC</strong> o <strong>JR C</strong>.
</p>

<p>
 La rutina de conversión tiene 2 puntos de entrada diferentes según
necesitemos convertir un número de 8 bits (valor en registro L) o de 16
bits (valor en registro HL), pero utiliza el mismo core de conversión
para ambos casos:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Bin2String_8 y Bin2String_16:</span>
<span class="co1">; Convierte el valor numerico de L o de HL en una cadena de</span>
<span class="co1">; texto con su representacion en binario (acabada en 0).</span>
<span class="co1">;</span>
<span class="co1">; IN:   L = Numero a convertir para la version de 8 bits</span>
<span class="co1">;       HL = Numero a convertir para la version de 16 bits</span>
<span class="co1">; OUT:  [conv2string] = Cadena con la conversion a BIN.</span>
<span class="co1">; Usa:  BC</span>
<span class="co1">;-------------------------------------------------------------</span>
&nbsp;
Bin2String_<span class="re1">1</span><span class="nu0">6</span>:               <span class="co1">; Punto de entrada de 16 bits</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, conv2string        <span class="co1">; DE = puntero cadena destino</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">H</span>                   <span class="co1">; C = a convertir (parte alta)</span>
   <span class="kw1">CALL</span> Bin2String_convert   <span class="co1">; Llamamos a rutina conversora</span>
   <span class="kw1">JR</span> Bin2String_8b          <span class="co1">; Convertimos la parte baja,</span>
                             <span class="co1">; saltando el LD DE, conv2string</span>
&nbsp;
Bin2String_8:                <span class="co1">; Punto de entrada de 8 bits</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, conv2string        <span class="co1">; DE = puntero cadena destino</span>
&nbsp;
Bin2String_8b:
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">L</span>                   <span class="co1">; C = a convertir (parte baja)</span>
   <span class="kw1">CALL</span> Bin2String_convert   <span class="co1">; Llamamos a rutina conversora</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Guardar End Of String</span>
   <span class="kw1">RET</span>
&nbsp;
Bin2String_convert:
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                   <span class="co1">; 8 iteraciones</span>
b2string_loop:               <span class="co1">; Bucle de conversion</span>
   <span class="kw1">RL</span> <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">'1'</span>                 <span class="co1">; Valor en A por defecto</span>
   <span class="kw1">JR</span> NC, b2string_noC
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Lo almacenamos en la cadena</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">DJNZ</span> b2string_loop
   <span class="kw1">RET</span>
b2string_noC:
   <span class="kw1">DEC</span> <span class="kw2">A</span>                     <span class="co1">; A = '0'</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Lo almacenamos y avanzamos</span>
   <span class="kw1">DJNZ</span> b2string_loop
   <span class="kw1">RET</span></pre>

<p>
 En el área de memoria apuntada por <em>conv2string</em> tendremos la representación binaria en <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> del valor en L o HL, acabado en un carácter 0, lista para imprimir con PrintString_8x8.
</p>

<p>
<br>

<br>

</p>

</div>

<h4 id="hex2stringconversion-a-representacion-hexadecimal">Hex2String: Conversión a representación hexadecimal</h4>
<div class="level4">

<p>
 Veamos la rutina de conversión de un valor numérico a una representación hexadecimal:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Hex2String_8 y Hex2String_16:</span>
<span class="co1">; Convierte el valor numerico de L o de HL en una cadena de</span>
<span class="co1">; texto con su representacion en hexadecimal (acabada en 0).</span>
<span class="co1">; Rutina adaptada de http://baze.au.com/misc/z80bits.html .</span>
<span class="co1">;</span>
<span class="co1">; IN:   L = Numero a convertir para la version de 8 bits</span>
<span class="co1">;       HL = Numero a convertir para la version de 16 bits</span>
<span class="co1">; OUT:  [conv2string] = Cadena con la conversion a HEX.</span>
<span class="co1">;-------------------------------------------------------------</span>
Hex2String_<span class="re1">1</span><span class="nu0">6</span>:
   <span class="kw1">LD</span> <span class="kw2">DE</span>, conv2string        <span class="co1">; Cadena destino</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">CALL</span> B2AHex_Num<span class="re1">1</span>          <span class="co1">; Convertir Hex1 de H</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">CALL</span> B2AHex_Num2          <span class="co1">; Convertir Hex2 de H</span>
   <span class="kw1">JR</span> Hex2String_8b          <span class="co1">; Realizar conversion de L</span>
&nbsp;
Hex2String_8:                <span class="co1">; Entrada para la rut de 8 bits</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, conv2string
&nbsp;
Hex2String_8b:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">CALL</span> B2AHex_Num<span class="re1">1</span>          <span class="co1">; Convertir Hex1 de L</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">CALL</span> B2AHex_Num2          <span class="co1">; Convertir Hex2 de L</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Guardar End Of String</span>
   <span class="kw1">RET</span>
&nbsp;
B2AHex_Num<span class="re1">1</span>:
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RRA</span>                       <span class="co1">; Desplazamos 4 veces &gt;&gt;</span>
   <span class="kw1">RRA</span>                       <span class="co1">; para poder usar el siguiente bloque</span>
&nbsp;
B2AHex_Num2:
   <span class="kw1">OR</span> <span class="sy0">$</span>F<span class="re1">0</span>                    <span class="co1">; Enmascaramos 11110000</span>
   <span class="kw1">DAA</span>                       <span class="co1">; Ajuste BCD</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>A<span class="re1">0</span>
   <span class="kw1">ADC</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Guardamos dato</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">RET</span></pre>

<p>
 La rutina siempre devolverá una cadena de 2 caracteres + End_Of_String
para valores de 8 bits, y de 4 caracteres + End_Of_String para valores
de 16 bits.
</p>

<p>
<br>

<br>

</p>

</div>

<h4 id="int2stringconversion-a-representacion-decimal">Int2String: Conversión a representación decimal</h4>
<div class="level4">

<p>
 Finalmente, veamos la rutina que convierte un valor numérico en su
representación en formato decimal natural (representación de número
positivo).
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------</span>
<span class="co1">; Int2String_8 e Int2String_16:</span>
<span class="co1">; Convierte un valor de 16 bits a una cadena imprimible.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:   HL = valor numerico a convertir</span>
<span class="co1">; Salida:    Cadena en int2dec16_result .</span>
<span class="co1">; De:        Milos Bazelides http://baze.au.com/misc/z80bits.html</span>
<span class="co1">;-----------------------------------------------------------------</span>
Int2String_<span class="re1">1</span><span class="nu0">6</span>:
   <span class="kw1">LD</span> <span class="kw2">DE</span>, conv2string           <span class="co1">; Apuntamos a cadena destino</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">-</span><span class="re1">10000</span>                <span class="co1">; Calcular digito decenas de miles</span>
   <span class="kw1">CALL</span> Int2Dec_num<span class="re1">1</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">-</span><span class="re1">1000</span>                 <span class="co1">; Calcular digito miles</span>
   <span class="kw1">CALL</span> Int2Dec_num<span class="re1">1</span>
   <span class="kw1">JR</span> Int2String_8b             <span class="co1">; Continuar en rutina de 8 bits (2)</span>
&nbsp;
Int2String_8:                   <span class="co1">; Punto de entrada de rutina 8 bits</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, conv2string           <span class="co1">; Apuntar a cadena destino</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>                      <span class="co1">; Parte alta de HL = 0</span>
&nbsp;
Int2String_8b:                  <span class="co1">; rutina de 8 bits (2)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">-</span><span class="re1">100</span>                  <span class="co1">; Calcular digito de centenas</span>
   <span class="kw1">CALL</span> Int2Dec_num<span class="re1">1</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="sy0">-</span><span class="re1">10</span>                    <span class="co1">; Calcular digito de decenas</span>
   <span class="kw1">CALL</span> Int2Dec_num<span class="re1">1</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">B</span>                      <span class="co1">; Calcular unidades</span>
   <span class="kw1">CALL</span> Int2Dec_num<span class="re1">1</span>
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Almacenar un fin de cadena</span>
   <span class="kw1">RET</span>
&nbsp;
Int2Dec_num<span class="re1">1</span>:
   <span class="kw1">LD</span> <span class="kw2">A</span>,<span class="st0">'0'</span><span class="sy0">-</span><span class="re1">1</span>                   <span class="co1">; Contador unidades, empieza '0'-1</span>
&nbsp;
Int2Dec_num2:
   <span class="kw1">INC</span> <span class="kw2">A</span>                        <span class="co1">; Incrementamos el digito ('0', ... '9')</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                   <span class="co1">; Restamos "unidades" hasta sobrepasarlo</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, Int2Dec_num2           <span class="co1">; Repetir n veces</span>
   <span class="kw1">SBC</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                   <span class="co1">; Deshacemos el último paso</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Almacenamos el valor</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">RET</span></pre>

<p>
 Esta rutina almacena en la cadena todos los valores '0' que obtiene,
incluídos los de las unidades superiores al primer dígito del número (<em>leading zeros</em>).
 Así, la conversión del valor de 8 bits 17 generará una cadena “017” y
la conversión del número de 16 bits 1034 generará la cadena “01034”.
</p>

<p>
<br>

<br>

<strong>Eliminando los “leading zeros”</strong>
<br>

<br>

</p>

<p>
 Si no queremos imprimir los ceros que hay al principio de una cadena
apuntada por HL, podemos utilizar la siguiente rutina que incrementa HL
mientras encuentre ceros <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> al principio de la cadena, y sale de la rutina cuando encuentra el fin de cadena o un carácter distinto de '0'.
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------</span>
<span class="co1">; Incrementar HL para saltar los 0's a principio de cadena</span>
<span class="co1">; (utilizar tras llamada a Int2String_8 o Int2String_16).</span>
<span class="co1">;-----------------------------------------------------------------</span>
INC_HL_Remove_Leading_Zeros:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Leemos caracter de la cadena</span>
   <span class="kw1">OR</span> <span class="kw2">A</span>
   <span class="kw1">RET</span> Z                     <span class="co1">; Fin de cadena -&gt; volver</span>
   <span class="kw1">CP</span> <span class="st0">'0'</span>
   <span class="kw1">RET</span> NZ                    <span class="co1">; Distinto de '0', volver</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; '0', incrementar HL y repetir</span>
   <span class="kw1">JR</span> INC_HL_Remove_Leading_Zeros</pre>

<p>
 La rutina de conversión, en conjunción con la subrutina para eliminar los <em>leading zeros</em> se utilizaría de la siguiente forma:
</p>
<pre class="code z80">   <span class="co1">;;; Imprimir variable de 8 bits (podría ser un registro)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>variable_8bits<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">CALL</span> Int2String_8
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> INC_HL_Remove_Leading_Zeros
   <span class="kw1">CALL</span> PrintString_8x8
&nbsp;
   <span class="co1">;;; Imprimir variable de 16 bits</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>variable_<span class="re1">1</span>6bits<span class="br0">)</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>                               <span class="co1">; HL = BC</span>
   <span class="kw1">CALL</span> Int2String_<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> INC_HL_Remove_Leading_Zeros
   <span class="kw1">CALL</span> PrintString_8x8</pre>

<p>
<br>

<br>

<strong>Justificando los “leading zeros”</strong>
<br>

<br>

</p>

<p>
 Finalmente, el usuario <strong>climacus</strong> en los foros de
Speccy.org nos ofrece la siguiente variación de
INC_HL_Remove_Leading_Zeros para que la rutina imprima espacios en lugar
 de “leading zeros”, lo que provoca que el texto en pantalla esté
justificado a la derecha en ocupando siempre 3 (valores de 8 bits) ó 5
(valores de 16 bits) caracteres. Esto permite que los valores impresos
puedan sobreescribir en pantalla valores anteriores aunque estemos
imprimiendo un valor “menor” que el que reside en pantalla:
</p>
<pre class="code z80">INC_HL_Justify_Leading_Zeros:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Leemos caracter de la cadena</span>
   <span class="kw1">OR</span> <span class="kw2">A</span>
   <span class="kw1">RET</span> Z                     <span class="co1">; Fin de cadena -&gt; volver</span>
   <span class="kw1">CP</span> <span class="st0">'0'</span>
   <span class="kw1">RET</span> NZ                    <span class="co1">; Distinto de '0', volver</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; '0', incrementar HL y repetir</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">' '</span>
   <span class="kw1">CALL</span> Font_Blank           <span class="co1">; Imprimimos espacio y avanzamos</span>
   <span class="kw1">JR</span> INC_HL_Justify_Leading_Zeros</pre>

<p>
 De esta forma, podemos tener en pantalla un valor “12345” que se vea
sobreescrito por un valor “100” al imprimir “  100” (con 2 espacios
delante).
</p>

<p>
 También podemos sustituir “CALL Font_Blank” por un simple “CALL
Font_Inc_X” para que se realice el avance del cursor horizontalmente
pero sin la impresión del carácter espacio.
</p>

<p>
<br>

<br>

</p>

</div>

<h4 id="int2string_8_2digitsvalores-enteros-de-2-digitos">Int2String_8_2Digits: Valores enteros de 2 dígitos</h4>
<div class="level4">

<p>
 En el caso de que necesitemos imprimir un valor numérico de 2 digítos
(00-99), incluyendo el posible cero inicial (en valores 1-9) o los dos
ceros para el valor 00, podemos utilizar la siguiente rutina:
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Int2String_8_2Digits: Convierte el valor del registro A en una </span>
<span class="co1">; cadena de texto de max. 2 caracteres (0-99) decimales en DE.</span>
<span class="co1">; IN:   A = Numero a convertir</span>
<span class="co1">; OUT:  DE = 2 bytes con los ASCIIs</span>
<span class="co1">; Basado en rutina dtoa2d de:</span>
<span class="co1">; http://99-bottles-of-beer.net/language-assembler-%28z80%29-813.html</span>
<span class="co1">;-----------------------------------------------------------------------</span>
Int2String_8_2Digits:
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="st0">'0'</span>                      <span class="co1">; Empezar en ASCII '0' </span>
   <span class="kw1">DEC</span> <span class="kw2">D</span>                          <span class="co1">; Decrementar porque el bucle hace INC</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="re1">10</span>                       <span class="co1">; Base 10</span>
   <span class="kw1">AND</span> <span class="kw2">A</span>                          <span class="co1">; Carry Flag = 0</span>
&nbsp;
dtoa2dloop:
   <span class="kw1">INC</span> <span class="kw2">D</span>                          <span class="co1">; Incrementar numero de decenas</span>
   <span class="kw1">SUB</span> <span class="kw2">E</span>                          <span class="co1">; Quitar una unidad de decenas de A</span>
   <span class="kw1">JR</span> NC, dtoa2dloop              <span class="co1">; Si A todavia no es negativo, seguir</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">E</span>                       <span class="co1">; Decrementado demasiado, volver atras</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="st0">'0'</span>                     <span class="co1">; Convertir a ASCII</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>                        <span class="co1">; E contiene las unidades</span>
   <span class="kw1">RET</span></pre>

<p>
 Este formato resulta especialmente útil para la impresión de variables
temporales (horas, minutos, segundos), o datos con valores máximos
limitados como vidas (0-99) o niveles (0-99).
</p>

<p>
 La forma de imprimir un valor con esta rutina sería el siguiente:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>vidas<span class="br0">)</span>
  <span class="kw1">CALL</span> Int2String_8_2Digits
&nbsp;
  <span class="co1">;; Imprimir parte alta (decenas)</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">0</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>
  <span class="kw1">CALL</span> PrintChar_8x8
&nbsp;
  <span class="co1">;;; Imprimir parte baja (unidades)</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>
  <span class="kw1">CALL</span> PrintChar_8x8</pre>

<p>
 En un posterior apartado de este mismo capítulo veremos cómo integrar
estas funciones en las rutinas de impresión de cadenas con formato.
</p>

<p>
<br>

<br>

</p>

</div>

<h2 id="fuente-estandar-8x8-de-la-rom">Fuente estándar 8x8 de la ROM</h2>
<div class="level2">

<p>
 En el Spectrum disponemos de un tipo de letra estándar de 8×8
pregrabado en ROM. Los caracteres imprimibles alojados en la ROM del
Spectrum van desde el 32 (espacio) al 127 (carácter de copyright),
empezando el primero en $3D00 (15161 decimal) y acabando el último en
$3FFF (16383, el último byte de la ROM).
</p>

<p>
 Existe una variable del sistema llamada <em>CHARS</em> (de 16 bits,
ubicada en las direcciones 23606 y 23607) que contiene la dirección de
memoria del juego de caracteres que esté en uso por BASIC.
</p>

<p>
 Por defecto, CHARS contiene el valor $3D00 (el tipo de letra estándar)
menos 256. El hecho de restar 256 al inicio real de la fuente es porque
los caracteres definidos en la ROM empiezan en el 32 y restando 256 (8
bytes por carácter para 32 caracteres = 256 bytes), al igual que hicimos
 nosotros con nuestro charset personalizado, podemos hacer coincidir un <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> &gt; 32 con <strong>CHARS+(8*VALOR_<abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>)</strong>.
</p>

<p>
 El valor por defecto de <em>CHARS</em> es, pues, $3D00 - $0100 = $3C00.
</p>

<p>
 El juego de caracteres estándar es inmutable al estar en ROM. La
variable CHARS permitía, en el BASIC del Spectrum, definir un juego de
caracteres personalizado en RAM y apuntar CHARS a su dirección en
memoria. La definición de los 21 UDGs (19 en el +2A/+3) también está en
RAM (desde $FF58 a $FFFF), ya que deben de ser personalizables por el
usuario.
</p>

<p>
 Veamos el aspecto de la tipográfia estándar del Spectrum:
</p>

<p>
<br>

<img src="img/gfx4_charsetrom.png" class="mediacenter" alt=" El juego de caracteres de la ROM"/>
</p>
<div style="text-align: center;"><em>El juego de caracteres estándar de la ROM</em>
</div>
<p>
<br>

</p>

<p>
 El formato en memoria de la fuente de la ROM es idéntico a un spriteset
 de 8×8 sin atributos, tal y como hemos definido las fuentes de texto
personalizadas de nuestras rutinas y ejemplos anteriores. A partir de
$3D00 empiezan los 8 bytes de datos (8 scanlines) del carácter 32, a los
 que siguen los 8 scanlines del carácter 33, etc., así hasta el carácter
 127.
</p>

<p>
 Gracias a esto podemos utilizar esta tipografía en nuestros juegos y
programas (ahorrando así tener que definir nuestro propio charset y
ocupar memoria con él) directamente con las rutinas de impresión de
caracteres y cadenas que hemos utilizado con las fuentes de texto
personalizables. Basta con establecer FONT_CHARSET a la dirección
adecuada, $3C00:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="re1">1</span><span class="nu0">56</span><span class="re1">1</span><span class="nu0">6</span><span class="sy0">-</span><span class="nu0">256</span>           <span class="co1">; Saltamos los 32 caracteres iniciales</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>, <span class="kw2">HL</span>      <span class="co1">; Ya podemos utilizar la tipografia del</span>
                             <span class="co1">; Spectrum con nuestras rutinas.</span></pre>

<p>
 Esto nos permite ahorrar 768 bytes de memoria en nuestro programa (el
de un charset personalizado) y disponer de un recurso para la impresión
de texto con un aspecto “estándar” (al que el usuario ya está
acostumbrado).
</p>

<p>
<br>

<br>

</p>

</div>

<h2 id="sistema-de-gestion-de-texto">Sistema de gestión de texto</h2>
<div class="level2">

<p>
 Si estamos escribiendo un programa o juego que requiera la impresión de
 gran cantidad de texto puede resultar imprescindible disponer de un
pequeño sistema para almacenar los datos sobre la posición actual del
“cursor” en pantalla, color y estilo de la fuente, etc. Asímismo,
también resulta especialmente útil un set de rutinas para modificar
todas estas variables fácilmente e imprimir cadenas con códigos de
control directamente embebidos dentro de las mismas.
</p>

<p>
 Normalmente no se usará este tipo de rutinas en un juego arcade o
videoaventura, pero puede aprovecharse en programas no lúdicos y en
juegos basados en texto o con gran cantidad de texto (managers
deportivos, aventuras de texto, RPGs, etc).
</p>

<p>
 Ya hemos visto cómo las rutinas PrintChar_8x8 y PrintString_8x8 hacen
uso de las variables FONT_X, FONT_Y, FONT_CHARSET y FONT_ATTRIB. En este
 apartado definiremos más variables, funciones para manipularlas y
nuevas funciones de impresión que hagan uso avanzado de ambas.
</p>

<p>
 La sección sobre sistemas de gestión de texto se divide en:
</p>
<ul class="fix-media-list-overlap">
<li> Descripción de las variables globales que se usarán.
</li>
<li> Rutina de impresión de caracteres con diferentes estilos.
</li>
<li> Descripción de códigos de control que se usarán en las cadenas.
</li>
<li> Rutina de impresión de cadenas avanzada que haga uso de los códigos de control.
</li>
<li> Rutina de impresión de cadenas extendida que soporte códigos de variable.
</li>
</ul>

<p>
 Cuando trabajamos con texto tenemos que tener en cuenta que no se
suelen requerir niveles de optimización de tiempos de ejecución como en
el caso de la rutinas de impresión de sprites. En este caso, dado que el
 tiempo de “lectura” del usuario es significativamente mayor que el
tiempo de ejecución, las rutinas deben tratar de ahorrar espacio en
memoria para que el programa pueda disponer de la mayor cantidad de
texto posible.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit8" id="variables-de-nuestro-sistema-de-gestion">Variables de nuestro sistema de gestión</h3>
<div class="level3">

<p>
 Estas son las variables que utilizaremos en nuestras rutinas:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>FONT_X</strong>, <strong>FONT_Y</strong>
 : Coordenadas X e Y en baja resolución (comenzando en 0) de la posición
 actual para la próxima impresión de un carácter (cursor).</div>
</li>
<li><div class="li"> <strong>FONT_CHARSET</strong> : Apunta al spriteset de la fuente de texto (charset) a utilizar. El valor por defecto es $3D00-256 (la fuente de la ROM).</div>
</li>
<li><div class="li"> <strong>FONT_ATTRIB</strong> : Almacena el atributo en uso para la impresión de caracteres.</div>
</li>
<li><div class="li"> <strong>FONT_STYLE</strong> : Almacena un valor numérico que define el estilo de impresión a utilizar. Por defecto es 0 (estilo normal).</div>
</li>
</ul>

<p>
 También utilizaremos algunas constantes que se modificarán sólo en tiempo de ensamblado:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>FONT_SRCWIDTH</strong> y <strong>FONT_SRCHEIGHT</strong> : Definen el ancho y alto de la pantalla en caracteres. Para fuentes de 8×8, vale 32 y 24 respectivamente.</div>
</li>
</ul>

<p>
 En código de programa:
</p>
<pre class="code z80">FONT_CHARSET     DW    <span class="sy0">$</span>3D<span class="re1">00</span><span class="sy0">-</span><span class="nu0">256</span>
FONT_ATTRIB      DB    <span class="nu0">56</span>       <span class="co1">; Negro sobre gris</span>
FONT_STYLE       DB    <span class="re1">0</span>
FONT_X           DB    <span class="re1">0</span>
FONT_Y           DB    <span class="re1">0</span>
FONT_SCRWIDTH    <span class="kw3">EQU</span>   <span class="nu0">32</span>
FONT_SCRHEIGHT   <span class="kw3">EQU</span>   <span class="nu0">24</span></pre>

<p>
 El resto de constantes (como los códigos de control) los veremos más adelante en sus correspondientes apartados.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit9" id="subrutinas-de-gestion-de-posicion-y-atributos">Subrutinas de gestión de posición y atributos</h3>
<div class="level3">

<p>
 Una vez definidas las diferentes variables, necesitamos funciones
básicas para gestionarlas. Nótese que ninguna de las siguientes
funciones provoca impresión de datos en pantalla, sólo altera el estado
de las variables que acabamos de ver y que después utilizarán las
funciones de impresión:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
FONT_CHARSET     DW    <span class="sy0">$</span>3D<span class="re1">00</span><span class="sy0">-</span><span class="nu0">256</span>
FONT_ATTRIB      DB    <span class="nu0">56</span>       <span class="co1">; Negro sobre gris</span>
FONT_STYLE       DB    <span class="re1">0</span>
FONT_X           DB    <span class="re1">0</span>
FONT_Y           DB    <span class="re1">0</span>
FONT_SCRWIDTH    <span class="kw3">EQU</span>   <span class="nu0">32</span>
FONT_SCRHEIGHT   <span class="kw3">EQU</span>   <span class="nu0">24</span>
&nbsp;
FONT_NORMAL      <span class="kw3">EQU</span>   <span class="re1">0</span>
FONT_BOLD        <span class="kw3">EQU</span>   <span class="re1">1</span>
FONT_UNDERSC     <span class="kw3">EQU</span>   <span class="nu0">2</span>
FONT_ITALIC      <span class="kw3">EQU</span>   <span class="nu0">3</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer el CHARSET en USO</span>
<span class="co1">; Entrada :  HL = direccion del charset en memoria</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_Charset:
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>, <span class="kw2">HL</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer el estilo de texto en uso.</span>
<span class="co1">; Entrada :  A = estilo</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_Style:
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_STYLE<span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer la coordenada X en pantalla.</span>
<span class="co1">; Entrada :  A = coordenada X</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_X:
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer la coordenada Y en pantalla.</span>
<span class="co1">; Entrada :  A = coordenada Y</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_Y:
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer la posicion X,Y del curso de fuente en pantalla.</span>
<span class="co1">; Entrada :  B = Coordenada Y</span>
<span class="co1">;            C = Coordenada X</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_XY:
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">BC</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer un valor de tinta para el atributo en curso.</span>
<span class="co1">; Entrada :  A = Tinta (0-7)</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_Ink:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Preservamos registros</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>                     <span class="co1">; Borramos bits 7-3</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>                   <span class="co1">; Lo guardamos en B</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>       <span class="co1">; Cogemos el atributo actual</span>
   <span class="kw1">AND</span> <span class="re1">%11111000</span>             <span class="co1">; Borramos el valor de INK</span>
   <span class="kw1">OR</span> <span class="kw2">B</span>                      <span class="co1">; Insertamos INK en A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Guardamos el valor de INK</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer un valor de papel para el atributo en curso.</span>
<span class="co1">; Entrada :  A = Papel (0-7)</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_Paper:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Preservamos registros</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>                     <span class="co1">; Borramos bits 7-3</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = 00000XXX -&gt; 0000XXX0</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = 000XXX00</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = 00XXX000 &lt;-- Valor en paper</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>                   <span class="co1">; Lo guardamos en B</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>       <span class="co1">; Cogemos el atributo actual</span>
   <span class="kw1">AND</span> <span class="re1">%11000111</span>             <span class="co1">; Borramos los datos de PAPER</span>
   <span class="kw1">OR</span> <span class="kw2">B</span>                      <span class="co1">; Insertamos PAPER en A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Guardamos el valor de PAPER</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer un valor de atributo para la impresion.</span>
<span class="co1">; Entrada :  A = Tinta</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_Attrib:
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer un valor de brillo (1/0) en el atributo actual.</span>
<span class="co1">; Entrada :  A = Brillo (0-7)</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_Bright:
   <span class="kw1">AND</span> <span class="re1">1</span>                     <span class="co1">; A = solo bit 0 de A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>       <span class="co1">; Cargamos en A el atributo</span>
   <span class="kw1">JR</span> NZ, fsbright_<span class="re1">1</span>         <span class="co1">; Si el bit solicitado era </span>
   <span class="kw1">RES</span> <span class="nu0">6</span>, <span class="kw2">A</span>                  <span class="co1">; Seteamos a 0 el bit de flash</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Escribimos el atributo</span>
   <span class="kw1">RET</span>
fsbright_<span class="re1">1</span>:
   <span class="kw1">SET</span> <span class="nu0">6</span>, <span class="kw2">A</span>                  <span class="co1">; Seteamos a 1 el bit de brillo</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Escribimos el atributo</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Establecer un valor de flash (1/0) en el atributo actual.</span>
<span class="co1">; Entrada :  A = Flash (1/0)</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Set_Flash:
   <span class="kw1">AND</span> <span class="re1">1</span>                     <span class="co1">; A = solo bit 0 de A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>       <span class="co1">; Cargamos en A el atributo</span>
   <span class="kw1">JR</span> NZ, fsflash_<span class="re1">1</span>          <span class="co1">; Si el bit solicitado era </span>
   <span class="kw1">RES</span> <span class="nu0">7</span>, <span class="kw2">A</span>                  <span class="co1">; Seteamos a 0 el bit de flash</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Escribimos el atributo</span>
   <span class="kw1">RET</span>
fsflash_<span class="re1">1</span>:
   <span class="kw1">SET</span> <span class="nu0">7</span>, <span class="kw2">A</span>                  <span class="co1">; Seteamos a 1 el bit de flash</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>       <span class="co1">; Escribimos el atributo</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Imprime un espacio, sobreescribiendo la posicion actual del</span>
<span class="co1">; cursor e incrementando X en una unidad.</span>
<span class="co1">; de la pantalla (actualizando Y en consecuencia).</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Blank:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">' '</span>                 <span class="co1">; Imprimir caracter espacio</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">CALL</span> PrintChar_8x8        <span class="co1">; Sobreescribir caracter</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">CALL</span> Font_Inc_X           <span class="co1">; Incrementamos la coord X</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Incrementa en 1 la coordenada X teniendo en cuenta el borde</span>
<span class="co1">; de la pantalla (actualizando Y en consecuencia).</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Inc_X:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_X<span class="br0">)</span>            <span class="co1">; Incrementamos la X</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>                     <span class="co1">; pero comprobamos si borde derecho</span>
   <span class="kw1">CP</span> FONT_SCRWIDTH<span class="sy0">-</span><span class="re1">1</span>        <span class="co1">; X &gt; ANCHO-1?</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, fincx_noedgex       <span class="co1">; No, se puede guardar el valor</span>
   <span class="kw1">CALL</span> Font_CRLF
   <span class="kw1">RET</span>
&nbsp;
fincx_noedgex:
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Establecemos el valor de X</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Produce un LineFeed (incrementa Y en 1). Tiene en cuenta</span>
<span class="co1">; las variables de altura de la pantalla.</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_LF:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_Y<span class="br0">)</span>            <span class="co1">; Cogemos coordenada Y</span>
   <span class="kw1">CP</span> FONT_SCRHEIGHT<span class="sy0">-</span><span class="re1">1</span>       <span class="co1">; Estamos en la parte inferior</span>
   <span class="kw1">JR</span> NC, fontlf_noedge      <span class="co1">; de pantalla? -&gt; No avanzar</span>
   <span class="kw1">INC</span> <span class="kw2">A</span>                     <span class="co1">; No estamos, avanzar</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
fontlf_noedge:
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Produce un Retorno de Carro (Carriage Return) -&gt; X=0.</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_CR:
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Provoca un LF y un CR en ese orden.</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_CRLF:
   <span class="kw1">CALL</span> Font_LF
   <span class="kw1">CALL</span> Font_CR
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Imprime un tabulador (3 espacios) mediante PrintString.</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Tab:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, font_tab_string
   <span class="kw1">CALL</span> PrintString_8x8      <span class="co1">; Imprimimos 3 espacios</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">RET</span>
&nbsp;
font_tab_string  DB  <span class="st0">"   "</span>, <span class="re1">0</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Decrementa la coordenada X, simultando un backspace.</span>
<span class="co1">; No realiza el borrado en si.</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Dec_X:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_X<span class="br0">)</span>            <span class="co1">; Cargamos la coordenada X</span>
   <span class="kw1">OR</span> <span class="kw2">A</span>
   <span class="kw1">RET</span> Z                     <span class="co1">; Es cero? no se hace nada (salir)</span>
   <span class="kw1">DEC</span> <span class="kw2">A</span>                     <span class="co1">; No es cero? Decrementar</span>
   <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">RET</span>                       <span class="co1">; Salir</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Decrementa la coordenada X, simultando un backspace.</span>
<span class="co1">; Realiza el borrado imprimiendo un espacio con LD.</span>
<span class="co1">; Modifica:  AF</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_Backspace:
   <span class="kw1">CALL</span> Font_Dec_X
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">' '</span>                 <span class="co1">; Imprimir caracter espacio</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">CALL</span> PrintChar_8x8        <span class="co1">; Sobreescribir caracter</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">RET</span>                       <span class="co1">; Salir</span></pre>

<p>
 Podemos llamar a estas funciones desde nuestro programa en lugar de
incluir una y otra vez el código necesario para efectuar una acción:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">HL</span>, micharset
  <span class="kw1">CALL</span> Font_Set_Charset
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="sy0">+</span><span class="br0">(</span><span class="nu0">7</span><span class="sy0">*</span><span class="nu0">8</span><span class="br0">)</span>
  <span class="kw1">Call</span> Font_Set_Attrib
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, FONT_NORMAL
  <span class="kw1">CALL</span> Font_Set_Style
  <span class="br0">(</span>...<span class="br0">)</span></pre>

<p>
<br>

<br>

</p>

</div>

<h3 class="sectionedit10" id="impresion-de-caracteres-con-estilos">Impresión de caracteres con estilos</h3>
<div class="level3">

<p>
 Aunque ya hemos visto una rutina PrintChar_8x8 para impresión de
caracteres, vamos a implementar a continuación una nueva versión de la
misma con la posibilidad de utilizar diferente estilos de fuente a
partir de la fuente original.
</p>

<p>
 Mediante un único juego de caracteres podemos simular estilos de texto a
 través de código, manipulando “al vuelo” los datos del charset antes de
 imprimirlos. Esto nos evita la necesidad de tener múltiples charsets de
 texto para distintos estilos con la consiguiente ocupación de espacio
en memoria.
</p>

<p>
 Los estilos básicos que podemos conseguir al vuelo son <strong>normal</strong>, <strong>negrita</strong>, <strong>cursiva</strong> y <strong>subrayado</strong>.
</p>

<p>
 Las rutinas de impresión para los 4 estilos esencialmente iguales salvo
 por el bucle de impresión, por lo que vamos a utilizar una variable
global llamada <strong>FONT_STYLE</strong> para indicar el estilo actual
 en uso, y modificaremos la rutina PrintChar_8x8 para que haga uso del
valor del estilo y modifique el bucle de impresión en consecuencia.
</p>
<pre class="code">;--- Variables de fuente --------------------
FONT_CHARSET     DW    $3D00-256
FONT_ATTRIB      DB    56       ; Negro sobre gris
FONT_STYLE       DB    0
FONT_X           DB    0
FONT_Y           DB    0

;--- Constantes predefinidas ----------------
FONT_NORMAL      EQU   0
FONT_BOLD        EQU   1
FONT_UNDERSC     EQU   2
FONT_ITALIC      EQU   3


;--- Nueva funcion PrintChar_8x8 ------------
PrintChar_8x8:
   ;;; Calcular coordenadas destino en Pantalla en DE
   ;;; Calcular posicion origen (array sprites) en HL
   ;;; Obtener el valor de FONT_STYLE
       ;;; Si es == FONT_NORMAL  -&gt; Bucle_Impresion_Normal
       ;;; Si es == FONT_BOLD    -&gt; Bucle_Impresion_Negrita
       ;;; Si es == FONT_UNDERSC -&gt; Bucle_Impresion_Subrayado
       ;;; Si es == FONT_ITALIC  -&gt; Bucle_Impresion_Cursiva
   ;;; Calcular posicion destino atributo.
   ;;; Imprimir Atributo.</pre>

<p>
 El esqueleto de la función PrintChar_8x8, a falta de introducir los bucles de impresión, ya lo conocemos:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; PrintChar_8x8:</span>
<span class="co1">; Imprime un caracter de 8x8 pixeles de un charset usando</span>
<span class="co1">; el estilo especificado en FONT_STYLE.</span>
<span class="co1">;-------------------------------------------------------------</span>
PrintChar_8x8:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>FONT_X<span class="br0">)</span>      <span class="co1">; B = Y,  C = X</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'           ; Nos guardamos el caracter en A'</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>              <span class="co1">; DE contiene ahora la direccion destino.</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*8)</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'           ; Recuperamos el caracter a dibujar de A'</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = BC + HL = FONT_CHARSET + (A * 8)</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>          <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="co1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="co1">;;; INSERTAR AQUI BUCLES DE IMPRESION SEGUN ESTILO</span>
   <span class="co1">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
&nbsp;
   <span class="co1">;;; (...)</span>
&nbsp;
   <span class="co1">;;; Impresion del caracter finalizada </span>
&nbsp;
   <span class="co1">;;; Impresion de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>            <span class="co1">; Recuperamos el valor inicial de HL</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>              <span class="co1">; Restando los 8 scanlines avanzados</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
                      <span class="co1">; A = H</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">L</span>
&nbsp;
   <span class="co1">;;; Escribir el atributo en memoria</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribimos el atributo en memoria</span>
   <span class="kw1">RET</span></pre>

<p>
 La manera de obtener los diferentes estilos es la siguiente:
</p>

<p>
<br>

<br>

<strong>Estilo normal</strong>:
No se realiza ningún tipo de modificación sobre los datos del carácter:
se imprimen tal cual se obtienen del spriteset en un bucle de 8
iteraciones:
</p>
<pre class="code z80">   <span class="co1">;;;;;; Estilo NORMAL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                      <span class="co1">; 8 scanlines a dibujar</span>
drawchar_loop_normal:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                   <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_normal
   <span class="kw1">JR</span> pchar8_printattr          <span class="co1">; Impresion de atributos</span></pre>

<p>
<br>

<br>

<strong>Estilo negrita (bold)</strong>:
Para simular el efecto de la negrita necesitamos aumentar el grosor del
carácter. Para eso, leemos cada scanline y realizamos un OR de dicho
scanline con una copia del mismo desplazada hacia la derecha o hacia la
izquierda.
</p>
<pre class="code z80">   <span class="co1">;;;;;; Estilo NEGRITA ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                      <span class="co1">; 8 scanlines a dibujar</span>
drawchar_loop_bold:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                   <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>                      <span class="co1">; Creamos copia de A</span>
   <span class="kw1">RRCA</span>                         <span class="co1">; Desplazamos A</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>                         <span class="co1">; Y agregamos C</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_bold
   <span class="kw1">JR</span> pchar8_printattr          <span class="co1">; Impresion de atributos</span></pre>

<p>
<br>

<br>

<strong>Estilo Subrayado (underscore)</strong>:
Basta con dibujar los 7 primeros scanlines del carácter correctamente, y
 trazar como octavo scanline un valor 255 (8 píxeles a 1, una línea
horizontal). De esta forma el último scanline se convierte en el
subrayado.
</p>
<pre class="code z80">   <span class="co1">;;;;;; Estilo SUBRAYADO ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">7</span>                      <span class="co1">; 7 scanlines a dibujar normales</span>
drawchar_loop_undersc:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                   <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_undersc
&nbsp;
   <span class="co1">;;; El octavo scanline, una linea de subrayado</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>                    <span class="co1">; Ultima linea = subrayado</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>                        <span class="co1">; Necesario para el SUB A, 8</span>
   <span class="kw1">JR</span> pchar8_printattr          <span class="co1">; Impresion de atributos</span></pre>

<p>
<br>

<br>

<strong>Estilo Cursiva (italic)</strong>:
Finalmente, el estilo de letra cursiva implica imprimir los 3 primeros
scanlines desplazados hacia la derecha, los 2 centrales sin modificación
 y los 3 últimos desplazados hacia la izquierda:
</p>
<pre class="code z80">   <span class="co1">;;;;;; Estilo ITALICA ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="co1">;;; 3 primeros scanlines, a la derecha,</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">3</span>
drawchar_loop_italic<span class="re1">1</span>:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">SRA</span> <span class="kw2">A</span>              <span class="co1">; Desplazamos A a la derecha</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_italic<span class="re1">1</span>
&nbsp;
   <span class="co1">;;; 2 siguientes scanlines, sin tocar</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">2</span>
&nbsp;
drawchar_loop_italic2:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_italic2
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">3</span>
drawchar_loop_italic3:
   <span class="co1">;;; 3 ultimos scanlines, a la izquierda,</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">SLA</span> <span class="kw2">A</span>              <span class="co1">; Desplazamos A</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_italic3
   <span class="kw1">JR</span> pchar8_printattr</pre>

<p>
 El código completo y definitivo de la función de impresión de caracteres con estilo es el siguiente:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; PrintChar_8x8:</span>
<span class="co1">; Imprime un caracter de 8x8 pixeles de un charset usando</span>
<span class="co1">; el estilo especificado en FONT_STYLE</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; -----------------------------------------------------</span>
<span class="co1">; FONT_CHARSET = Direccion de memoria del charset.</span>
<span class="co1">; FONT_X       = Coordenada X en baja resolucion (0-31)</span>
<span class="co1">; FONT_Y       = Coordenada Y en baja resolucion (0-23)</span>
<span class="co1">; FONT_ATTRIB  = Atributo a utilizar en la impresion.</span>
<span class="co1">; FONT_STYLE   = Estilo a utilizar (0-N).</span>
<span class="co1">; Registro A   = ASCII del caracter a dibujar.</span>
<span class="co1">;-------------------------------------------------------------</span>
PrintChar_8x8:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>FONT_X<span class="br0">)</span>      <span class="co1">; B = Y,  C = X</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'           ; Nos guardamos el caracter en A'</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>              <span class="co1">; DE contiene ahora la direccion destino.</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*8)</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'           ; Recuperamos el caracter a dibujar de A'</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>         <span class="co1">; HL = BC + HL = FONT_CHARSET + (A * 8)</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>          <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="co1">;;; NUEVO: Verificacion del estilo actual</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_STYLE<span class="br0">)</span>           <span class="co1">; Obtenemos el estilo actual</span>
   <span class="kw1">OR</span> <span class="kw2">A</span>
   <span class="kw1">JR</span> NZ, pchar8_estilos_on     <span class="co1">; Si es != cero, saltar</span>
&nbsp;
   <span class="co1">;;;;;; Estilo NORMAL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                      <span class="co1">; 8 scanlines a dibujar</span>
drawchar_loop_normal:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                   <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                   <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_normal
   <span class="kw1">JR</span> pchar8_printattr          <span class="co1">; Imprimir atributos</span>
&nbsp;
pchar8_estilos_on:
   <span class="kw1">CP</span> FONT_BOLD                 <span class="co1">; ¿Es estilo NEGRITA?</span>
   <span class="kw1">JR</span> NZ, pchar8_nobold         <span class="co1">; No, saltar</span>
&nbsp;
   <span class="co1">;;;;;; Estilo NEGRITA ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>            <span class="co1">; 8 scanlines a dibujar</span>
drawchar_loop_bold:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>            <span class="co1">; Creamos copia de A</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Desplazamos A</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>               <span class="co1">; Y agregamos C</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>             <span class="co1">; Incrementamos puntero en caracter</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>              <span class="co1">; Incrementamos puntero en pantalla (scanline+=1)</span>
   <span class="kw1">DJNZ</span> drawchar_loop_bold
   <span class="kw1">JR</span> pchar8_printattr
&nbsp;
pchar8_nobold:
   <span class="kw1">CP</span> FONT_UNDERSC              <span class="co1">; ¿Es estilo SUBRAYADO?</span>
   <span class="kw1">JR</span> NZ, pchar8_noundersc      <span class="co1">; No, saltar</span>
&nbsp;
   <span class="co1">;;;;;; Estilo SUBRAYADO ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">7</span>            <span class="co1">; 7 scanlines a dibujar normales</span>
drawchar_loop_undersc:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_undersc
&nbsp;
   <span class="co1">;;; El octavo scanline, una linea de subrayado</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">255</span>          <span class="co1">; Ultima linea = subrayado</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>              <span class="co1">; Necesario para el SUB A, 8</span>
   <span class="kw1">JR</span> pchar8_printattr
&nbsp;
pchar8_noundersc:
   <span class="kw1">CP</span> FONT_ITALIC               <span class="co1">; ¿Es estilo ITALICA?</span>
   <span class="kw1">JR</span> NZ, pchar8_UNKNOWN        <span class="co1">; No, saltar</span>
&nbsp;
   <span class="co1">;;;;;; Estilo ITALICA ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span>
   <span class="co1">;;; 3 primeros scanlines, a la derecha,</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">3</span>
drawchar_loop_italic<span class="re1">1</span>:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">SRA</span> <span class="kw2">A</span>              <span class="co1">; Desplazamos A a la derecha</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_italic<span class="re1">1</span>
&nbsp;
   <span class="co1">;;; 2 siguientes scanlines, sin tocar</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">2</span>
&nbsp;
drawchar_loop_italic2:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_italic2
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">3</span>
drawchar_loop_italic3:
   <span class="co1">;;; 3 ultimos scanlines, a la izquierda,</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>         <span class="co1">; Tomamos el dato del caracter</span>
   <span class="kw1">SLA</span> <span class="kw2">A</span>              <span class="co1">; Desplazamos A</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el valor en videomemoria</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>
   <span class="kw1">DJNZ</span> drawchar_loop_italic3
   <span class="kw1">JR</span> pchar8_printattr
&nbsp;
&nbsp;
pchar8_UNKNOWN:                 <span class="co1">; Estilo desconocido...</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                      <span class="co1">; Lo imprimimos con el normal</span>
   <span class="kw1">JR</span> drawchar_loop_normal      <span class="co1">; (estilo por defecto)</span>
&nbsp;
   <span class="co1">;;; Impresion de los atributos</span>
pchar8_printattr:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>            <span class="co1">; Recuperamos el valor inicial de HL</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>              <span class="co1">; Restando los 8 scanlines avanzados</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
                      <span class="co1">; A = H</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">L</span>
&nbsp;
   <span class="co1">;;; Escribir el atributo en memoria</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribimos el atributo en memoria</span>
   <span class="kw1">RET</span></pre>

<p>
 Si definimos esta función PrintChar_8x8 en nuestro programa, la función
 PrintString_8x8 hará uso de ella y podremos imprimir cadenas en
diferentes estilos, como en el siguiente ejemplo:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo de estilos de fuente</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="sy0">$</span>3D<span class="re1">00</span><span class="sy0">-</span><span class="nu0">256</span>        <span class="co1">; Saltamos los 32 caracteres iniciales</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="sy0">+</span><span class="br0">(</span><span class="nu0">7</span><span class="sy0">*</span><span class="nu0">8</span><span class="br0">)</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
  <span class="co1">;;; Probamos los diferentes estilos: NORMAL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, FONT_NORMAL
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_STYLE<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena<span class="re1">1</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">4</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">CALL</span> PrintString_8x8
&nbsp;
  <span class="co1">;;; Probamos los diferentes estilos: NEGRITA</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, FONT_BOLD
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_STYLE<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena2
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">CALL</span> PrintString_8x8
&nbsp;
  <span class="co1">;;; Probamos los diferentes estilos: CURSIVA</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, FONT_ITALIC
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_STYLE<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena3
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">8</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">CALL</span> PrintString_8x8
&nbsp;
  <span class="co1">;;; Probamos los diferentes estilos: SUBRAYADO</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, FONT_UNDERSC
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_STYLE<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena4
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">10</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>FONT_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">CALL</span> PrintString_8x8
&nbsp;
loop:
  <span class="kw1">JR</span> loop
&nbsp;
  <span class="kw1">RET</span>
&nbsp;
cadena<span class="re1">1</span> DB <span class="st0">"IMPRESION CON ESTILO NORMAL."</span>, <span class="re1">0</span>
cadena2 DB <span class="st0">"IMPRESION CON ESTILO NEGRITA."</span>, <span class="re1">0</span>
cadena3 DB <span class="st0">"IMPRESION CON ESTILO CURSIVA."</span>, <span class="re1">0</span>
cadena4 DB <span class="st0">"IMPRESION CON ESTILO SUBRAYADO."</span>, <span class="re1">0</span>
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
FONT_CHARSET     DW    <span class="sy0">$</span>3D<span class="re1">00</span><span class="sy0">-</span><span class="nu0">256</span>
FONT_ATTRIB      DB    <span class="nu0">56</span>       <span class="co1">; Negro sobre gris</span>
FONT_STYLE       DB    <span class="re1">0</span>
FONT_X           DB    <span class="re1">0</span>
FONT_Y           DB    <span class="re1">0</span>
FONT_NORMAL      <span class="kw3">EQU</span>   <span class="re1">0</span>
FONT_BOLD        <span class="kw3">EQU</span>   <span class="re1">1</span>
FONT_UNDERSC     <span class="kw3">EQU</span>   <span class="nu0">2</span>
FONT_ITALIC      <span class="kw3">EQU</span>   <span class="nu0">3</span>
FONT_SCRWIDTH    <span class="kw3">EQU</span>   <span class="nu0">32</span>
FONT_SCRHEIGHT   <span class="kw3">EQU</span>   <span class="nu0">24</span></pre>

<p>
 El anterior ejemplo (que usa el juego de caracteres estándar de la ROM) produce el siguiente resultado en pantalla:
</p>

<p>
<br>

<img src="img/gfx4_estilos.png" class="mediacenter" alt=" Estilos de texto con PrintChar_8x8 "/>
<br>

</p>

<p>
 La rutina de impresión PrintChar_8x8 es ahora ligeramente más lenta que
 la original, pero a cambio nos permite diferentes estilos de texto.
Para la impresión de texto con estilo normal, sólo le hemos añadido el
siguiente código adicional a ejecutar:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_STYLE<span class="br0">)</span>
   <span class="kw1">OR</span> <span class="kw2">A</span>
   <span class="kw1">JR</span> NZ, pchar8_estilos_on      <span class="co1">; Aqui no se produce salto</span>
&nbsp;
   <span class="sy0">+</span>
&nbsp;
   <span class="kw1">JR</span> pchar8_printattr           <span class="co1">; Este salto si se produce</span></pre>

<p>
 Son 13 (LD) + 4 (OR) + 7 (JR NZ sin salto) + 12 (JR) = 36 t-estados
adicionales por carácter en estilo normal a cambio de la posibilidad de
disponer de 4 estilos de texto diferentes para cualquier charset,
incluído el de la ROM.
</p>

<p>
 En la rutina se han utilizado operaciones de transferencia LD para
imprimir los caracteres, lo que implica que no se respeta el fondo sobre
 el que se imprime, y se ponen a cero en pantalla todos los píxeles a
cero en el charset. Este suele ser el sistema de impresión habitual
puesto que el texto, para hacerlo legible, suele imprimirse sobre áreas
en blanco de la pantalla, y un caracter impreso sobre otro debe
sobreescribir totalmente al primero.
</p>

<p>
 No obstante, la rutina PrintChar_8x8 puede ser modificada por el
lector, para utilizar operaciones OR en la transferencia a pantalla y
por tanto respetar el contenido de pantalla al imprimir el carácter.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit11" id="impresion-de-cadenas-con-codigos-de-control">Impresión de cadenas con códigos de control</h3>
<div class="level3">

<p>
 Llegados a este punto, tenemos:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Un sistema de variables que controlan los datos sobre la impresión: posición, estilo, color, fuente de texto, etc.
</li>
<li> Un set de funciones que permite modificar estas variables fácilmente.
</li>
<li> Una función de impresión de
caracteres 8×8 que utiliza estas variables para imprimir el carácter
indicado en la posición adecuada, con el estilo seleccionado y con el
color y fondo elegidos.
</li>
</ul>

<p>
<br>

</p>

<p>
 El siguiente paso en la escala de la gestión del texto sería la <strong>impresión de cadenas con formato</strong>
 para que aproveche nuestras nuevas funciones extendidas. Para esto
modificaremos la rutina PrinString_8x8 vista al principio del capítulo
de forma que haga uso no sólo de FONT_X y FONT_Y sino también de
funciones adicionales que especificaremos en la cadena mediante códigos
de control o <em>tokens</em>.
</p>

<p>
 Los códigos de control que vamos a definir y utilizar serán los siguientes:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit12"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Código de control </th><th class="col1"> Significado </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 0 </td><td class="col1"> Indica Fin de cadena </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 1 </td><td class="col1"> Cambiar estilo (seguido del byte con el estilo) </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 2 </td><td class="col1"> Cambiar posicion x (seguido de la coordenada x) </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 3 </td><td class="col1"> Cambiar posicion y (seguido de la coordenada y) </td>
	</tr>
	<tr class="row5">
		<td class="col0"> 4 </td><td class="col1"> Cambiar color tinta (seguido del color de tinta) </td>
	</tr>
	<tr class="row6">
		<td class="col0"> 5 </td><td class="col1"> Cambiar color de papel (seguido del color de papel) </td>
	</tr>
	<tr class="row7">
		<td class="col0"> 6 </td><td class="col1"> Cambiar color de atributo (seguido del byte de atributo) </td>
	</tr>
	<tr class="row8">
		<td class="col0"> 7 </td><td class="col1"> Cambiar Brillo ON / OFF (seguido de 1 ó 0) </td>
	</tr>
	<tr class="row9">
		<td class="col0"> 8 </td><td class="col1"> Cambiar Flash ON / OFF (seguido de 1 ó 0) </td>
	</tr>
	<tr class="row10">
		<td class="col0"> 10 </td><td class="col1"> Provocar LF (LineFeed = avance de linea) (y+=1) </td>
	</tr>
	<tr class="row11">
		<td class="col0"> 11 </td><td class="col1"> Provocar avance de linea y retorno de carro (LF y CR) (y+=1 y x=0) </td>
	</tr>
	<tr class="row12">
		<td class="col0"> 12 </td><td class="col1"> Avanzar 1 caracter sin imprimir nada (x+=1) </td>
	</tr>
	<tr class="row13">
		<td class="col0"> 13 </td><td class="col1"> Provocar CR (retorno de carro o Carriage Return) (x=0) </td>
	</tr>
	<tr class="row14">
		<td class="col0"> 14 </td><td class="col1"> Backspace: borrar el caracter de (x-1 si x&gt;0)<br>
imprimiendo un espacio y decrementando x. </td>
	</tr>
	<tr class="row15">
		<td class="col0"> 15 </td><td class="col1"> Tabulador (impresion de 3 espacios por llamada a PrintString) </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Así pues, declaramos las siguientes constantes predefinidas:
</p>
<pre class="code">FONT_EOS            EQU 0      ; End of String
FONT_SET_STYLE      EQU 1
FONT_SET_X          EQU 2
FONT_SET_Y          EQU 3
FONT_SET_INK        EQU 4
FONT_SET_PAPER      EQU 5
FONT_SET_ATTRIB     EQU 6
FONT_SET_BRIGHT     EQU 7
FONT_SET_FLASH      EQU 8
FONT_XXXXXX         EQU 9       ; Libre para ampliaciones
FONT_LF             EQU 10
FONT_CRLF           EQU 11
FONT_BLANK          EQU 12
FONT_CR             EQU 13
FONT_BACKSPACE      EQU 14
FONT_TAB            EQU 15
FONT_INC_X          EQU 16      ; De la 17 a la 31 libres</pre>

<p>
 Esto nos permitirá definir las cadenas como, por ejemplo:
</p>
<pre class="code z80">cadena DB <span class="st0">"Cadena de texto "</span>, FONT_SET_INK, <span class="nu0">2</span>, <span class="st0">"ROJO "</span>, FONT_CRLF
       DB FONT_SET_INK, <span class="re1">1</span>, <span class="st0">"AHORA AZUL"</span>
       DB FONT_SET_Y, <span class="nu0">2</span><span class="re1">0</span>, <span class="st0">"AHORA EN LA LINEA 20"</span>, FONT_EOS</pre>

<p>
 La rutina de impresión de cadenas deberá interpretar cada byte de la misma determinando:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> Si es un código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> &gt;= 32 → Imprimir el caracter en FONT_X, FONT_Y (y variar las coordenadas).</div>
</li>
<li> Si es un código de control 0 (EOS) → Fin de la rutina
</li>
<li> Si es un código entre el 1 y el 9 → Recoger parámetro en cadena (siguiente byte) y llamar a la función apropiada.
</li>
<li> Si es un código entre el 10 y el 31 → Llamar a la función apropiada (no hay parámetro).
</li>
</ul>

<p>
 Esto nos permitirá trabajar con cadenas de texto con múltiples formatos
 sin tener que realizar el posicionamiento, cambio de color, de papel,
gestión de los retornos de carro, etc. en nuestro código, con un gran
ahorro en código de manipulación gracias a nuestra nueva rutina genérica
 de impresión.
</p>

<p>
 Llamaremos a esta rutina de impresión con formato <em>PrintString_8x8_Format</em>, y tendrá el siguiente pseudocódigo:
</p>
<pre class="code">;;; HL = Cadena que imprimir

PrintString_8x8_Format:
   ;;;
bucle:
      ;;; Coger caracter apuntado por HL.
      ;;; Incrementar HL
      ;;; Si HL es mayor que 32 :
          ;;; Imprimir caracter en FONT_X,FONT_Y
          ;;; Avanzar el puntero FONT_X
      ;;; Si HL es menor que 31 :
          ;;; Si es CERO, salir de la rutina con RET Z.
          ;;; Si es FONT_SET_SETSTYLE (1):
              ;;; Coger el siguiente byte de la cadena (el estilo)
              ;;; Llamar a función Font_Set_Style
          ;;; Si es FONT_SET_X (2):
              ;;; Coger el siguiente byte de la cadena (coordenada X)
              ;;; Llamar a función Font_Set_X
          ;;; Si es FONT_SET_Y (3):
              ;;; Coger el siguiente byte de la cadena (coordenada X)
              ;;; Llamar a función Font_Set_X
          ;;; (...)
          ;;; (...)
          ;;; (...)
          ;;; Si es FONT_BACKSPACE (14):
              ;;; Llamar a funcion Font_Backspace
          ;;; Si es FONT_TAB (15):
              ;;; Llamar a funcion Font_Tab
      ;;; Saltar a bucle (se saldrá con el RET Z)</pre>

<p>
 El pseudocódigo que acabamos de ver utiliza gran cantidad de controles
de flujo condicionales para decidir a qué rutina debemos de saltar y si
tenemos que recoger un parámetro de la cadena (leer valor apuntado por
HL e incrementar HL) o no.
</p>

<p>
 En lugar de utilizar un enorme bloque de código con gran cantidad de saltos, vamos a emplear una <strong>tabla de saltos</strong>. Para ello creamos una tabla en memoria que contenga las direcciones de salto de todos los códigos de control, excepto el cero:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Tabla con las direcciones de las 16 rutinas de cambio. </span>
<span class="co1">;-------------------------------------------------------------</span>
FONT_CALL_JUMP_TABLE:
  DW <span class="re1">0000</span>, Font_Set_Style, Font_Set_X, Font_Set_Y, Font_Set_Ink
  DW Font_Set_Paper, Font_Set_Attrib, Font_Set_Bright
  DW Font_Set_Flash, <span class="re1">0000</span>, Font_LF, Font_CRLF, Font_Blank
  DW Font_CR, Font_Backspace, Font_Tab, Font_Inc_X</pre>

<p>
 Ahora, suponiendo que tengamos en A el código de control, la rutina en pseudocódigo podría ser así:
</p>
<pre class="code">PrintString_8x8_Format:
bucle:
      ;;; Coger caracter apuntador por HL.
      ;;; Incrementar HL
      ;;; Si HL es mayor que 32 :
          ;;; Imprimir caracter en FONT_X,FONT_Y
          ;;; Avanzar el puntero FONT_X
      ;;; Si HL es menor que 31 :
          ;;; Si es CERO, salir de la rutina con RET Z.
          ;;; Calculamos DIR_SALTO = TABLA_SALTOS [ COD_CONTROL ]
          ;;; Como la tabla es de 2 bytes -&gt; DIR_SALTO = TABLA_SALTOS + COD_CONTROL*2
          ;;; Si es menor que 10, requiere recoger parametro
              ;;; Recoger parametro
          ;;; Si es mayor que 10, no requiere recoger parametro
          ;;; Saltar a la dirección DIR_SALTO
      ;;; Saltar a bucle (se saldrá con el RET Z)</pre>

<p>
 Veamos el código de la rutina definitiva:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Tabla con las direcciones de las 16 rutinas de cambio. </span>
<span class="co1">; Notese que la 9 queda libre para una posible ampliacion.</span>
<span class="co1">;-------------------------------------------------------------</span>
FONT_CALL_JUMP_TABLE:
  DW <span class="re1">0000</span>, Font_Set_Style, Font_Set_X, Font_Set_Y, Font_Set_Ink
  DW Font_Set_Paper, Font_Set_Attrib, Font_Set_Bright
  DW Font_Set_Flash, <span class="re1">0000</span>, Font_LF, Font_CRLF, Font_Blank
  DW Font_CR, Font_Backspace, Font_Tab, Font_Inc_X
&nbsp;
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; PrintString_8x8_Format:</span>
<span class="co1">; Imprime una cadena de texto de un charset de fuente 8x8.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; -----------------------------------------------------</span>
<span class="co1">; FONT_CHARSET = Direccion de memoria del charset.</span>
<span class="co1">; FONT_X       = Coordenada X en baja resolucion (0-31)</span>
<span class="co1">; FONT_Y       = Coordenada Y en baja resolucion (0-23)</span>
<span class="co1">; FONT_ATTRIB  = Atributo a utilizar en la impresion.</span>
<span class="co1">; Registro HL  = Puntero a la cadena de texto a imprimir.</span>
<span class="co1">;                Debe acabar en un cero.</span>
<span class="co1">; Usa: DE, BC</span>
<span class="co1">;-------------------------------------------------------------</span>
PrintString_8x8_Format:
&nbsp;
   <span class="co1">;;; Bucle de impresion de caracter</span>
pstring8_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Leemos un caracter de la cadena</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; Apuntamos al siguiente caracter</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">32</span>                     <span class="co1">; Es menor que 32?</span>
   <span class="kw1">JP</span> <span class="kw2">C</span>,  pstring8_ccontrol  <span class="co1">; Si, es un codigo de control, saltar</span>
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                   <span class="co1">; Salvaguardamos HL</span>
   <span class="kw1">CALL</span> PrintChar_8x8        <span class="co1">; Imprimimos el caracter</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperamos HL</span>
&nbsp;
   <span class="co1">;;; Avanzamos el cursor usando Font_Blank, que incrementa X</span>
   <span class="co1">;;; y actualiza X e Y si se llega al borde de la pantalla</span>
   <span class="kw1">CALL</span> Font_Inc_X           <span class="co1">; Avanzar coordenada X</span>
   <span class="kw1">JR</span> pstring8_loop          <span class="co1">; Continuar impresion hasta CHAR=0</span>
&nbsp;
pstring8_ccontrol:
   <span class="kw1">OR</span> <span class="kw2">A</span>                      <span class="co1">; A es cero? </span>
   <span class="kw1">RET</span> Z                     <span class="co1">; Si es 0 (fin de cadena) volver</span>
&nbsp;
   <span class="co1">;;; Si estamos aqui es porque es un codigo de control distinto &gt; 0</span>
   <span class="co1">;;; Ahora debemos calcular la direccion de la rutina que lo atendera.</span>
&nbsp;
   <span class="co1">;;; Calculamos la direccion destino a la que saltar usando</span>
   <span class="co1">;;; la tabla de saltos y el codigo de control como indice</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, FONT_CALL_JUMP_TABLE
   <span class="kw1">RLCA</span>                      <span class="co1">; A = A * 2 = codigo de control * 2</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>                   <span class="co1">; BC = A*2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = DIR FONT_CALL_JUMP_TABLE+(CodControl*2)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Leemos la parte baja de la direccion en C...</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; ... para no corromper HL y poder leer ...</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; ... la parte alta sobre H ...</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">C</span>                   <span class="co1">; No hemos usado A porque se usa en el CP</span>
&nbsp;
   <span class="co1">;;; Si CCONTROL&gt;0 y CCONTROL&lt;10 -&gt; recoger parametro y saltar a rutina</span>
   <span class="co1">;;; Si CCONTROL&gt;9 y CCONTROL&lt;32 -&gt; saltar a rutina sin recogida</span>
   <span class="kw1">CP</span> <span class="re1">1</span><span class="nu0">8</span>                     <span class="co1">; Comprobamos si (CCONTROL-1)*2 &lt; 18</span>
   <span class="kw1">JP</span> NC, pstring8_noparam   <span class="co1">; Es decir, si CCONTROL &gt; 9, no hay param</span>
&nbsp;
   <span class="co1">;;; Si CCONTROL &lt; 10 -&gt; recoger parametro:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Cogemos el parametro en cuestion de la cadena</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Apuntamos al siguiente caracter</span>
&nbsp;
   <span class="co1">;;; Realizamos el salto a la rutina con o sin parametro recogido</span>
pstring8_noparam:
   <span class="kw1">LD</span> <span class="kw2">BC</span>, pstring8_retaddr   <span class="co1">; Ponemos en BC la dir de retorno</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Hacemos un push de la dir de retorno</span>
   <span class="kw1">JP</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                   <span class="co1">; Saltamos a la rutina seleccionada</span>
&nbsp;
   <span class="co1">;;; Este es el punto al que volvemos tras la rutina</span>
pstring8_retaddr:
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                 <span class="co1">; Recuperamos en HL el puntero a cadena</span>
   <span class="kw1">JR</span> pstring8_loop          <span class="co1">; Continuamos en el bucle</span>
&nbsp;</pre>

<p>
 El esqueleto de la rutina y la parte de impresión ya la conocemos,
porque es idéntica a PrintString_8x8. El principal añadido es la
interpretación de los códigos de control, donde la parte más interesante
 es la construcción y uso de la tabla de saltos:
</p>

<p>
 Una vez ubicadas todas las diferentes direcciones de las rutinas en
FONT_CALL_JUMP_TABLE, podemos utilizar el valor del registro A para
direccionar la tabla. Para ello debemos multiplicar A por 2 ya que cada
dirección consta de 2 bytes. Cargando A*2 en BC podemos calcular la
dirección destino en la tabla como HL+BC (BASE+DESPLAZAMIENTO =
BASE+COD_CONTROL*2). Leyendo el valor apuntado por HL obtenemos la
dirección de la tabla, es decir, la dirección de la rutina que puede
interpretar el código de control que hemos recibido.
</p>
<pre class="code z80">   <span class="co1">;;; Calculamos la direccion destino a la que saltar usando</span>
   <span class="co1">;;; la tabla de saltos y el codigo de control como indice</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, FONT_CALL_JUMP_TABLE
   <span class="kw1">RLCA</span>                      <span class="co1">; A = A * 2 = codigo de control * 2</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>                   <span class="co1">; BC = A*2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = DIR FONT_CALL_JUMP_TABLE+(CodControl*2)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Leemos la parte baja de la direccion en C...</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; ... para no corromper HL y poder leer ...</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; ... la parte alta sobre H ...</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">C</span>                   <span class="co1">; No hemos usado A porque se usa en el CP</span>
                             <span class="co1">; HL = FONT_CALL_JUMP_TABLE+(CodControl*2)</span>
&nbsp;
   <span class="co1">; (...)                   ; Codigo de recogida de parametro si procede</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">BC</span>, pstring8_retaddr   <span class="co1">; Ponemos en BC la dir de retorno</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Hacemos un push de la dir de retorno</span>
   <span class="kw1">JP</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                   <span class="co1">; Saltamos a la rutina seleccionada</span>
&nbsp;
   <span class="co1">;;; Este es el punto al que volvemos tras la rutina</span>
pstring8_retaddr:</pre>

<p>
 Con el anterior cálculo, por ejemplo, si recibimos un código de control
 6, se pondrá en HL la dirección de memoria contenida en
FONT_CALL_JUMP_TABLE+(6*2), que es el valor <em>Font_Set_Attrib</em>, que el ensamblador sustituirá en la tabla durante el proceso de ensamblado por la dirección de memoria de dicha rutina.
</p>

<p>
 Nótese cómo después de calcular el valor de salto correcto para HL
tenemos que simular un “CALL HL”, que no forma parte del juego de
instrucciones del Spectrum. ¿Cómo realizamos esto? Utilizando la pila y
la instrucción JP. Recordemos que un CALL es un salto a subrutina, lo
cual implica introducir en la pila la dirección de retorno y salta a la
dirección de la rutina. Cuando la rutina realice el RET, se extrae de la
 pila la dirección de retorno para continuar el flujo del programa.
</p>

<p>
 En el código anterior introducimos en el registro BC la dirección de la etiqueta <strong>pstring8_retaddr</strong>,
 que es la posición exacta de memoria después del salto. Una vez
introducida en la pila la dirección de retorno, saltamos con el salto
incondicional <strong>JP (HL)</strong> a la rutina especificada por el
código de control. La subrutina efectuará la tarea correspondiente y
volverá con un RET, provocando que la rutina de impresión de cadenas
continúe en pstring8_retaddr, que es la dirección que el RET extraerá de
 la pila para volver.
</p>

<p>
 Hemos hecho distinción de 2 tipos de subrutinas de control, ya que las 9
 primeras requieren recoger un parámetro de la cadena (apuntado por HL) y
 las restantes no. El cálculo de la dirección de salto es igual en todos
 los casos pero para las 9 primeras es necesario obtener el dato
adicional al código de control en el registro A antes de saltar. El
registro A es el parámetro común en todas las subrutinas de gestión de
códigos de control que requieren parámetros, algo necesario para poder
usar las rutinas vía tabla de saltos.
</p>

<p>
 La comprobación de si debemos recoger o no parámetro desde la cadena la realizamos con el siguiente código:
</p>
<pre class="code z80">   <span class="co1">;;; Si CCONTROL&gt;0 y CCONTROL&lt;10 -&gt; recoger parametro y saltar a rutina</span>
   <span class="co1">;;; Si CCONTROL&gt;9 y CCONTROL&lt;32 -&gt; saltar a rutina sin recogida</span>
   <span class="kw1">CP</span> <span class="re1">1</span><span class="nu0">8</span>                     <span class="co1">; Comprobamos si (CCONTROL-1)*2 &lt; 18</span>
   <span class="kw1">JP</span> NC, pstring8_noparam   <span class="co1">; Es decir, si CCONTROL &gt; 9, no hay param</span></pre>

<p>
 En lugar de volver a dividir el código de control entre 2 (recordemos
que se multiplicó por 2 para el cálculo de la dirección de salto) y
comprobar si es &gt; 9, podemos comprobar directamente si es &gt; 9*2 =
18.
</p>

<p>
 Tras interpretar el código de control, bastará con volver a saltar al
principio de la rutina para continuar con el siguiente carácter. Todo el
 proceso se repetirá hasta recibir en A un código de control 0
(FONT_EOS, de FONT_END_OF_STRING).
</p>

<p>
 Una vez explicada la rutina, veamos un ejemplo de cómo podríamos utilizarla en nuestros programas:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo de gestion de texto</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="sy0">$</span>3D<span class="re1">00</span><span class="sy0">-</span><span class="nu0">256</span>        <span class="co1">; Saltamos los 32 caracteres iniciales</span>
  <span class="kw1">CALL</span> Font_Set_Charset
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="sy0">+</span><span class="br0">(</span><span class="nu0">7</span><span class="sy0">*</span><span class="nu0">8</span><span class="br0">)</span>
  <span class="kw1">Call</span> Font_Set_Attrib
&nbsp;
  <span class="co1">;;; Probamos los diferentes estilos: NORMAL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, FONT_NORMAL
  <span class="kw1">CALL</span> Font_Set_Style
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena<span class="re1">1</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">4</span>
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">0</span>
  <span class="kw1">CALL</span> Font_Set_XY
  <span class="kw1">CALL</span> PrintString_8x8_Format
&nbsp;
loop:
  <span class="kw1">JR</span> loop
&nbsp;
cadena<span class="re1">1</span> DB <span class="st0">"SALTO DE"</span>, FONT_LF, <span class="st0">"LINEA "</span>, FONT_SET_X, <span class="nu0">4</span>, FONT_SET_Y, <span class="nu0">9</span>
        DB <span class="st0">"IR A (4,9) "</span>, FONT_SET_INK, <span class="nu0">2</span>, <span class="st0">"ROJO "</span>
        DB FONT_SET_INK, <span class="re1">0</span>, <span class="st0">"NEGRO"</span>, FONT_CRLF, FONT_LF
        DB <span class="st0">"CRLF+LF "</span>, FONT_SET_STYLE, FONT_UNDERSC, <span class="st0">"ESTILO SUBRAYADO"</span>
        DB FONT_CRLF, FONT_CRLF, FONT_SET_STYLE, FONT_BOLD, <span class="st0">"NEGRITA"</span>
        DB FONT_CRLF, FONT_CRLF, FONT_SET_STYLE, FONT_ITALIC, <span class="st0">"CURSIVA"</span>
        DB FONT_CRLF, FONT_CRLF, FONT_TAB, FONT_SET_PAPER, <span class="re1">0</span>
        DB FONT_SET_INK, <span class="nu0">6</span>, <span class="st0">"TABULADOR + INK 6 PAPER 0"</span>
        DB FONT_EOS</pre>

<p>
 La salida en pantalla del anterior ejemplo (añadiendo las funciones correspondientes al código):
</p>

<p>
<br>

<img src="img/gfx4_texto.png" class="mediacenter" alt=" Impresion de cadenas con codigos de control "/>
<br>

</p>

<p>
 Es importante destacar que podríamos ampliar la rutina de impresión con
 más códigos de control y funciones. Con la configuración que hemos
visto, el código de control 9 queda libre para la introducción de una
función adicional que requiera parámetro, y del 17 al 31 podemos añadir
más funciones de formato que no requieran parámetros (por ejemplo,
combinaciones de color y estilos concretos en una función que cambie
BRIGHT, FLASH, INK, PAPER y STYLE, o incluso cambios entre diferentes
charsets).
</p>

<p>
 Si necesitaremos más “espacio” para rutinas con parámetro, podríamos
“reubicar” los códigos de control por encima del 10 (cambiando los EQUs)
 y modificando el CP de la rutina que determinar si el control-code
tiene parámetro o no.
</p>

<p>
 Recomendamos al lector que utilice siempre en sus cadenas los códigos
de control mediante las constantes EQU en lugar de utilizar los códigos
numéricos en sí mismos. Esto permite reubicar los valores numéricos (los
 EQUs) sin modificar las cadenas. Recordemos que el ensamblador
sustituirá las constantes por sus valores numéricos durante el proceso
de ensamblado, por lo que la ocupación en las cadenas definitivas no
será “mayor” al usar las constantes. El único código de control que no
debe reubicarse nunca es FONT_EOS (0).
</p>

<p>
 Finalmente, creemos importante indicar al lector que para marcar
claramente la dirección de salto del código de control 9 (que no está en
 uso) se ha usado la cadena “0000”, pero probablemente sería más seguro
el colocar la dirección de una rutina como FONT_TAB o FONT_CRLF. De esta
 forma, ante un error del programador al escribir una cadena y utilizar
el inexistente código 9 en ella, evitaremos que se produzca un reset (JP
 $0000) que nos cueste gran cantidad de horas de encontrar / depurar.
</p>

<p>
 En cuanto a las diferencias en tiempo de ejecución de
PrintString_8x8_Format vs PrintString_8x8, cabe destacar que el coste
adicional de la rutina para la impresión del texto normal (ASCIIs &lt;
32) se reduce a las siguientes 2 instrucciones adicionales:
</p>
<pre class="code z80">   <span class="kw1">CP</span> <span class="nu0">32</span>                     <span class="co1">; Es menor que 32?</span>
   <span class="kw1">JP</span> <span class="kw2">C</span>,  pstring8_ccontrol  <span class="co1">; Si, es un codigo de control, saltar</span></pre>

<p>
 Aparte de eso, se ha sustituído el código de avance de la coordenada X
por el de las rutinas genéricas vistas anteriormente, lo que añade un <em>CALL Font_Inc_X</em> (y su RET) adicional. Así pues, el coste en tiempo de ejecución no difiere apenas de la función sin códigos de control.
</p>

<p>
 En el caso del código de fin de cadena (EOS = 0), ya no se sale de la rutina con un RET Z sino que se pasa por el <strong>CP 32</strong> y se realiza el salto a <em>pstring8_ccontrol</em>.
</p>

<p>
 Sí que hay un coste real en la ocupación de memoria, puesto que todas
las funciones auxiliares de control que hemos definido seguramente
pueden no resultarnos útiles en la programación de un juego donde no se
utilice apenas texto. Ese código adicional sumado a la gestión de
códigos de control de la rutina y a la tabla de saltos puede ser espacio
 utilizable por nosotros si empleados la rutina sin formato <em>PrintString_8x8</em>.
</p>

<p>
 Donde no hay duda de la gran utilidad de las anteriores rutinas es en
cualquier juego basado en texto, donde nos evitamos realizar el formato
de los textos en base a programación y llamadas continuadas a las
funciones de formato, posicionamiento, etc. Bastará con definir las
cadenas en nuestro programa con el formato adecuado. El ahorro en líneas
 de código será muy considerable.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit13" id="impresion-avanzadadatos-variables">Impresión avanzada: datos variables</h3>
<div class="level3">

<p>
 Nuestro siguiente objetivo es extender PringString_8x8_Format para
permitir la utilización de códigos de control que representen valores de
 variables. El objetivo es simular la funcionalidad de la función
printf() del lenguaje C, el cual permite impresiones de cadena como la
siguiente:
</p>
<pre class="code c"><a href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><span class="kw3">printf</span></a><span class="br0">(</span> <span class="st0">"Jugador %s: Tienes %d vidas."</span><span class="sy0">,</span> nombre<span class="sy0">,</span> vidas <span class="br0">)</span><span class="sy0">;</span></pre>

<p>
 Para eso vamos a crear una nueva rutina <strong>PrintString_8x8_Format_Args</strong>
 que además de los códigos de control de formato, comprenda códigos para
 la impresión de variables de cadena o numéricas en representación
decimal, hexadecimal o binaria.
</p>

<p>
 Los nuevos códigos de control imitarán el formato de C (símbolo de %
seguido de un identificador del tipo de variable) y podrán estar así
integrados dentro del propio texto:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit14"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Código de control </th><th class="col1"> Significado </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> %d </td><td class="col1"> Imprimir argumento número entero de 8 bits en formato decimal </td>
	</tr>
	<tr class="row2">
		<td class="col0"> %D </td><td class="col1"> Imprimir argumento número entero de 16 bits en formato decimal </td>
	</tr>
	<tr class="row3">
		<td class="col0"> %t </td><td class="col1"> Imprimir argumento número entero 0-99 con 2 dígitos incluyendo ceros </td>
	</tr>
	<tr class="row4">
		<td class="col0"> %x </td><td class="col1"> Imprimir argumento de 8 bits en formato hexadecimal </td>
	</tr>
	<tr class="row5">
		<td class="col0"> %X </td><td class="col1"> Imprimir argumento de 16 bits en formato hexadecimal </td>
	</tr>
	<tr class="row6">
		<td class="col0"> %b </td><td class="col1"> Imprimir argumento de 8 bits en formato binario </td>
	</tr>
	<tr class="row7">
		<td class="col0"> %B </td><td class="col1"> Imprimir argumento de 16 bits en formato binario </td>
	</tr>
	<tr class="row8">
		<td class="col0"> %s </td><td class="col1"> Imprimir argumento de tipo cadena (acabada en 0 / EOS) </td>
	</tr>
	<tr class="row9">
		<td class="col0"> %% </td><td class="col1"> Símbolo del porcentaje (%) </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 De esta forma podremos definir cadenas como:
</p>
<pre class="code">cadena1   DB   "Has obtenido %D puntos", FONT_EOS
cadena2   DB   "El numero %d en binario es %b", FONT_EOS
cadena3   DB   "Has tenido un %d %% de aciertos", FONT_EOS
cadena4   DB   "Bienvenido al juego, %s", FONT_EOS
cadena5   DB   "Hora: %t:%t", FONT_EOS</pre>

<p>
 Nótese que podríamos haber empleado el sistema de códigos de formato
con los ASCIIs libres entre el 17 y el 31. El lector puede adaptar
fácilmente la rutina a ese sistema si así lo deseara.
</p>

<p>
 Volvamos a PrintString_8x8_Format_Args: Nuestra nueva rutina deberá
recibir ahora un parámetro adicional: además de la cadena a imprimir en
HL, deberemos apuntar el registro IX a un array con los datos a
sustuitir, o apuntando a una única variable de memoria si sólo hay un
parámetro.
</p>

<p>
 La rutina es similar a PrintString_8x8_Format, pero añadiendo lo siguiente:
</p>
<pre class="code">;;; HL = Cadena que imprimir

PrintString_8x8_Format_Args:
   ;;;
bucle:
      ;;; Coger caracter apuntado por HL.
      ;;; Incrementar HL
      ;;; Si HL es mayor que 32 :
          ;;; Si es un caracter '%':
              ;;; Si el siguiente caracter no es %:
              ;;; Saltamos a seccion de codigo_gestion_ARGS
          ;;; Imprimir caracter en FONT_X,FONT_Y
          ;;; Avanzar el puntero FONT_X
      ;;; Si HL es menor que 31 :
          ;;; Si es CERO, salir de la rutina con RET Z.
          (...)

codigo_gestion_ARGS:
   ;;; Llegamos aqui con el codigo en A
   ;;; Si el codigo es 'd' -&gt; Saltar a gestion de tipo int8
   ;;; Si el codigo es 'D' -&gt; Saltar a gestion de tipo int16
   ;;; Si el codigo es 't' -&gt; Saltar a gestion de tipo int8_2digits
   ;;; Si el codigo es 'x' -&gt; Saltar a gestion de tipo hex8
   ;;; Si el codigo es 'X' -&gt; Saltar a gestion de tipo hex16
   ;;; Si el codigo es 'b' -&gt; Saltar a gestion de tipo bin8
   ;;; Si el codigo es 'B' -&gt; Saltar a gestion de tipo bin16
   ;;; Si el codigo es 's' -&gt; Saltar a gestion de tipo string</pre>

<p>
 En código:
</p>
<pre class="code z80">loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Leemos un caracter de la cadena</span>
&nbsp;
   <span class="co1">;;; (...)</span>
&nbsp;
   <span class="kw1">CP</span> <span class="st0">'%'</span>                    <span class="co1">; Es un caracter %?</span>
   <span class="kw1">JR</span> NZ, pstring8_novar     <span class="co1">; Comprobamos si es variable</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Cogemos en A el siguiente char</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>
   <span class="kw1">CP</span> <span class="st0">'%'</span>                    <span class="co1">; Es otro caracter %? (leido %%?)</span>
   <span class="kw1">JR</span> NZ, pstring8v_var      <span class="co1">; No, es una variable -&gt; Saltar</span>
                             <span class="co1">; Si, era %, seguir para imprimirlo</span>
<span class="br0">(</span>...<span class="br0">)</span>
   <span class="co1">;;; Aqui se gestionan los codigos de control con % (tipo = A)</span>
pstring8v_var:
   <span class="co1">;;; comprobamos los tipos y saltamos a sus rutinas de gestion</span>
   <span class="kw1">CP</span> <span class="st0">'d'</span>
   <span class="kw1">JR</span> Z, pstring8v_int8
   <span class="kw1">CP</span> <span class="st0">'t'</span>
   <span class="kw1">JR</span> Z, pstring8v_int8_2d
   <span class="kw1">CP</span> <span class="st0">'D'</span>
   <span class="kw1">JR</span> Z, pstring8v_int<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">CP</span> <span class="st0">'s'</span>
   <span class="kw1">JR</span> Z, pstring8v_string
   <span class="kw1">CP</span> <span class="st0">'x'</span>
   <span class="kw1">JR</span> Z, pstring8v_hex8
   <span class="kw1">CP</span> <span class="st0">'X'</span>
   <span class="kw1">JR</span> Z, pstring8v_hex<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">CP</span> <span class="st0">'b'</span>
   <span class="kw1">JP</span> Z, pstring8v_bin8
   <span class="kw1">CP</span> <span class="st0">'B'</span>
   <span class="kw1">JP</span> Z, pstring8v_bin<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">JP</span> pstring8_novar         <span class="co1">; Otro: imprimir caracter tal cual</span></pre>

<p>
 Las diferentes porciones de código a las que saltaremos según el tipo
de dato a imprimir harán uso de las funciones de conversión de valor
numérico a cadena que ya vimos en un anterior apartado de este capítulo.
 Por ejemplo:
</p>
<pre class="code z80">   <span class="kw1">CP</span> <span class="st0">'d'</span>
   <span class="kw1">JR</span> Z, pstring8v_int8
&nbsp;
<span class="br0">(</span>...<span class="br0">)</span>
pstring8v_int8:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Int2String_8
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> INC_HL_Remove_Leading_Zeros
   <span class="kw1">CALL</span> PrintString_8x8
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span></pre>

<p>
 El código completo de la rutina es el siguiente:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; PrintString_8x8_Format_Args:</span>
<span class="co1">; Imprime una cadena de texto de un charset de fuente 8x8.</span>
<span class="co1">; Soporta codigos de control y argumentos.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; -----------------------------------------------------</span>
<span class="co1">; FONT_CHARSET = Direccion de memoria del charset.</span>
<span class="co1">; FONT_X       = Coordenada X en baja resolucion (0-31)</span>
<span class="co1">; FONT_Y       = Coordenada Y en baja resolucion (0-23)</span>
<span class="co1">; FONT_ATTRIB  = Atributo a utilizar en la impresion.</span>
<span class="co1">; Registro HL  = Puntero a la cadena de texto a imprimir.</span>
<span class="co1">;                Debe acabar en cero (FONT_EOS).</span>
<span class="co1">; Registro IX  = Puntero al listado de argumentos (si hay).</span>
<span class="co1">; Usa: DE, BC</span>
<span class="co1">;-------------------------------------------------------------</span>
PrintString_8x8_Format_Args:
&nbsp;
   <span class="co1">;;; Bucle de impresion de caracter</span>
pstring8v_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Leemos un caracter de la cadena</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; Apuntamos al siguiente caracter</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">32</span>                     <span class="co1">; Es menor que 32?</span>
   <span class="kw1">JP</span> <span class="kw2">C</span>, pstring8v_ccontrol  <span class="co1">; Si, es un codigo de control, saltar</span>
&nbsp;
   <span class="kw1">CP</span> <span class="st0">'%'</span>                    <span class="co1">; Es un caracter %?</span>
   <span class="kw1">JR</span> NZ, pstring8_novar     <span class="co1">; Comprobamos si es variable</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Cogemos en A el siguiente char</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>
   <span class="kw1">CP</span> <span class="st0">'%'</span>                    <span class="co1">; Es otro caracter %? (leido %%?)</span>
   <span class="kw1">JR</span> NZ, pstring8v_var      <span class="co1">; No, es una variable -&gt; Saltar</span>
                             <span class="co1">; Si, era %, seguir para imprimirlo</span>
pstring8_novar:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                   <span class="co1">; Salvaguardamos HL</span>
   <span class="kw1">CALL</span> PrintChar_8x8        <span class="co1">; Imprimimos el caracter</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperamos HL</span>
&nbsp;
   <span class="co1">;;; Avanzamos el cursor usando Font_Blank, que incrementa X</span>
   <span class="co1">;;; y actualiza X e Y si se llega al borde de la pantalla</span>
   <span class="kw1">CALL</span> Font_Inc_X           <span class="co1">; Avanzar coordenada X</span>
   <span class="kw1">JR</span> pstring8v_loop         <span class="co1">; Continuar impresion hasta CHAR=0</span>
&nbsp;
pstring8v_ccontrol:
   <span class="kw1">OR</span> <span class="kw2">A</span>                      <span class="co1">; A es cero? </span>
   <span class="kw1">RET</span> Z                     <span class="co1">; Si es 0 (fin de cadena) volver</span>
&nbsp;
   <span class="co1">;;; Si estamos aqui es porque es un codigo de control distinto &gt; 0</span>
   <span class="co1">;;; Ahora debemos calcular la direccion de la rutina que lo atendera.</span>
&nbsp;
   <span class="co1">;;; Calculamos la direccion destino a la que saltar usando</span>
   <span class="co1">;;; la tabla de saltos y el codigo de control como indice</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, FONT_CALL_JUMP_TABLE
   <span class="kw1">DEC</span> <span class="kw2">A</span>                     <span class="co1">; Decrementamos A (puntero en tabla)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = A * 2 = codigo de control * 2</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>                   <span class="co1">; BC = A*2</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = DIR FONT_CALL_JUMP_TABLE+(CodControl*2)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">C</span>                   <span class="co1">; Leemos la direccion de la tabla en HL</span>
&nbsp;
   <span class="co1">;;; Si CCONTROL&gt;0 y CCONTROL&lt;10 -&gt; recoger parametro y saltar a rutina</span>
   <span class="co1">;;; Si CCONTROL&gt;9 y CCONTROL&lt;32 -&gt; saltar a rutina sin recogida</span>
   <span class="kw1">CP</span> <span class="re1">1</span><span class="nu0">8</span>                     <span class="co1">; Comprobamos si (CCONTROL-1)*2 &lt; 18</span>
   <span class="kw1">JP</span> NC, pstring8v_noparam  <span class="co1">; Es decir, si CCONTROL &gt; 9, no hay param</span>
&nbsp;
   <span class="co1">;;; Si CCONTROL &lt; 10 -&gt; recoger parametro:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Cogemos el parametro en cuestion de la cadena</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Apuntamos al siguiente caracter</span>
&nbsp;
   <span class="co1">;;; Realizamos el salto a la rutina con o sin parametro recogido</span>
pstring8v_noparam:
   <span class="kw1">LD</span> <span class="kw2">BC</span>, pstring8v_retaddr  <span class="co1">; Ponemos en BC la dir de retorno</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Hacemos un push de la dir de retorno</span>
   <span class="kw1">JP</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                   <span class="co1">; Saltamos a la rutina seleccionada</span>
&nbsp;
   <span class="co1">;;; Este es el punto al que volvemos tras la rutina</span>
pstring8v_retaddr:
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                 <span class="co1">; Recuperamos en HL el puntero a cadena</span>
   <span class="kw1">JR</span> pstring8v_loop         <span class="co1">; Continuamos en el bucle</span>
&nbsp;
   <span class="co1">;;; Aqui se gestionan los codigos de control con % (tipo = A)</span>
pstring8v_var:
   <span class="co1">;;; comprobamos los tipos y saltamos a sus rutinas de gestion</span>
   <span class="kw1">CP</span> <span class="st0">'d'</span>
   <span class="kw1">JR</span> Z, pstring8v_int8
   <span class="kw1">CP</span> <span class="st0">'t'</span>
   <span class="kw1">JR</span> Z, pstring8v_int8_2d
   <span class="kw1">CP</span> <span class="st0">'D'</span>
   <span class="kw1">JR</span> Z, pstring8v_int<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">CP</span> <span class="st0">'s'</span>
   <span class="kw1">JR</span> Z, pstring8v_string
   <span class="kw1">CP</span> <span class="st0">'x'</span>
   <span class="kw1">JR</span> Z, pstring8v_hex8
   <span class="kw1">CP</span> <span class="st0">'X'</span>
   <span class="kw1">JP</span> Z, pstring8v_hex<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">CP</span> <span class="st0">'b'</span>
   <span class="kw1">JP</span> Z, pstring8v_bin8
   <span class="kw1">CP</span> <span class="st0">'B'</span>
   <span class="kw1">JP</span> Z, pstring8v_bin<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">JP</span> pstring8_novar         <span class="co1">; Otro: imprimir caracter tal cual</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_int8:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Int2String_8
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> INC_HL_Remove_Leading_Zeros
   <span class="kw1">CALL</span> PrintString_8x8
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_int8_2d:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Int2String_8_2Digits
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>                   <span class="co1">; Resultado conversion en DE</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">CALL</span> PrintChar_8x8        <span class="co1">; Imprimir parte alta (decenas)</span>
   <span class="kw1">CALL</span> Font_Inc_X
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>
   <span class="kw1">CALL</span> PrintChar_8x8        <span class="co1">; Imprimir parte alta (decenas)</span>
   <span class="kw1">CALL</span> Font_Inc_X
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_int<span class="re1">1</span><span class="nu0">6</span>:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Int2String_<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> INC_HL_Remove_Leading_Zeros
   <span class="kw1">CALL</span> PrintString_8x8
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_string:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">PUSH</span> <span class="kw2">IX</span>                   <span class="co1">; HL = IX</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">call</span> PrintString_8x8      <span class="co1">; Imprimimos cadena</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
pstring8v_strloop:           <span class="co1">; Incrementamos IX hasta el fin</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; de la cadena, recorriendola</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>                    <span class="co1">; hasta (IX) = 0</span>
   <span class="kw1">OR</span> <span class="kw2">A</span>
   <span class="kw1">JR</span> NZ, pstring8v_strloop
&nbsp;
   <span class="co1">; De esta forma IX ya apunta al siguiente argumento</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_hex8:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="nu0">4</span><span class="re1">0</span>
   <span class="kw1">CALL</span> Hex2String_8
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> PrintString_8x8
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_hex<span class="re1">1</span><span class="nu0">6</span>:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Hex2String_<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> PrintString_8x8
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_bin8:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Bin2String_8
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> PrintString_8x8
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_bin<span class="re1">1</span><span class="nu0">6</span>:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Bin2String_<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> PrintString_8x8
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span></pre>

<p>
 La llamada a la rutina de impresión con parámetros se realiza apuntando
 HL a la cadena con formato e IX al listado de parámetros:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo de impresion de texto con argumentos</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="sy0">$</span>3D<span class="re1">00</span><span class="sy0">-</span><span class="nu0">256</span>
  <span class="kw1">CALL</span> Font_Set_Charset
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">4</span><span class="re1">00</span>
  <span class="kw1">CALL</span> Font_Set_XY
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena<span class="re1">1</span>
  <span class="kw1">LD</span> <span class="kw2">IX</span>, args<span class="re1">1</span>
  <span class="kw1">CALL</span> PrintString_8x8_Format_Args
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena2
  <span class="kw1">LD</span> <span class="kw2">IX</span>, args2
  <span class="kw1">CALL</span> PrintString_8x8_Format_Args
&nbsp;
loop:
  <span class="kw1">JR</span> loop
  <span class="kw1">RET</span>
&nbsp;
cadena<span class="re1">1</span> DB <span class="st0">"VALOR 8 bits: 40"</span>, FONT_CRLF, FONT_CRLF
        DB <span class="st0">"Decimal: %d"</span> , FONT_CRLF
        DB <span class="st0">"Hexadecimal: $%x"</span> , FONT_CRLF
        DB <span class="st0">"Binario: %%%b"</span> , FONT_CRLF
        DB FONT_CRLF, FONT_CRLF
        DB <span class="st0">"VALOR 16 bits: 1205"</span>, FONT_CRLF, FONT_CRLF
        DB <span class="st0">"Decimal: %D"</span> , FONT_CRLF
        DB <span class="st0">"Hexadecimal: $%X"</span> , FONT_CRLF
        DB <span class="st0">"Binario: %%%B"</span> , FONT_CRLF, FONT_CRLF, FONT_CRLF
        DB FONT_EOS
&nbsp;
args<span class="re1">1</span>   DB <span class="nu0">4</span><span class="re1">0</span>, <span class="nu0">4</span><span class="re1">0</span>, <span class="re1">0</span><span class="nu0">4</span><span class="re1">0</span>
        DW <span class="re1">1</span><span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>, <span class="re1">1</span><span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>, <span class="re1">1</span><span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>
&nbsp;
cadena2 DB <span class="st0">"2 CADENAS:"</span>, FONT_CRLF, FONT_CRLF
        DB <span class="st0">"Cadenas: %t: %s y %s"</span>
        DB FONT_EOS
&nbsp;
args2   DB <span class="nu0">2</span>, <span class="st0">"cad 1"</span>, FONT_EOS, <span class="st0">"cad 2"</span>, FONT_EOS</pre>

<p>
<br>

<img src="img/gfx4_params.png" class="mediacenter" alt=" Procesado de parametros"/>
<br>

</p>

<p>
 No es necesario que el vector de parámetros contenga más de un
elemento. Podemos utilizar la rutina directamente con una variable de
datos para imprimir su valor:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadvidas                     <span class="co1">; Cadena</span>
  <span class="kw1">LD</span> <span class="kw2">IX</span>, vidas                        <span class="co1">; Variable de argumentos</span>
  <span class="kw1">CALL</span> PrintString_8x8_Format_Args    <span class="co1">; Imprimir</span>
&nbsp;
  <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
cadvidas DB <span class="st0">"Tienes %d vidas"</span>, FONT_EOS
vidas    DB <span class="re1">10</span></pre>

<p>
 Sí que hay que ser especialmente cuidadoso a la hora de definir los
parámetros en la variable que apuntamos con IX: es importante que cada
parámetro tenga su tamaño adecuado (DB, DW), y que no le falten los End
Of String (0) a las cadenas.
</p>

<p>
 Nótese que los parámetros que se imprimen pueden ser modificados por el
 programa, por lo que esta rutina es muy útil en juegos o programas que
trabajen con muchos datos a mostrar.
</p>

<p>
<br>

<br>

<strong>Añadiendo más códigos de control</strong>
<br>

<br>

</p>

<p>
 El sistema que acabamos de ver permite su ampliación con nuevos tipos
de datos o métodos de impresión específicos. Supongamos por ejemplo que
queremos añadir 2 nuevos tipos de impresión de valores enteros, uno en
el que se añadan los ceros al inicio de las cadenas resultantes de la
conversión, y otro que permita la impresión justificada.
</p>

<p>
 Para ello creamos los nuevos “códigos de control”:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit15"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Código de control </th><th class="col1"> Significado </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> %z </td><td class="col1"> Imprimir argumento número entero de 8 bits en formato decimal con sus <em>leading zeros</em> </td>
	</tr>
	<tr class="row2">
		<td class="col0"> %Z </td><td class="col1"> Imprimir argumento número entero de 16 bits en formato decimal con sus <em>leading zeros</em> </td>
	</tr>
	<tr class="row3">
		<td class="col0"> %j </td><td class="col1"> Imprimir argumento número entero de 8 bits en formato decimal <em>justificado a derecha</em> (3 caracteres) </td>
	</tr>
	<tr class="row4">
		<td class="col0"> %J </td><td class="col1"> Imprimir argumento número entero de 16 bits en formato decimal <em>justificado a derecha</em> (5 caracteres) </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 A continuación realizamos las modificaciones adecuadas a la rutina PrintString_8x8_Format_Args:
</p>
<pre class="code z80">PrintString_8x8_Format_Args:
&nbsp;
   <span class="co1">;;; (...)</span>
&nbsp;
   <span class="co1">;;; Aqui se gestionan los codigos de control con % (tipo = A)</span>
pstring8v_var:
   <span class="co1">;;; comprobamos los tipos y saltamos a sus rutinas de gestion</span>
   <span class="br0">(</span>...<span class="br0">)</span>
   <span class="kw1">CP</span> <span class="st0">'z'</span>
   <span class="kw1">JR</span> Z, pstring8v_int8_zeros
   <span class="kw1">CP</span> <span class="st0">'Z'</span>
   <span class="kw1">JR</span> Z, pstring8v_int<span class="re1">1</span><span class="nu0">6</span>_zeros
   <span class="kw1">CP</span> <span class="st0">'j'</span>
   <span class="kw1">JR</span> Z, pstring8v_int8_justify
   <span class="kw1">CP</span> <span class="st0">'J'</span>
   <span class="kw1">JR</span> Z, pstring8v_int<span class="re1">1</span><span class="nu0">6</span>_justify
   <span class="kw1">JP</span> pstring8_novar
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_int8_zeros:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Int2String_8
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> PrintString_8x8      <span class="co1">; No llamamos a Remove_Leading_Zeros</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_int<span class="re1">1</span><span class="nu0">6</span>_zeros:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Int2String_<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string
   <span class="kw1">CALL</span> PrintString_8x8      <span class="co1">; No llamamos a Remove_Leading_Zeros</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_int8_justify:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Int2String_8
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string        <span class="co1">; Llamamos a funcion Justify</span>
   <span class="kw1">CALL</span> INC_HL_Justify_Leading_Zeros
   <span class="kw1">CALL</span> PrintString_8x8
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
<span class="co1">;----------------------------------------------------------</span>
pstring8v_int<span class="re1">1</span><span class="nu0">6</span>_justify:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">CALL</span> Int2String_<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, conv2string        <span class="co1">; Llamamos a funcion Justify</span>
   <span class="kw1">CALL</span> INC_HL_Justify_Leading_Zeros
   <span class="kw1">CALL</span> PrintString_8x8
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">JP</span> pstring8v_loop         <span class="co1">; Volvemos al bucle principal</span>
&nbsp;
   <span class="br0">(</span>...<span class="br0">)</span></pre>

<p>
 Lo normal a la hora de utilizar PrintString_Format_Args en nuestro
programa es que eliminemos todos aquellos códigos de control (y sus
rutinas de chequeo y de gestión) de los cuales no vayamos a hacer uso,
con el consiguiente ahorro de memoria (desaparecen las instrucciones de
las subrutinas de gestión).
</p>

<p>
<br>

<br>

</p>

</div>

<h3 class="sectionedit16" id="lectura-de-texto-desde-teclado">Lectura de texto desde teclado</h3>
<div class="level3">

<p>
 La posibilidad de leer una cadena tecleada por el usuario puede
resultar fundamental en programas basados en texto. En algunos juegos
podríamos aprovecharla para introducción de claves de acceso, pero en
aventuras de texto o programas puede resultar imprescindible.
</p>

<p>
 Una rutina de lectura de teclado recibirá como parámetro un puntero a
un área vacía en memoria con suficiente espacio libre para la cadena,
así como el tamaño máximo de cadena que queremos leer (un límite que
asegure que no escribimos contenido fuera del área reservada y apuntada
por HL).
</p>

<p>
 En el artículo dedicado al teclado estudiamos rutinas de lectura del
mismo que nos proporcionaban scancodes de las teclas pulsadas. También
vimos rutinas de obtención del código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> correspondiente a un scancode dado.
</p>

<p>
 En este caso necesitaremos una rutina más “avanzada”, que permita
detectar el uso de CAPS SHIFT y DELETE (CAPS SHIFT + '0') y que distinga
 por tanto entre mayúsculas y minúsculas. Para eso, utilizaremos la
rutina de escaneo de teclado y conversión a <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> de la ROM del Spectrum (<strong>KEY_SCAN</strong>), ubicada en la dirección de memoria $028E de la ROM.
</p>

<p>
 Al realizar un CALL a KEY_SCAN se produce una lectura de todas las
filas del teclado seguida de una decodificación del resultado de la
lectura. La rutina de la ROM coloca entonces en la variable del sistema <strong>LAST_K</strong> (dirección 23560) el código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>
 de la tecla pulsada. KEY_SCAN también decodifica las teclas extendidas y
 LAST_K nos puede servir también para detectar ENTER (código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> 13) o DELETE (código <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> 12).
</p>

<p>
 El desarrollo de la rutina será el siguiente:
</p>
<pre class="code">;;; Utilizar HL como puntero a una cadena vacía o con contenido.
;;; Utilizar un contador de tamaño de la cadena con valor inicial = longitud maxima - 1
;;; Imprimir cursor.
;;; En un bucle:
    ; Bucle lectura teclado:
       ; Hacer LAST_K = 0
       ; Leer el estado del teclado con KEY_SCAN.
       ; Repetir hasta que LAST_K sea distinto de 0.
    ; Si se ha pulsado la tecla de ENTER (LAST_K==13):
       ; Borrar el cursor en pantalla.
       ; Insertar un cero en la cadena (End Of String) y salir.
    ; Si se ha pulsado la tecla de DELETE o CAPS+'0' (LAST_K==12):
       ; Si no estamos en el primer caracter de la cadena:
         ; Borrar el cursor en pantalla.
         ; Realizar un FONT_BACKSPACE.
         ; Incrementar contador de longitud (cabe un caracter más).
    ; Si se ha pulsado una tecla de ASCII &gt;= 32:
       ; Si el contador de longitud es mayor que 0:
         ; Insertar el ASCII en (HL) e incrementar HL.
         ; Imprimirla en pantalla e incrementar FONT_X.
         ; Decrementar contador de longitud.
         ; Reimprimir cursor.</pre>

<p>
 Veamos el código de la rutina <strong>InputString_8x8</strong>:
</p>
<pre class="code z80">LAST_K      <span class="kw3">EQU</span>    <span class="nu0">2356</span><span class="re1">0</span>
KEY_SCAN    <span class="kw3">EQU</span>    <span class="sy0">$</span><span class="re1">0</span>28E
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; InputString_8x8:</span>
<span class="co1">; Obtiene una cadena de texto desde teclado.</span>
<span class="co1">;</span>
<span class="co1">; Entrada:</span>
<span class="co1">; Registro HL = Puntero a la cadena de texto a obtener.</span>
<span class="co1">; Registro A = Longitud maxima de la cadena a obtener </span>
<span class="co1">; Usa: </span>
<span class="co1">;-------------------------------------------------------------</span>
InputString_8x8:
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                   <span class="co1">; Guardamos el puntero a la cadena </span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Modificados por KEY_SCAN</span>
&nbsp;
   <span class="kw1">LD</span> <span class="br0">(</span>inputs_counter<span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; Contador de caracteres a usar</span>
   <span class="kw1">LD</span> <span class="br0">(</span>inputs_limit<span class="br0">)</span>, <span class="kw2">A</span>      <span class="co1">; Guardamos la longitud maxima</span>
&nbsp;
&nbsp;
inputs_start:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">'_'</span>                 <span class="co1">; Imprimir nuevo cursor</span>
   <span class="kw1">CALL</span> Font_SafePrintChar_8x8
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>LAST_K<span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Limpiar ultima tecla pulsada</span>
&nbsp;
inputs_loop:
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                   <span class="co1">; KEY_SCAN modifica HL -&gt; preservar</span>
   <span class="kw1">CALL</span> KEY_SCAN             <span class="co1">; Escanear el teclado</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>LAST_K<span class="br0">)</span>            <span class="co1">; Obtener el valor decodificado</span>
&nbsp;
   <span class="kw1">CP</span> <span class="re1">1</span><span class="nu0">3</span>
   <span class="kw1">JR</span> Z, inputs_end          <span class="co1">; Es enter? -&gt; fin de rutina</span>
&nbsp;
   <span class="kw1">CP</span> <span class="re1">1</span><span class="nu0">2</span>
   <span class="kw1">JR</span> Z, inputs_delete       <span class="co1">; Es DELETE? -&gt; borrar caracter</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">32</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, inputs_loop         <span class="co1">; Es &lt; 32? -&gt; repetir bucle escaneo</span>
&nbsp;
   <span class="co1">;;; Si estamos aqui, ASCII &gt;= 32 -&gt; Es caracter valido -&gt; Guardiar</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                ; Nos guardamos el valor ASCII en A'</span>
&nbsp;
   <span class="co1">;;; Comprobacion de longitud maxima de cadena</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>inputs_counter<span class="br0">)</span>    <span class="co1">; A = caracteres disponibles</span>
   <span class="kw1">OR</span> <span class="kw2">A</span>                      <span class="co1">; Comprobar si es 0</span>
   <span class="kw1">JR</span> Z, inputs_loop         <span class="co1">; Si es cero, no insertar caracter</span>
   <span class="kw1">DEC</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span>inputs_counter<span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; Decrementar espacio disponible</span>
&nbsp;
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                ; Recuperamos ASCII de A'</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Guardamos el caracter leido</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; Avanzamos al siguiente caracter e imprimir</span>
   <span class="kw1">CALL</span> Font_SafePrintChar_8x8
   <span class="kw1">CALL</span> Font_Inc_X
   <span class="kw1">JR</span> inputs_start           <span class="co1">; Repetir continuamente hasta ENTER</span>
&nbsp;
<span class="co1">;;; Codigo a ejecutar cuando se pulsa enter</span>
inputs_end:                  <span class="co1">; ENTER pulsado -&gt; Fin de la rutina</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">' '</span>                 <span class="co1">; Borramos de la pantalla el cursor</span>
   <span class="kw1">CALL</span> Font_SafePrintChar_8x8
   <span class="kw1">XOR</span> <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Almacenamos un FIN DE CADENA en HL</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">POP</span> <span class="kw2">DE</span>                    <span class="co1">; Recuperamos valores de registros</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperamos el inicio de la cadena</span>
   <span class="kw1">RET</span>
&nbsp;
<span class="co1">;;; Codigo a ejecutar cuando se pulsa DELETE</span>
inputs_delete:               <span class="co1">; DELETE pulsado -&gt; Borrar caracter</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>inputs_limit<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> , <span class="br0">(</span>inputs_counter<span class="br0">)</span>
   <span class="kw1">CP</span> <span class="kw2">B</span>                      <span class="co1">; Si char_disponibles-limite == 0 ...</span>
   <span class="kw1">JR</span> Z, inputs_loop         <span class="co1">; ... no podemos borrar (inicio de cadena)</span>
&nbsp;
   <span class="kw1">INC</span> <span class="kw2">A</span>                     <span class="co1">; Si no, si que podemos borrar:</span>
   <span class="kw1">LD</span> <span class="br0">(</span>inputs_counter<span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; incrementar espacio disponible</span>
&nbsp;
   <span class="kw1">DEC</span> <span class="kw2">HL</span>                    <span class="co1">; Decrementar puntero en la cadena</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">' '</span>                 <span class="co1">; Borrar cursor y caracter anterior</span>
   <span class="kw1">CALL</span> Font_SafePrintChar_8x8
   <span class="kw1">CALL</span> Font_Dec_X
   <span class="kw1">JR</span> inputs_start           <span class="co1">; Bucle principal</span>
&nbsp;
inputs_counter   DB  <span class="re1">0</span>
inputs_limit     DB  <span class="re1">0</span></pre>

<p>
 InputString_8x8 utiliza una nueva subrutina llamada <strong>Font_SafePrintChar8x8</strong>
 que no es más que una encapsulación del PrintChar_8x8 original en la
que se preservan y restauran los valores de los registros que modifica
internamente PrintChar:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Ejecuta PrintChar_8x8 preservando registros</span>
<span class="co1">;-------------------------------------------------------------</span>
Font_SafePrintChar_8x8
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                   <span class="co1">; Preservar registros</span>
   <span class="kw1">CALL</span> PrintChar_8x8        <span class="co1">; Imprimir caracter</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperar registros</span>
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">RET</span></pre>

<p>
 Veamos un ejemplo de uso de nuestra nueva función de INPUT:
</p>
<pre class="code z80"> <span class="co1">; Ejemplo de input de texto</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="sy0">$</span>3D<span class="re1">00</span><span class="sy0">-</span><span class="nu0">256</span>
  <span class="kw1">CALL</span> Font_Set_Charset
&nbsp;
  <span class="co1">;;; Imprimir cadena "Introduce un texto:"</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena<span class="re1">1</span>
  <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">4</span>
  <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="re1">0</span>
  <span class="kw1">CALL</span> Font_Set_XY
  <span class="kw1">CALL</span> PrintString_8x8_Format
&nbsp;
  <span class="co1">;;; Obtener el input del usuario</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, input<span class="re1">1</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">2</span><span class="re1">0</span>
  <span class="kw1">CALL</span> InputString_8x8
&nbsp;
  <span class="co1">;;; Imprimir "Tu cadena es:" + la cadena resultante</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena2
  <span class="kw1">CALL</span> PrintString_8x8_Format
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, input<span class="re1">1</span>
  <span class="kw1">CALL</span> PrintString_8x8_Format
&nbsp;
  <span class="kw1">RET</span>
&nbsp;
cadena<span class="re1">1</span> DB <span class="st0">"Introduce un texto:"</span>, FONT_CRLF, FONT_CRLF
        DB FONT_SET_INK, <span class="nu0">2</span>, FONT_SET_STYLE, FONT_BOLD
        DB <span class="st0">"&gt; "</span>, FONT_EOS
&nbsp;
cadena2 DB FONT_CRLF, FONT_CRLF, FONT_SET_STYLE, FONT_NORMAL
        DB FONT_SET_INK, <span class="re1">0</span>, <span class="st0">"Tu cadena es: "</span>, FONT_CRLF, FONT_CRLF
        DB FONT_SET_INK, <span class="nu0">2</span>, FONT_SET_STYLE, FONT_BOLD, FONT_EOS
&nbsp;
input<span class="re1">1</span>  DS <span class="nu0">35</span>
        DB <span class="re1">0</span></pre>

<p>
<br>

<img src="img/gfx4_input.png" class="mediacenter" alt=" Input de texto "/>
<br>

</p>

<p>
 Si nuestro programa o juego va a requerir un posibilidades de
introducción o edición de textos avanzadas, sería aconsejable ampliar la
 rutina anterior con nuevas opciones o mejoras como las siguientes:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Permitir edición multilínea. La
rutina actual no permite trabajar (al menos en cuanto al borrado) con
entrada de texto de múltiples líneas. Se podría editar la rutina para
permitir editar más de una línea de texto, realizando una versión
especial de Font_Dec_X que decremente el valor de FONT_Y y ponga
FONT_X=0 cuando tratemos de borrar desde el margen izquierdo de la
pantalla.
</li>
<li> Habilitar el uso de las teclas de
cursor para moverse entre los caracteres de la cadena y así permitir
edición avanzada. La rutina debería basarse entonces en un FONT_X y
FONT_Y propios y ya no se podría utilizar FONT_BACKSPACE para el
borrado. Además, al insertar un carácter en el interior de la cadena
habría que mover todos los caracteres en memoria una posición a la
derecha y redibujar la cadena completa en pantalla. El cursor podría
simularse entonces con FLASH o subrayando la letra actual (por lo que no
 serviría para editar texto subrayado).
</li>
<li> Permitir llamar a la función con una
 cadena ya en la zona apuntada por HL. En conjunción con la mejora
anterior permitiría editar texto anteriormente introducido.
</li>
</ul>

<p>
<br>

</p>

<p>
 En cualquier caso, la rutina que acabamos de ver es más que suficiente para recoger cadenas simples en nuestro programa.
</p>

<p>
<br>

<br>

</p>

</div>

<h2 id="fuentes-de-4x8-pixeles-64-caracteres-en-pantalla">Fuentes de 4x8 píxeles (64 caracteres en pantalla)</h2>
<div class="level2">

<p>
 La resolución de texto del Spectrum es bastante reducida, con sus 32
caracteres en pantalla por línea. Esto provoca limitaciones en programas
 o juegos de texto que requieren mostrar muchas cadenas de caracteres
por pantalla.
</p>

<p>
 Para solucionar esto podemos utilizar una fuente de tamaño 4×8 que nos
permita ubicar 2 letras en un mismo bloque de pantalla,
proporcionándonos una resolución de 64×24 caracteres.
</p>

<p>
 Dibujar letras distinguibles en 4×8 píxeles no es sencillo, pero existe
 una fuente de texto ya creada y código para su impresión, creados por
Andrew Owen (<a href="http://chuntey.wordpress.com/" class="urlextern" title="http://chuntey.wordpress.com">http://chuntey.wordpress.com</a>) y Tony Samuels (Your Spectrum #13, Abril de 1985).
</p>

<p>
 La fuente de texto en 4×8 tiene el siguiente aspecto:
</p>

<p>
<br>

<img src="img/gfx4_charset4x8_1.png" class="mediacenter" alt=" Charset 4x8 "/>
<br>

</p>

<p>
 Para utilizar este set de caracteres sólo tendremos que realizar una nueva rutina de impresión llamada <strong>PrintChar_4x8</strong> y modificar la variable que define la anchura de la pantalla, FONT_SWIDTH (que pasa de valer 32 a 64).
</p>

<p>
 La definición de la fuente de 4×8 píxeles en formato DB es la siguiente:
</p>
<pre class="code z80"><span class="co1">; half width 4x8 font - 384 bytes</span>
charset_4x8:
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>52,<span class="sy0">$</span>57,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">7</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>25,<span class="sy0">$</span>7<span class="re1">1</span>,<span class="sy0">$</span>62,<span class="sy0">$</span>32,<span class="sy0">$</span>74,<span class="sy0">$</span>25,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>22,<span class="sy0">$</span>42,<span class="sy0">$</span>3<span class="re1">0</span>,<span class="sy0">$</span>5<span class="re1">0</span>,<span class="sy0">$</span>5<span class="re1">0</span>,<span class="sy0">$</span>3<span class="re1">0</span>,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">4</span>,<span class="sy0">$</span>22,<span class="sy0">$</span>4<span class="re1">1</span>,<span class="sy0">$</span>4<span class="re1">1</span>,<span class="sy0">$</span>4<span class="re1">1</span>,<span class="sy0">$</span>22,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">4</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>2<span class="re1">0</span>,<span class="sy0">$</span>7<span class="re1">0</span>,<span class="sy0">$</span>22,<span class="sy0">$</span>57,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">7</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>2<span class="re1">0</span>,<span class="sy0">$</span>2<span class="re1">0</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">01</span>,<span class="sy0">$</span><span class="re1">01</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">4</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">4</span>,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>22,<span class="sy0">$</span>56,<span class="sy0">$</span>52,<span class="sy0">$</span>52,<span class="sy0">$</span>52,<span class="sy0">$</span>27,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>27,<span class="sy0">$</span>5<span class="re1">1</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">2</span>,<span class="sy0">$</span>2<span class="re1">1</span>,<span class="sy0">$</span>45,<span class="sy0">$</span>72,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>57,<span class="sy0">$</span>54,<span class="sy0">$</span>56,<span class="sy0">$</span>7<span class="re1">1</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">5</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">7</span>,<span class="sy0">$</span>2<span class="re1">1</span>,<span class="sy0">$</span>6<span class="re1">1</span>,<span class="sy0">$</span>52,<span class="sy0">$</span>52,<span class="sy0">$</span>22,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>22,<span class="sy0">$</span>55,<span class="sy0">$</span>25,<span class="sy0">$</span>53,<span class="sy0">$</span>52,<span class="sy0">$</span>24,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>22,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>22,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">10</span>,<span class="sy0">$</span>27,<span class="sy0">$</span>4<span class="re1">0</span>,<span class="sy0">$</span>27,<span class="sy0">$</span><span class="re1">10</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span>45,<span class="sy0">$</span>2<span class="re1">1</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">2</span>,<span class="sy0">$</span>2<span class="re1">0</span>,<span class="sy0">$</span>42,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>23,<span class="sy0">$</span>55,<span class="sy0">$</span>75,<span class="sy0">$</span>77,<span class="sy0">$</span>45,<span class="sy0">$</span>35,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>63,<span class="sy0">$</span>54,<span class="sy0">$</span>64,<span class="sy0">$</span>54,<span class="sy0">$</span>54,<span class="sy0">$</span>63,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>67,<span class="sy0">$</span>54,<span class="sy0">$</span>56,<span class="sy0">$</span>54,<span class="sy0">$</span>54,<span class="sy0">$</span>67,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>73,<span class="sy0">$</span>44,<span class="sy0">$</span>64,<span class="sy0">$</span>45,<span class="sy0">$</span>45,<span class="sy0">$</span>43,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>57,<span class="sy0">$</span>52,<span class="sy0">$</span>72,<span class="sy0">$</span>52,<span class="sy0">$</span>52,<span class="sy0">$</span>57,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>35,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">5</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">6</span>,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>25,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>45,<span class="sy0">$</span>47,<span class="sy0">$</span>45,<span class="sy0">$</span>45,<span class="sy0">$</span>45,<span class="sy0">$</span>75,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>62,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>52,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>62,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>65,<span class="sy0">$</span>45,<span class="sy0">$</span>43,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>63,<span class="sy0">$</span>54,<span class="sy0">$</span>52,<span class="sy0">$</span>6<span class="re1">1</span>,<span class="sy0">$</span>55,<span class="sy0">$</span>52,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>75,<span class="sy0">$</span>25,<span class="sy0">$</span>25,<span class="sy0">$</span>25,<span class="sy0">$</span>25,<span class="sy0">$</span>22,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>27,<span class="sy0">$</span>25,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>25,<span class="sy0">$</span>22,<span class="sy0">$</span>52,<span class="sy0">$</span>52,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>73,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">2</span>,<span class="sy0">$</span>22,<span class="sy0">$</span>22,<span class="sy0">$</span>42,<span class="sy0">$</span>72,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">3</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>46,<span class="sy0">$</span>42,<span class="sy0">$</span>22,<span class="sy0">$</span>22,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">6</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>2<span class="re1">0</span>,<span class="sy0">$</span>5<span class="re1">0</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">0</span>F
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>2<span class="re1">0</span>,<span class="sy0">$</span><span class="re1">10</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">3</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">5</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">5</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">3</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>4<span class="re1">0</span>,<span class="sy0">$</span>4<span class="re1">0</span>,<span class="sy0">$</span>63,<span class="sy0">$</span>54,<span class="sy0">$</span>54,<span class="sy0">$</span>63,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">10</span>,<span class="sy0">$</span><span class="re1">10</span>,<span class="sy0">$</span>32,<span class="sy0">$</span>55,<span class="sy0">$</span>56,<span class="sy0">$</span>33,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">10</span>,<span class="sy0">$</span>2<span class="re1">0</span>,<span class="sy0">$</span>73,<span class="sy0">$</span>25,<span class="sy0">$</span>25,<span class="sy0">$</span>43,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">6</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>42,<span class="sy0">$</span>4<span class="re1">0</span>,<span class="sy0">$</span>66,<span class="sy0">$</span>52,<span class="sy0">$</span>52,<span class="sy0">$</span>57,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">4</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">4</span>,<span class="sy0">$</span>35,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">6</span>,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">5</span>,<span class="sy0">$</span>55,<span class="sy0">$</span>2<span class="re1">0</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>6<span class="re1">0</span>,<span class="sy0">$</span>2<span class="re1">0</span>,<span class="sy0">$</span>25,<span class="sy0">$</span>27,<span class="sy0">$</span>25,<span class="sy0">$</span>75,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>62,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>52,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>63,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>63,<span class="sy0">$</span>4<span class="re1">1</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>53,<span class="sy0">$</span>66,<span class="sy0">$</span>43,<span class="sy0">$</span>46,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>2<span class="re1">0</span>,<span class="sy0">$</span>75,<span class="sy0">$</span>25,<span class="sy0">$</span>25,<span class="sy0">$</span><span class="re1">1</span><span class="nu0">2</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>55,<span class="sy0">$</span>55,<span class="sy0">$</span>27,<span class="sy0">$</span>25,<span class="sy0">$</span><span class="re1">00</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>55,<span class="sy0">$</span>25,<span class="sy0">$</span>25,<span class="sy0">$</span>53,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">6</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span><span class="re1">01</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">2</span>,<span class="sy0">$</span>72,<span class="sy0">$</span>34,<span class="sy0">$</span>62,<span class="sy0">$</span>72,<span class="sy0">$</span><span class="re1">01</span>
   DB <span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>24,<span class="sy0">$</span>22,<span class="sy0">$</span>22,<span class="sy0">$</span>2<span class="re1">1</span>,<span class="sy0">$</span>22,<span class="sy0">$</span>22,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">4</span>,<span class="sy0">$</span><span class="re1">00</span>,<span class="sy0">$</span>56,<span class="sy0">$</span>A9,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">6</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">4</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">6</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">9</span>,<span class="sy0">$</span><span class="re1">0</span><span class="nu0">6</span></pre>

<p>
 Dado que cada caracter es de 4×8 bytes, podemos almacenar en un mismo byte bien 2 scanlines de un mismo <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> o bien 2 scanlines de 2 ASCIIs consecutivos.
</p>

<p>
 En nuestro caso, cada byte de la fuente contiene los datos de 2
caracteres, por lo que 8 bytes del array tienen los 8 scanlines de 2
ASCIIs consecutivos. El nibble superior (4 bits superiores) de cada byte
 tiene los datos de un carácter <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>
 y el nibble inferior los del siguiente. Así, el primer byte del array
tiene el scanline superior (0) de los ASCIIs 32 (nibble alto) y 33
(nibble bajo).
</p>

<p>
 Esta disposición de 2 scanlines por byte permite un ahorro de memoria
tal que la fuente completa de texto con 96 caracteres ocupe 768/2 = 384
bytes.
</p>

<p>
 Para posicionarnos en esta fuente desde su base con el objetivo de
localizar un carácter en A, deberemos dividir el valor del carácter
entre 2 ya que cada byte referencia a 2 caracteres. El resto de la
división entre 2 (par o impar) nos indica si el carácter que buscamos
está en el nibble superior o el inferior de los 8 bytes consecutivos a
leer.
</p>

<p>
 Por otra parte, la pantalla tiene “físicamente” 32 bloques, pero
nosotros vamos a imprimir 64 caracteres, por lo que cada bloque puede
contener 2 caracteres. Cuando especificamos una coordenada X para
imprimir, la rutina necesita dividirla por 2 para saber en qué carácter
de pantalla irá impresa la letra. Una vez calculado este carácter, la
letra puede ir en la parte “izquierda” del bloque de pantalla (4 bits
superiores) o en la parte derecha (4 bits inferiores del bloque). El
resto de la división entre 2 de la coordenada X nos indica en cuál de
las 2 partes se debe imprimir el carácter.
</p>

<p>
 La rutina de impresión de caracteres de 4×8 es bastante parecida a la
rutina estándar de 8×8 salvo por las divisiones entre 2 del carácter <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr> y de la posición X en pantalla para el cálculo del origen en la fuente y del destino en vram.
</p>

<p>
 La impresión del carácter en sí mismo también cambia, ya que existen 4
posibilidades de impresión que requieren 4 porciones de código
diferentes:
</p>

<p>
 Como en cada byte de la fuente se definen 2 caracteres (izquierdo y
derecho) y a su vez a la hora imprimir en pantalla hay 2 posibilidades
de impresión en el mismo bloque (parte izquierda y parte derecha del
bloque), necesitamos 4 rutinas que cubran esas cuatro posibilidades.
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Imprimir un carácter de la “parte
izquierda” (nibble alto en datos de caracter) de la fuente en la “parte
izquierda” de un bloque de pantalla (nibble alto del byte en videoram).
</li>
<li> Imprimir un carácter de la “parte
derecha” (nibble bajo en datos de caracter) de la fuente en la “parte
izquierda” de un bloque de pantalla (nibble alto del byte en videoram).
</li>
<li> Imprimir un carácter de la “parte
izquierda” (nibble alto en datos de caracter) de la fuente en la “parte
derecha” de un bloque de pantalla (nibble bajo del byte en videoram).
</li>
<li> Imprimir un carácter de la “parte
derecha” (nibble bajo en datos de caracter) de la fuente en la “parte
derecha” de un bloque de pantalla (nibble bajo del byte en videoram).
</li>
</ul>

<p>
<br>

</p>

<p>
 Al trazar el carácter en pantalla tenemos que hacerlo con OR para
respetar otro posible carácter de 4×8 que pueda haber en el mismo
bloque, ya lo estemos imprimiendo en la parte izquierda de un bloque
(respetar el nibble de la derecha) o en la derecha (respetar el nibble
de la izquierda).
</p>

<p>
 Veamos la rutina de impresión <strong>PrintChar_4x8</strong> seguida de la 4 subrutinas de volcado de carácter que son llamados una vez calculados HL y DE como origen y destino.
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; PrintChar_4x8:</span>
<span class="co1">; Imprime un caracter de 4x8 pixeles de un charset.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; -----------------------------------------------------</span>
<span class="co1">; FONT_CHARSET = Direccion de memoria del charset.</span>
<span class="co1">; FONT_X       = Coordenada X en baja resolucion (0-31)</span>
<span class="co1">; FONT_Y       = Coordenada Y en baja resolucion (0-23)</span>
<span class="co1">; FONT_ATTRIB  = Atributo a utilizar en la impresion.</span>
<span class="co1">; Registro A   = ASCII del caracter a dibujar.</span>
<span class="co1">;-------------------------------------------------------------</span>
PrintChar_4x8:
&nbsp;
   <span class="kw1">RRA</span>                       <span class="co1">; Dividimos A por 2 (resto en CF)</span>
   <span class="kw1">PUSH</span> <span class="kw2">AF</span>                   <span class="co1">; Guardamos caracter y CF en A'</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array fuente) en HL como:</span>
   <span class="co1">;;;     direccion = base_charset + ((CARACTER/2)*8)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>FONT_CHARSET<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = Direccion origen de A en fuente</span>
&nbsp;
   <span class="co1">;;; Calculamos las coordenadas destino de pantalla en DE:</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>FONT_X<span class="br0">)</span>           <span class="co1">; B = Y,  C = X</span>
   <span class="kw1">RR</span> <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>                  <span class="co1">; DE contiene ahora la direccion destino.</span>
&nbsp;
   <span class="co1">;;; Calculamos posición en pantalla. Tenemos que dividirla por 2 porque</span>
   <span class="co1">;;; en cada columna de pantalla caben 2 caracteres. Usaremos el resto </span>
   <span class="co1">;;; (Carry) para saber si va en la izq (CF=0) o der (CF=1) del caracter.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_X<span class="br0">)</span>            <span class="co1">; Volvemos a leer coordenada X</span>
   <span class="kw1">RRA</span>                       <span class="co1">; Dividimos por 2 (posicion X en pantalla)</span>
                             <span class="co1">; Ademas el carry tiene el resto (par/impar)</span>
   <span class="kw1">JR</span> NC, pchar4_x_odd       <span class="co1">; Saltar si es columna impar (por el CF)</span>
&nbsp;
   <span class="co1">;;; Ahora tenemos que imprimir el caracter en pantalla. Hemos saltado</span>
   <span class="co1">;;; a pchar4_x_even o pchar4_x_odd segun si la posicion en pantalla es</span>
   <span class="co1">;;; par o impar, pero cada una de estas 2 opciones nos da la posibilidad</span>
   <span class="co1">;;; de usar una rutina u otra segun si el caracter ASCII es par o impar</span>
   <span class="co1">;;; ya que tenemos que cogerlo de la fuente de una forma u otra</span>
   <span class="co1">;;; Posicion de columna en pantalla par:</span>
pchar4_x_even  :
   <span class="kw1">POP</span> <span class="kw2">AF</span>                    <span class="co1">; Restaura A=char y CF=si es char par/impar</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, pchar4_l_on_l
   <span class="kw1">JR</span> pchar4_r_on_l
&nbsp;
pchar4_x_odd:
   <span class="kw1">POP</span> <span class="kw2">AF</span>                    <span class="co1">; Restaura A=char y CF=si es char par/impar</span>
   <span class="kw1">JR</span> NC, pchar4_r_on_r
   <span class="kw1">JR</span> pchar4_l_on_r
&nbsp;
pchar4_continue:
&nbsp;
   <span class="co1">;;; Impresion de los atributos</span>
pchar4_printattr:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>            <span class="co1">; Recuperamos el valor inicial de DE</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>              <span class="co1">; Restando los 8 scanlines avanzados</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en HL.</span>
   <span class="kw1">RRCA</span>               <span class="co1">; A ya es = D, listo para rotar</span>
   <span class="kw1">RRCA</span>               <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">E</span>
&nbsp;
   <span class="co1">;;; Escribir el atributo en memoria</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>FONT_ATTRIB<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Escribimos el atributo en memoria</span>
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">;;;------------------------------------------------------------------</span>
<span class="co1">;;; "Subrutinas" de impresion de caracter de 4x8</span>
<span class="co1">;;; Entrada: HL = posicion del caracter en la fuente 4x8</span>
<span class="co1">;;;          DE = posicion en pantalla del primer scanline</span>
<span class="co1">;;;------------------------------------------------------------------</span>
&nbsp;
<span class="co1">;;;----------------------------------------------------</span>
pchar4_l_on_l:
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                   <span class="co1">; 8 scanlines / iteraciones</span>
pchar4_ll_lp:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leer byte de la pantalla</span>
   <span class="kw1">AND</span> <span class="re1">%11110000</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>                   <span class="co1">; Nos lo guardamos en C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Cogemos el byte de la fuente</span>
   <span class="kw1">AND</span> <span class="re1">%00001111</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>                      <span class="co1">; Lo combinamos con el fondo</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Y lo escribimos en pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">D</span>                     <span class="co1">; Siguiente scanline</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; Siguiente dato del "sprite"</span>
   <span class="kw1">DJNZ</span> pchar4_ll_lp
   <span class="kw1">JR</span> pchar4_continue        <span class="co1">; Volver tras impresion</span>
&nbsp;
&nbsp;
<span class="co1">;;;----------------------------------------------------</span>
pchar4_r_on_r:
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                   <span class="co1">; 8 scanlines / iteraciones</span>
pchar4_rr_lp:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leer byte de la pantalla</span>
   <span class="kw1">AND</span> <span class="re1">%00001111</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>                   <span class="co1">; Nos lo guardamos en C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Cogemos el byte de la fuente</span>
   <span class="kw1">AND</span> <span class="re1">%11110000</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>                      <span class="co1">; Lo combinamos con el fondo</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Y lo escribimos en pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">D</span>                     <span class="co1">; Siguiente scanline</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; Siguiente dato del "sprite"</span>
   <span class="kw1">DJNZ</span> pchar4_rr_lp
   <span class="kw1">JR</span> pchar4_continue        <span class="co1">; Volver tras impresion</span>
&nbsp;
&nbsp;
<span class="co1">;;;----------------------------------------------------</span>
pchar4_l_on_r:
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                   <span class="co1">; 8 scanlines / iteraciones</span>
pchar4_lr_lp:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leer byte de la pantalla</span>
   <span class="kw1">AND</span> <span class="re1">%00001111</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>                   <span class="co1">; Nos lo guardamos en C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Cogemos el byte de la fuente</span>
   <span class="kw1">RRCA</span>                      <span class="co1">; Lo desplazamos 4 veces &gt;&gt; dejando</span>
   <span class="kw1">RRCA</span>                      <span class="co1">; lo bits 4 al 7 vacios</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">AND</span> <span class="re1">%11110000</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>                      <span class="co1">; Lo combinamos con el fondo</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Y lo escribimos en pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">D</span>                     <span class="co1">; Siguiente scanline</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; Siguiente dato del "sprite"</span>
   <span class="kw1">DJNZ</span> pchar4_lr_lp
   <span class="kw1">JR</span> pchar4_continue        <span class="co1">; Volver tras impresion</span>
&nbsp;
&nbsp;
<span class="co1">;;;----------------------------------------------------</span>
pchar4_r_on_l:
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>                   <span class="co1">; 8 scanlines / iteraciones</span>
pchar4_rl_lp:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leer byte de la pantalla</span>
   <span class="kw1">AND</span> <span class="re1">%11110000</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>                   <span class="co1">; Nos lo guardamos en C</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                <span class="co1">; Cogemos el byte de la fuente</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; Lo desplazamos 4 veces &lt;&lt; dejando</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; los bits 0 al 3 vacios</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">RLCA</span>
   <span class="kw1">AND</span> <span class="re1">%00001111</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>                      <span class="co1">; Lo combinamos con el fondo</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Y lo escribimos en pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">D</span>                     <span class="co1">; Siguiente scanline</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                    <span class="co1">; Siguiente dato del "sprite"</span>
   <span class="kw1">DJNZ</span> pchar4_rl_lp
   <span class="kw1">JR</span> pchar4_continue        <span class="co1">; Volver tras impresion</span></pre>

<p>
 Para poder utilizar estas rutinas con nuestro sistema de impresión
habría que cambiar la constante que define el tamaño de anchura de la
pantalla en caracteres:
</p>
<pre class="code z80">FONT_SCRWIDTH    <span class="kw3">EQU</span>   <span class="nu0">64</span></pre>

<p>
 También habría que crear un PrintString_4x8 idéntico a PrintString_8x8
pero que llame a PrintChar_4x8, y modificar aquellas rutinas que hagan
referencia a una de estas 2 funciones, como por ejemplo:
</p>
<pre class="code z80">Font_Backspace:
   <span class="kw1">CALL</span> Font_Dec_X
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="st0">' '</span>                 <span class="co1">; Imprimir caracter espacio</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">PUSH</span> <span class="kw2">DE</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
   <span class="kw1">CALL</span> PrintChar_4x8        <span class="co1">; Sobreescribir caracter</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">DE</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">RET</span>                       <span class="co1">; Salir</span></pre>

<p>
 Una vez realizados estos cambios, podemos utilizar la fuente de 4×8 con
 nuestro sistema de gestión de texto. Veamos un sencillo ejemplo:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo de fuente de 4x8 pixeles (64 caracteres por linea)</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, charset_4x8<span class="sy0">-</span><span class="re1">1</span><span class="nu0">28</span>                    <span class="co1">; Inicio charset - (256/2)</span>
  <span class="kw1">CALL</span> Font_Set_Charset
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, cadena<span class="re1">1</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span><span class="re1">0</span><span class="nu0">4</span><span class="re1">00</span>                              <span class="co1">; X=00, Y=04</span>
  <span class="kw1">CALL</span> Font_Set_XY
  <span class="kw1">CALL</span> PrintString_4x8_Format
&nbsp;
loop:
  <span class="kw1">JR</span> loop
  <span class="kw1">RET</span>
&nbsp;
cadena<span class="re1">1</span> DB <span class="st0">"Fuente de 4x8"</span>, FONT_CRLF, FONT_CRLF
        DB <span class="st0">"Esto es un texto impreso a 64 columnas con fuente "</span>
        DB <span class="st0">"de 4x8 pixeles. La letra tiene la mitad de anchura "</span>
        DB <span class="st0">"que la estandar pero todavia se lee con facilidad."</span>
        DB FONT_CRLF, FONT_CRLF
        DB <span class="st0">"Con esta fuente se pueden realizar juegos basados en "</span>
        DB <span class="st0">"texto pero hay que tener en cuenta que los atributos "</span>
        DB FONT_SET_INK, <span class="nu0">2</span>, <span class="st0">"afectan a 2 caracteres "</span>, FONT_SET_INK, <span class="re1">0</span>
        DB <span class="st0">"a la vez, por lo que es mejor no cambiar el paper y "</span>
        DB <span class="st0">"modificarlos solo antes o tras un espacio."</span>
        DB FONT_EOS</pre>

<p>
<br>

<img src="img/gfx4_64col.png" class="mediacenter" alt=" Ejemplo de impresión a 64 columnas "/>
<br>

</p>

<p>
 Nótese cómo hemos inicializado FONT_CHARSET a la dirección de la fuente
 menos 128 en lugar de restarle 256. Esto se debe a que la fuente tiene 2
 caracteres definidos en cada byte y vamos a dividir el <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>
 entre 2 en nuestra rutina, por lo que el carácter en que empieza
nuestra fuente, el 32, está en charset4x8 - (256/2) = charset4x8 - 128.
</p>

<p>
 Otro detalle importante es el tema de los atributos: como cada bloque
de pantalla contiene 2 caracteres, no podemos establecer atributos
diferentes para 2 caracteres del mismo byte. Por esto, hay que ser cauto
 a la hora de establecer atributos. La solución más sencilla es cambiar
las tintas en posiciones donde haya espacios, ya que en ese caso el
cambio será efectivo en la letra deseada si ésta es la primera del byte,
 o en el espacio seguido de la letra deseada si está en la parte
derecha. Los cambios de PAPER, BRIGHT o FLASH supondrán problemas si no
se realizan siempre en posiciones de pantalla pares.
</p>

<p>
 Finalmente, debido al reducido tamaño de la fuente no se han definido
funciones de estilo, ya que es muy difícil realizar estilos de negrita o
 cursiva con una definición de 4×8. La única opción viable es la
creación de un estilo de subrayado creando 4 funciones de impresión 4×8
adicionales (para las 4 combinaciones de par/impar en cuanto a <abbr title="" data-original-title="American Standard Code for Information Interchange">ASCII</abbr>/pantalla) donde se tracen 7 scanlines y el último se trace como %11110000 ó %00001111.
</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/gfx4_charset.asm">Visualizando el charset personalizado</a>
</li>
<li><a href="src/gfx4_charset.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx4_charsetrom.asm">Visualizando el charset de la ROM</a>
</li>
<li><a href="src/gfx4_charsetrom.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx4_estilos.asm">Ejemplo: Diferentes estilos de fuente</a>
</li>
<li><a href="src/gfx4_estilos.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx4_texto.asm">Ejemplo: Impresion de texto con códigos de control</a>
</li>
<li><a href="src/gfx4_texto.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx4_params.asm">Ejemplo: Impresión de texto con códigos de variable</a>
</li>
<li><a href="src/gfx4_params.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx4_input.asm">Ejemplo: INPUT de texto desde teclado</a>
</li>
<li><a href="src/gfx4_input.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx4_64col.asm">Ejemplo: Texto a 64 columnas</a>
</li>
<li><a href="src/gfx4_64col.tap">Tap del ejemplo anterior</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="http://chuntey.wordpress.com/2010/01/08/64-column-print/" class="urlextern" title="http://chuntey.wordpress.com/2010/01/08/64-column-print/">Impresión a 64 Columnas</a>.</div>
</li>
<li><div class="li"> <a href="http://metalbrain.speccy.org/" class="urlextern" title="http://metalbrain.speccy.org">Web de SevenuP</a> (por metalbrain).</div>
</li>
<li><div class="li"> <a href="http://manuales.speccy.org/basic_gomas/capitulo14.php" class="urlextern" title="http://manuales.speccy.org/basic_gomas/capitulo14.php">Manual del Spectrum 48K</a>: el juego de caracteres.</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a>.</div>
</li>
<li><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/z80time.txt" class="urlextern" title="external/www.ticalc.org/pub/text/z80/z80time.txt">Tiempos de ejecución y tamaños</a> de las instrucciones del Z80.</div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a>.</div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a>.</div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a>.</div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="graficos-y-vtecnicas-de-mapeado-por-bloques">Gráficos (y V): Técnicas de mapeado por bloques</h1>
<div class="level1">

<p>
 En el amplio catálogo de software del Spectrum existen juegos con
decenas y hasta cientos de pantallas. ¿Cómo es posible que, a 7KB por
pantalla, quepan tantas “localidades” de juego en la memoria del
Spectrum?
</p>

<p>
 Lo que posibilita esta variedad de pantallas de juego es la técnica de mapeado por bloques.
</p>

<p>
 En esta técnica se utiliza un spriteset de bitmaps denominados tiles y
se definen en memoria mapas basados en identificadores numéricos donde
cada valor representa un tile concreto. Así, se compone cada pantalla de
 juego como una matriz de “tiles” a dibujar.
</p>

<p>
 Un sólo spriteset (tileset) lo suficientemente variado y la habilidad
del diseñador y del programador pueden dar lugar a gran cantidad de
pantallas y un amplio mapeado con un mínimo uso de memoria, todo basado
en la composición de la pantalla como repetición de tiles.
</p>

<p>
 En este capítulo veremos cómo definir las pantallas del mapeado y rutinas para imprimir estas pantallas en la videomemoria.
</p>

<p>
<br>

</p>

</div>

<h2 id="creacion-de-mapas-a-partir-de-bloques-o-tiles">Creación de mapas a partir de bloques o tiles</h2>
<div class="level2">

<p>
 Como ya vimos en el capítulo dedicado a Sprites en baja resolución,
podemos generar las pantallas de nuestros juegos como repetición de
bitmaps tomados de un set gráfico a partir del cual se puedan construir
todo el mapeado.
</p>

<p>
 Cada uno de estos “bloques” a partir del cual componemos la pantalla recibe el nombre de <strong>tile</strong>.
</p>

<p>
 Con los tiles podemos componer tanto pantallas individuales de juego
como mapas de gran extensión en los que podemos cambiar de una pantalla a
 otra constantemente (redibujando una pantalla entera cada vez) o
incluso scrollear porciones de la misma.
</p>

<p>
 La pantalla se codifica como una matriz o vector de datos numéricos
donde cada valor representa un índice en el tileset (un bitmap
concreto). La rutina de impresión recorre este vector/matriz y traza
cada bitmap en su posición correspondiente para generar la imagen que ve
 el jugador.
</p>

<p>
 Pueden existir incluso identificadores numéricos de bloque que nuestra
rutina trate de forma especial, para definir por ejemplo bloques que no
deben de ser dibujados y que permitan ver el fondo que hay en la
pantalla, como sucede en el caso de Sokoban:
</p>

<p>
<br>

<img src="img/gfx3_tilemap.png" class="mediacenter" alt=" Tilemaps "/>
</p>
<div style="text-align: center;"><em>Tilemap: componiendo un mapa en pantalla<br>
a partir de tiles de un tileset/spriteset + mapa.</em>
</div>
<p>
<br>

</p>

<p>
 Crear los mapeados mediante tiles nos permite un enorme ahorro de
memoria ya que en lugar de necesitar 6912 bytes por cada pantalla de
juego nos basta con un tileset y pantallas formadas por repetición de
los mismos. Una pantalla completa (256×192) formada por tiles de 16×16
ocupará apenas (256/16)x (192/16) = 16×12 = 192 bytes. En los 7 KB que
ocupa una pantalla gráfica entera podemos definir 36 pantallas de juego
en base a tiles.
</p>

<p>
 Una gran parte de los juegos de Spectrum tienen sus pantallas formadas
por mapas de tiles, debido al gran ahorro de memoria que suponen. El
diseñador de los gráficos y de las pantallas será el principal
responsable de que existan suficientes bloques diferentes para
representar todos los elementos del mapeado con suficiente diversidad
gráfica.
</p>

<p>
<br>

<img src="img/gfx5_gamemaps.png" class="mediacenter" alt=" Juegos basados en tiles "/>
<br>

</p>

<p>
 Y no sólo podemos realizar juego de puzzle tipo Puzznic, Plotting o
Sokoban: en base a tiles podemos crear videoaventuras, los mapeados de
un juego de disparos, juegos de laberintos, plataformas, o generar todas
 las pantallas en que se desenvuelva un arcade. Una vez impresa la
pantalla en base a bloques, el juego puede desarrollarse pixel a pixel
en cuanto al movimiento del personaje principal y los enemigos y
objetos.
</p>

<p>
<br>

</p>

</div>

<h2 id="organizacion-de-los-mapas-en-memoria">Organización de los mapas en memoria</h2>
<div class="level2">

<p>
 Los mapas están compuestos por <strong>pantallas</strong>, que representan la porción del mismo que resulta visible por el usuario.
</p>

<p>
 Cada nivel puede estar formado por una única pantalla (caso de juegos
como Sokoban, Bubble Bobble, Manic Miner, etc.), o puede estar formado
por múltiples pantallas (R-Type, Rick Dangerous, Dynamite Dan, Sabre
Wulf, Into the eagle's Nest, etc.).
</p>

<p>
 Comencemos examinando la forma de definir y trazar una única pantalla.
Posteriormente veremos las estructuras de datos necesarias para definir
un mapa completo como una matriz de pantallas.
</p>

<p>
<br>

</p>

</div>

<h2 id="pantallas-del-mapa">Pantallas del mapa</h2>
<div class="level2">

<p>
 Las <strong>pantallas de un mapa</strong> son vectores de datos donde
cada elemento representa un identificador de tile (valor numérico 0-N)
que utilizaremos para obtener desde el tileset el gráfico concreto a
dibujar en esa posición.
</p>

<p>
 Podemos organizar los tiles linealmente en memoria en formato horizontal o en formato vertical.
</p>

<p>
 Una pantalla en formato horizontal contiene los identificadores de
tiles de la pantalla en scanlines horizontales de tiles, comenzando con
la fila 0, a la cual le sigue la fila 1, la 2, la 3, etc.
</p>

<p>
<br>

 El tileset de Sokoban (el primero de los sets gráficos disponibles) es el siguiente:
</p>

<p>
<br>

<img src="img/gfx5_sokoset.png" class="mediacenter" alt=" Tileset de Sokoban "/>
<br>

</p>

<p>
 Veamos ampliados los bloques de 16×16:
</p>

<p>
<br>

<img src="img/gfx3_tilesetsk.png" class="mediacenter" alt=" (Ampliacion del tileset) "/>
<br>

</p>

<p>
 Como puede apreciarse, hay 8 tiles gráficos que numeramos desde el 0 al 7 siendo el 0 un bloque vacío de fondo negro.
</p>

<p>
<br>

 Ahora veamos cómo codificar una pantalla utilizando el tileset que
acabamos de ver. Utilizaremos para eso la primera pantalla del juego,
que es la siguiente:
</p>

<p>
<br>

<img src="img/gfx5_sokobanl1.png" class="mediacenter" alt=" Pantalla 1 de Sokoban "/>
<br>

</p>

<p>
 Es una pantalla de 16×12 tiles formados por 2×2 bloques cada uno
(16×16=256 y 12×16=192 → 256×192 pixeles). Hay 7 tiles gráficos, uno “en
 blanco” (el 0), y un tile que es transparente (el que permite que se
vea el fondo). Los tiles están impresos sobre un fondo negro decorado
con diferentes logotipos y gráficos del robot protagonista (de ahí la
importancia de los tiles transparentes, que permiten que no se
sobreescriba el fondo).
</p>

<p>
 Veamos el proceso de construcción de la pantalla: Codificaremos cada
“bloque” de pantalla con el identificador numérico que lo representa en
el tileset, siendo 0 el tile inicial de contenido vacío, y siendo 8 el
código especial que indique que no se debe dibujar el tile (de forma que
 sea transparente y deje ver el fondo).
</p>

<p>
<br>

<br>

<strong>Organización horizontal</strong>
</p>

<p>
 Empecemos con la primera fila horizonzal de datos. Nótese que esta
primera fila (fila superior de la pantalla) es totalmente transparente
(no se debe escribir ningún tile y debe verse el fondo original con el
patrón de relleno), por lo que se codifica como:
</p>
<pre class="code z80">  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span></pre>

<p>
 La siguiente fila (segunda fila horizontal de tiles) ya tiene 4 bloques
 gráficos (tiles 2, 3, 1, 4), en el centro de la pantalla. Todos los
demás tiles son transparentes (valor 8):
</p>
<pre class="code z80">  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">1</span>,<span class="nu0">4</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span></pre>

<p>
 Continuemos observando la pantalla del nivel 1 de Sokoban y el vector
de datos que vamos generando: La tercera fila tiene 7 tiles: 3
consecutivos con formas de paredes (tiles nº 1, 2 y 3), luego 2 tiles
“vacíos” de fondo (valor 0) y 2 tiles más de “paredes” (tiles nº 5 y 4).
 El resto de tiles son transparentes (valor 8):
</p>
<pre class="code z80">  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="re1">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">4</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span></pre>

<p>
 Si continuamos codificando cada línea horizontal de pantalla en nuestro vector de datos, obtenemos la pantalla completa:
</p>
<pre class="code z80"><span class="co1">;;; Pantalla 1 de Sokoban codificada horizontalmente.</span>
<span class="co1">;;;</span>
<span class="co1">;;; El tile de valor 8 es un tile transparente (no esta en el tileset).</span>
&nbsp;
sokoban_LEVEL<span class="re1">1</span>_h:
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">1</span>,<span class="nu0">4</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="re1">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">4</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">5</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">4</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="nu0">5</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">5</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span></pre>

<p>
 Hemos ubicado los datos en una representación visual clara mediante un
DEFB por cada fila horizontal, pero el aspecto real de los datos en
memoria es totalmente lineal:
</p>
<pre class="code z80">sokoban_LEVEL<span class="re1">1</span>_h:
 DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">1</span>,<span class="nu0">4</span>,<span class="br0">(</span>...<span class="br0">)</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span></pre>

<p>
 Así pues, cada “fila” de 16 tiles de la pantalla se codifica con 16
identificadores de tile. Hay un total de 12 filas, por lo que acabamos
obteniendo un vector de 16*12 = 192 bytes de datos para la pantalla.
</p>

<p>
 Normalmente, la conversión de datos gráficos a identificadores de tile
no se realiza manualmente sino que se emplea un “programa de dibujo de
mapeados” (editor de mapas) con el que “dibujamos tiles” utilizando el
tileset como paleta y que permite exportar el mapa directamente como
datos.
</p>

<p>
<br>

<br>

<strong>Organización vertical</strong>
</p>

<p>
 En el anterior ejemplo hemos organizado el mapa en formato horizontal.
También habría cabido la posibilidad de organizarlo verticalmente, es
decir, creando un vector que almacenara los identificadores de tile de
cada <strong>columna</strong> de la pantalla.
</p>

<p>
 Veamos de nuevo la pantalla inicial de Sokoban para codificarla verticalmente:
</p>

<p>
<br>

<img src="img/gfx5_sokobanl1.png" class="mediacenter" alt=" Pantalla 1 de Sokoban "/>
<br>

</p>

<p>
 En este caso, la pantalla comenzaría con 4 columnas de datos “transparentes”.
</p>
<pre class="code z80">  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span></pre>

<p>
 La quinta columna ya tiene bloques gráficos :
</p>
<pre class="code z80">  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="re1">1</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span></pre>

<p>
 La sexta columna bloques gráficos y bloques “vacíos” (0):
</p>
<pre class="code z80">  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">2</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span></pre>

<p>
 La pantalla completa codificada verticalmente sería la siguiente:
</p>
<pre class="code z80"><span class="co1">;;; Pantalla 1 de Sokoban codificada verticalmente.</span>
<span class="co1">;;;</span>
<span class="co1">;;; El tile de valor 8 es un tile transparente (no esta en el tileset).</span>
&nbsp;
sokoban_LEVEL<span class="re1">1</span>_v:
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="re1">1</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">2</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">3</span>,<span class="re1">1</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">7</span>,<span class="nu0">2</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">7</span>,<span class="nu0">3</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="re1">0</span>,<span class="nu0">7</span>,<span class="nu0">2</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">3</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">3</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>
  DEFB <span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span>,<span class="nu0">8</span></pre>

<p>
 En este caso nuestros “DEFBs” son de 12 bytes cada uno, teniendo un
total de 16 columnas de 12 bytes = los mismos 192 bytes de datos de
pantalla.
</p>

<p>
 Según codifiquemos el mapa en formato horizontal o vertical tendremos
que programar una rutina de impresión de pantalla u otra, ya que el
orden de obtención de los datos desde el “vector de pantalla” es
diferente.
</p>

<p>
 La rutina de impresión vertical suele ser ligeramente más óptima que la
 horizontal dada la estructura de la pantalla del Spectrum. Por contra,
existe una tendencia generalizada a utilizar la codificación e impresión
 en formato horizontal por similitud con nuestro sistema de escritura
(de izquierda a derecha y de arriba a abajo) en cuanto a la hora de
“leer” los datos gráficos por parte del programador (visualmente
hablando).
</p>

<p>
 En nuestros ejemplos utilizaremos codificación horizontal y rutinas de
impresión de filas (impresión horizontal) siendo las rutinas de
impresión vertical fácilmente deducibles a partir de estas.
</p>

<p>
 Por otra parte, cabe destacar que podemos crear diferentes tilesets y
una misma pantalla puede trazarse con cualquiera de ellos permitiéndonos
 tener “sets gráficos” diferentes para que el usuario pueda elegir el
más acorde a sus gustos. El juego Sokoban, por ejemplo, incluye
diferentes sets gráficos seleccionables por el usuario; las pantallas de
 mapa son las mismas, y sólo cambia la dirección de origen de la que se
leen los tiles (el tileset) entre los varios disponibles (bastará con
cambiar DM_SPRITES, la variable de memoria que utilizarán nuestras
rutinas, para apuntar a un tileset diferente).
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit5" id="rutinas-de-impresion-de-pantallas">Rutinas de impresión de pantallas</h3>
<div class="level3">

<p>
 En este apartado vamos a ver rutinas diseñadas para dibujar una
pantalla estática formada a base de tiles. La rutina debe imprimir un
mapa de ANCHOxALTO tiles a partir de una posición inicial
(X_INICIO,Y_INICIO), y está pensada para el trazado de una pantalla que
no tiene scroll de ningún tipo y sobre la que después trabajaremos.
</p>

<p>
 Ejemplos de juegos con este “formato” de pantalla son Manic Miner,
Bubble Bobble, Sabre Wulf, Dynamite Dan, Sir Fred, etc…. La pantalla del
 mapa se dibuja una sóla vez y no se redibuja se o cambia de pantalla a
menos que el personaje cruce los límites de la misma.
</p>

<p>
 Para juegos con scroll basados en tiles es necesario scrollear la
pantalla y diseñar rutinas que impriman porciones del mapeado (tiras
verticales u horizontales de la pantalla entrante que aparezcan por
alguna de las 4 direcciones), además de requerir una estructura de
mapeado concreta, como veremos más adelante.
</p>

<p>
 Aunque nos vamos a centrar ahora en la impresión de una sóla pantalla,
no debemos olvidar que el mapa completo del juego está formado por
múltiples pantallas. El mapa en sí no será más que un array de
direcciones de las diferentes pantallas, del que obtendremos la
dirección de la pantalla actual para proporcionársela a la rutina de
impresión.
</p>

<p>
 Una primera aproximación a la impresión del mapa se basaría en la
utilización de las rutinas de impresión de Sprites ya vistas usando dos
bucles (uno vertical y el otro, anidado, horizontal). La rutina
recorrería toda la pantalla del mapa e imprimiría cada tile utilizando
DrawSprite:
</p>
<pre class="code">;;; Aproximacion 1:
FOR Y=0 TO ALTO_PANTALLA_EN_TILES:
  FOR X=0 TO ANCHO_PANTALLA_EN_TILES:
     TILE = PANTALLA[x][y]
     XTILE = X_INICIAL + X*ANCHO_TILE
     YTILE = Y_INICIAL + Y*ALTO_TILE
     CALL Draw_Sprite</pre>

<p>
 La implementación de esta rutina no sería óptima porque implica gran
cantidad de cálculos tanto en el bucle interior como dentro de la rutina
 Draw_Sprite. Para cada tile de pantalla se realizaría un cálculo de
dirección de memoria a partir de las coordenadas X,Y.
</p>

<p>
 Además, la obtención de cada TILE implica un acceso a una matriz de 2
dimensiones X,Y, que en nuestro array de datos se corresponde con:
</p>
<pre class="code">TILE = [ PANTALLA + (Y*ANCHO_PANTALLA_EN_TILES) + X ]</pre>

<p>
 Veamos una aproximación mucho más óptima:
</p>

<p>
1.- Teniendo en cuenta que los datos de la pantalla son consecutivos en
memoria, vamos a utilizar un puntero para obtener los datos de los tiles
 linealmente sin tener que calcular la posición dentro del array de
datos una y otra vez. Bastará con incrementar nuestro puntero
(DIR_PANTALLA) para apuntar al siguiente dato.
</p>

<p>
2.- En lugar de calcular la posición en videomemoria (DIR_MEM) de cada
tile, calcularemos una sóla vez esta posición para el primer tile de
cada fila y avanzaremos diferencialmente a lo largo de la misma. De esta
 forma sólo realizamos un cálculo de dirección de videomemoria por fila,
 y no por tile.
</p>
<pre class="code">;;; Aproximacion 2b - Impresion horizontal con mapa horizontal.
;;; Calculamos la posicion en memoria del primer bloque de linea
;;; y despues nos movemos diferencialmente a los siguientes bloques
;;; El mapa se accede linealmente (no se indexa por x,y):

DIR_PANTALLA = Direccion de memoria de los datos de la PANTALLA actual
FOR Y=0 TO ALTO:
  DIR_MEM = Posicion_Memoria( X_INICIAL, Y_INICIAL + Y*ALTO_BLOQUE )
  FOR X=0 TO ANCHO_PANTALLA:
     TILE = [DIR_PANTALLA]
     DIR_PANTALLA = DIR_PANTALLA + 1
     PUSH DIR_MEM
     DIR_SPRITE = BASE_TILESET + (TILE*ANCHO_TILE*ALTO_TILE)
     Dibujar Sprite desde DIR_SPRITE a DIR_MEM
     POP DIR_MEM
     DIR_MEM = DIR_MEM + ANCHO_TILE</pre>

<p>
 Esta rutina sólo realiza un cálculo de posición de videomemoria por
fila y además accede a nuestra pantalla de mapa linealmente. Antes de
dibujar el tile en pantalla hacemos un PUSH de la dirección actual de
memoria ya que la rutina de impresión la modifica. El posterior POP nos
recupera la posición de impresión inicial de forma que baste un simple
incremento de la misma para apuntar en videomemoria a la posición del
siguiente tile que tenemos que dibujar.
</p>

<p>
 Vamos a desarrollar un poco más la rutina en un pseudocódigo más
parecido a ASM y con más detalles. Para ello establecemos las siguientes
 premisas:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Utilizaremos IX como puntero de la pantalla del mapa (DIR_PANTALLA).
</li>
<li> Utilizaremos el valor de tile 255
como un tile “especial” que la rutina no dibujará. Este tile será pues
un tile transparente que dejará ver el fondo en contraposición al típico
 bloque “0” vacío que borra un tile de pantalla.
</li>
</ul>
<pre class="code">DrawMap:

  IX = MAPA
  B = ALTURA_MAPA_EN_TILES

bucle_altura:
  Y = ALTURA_MAPA_EN_TILES - B
  DE = DIR_MEM( X_INICIO, Y_INICIO + (Y*2) )

       B = ANCHURA_MAPA_EN_TILES
       bucle_anchura:
          A = (IX)
          INC IX

          Si A == 255 :
             JR saltar_bloque

          PUSH HL
          DIR_SPRITE = BASE_TILESET + (A*ANCHO_TILE*ALTO_TILE)
          HL = BASE_TILESET + (A*8*TAMAÑO_BLOQUES_EN_CADA_TILE)
          PUSH HL
          Imprimir_Sprite_de_HL_a_DE
          Convertir DIR HL imagen en DIR HL atributos
          Imprimir_Atributos_Sprite
          POP HL

       saltar_bloque:
          HL = HL + ANCHO_TILE
          DJNZ bucle_anchura

  DJNZ bucle_altura</pre>

<p>
 Este algoritmo es genérico y puede ser optimizado personalizándolo a cada situación / tipo de juego que estemos realizando.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit6" id="rutina-para-bloques-de-16x16-con-mapeados-horizontales">Rutina para bloques de 16x16 con mapeados horizontales</h3>
<div class="level3">

<p>
 Veamos una rutina de impresión de pantallas de mapa basadas en tiles de
 16×16 píxeles, el tamaño más habitual de tile para la resolución del
Spectrum.
</p>

<p>
 Con tiles de 16×16 píxeles podemos generar una pantalla de hasta 16×12
tiles utilizando 192 tiles por pantalla. Con tiles referenciadas por
variables de 1 byte, cada pantalla ocuparía, pues, 192 bytes.
</p>

<p>
 Tamaños de 8×8 requerirían 768 bytes por pantalla y un tileset con gran
 cantidad de elementos para poder componer las pantallas.
</p>

<p>
 Tiles de mayores tamaños darían poca “resolución” para generar la
pantalla, ya que serían demasiado grandes. Por ejemplo, tiles de 32×32
pixeles generarían pantallas de 8×6 tiles (poca “resolución” de mapa).
</p>

<p>
 La rutina que veremos ahora es genérica: permite especificar un ancho y
 alto de cada pantalla en tiles para poder dibujar pantallas desde 1×1 a
 16×12 tiles. Además podemos especificar una dirección de inicio de
impresión (inicio_x, inicio_y), de forma que podamos dibujar nuestro
mapa en una posición concreta de pantalla (por ejemplo, dentro de un
marco, centrado, etc).
</p>

<p>
 El hecho de ser una rutina genérica también le resta algo de velocidad
en ciertos cálculos que podríamos evitar o desenrollar para rutinas
específicas. Si en nuestro juego todas las pantallas tienen el mismo
tamaño y las imprimimos siempre en la misma posición, podemos (y
debemos) alterar la rutina para utilizar los valores adecuados dentro de
 ella, modificar los cálculos y desenrollar los bucles utilizando estos
datos constantes.
</p>

<p>
 La rutina se basa en el pseudocódigo que vimos al inicio del capítulo,
pero adaptado a tamaños de 16×16. Veamos la rutina comentada:
</p>
<pre class="code z80"><span class="co1">;---------------------------------------------------------------</span>
<span class="co1">; DrawMap_16x16:</span>
<span class="co1">; Imprime una pantalla de tiles de 16x16 pixeles.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion             Parametro</span>
<span class="co1">; --------------------------------------------------------------</span>
<span class="co1">; DM_SPRITES (2 bytes)  Direccion de la tabla de tiles.</span>
<span class="co1">; DM_ATTRIBS (2 bytes)  Direccion de la tabla de atributos.</span>
<span class="co1">; DM_MAP     (2 bytes)  Direccion de la pantalla en memoria.</span>
<span class="co1">; DM_COORD_X (1 byte)   Coordenada X-Inicial en baja resolucion.</span>
<span class="co1">; DM_COORD_Y (1 byte)   Coordenada Y-Inicial en baja resolucion.</span>
<span class="co1">; DM_WIDTH   (1 byte)   Ancho del mapa en tiles</span>
<span class="co1">; DM_HEIGHT  (1 byte)   Alto del mapa en tiles</span>
<span class="co1">;---------------------------------------------------------------</span>
DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>:
&nbsp;
   <span class="co1">;;;;;; Impresion de la parte grafica de los tiles ;;;;;;</span>
   <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>           <span class="co1">; IX apunta al mapa </span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>                   <span class="co1">; B = ALTO_EN_TILES (para bucle altura)</span>
&nbsp;
drawm<span class="re1">1</span><span class="nu0">6</span>_yloop:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Guardamos el valor de B</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>         <span class="co1">; A = ALTO_EN_TILES</span>
   <span class="kw1">SUB</span> <span class="kw2">B</span>                     <span class="co1">; A = ALTO - iteracion_bucle = Y actual</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = Y * 2</span>
&nbsp;
   <span class="co1">;;; Calculamos la direccion destino en pantalla como</span>
   <span class="co1">;;; DIR_PANT = DIRECCION(X_INICIAL, Y_INICIAL + Y*2)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>       <span class="co1">; B = DB_COORD_Y y C = DB_COORD_X</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                   <span class="co1">; HL = DIR_PANTALLA(X_INICIAL,Y_INICIAL+Y*2)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DM_WIDTH<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>                   <span class="co1">; B = ANCHO_EN_TILES</span>
&nbsp;
drawm<span class="re1">1</span><span class="nu0">6</span>_xloop:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Nos guardamos el contador del bucle</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; Leemos un byte del mapa   </span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>                    <span class="co1">; Apuntamos al siguiente byte del mapa</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">255</span>                    <span class="co1">; Bloque especial a saltar: no se dibuja</span>
   <span class="kw1">JP</span> Z, drawm<span class="re1">1</span><span class="nu0">6</span>_next
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                ; Nos guardamos una copia del bloque en A'</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*32)</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                 <span class="co1">; Intercambiamos DE y HL (DE=destino)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="re1">0</span>
   <span class="kw1">SRL</span> <span class="kw2">A</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = BC + HL = DS_SPRITES + (DS_NUMSPR * 32)</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                 <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                   <span class="co1">; Guardamos el puntero a pantalla recien calculado</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
&nbsp;
   <span class="co1">;;; Impresion de los primeros 2 bloques horizontales del tile</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
drawm<span class="re1">1</span><span class="nu0">6</span>_loop<span class="re1">1</span>:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; Incrementar puntero en pantalla</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Bloque 2: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>                     <span class="co1">; Hay que sumar 256 para ir al siguiente scanline</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>                     <span class="co1">; pero hay que restar el INC L que hicimos.</span>
   <span class="kw1">DJNZ</span> drawm<span class="re1">1</span><span class="nu0">6</span>_loop<span class="re1">1</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; Decrementar el ultimo incrementado en el bucle</span>
&nbsp;
   <span class="co1">; Avanzamos HL 1 scanline (codigo de incremento de HL en 1 scanline)</span>
   <span class="co1">; desde el septimo scanline de la fila Y+1 al primero de la Y+2</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">3</span><span class="re1">1</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, drawm<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
drawm<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop:
&nbsp;
   <span class="co1">;;; Impresion de los segundos 2 bloques horizontales:</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
drawm<span class="re1">1</span><span class="nu0">6</span>_loop2:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; Incrementar puntero en pantalla</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Bloque 2: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>                     <span class="co1">; Hay que sumar 256 para ir al siguiente scanline</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>                     <span class="co1">; pero hay que restar el INC L que hicimos.</span>
   <span class="kw1">DJNZ</span> drawm<span class="re1">1</span><span class="nu0">6</span>_loop2
&nbsp;
&nbsp;
   <span class="co1">;;; En este punto, los 16 scanlines del tile estan dibujados.</span>
&nbsp;
   <span class="co1">;;;;;; Impresion de la parte de atributos del tile ;;;;;;</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperar puntero a inicio de tile</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                   <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">L</span>                   <span class="co1">; DE tiene el offset del attr de HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                ; Recuperamos el bloque del mapa desde A'</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = HL+HL=(DS_NUMSPR*4) = Origen de atributo</span>
&nbsp;
   <span class="kw1">LDI</span>
   <span class="kw1">LDI</span>                       <span class="co1">; Imprimimos la primeras fila de atributos</span>
&nbsp;
   <span class="co1">;;; Avance diferencial a la siguiente linea de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>                   <span class="co1">; A = E</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">3</span><span class="re1">0</span>                 <span class="co1">; Sumamos A = A + 30 mas los 2 INCs de LDI.</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>                   <span class="co1">; Guardamos en E (E = E+30 + 2 por LDI=E+32)</span>
   <span class="kw1">JR</span> NC, drawm<span class="re1">1</span><span class="nu0">6</span>_att_noinc
   <span class="kw1">INC</span> <span class="kw2">D</span>
drawm<span class="re1">1</span><span class="nu0">6</span>_att_noinc:
   <span class="kw1">LDI</span>
   <span class="kw1">LDI</span>                       <span class="co1">; Imprimimos la segunda fila de atributos</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperamos el puntero al inicio</span>
&nbsp;
drawm<span class="re1">1</span><span class="nu0">6</span>_next:
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; Avanzamos al siguiente tile en pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; horizontalmente</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">BC</span>                    <span class="co1">; Recuperamos el contador para el bucle</span>
   <span class="kw1">DEC</span> <span class="kw2">B</span>                     <span class="co1">; DJNZ se sale de rango, hay que usar DEC+JP</span>
   <span class="kw1">JP</span> NZ, drawm<span class="re1">1</span><span class="nu0">6</span>_xloop
&nbsp;
   <span class="co1">;;; En este punto, hemos dibujado ANCHO tiles en pantalla (1 fila)</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">DEC</span> <span class="kw2">B</span>                     <span class="co1">; Bucle vertical</span>
   <span class="kw1">JP</span> NZ, drawm<span class="re1">1</span><span class="nu0">6</span>_yloop
&nbsp;
   <span class="kw1">RET</span></pre>

<p>
 Nótese que hemos integrado las rutinas de impresión de sprites 16×16
con sus correspondientes cálculos dentro del cuerpo de nuestra rutina de
 “mapeado”.
</p>

<p>
 Por motivos de espacio (gran extensión de la rutina), la impresión de
los 4 bloques gráficos se realiza en dos bucles aunque la versión
definitiva de nuestro programa debería desenrollarlos con los siguientes
 cambios:
</p>

<p>
<br>

1.- Eliminar el <strong>INC L</strong> tras el <strong>DJNZ drawm16_loop1</strong>.
</p>

<p>
2.- Eliminar los <strong>INC DE</strong>, <strong>INC H</strong> y <strong>DEC L</strong> antes del <strong>DJNZ drawm16_loop2</strong>.
<br>

</p>

<p>
 Por supuesto, si se conocen de antemano otros parámetros fijos de la
rutina (ancho, alto, posición inicial, etc) podemos utilizar estos
valores directamente (como constantes o incluso anticipar el cálculo de
la dirección de pantalla inicial o usar una tabla de direcciones
iniciales de tile precalculadas) para acelerar la ejecución de la misma.
</p>

<p>
 No obstante, si estamos ante un juego de pantallas “fijas” y
“estáticas”, el tiempo de dibujado de la pantalla será prácticamente
inapreciable para el jugador, por lo que no suele ser necesario realizar
 optimizaciones extremas.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit7" id="ejemploimpresion-de-una-pantalla-16x16">Ejemplo: Impresión de una pantalla 16x16</h3>
<div class="level3">

<p>
 Juntemos en un mismo programa la rutina de impresión de pantallas de
mapa en 16×16, la pantalla del nivel 1 de Sokoban y su tileset, y el
siguiente código de test:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo impresion mapa de 16x16</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="kw1">CALL</span> ClearScreen_Pattern        <span class="co1">; Imprimimos patron de fondo</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_gfx
  <span class="kw1">LD</span> <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_attr
  <span class="kw1">LD</span> <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban_LEVEL<span class="re1">1</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAP<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_WIDTH<span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; ANCHO</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">2</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>, <span class="kw2">A</span>               <span class="co1">; ALTO</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; X = Y = 0</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; Establecemos valores llamada</span>
&nbsp;
  <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>              <span class="co1">; Imprimir pantalla de mapa</span>
&nbsp;
loop:
  <span class="kw1">JR</span> loop
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
ClearScreen_Pattern:              <span class="co1">; Rutina para incluir:</span>
   <span class="br0">(</span>...<span class="br0">)</span>                          <span class="co1">; Rellenado de fondo con un patron</span>
   <span class="kw1">RET</span>                            <span class="co1">; (del capitulo de Sprites Lowres)</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
DM_SPRITES  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">2</span><span class="re1">0</span>
DM_ATTRIBS  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">22</span>
DM_MAP      <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">24</span>
DM_COORD_X  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">26</span>
DM_COORD_Y  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">27</span>
DM_WIDTH    <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">28</span>
DM_HEIGHT   <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">29</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Level 1 from Sokoban:</span>
<span class="co1">;-----------------------------------------------------------------------</span>
sokoban_LEVEL<span class="re1">1</span>:
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">1</span>,<span class="nu0">4</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="re1">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">4</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">5</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">4</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="nu0">5</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">5</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>,<span class="nu0">255</span>
&nbsp;
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; ASM source file created by SevenuP v1.20 </span>
<span class="co1">; SevenuP (C) Copyright 2002-2006 by Jaime Tejedor Gomez, aka Metalbrain</span>
<span class="co1">; Pixel Size:      ( 16, 128) -   Char Size:       (  2,  16)</span>
<span class="co1">; Sort Priorities: X char, Char line, Y char</span>
<span class="co1">; Data Outputted:  Gfx / Attr</span>
<span class="co1">;-----------------------------------------------------------------------</span>
&nbsp;
sokoban<span class="re1">1</span>_gfx:
  DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
  DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
  DEFB <span class="re1">1</span><span class="nu0">27</span>,<span class="nu0">252</span>,<span class="re1">1</span><span class="nu0">93</span>, <span class="nu0">86</span>,<span class="re1">1</span><span class="nu0">52</span>,  <span class="nu0">2</span>,<span class="re1">1</span><span class="nu0">8</span><span class="re1">0</span>,<span class="re1">1</span><span class="nu0">7</span><span class="re1">0</span>, <span class="re1">1</span><span class="nu0">73</span>, <span class="nu0">86</span>,<span class="re1">1</span><span class="nu0">53</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">94</span>,<span class="re1">1</span><span class="nu0">7</span><span class="re1">0</span>,<span class="nu0">255</span>,<span class="nu0">254</span>
  DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,<span class="re1">10</span><span class="nu0">2</span>,<span class="re1">10</span><span class="nu0">2</span>, <span class="nu0">5</span><span class="re1">1</span>, <span class="nu0">5</span><span class="re1">0</span>,<span class="re1">1</span><span class="nu0">53</span>,<span class="re1">1</span><span class="nu0">52</span>, <span class="nu0">2</span><span class="re1">0</span><span class="nu0">4</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">4</span>,<span class="re1">10</span><span class="nu0">2</span>,<span class="re1">10</span><span class="nu0">2</span>, <span class="nu0">5</span><span class="re1">1</span>, <span class="nu0">5</span><span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
  DEFB <span class="re1">1</span><span class="nu0">27</span>,<span class="re1">10</span><span class="nu0">2</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>, <span class="nu0">76</span>,<span class="re1">1</span><span class="nu0">5</span><span class="re1">1</span>, <span class="nu0">24</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>, <span class="nu0">5</span><span class="re1">0</span>, <span class="re1">1</span><span class="nu0">5</span><span class="re1">1</span>,<span class="re1">10</span><span class="nu0">2</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>, <span class="nu0">76</span>,<span class="re1">1</span><span class="nu0">5</span><span class="re1">1</span>, <span class="nu0">24</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>, <span class="nu0">5</span><span class="re1">0</span>
  DEFB <span class="re1">1</span><span class="nu0">3</span><span class="re1">1</span>,<span class="re1">10</span><span class="nu0">2</span>,<span class="re1">1</span><span class="nu0">53</span>, <span class="nu0">76</span>,<span class="re1">1</span><span class="nu0">73</span>, <span class="nu0">24</span>,<span class="re1">1</span><span class="nu0">8</span><span class="re1">1</span>, <span class="nu0">5</span><span class="re1">0</span>, <span class="re1">1</span><span class="nu0">53</span>,<span class="re1">10</span><span class="nu0">2</span>,<span class="re1">1</span><span class="nu0">95</span>, <span class="nu0">76</span>,<span class="re1">1</span><span class="nu0">27</span>, <span class="nu0">24</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">252</span>,<span class="nu0">255</span>,<span class="re1">1</span><span class="nu0">34</span>,<span class="nu0">255</span>, <span class="nu0">5</span><span class="re1">0</span>,<span class="nu0">255</span>, <span class="nu0">9</span><span class="re1">0</span>, <span class="nu0">255</span>,<span class="re1">10</span><span class="nu0">6</span>,<span class="nu0">255</span>, <span class="nu0">5</span><span class="re1">0</span>,<span class="nu0">255</span>,<span class="re1">1</span><span class="nu0">34</span>,<span class="nu0">255</span>,<span class="nu0">254</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">254</span>,<span class="nu0">255</span>,<span class="nu0">254</span>,<span class="nu0">255</span>,<span class="nu0">254</span>,<span class="nu0">255</span>,<span class="nu0">25</span><span class="re1">0</span>, <span class="nu0">255</span>,<span class="nu0">242</span>,<span class="nu0">253</span>,<span class="re1">1</span><span class="nu0">66</span>,<span class="nu0">255</span>,<span class="nu0">252</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
  DEFB <span class="re1">1</span><span class="nu0">27</span>,<span class="nu0">252</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>,<span class="re1">1</span><span class="nu0">34</span>,<span class="re1">1</span><span class="nu0">5</span><span class="re1">1</span>, <span class="nu0">5</span><span class="re1">0</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>,<span class="re1">10</span><span class="nu0">6</span>, <span class="re1">1</span><span class="nu0">5</span><span class="re1">1</span>, <span class="nu0">9</span><span class="re1">0</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>, <span class="nu0">5</span><span class="re1">0</span>,<span class="re1">1</span><span class="nu0">5</span><span class="re1">1</span>,<span class="re1">1</span><span class="nu0">34</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">5</span>,<span class="nu0">254</span>
  DEFB <span class="re1">1</span><span class="nu0">95</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">53</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">73</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">8</span><span class="re1">1</span>,<span class="nu0">25</span><span class="re1">0</span>, <span class="re1">1</span><span class="nu0">53</span>,<span class="nu0">242</span>,<span class="re1">1</span><span class="nu0">95</span>,<span class="re1">1</span><span class="nu0">66</span>,<span class="re1">1</span><span class="nu0">27</span>,<span class="nu0">252</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">254</span>,<span class="nu0">255</span>,<span class="nu0">254</span>,<span class="nu0">255</span>,<span class="nu0">254</span>,<span class="nu0">255</span>,<span class="nu0">254</span>, <span class="nu0">255</span>,<span class="nu0">254</span>,<span class="nu0">255</span>,<span class="nu0">254</span>,<span class="re1">1</span><span class="nu0">9</span><span class="re1">1</span>,<span class="nu0">254</span>,<span class="nu0">255</span>,<span class="nu0">254</span>
  DEFB <span class="nu0">255</span>,<span class="re1">1</span><span class="nu0">34</span>,<span class="re1">1</span><span class="nu0">9</span><span class="re1">1</span>, <span class="nu0">5</span><span class="re1">0</span>,<span class="nu0">255</span>,<span class="re1">10</span><span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">9</span><span class="re1">1</span>, <span class="nu0">9</span><span class="re1">0</span>, <span class="re1">1</span><span class="nu0">59</span>, <span class="nu0">5</span><span class="re1">0</span>,<span class="nu0">2</span><span class="re1">0</span><span class="nu0">7</span>,<span class="re1">1</span><span class="nu0">34</span>,<span class="re1">1</span><span class="nu0">27</span>,<span class="nu0">252</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
  DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">27</span>,<span class="nu0">254</span>, <span class="nu0">95</span>,<span class="nu0">25</span><span class="re1">0</span>, <span class="nu0">96</span>,  <span class="nu0">6</span>, <span class="re1">111</span>,<span class="re1">1</span><span class="nu0">82</span>,<span class="re1">111</span>,<span class="re1">11</span><span class="nu0">8</span>, <span class="nu0">96</span>,<span class="nu0">23</span><span class="re1">0</span>,<span class="re1">10</span><span class="nu0">9</span>,<span class="nu0">2</span><span class="re1">1</span><span class="nu0">4</span>
  DEFB <span class="re1">10</span><span class="nu0">7</span>,<span class="re1">1</span><span class="nu0">82</span>,<span class="re1">10</span><span class="nu0">3</span>,  <span class="nu0">6</span>,<span class="re1">110</span>,<span class="nu0">246</span>,<span class="re1">10</span><span class="nu0">9</span>,<span class="nu0">246</span>,  <span class="nu0">96</span>,  <span class="nu0">6</span>, <span class="nu0">95</span>,<span class="nu0">25</span><span class="re1">0</span>,<span class="re1">1</span><span class="nu0">27</span>,<span class="nu0">254</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
  DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,<span class="re1">1</span><span class="nu0">23</span>,<span class="nu0">222</span>,<span class="re1">1</span><span class="nu0">23</span>,<span class="nu0">222</span>, <span class="nu0">96</span>,  <span class="nu0">6</span>,  <span class="nu0">96</span>,  <span class="nu0">6</span>,  <span class="re1">0</span>,  <span class="re1">0</span>, <span class="nu0">96</span>,  <span class="nu0">6</span>, <span class="nu0">96</span>,  <span class="nu0">6</span>
  DEFB  <span class="nu0">96</span>,  <span class="nu0">6</span>, <span class="nu0">96</span>,  <span class="nu0">6</span>,  <span class="re1">0</span>,  <span class="re1">0</span>, <span class="nu0">96</span>,  <span class="nu0">6</span>,  <span class="nu0">96</span>,  <span class="nu0">6</span>,<span class="re1">1</span><span class="nu0">23</span>,<span class="nu0">222</span>,<span class="re1">1</span><span class="nu0">23</span>,<span class="nu0">222</span>,  <span class="re1">0</span>,  <span class="re1">0</span>
&nbsp;
sokoban<span class="re1">1</span>_attr:
  DEFB   <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="nu0">5</span>,  <span class="nu0">5</span>, <span class="nu0">7</span><span class="re1">0</span>, <span class="nu0">7</span><span class="re1">0</span>, <span class="nu0">5</span>, <span class="nu0">7</span><span class="re1">0</span>,  <span class="nu0">5</span>, <span class="nu0">7</span><span class="re1">0</span>, <span class="nu0">69</span>, <span class="nu0">7</span><span class="re1">1</span>, <span class="nu0">69</span>, <span class="nu0">7</span><span class="re1">1</span>
  DEFB   <span class="nu0">5</span>, <span class="nu0">69</span>, <span class="nu0">69</span>, <span class="nu0">7</span><span class="re1">1</span>, <span class="nu0">69</span>, <span class="nu0">69</span>, <span class="nu0">7</span><span class="re1">1</span>, <span class="nu0">7</span><span class="re1">1</span>, <span class="nu0">2</span>, <span class="nu0">66</span>, <span class="nu0">66</span>, <span class="nu0">67</span>,  <span class="nu0">6</span>, <span class="nu0">7</span><span class="re1">0</span>, <span class="nu0">7</span><span class="re1">0</span>, <span class="nu0">7</span><span class="re1">1</span></pre>

<p>
 El resultado de la ejecución del anterior ejemplo es la siguiente pantalla:
</p>

<p>
<br>

<img src="img/gfx5_sokoban1.png" class="mediacenter" alt=" Programa de ejemplo impresion pantalla 16x16"/>
<br>

</p>

<p>
 Nótese que las pantallas de mapa no tienen por qué tener el tamaño
exacto de 256×192 de la pantalla de TV. Nuestra pantalla anterior ocupa
más memoria de la estrictamente necesaria, ya que gran parte de la
información alrededor del “área de juego real” son bloques
transparentes.
</p>

<p>
 La misma pantalla codificada con un tamaño de 7×9 e impresa a partir de
 las coordenadas de pantalla (8,3) ocuparía 63 bytes en lugar de 192 y
produciría el mismo resultado visual:
</p>
<pre class="code z80"><span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">; Level 1 from Sokoban (7x9):</span>
<span class="co1">;-----------------------------------------------------------------------</span>
sokoban_LEVEL<span class="re1">1</span>:
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,  <span class="nu0">2</span>,  <span class="nu0">3</span>,  <span class="nu0">4</span>,  <span class="re1">1</span>,<span class="nu0">255</span>
  DEFB   <span class="nu0">4</span>,  <span class="nu0">2</span>,  <span class="nu0">3</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="nu0">5</span>,  <span class="re1">1</span>
  DEFB   <span class="re1">1</span>,  <span class="re1">0</span>,  <span class="nu0">6</span>,  <span class="nu0">6</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="nu0">5</span>
  DEFB   <span class="nu0">5</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="nu0">6</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">1</span>
  DEFB   <span class="re1">1</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="nu0">5</span>
  DEFB   <span class="nu0">5</span>,  <span class="nu0">2</span>,  <span class="nu0">3</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="nu0">2</span>,  <span class="nu0">3</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,  <span class="nu0">4</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">0</span>,  <span class="re1">1</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,  <span class="re1">1</span>,  <span class="nu0">7</span>,  <span class="nu0">7</span>,  <span class="nu0">7</span>,  <span class="nu0">5</span>
  DEFB <span class="nu0">255</span>,<span class="nu0">255</span>,  <span class="nu0">5</span>,  <span class="nu0">2</span>,  <span class="nu0">3</span>,  <span class="nu0">2</span>,  <span class="nu0">3</span></pre>

<p>
 La pantalla de 7×9 se imprimiría así:
</p>
<pre class="code z80">  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_gfx
  <span class="kw1">LD</span> <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_attr
  <span class="kw1">LD</span> <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban_LEVEL<span class="re1">1</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAP<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">7</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_WIDTH<span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; ANCHO</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">9</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>, <span class="kw2">A</span>               <span class="co1">; ALTO</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">8</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; X_INICIAL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="nu0">3</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; Y_INICIAL</span>
  <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>              <span class="co1">; Imprimir pantalla de mapa</span></pre>

<p>
 Si tenemos pantallas de diferentes tamaños podemos almacenarlas en
memoria utilizando una estructura de datos con 4 bytes de información
por pantalla: ancho, alto, x_inicial e y_inicial. De esta forma cada
pantalla ocuparía en memoria sólo el espacio necesario para definirla,
sin necesidad de que todas las pantallas se adapten a un tamaño común.
Nuestra rutina de cambio de pantalla recogería estos 4 bytes de datos de
 la tabla de “tamaños y posiciones” para establecer los parámetros de
entrada a DrawMap_16x16 y dibujar la pantalla en su posición correcta.
</p>

<p>
 Esto puede valer para juegos como Sokoban (donde cada pantalla puede
tener un tamaño diferente) pero no para juegos tipo
plataformas/aventuras/arcade donde todas las pantallas tienen un tamaño
fijo. En ese caso basta con usar nuestra rutina con unos valores fijos
para todas ellas.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit8" id="rutina-para-bloques-de-8x8-con-mapeados-horizontales">Rutina para bloques de 8x8 con mapeados horizontales</h3>
<div class="level3">

<p>
 La rutina para tiles de 8×8 es fácilmente adaptable a partir de la
rutina de 16×16 modificando los bucles de impresión y los cálculos
(multiplicaciones y posicionamientos) para el nuevo tamaño de tile y
atributo:
</p>
<pre class="code z80"><span class="co1">;---------------------------------------------------------------</span>
<span class="co1">; DrawMap_8x8:</span>
<span class="co1">; Imprime una pantalla de tiles de 8x8 pixeles.</span>
<span class="co1">;---------------------------------------------------------------</span>
DrawMap_8x8:
&nbsp;
   <span class="co1">;;;;;; Impresion de la parte grafica de los tiles ;;;;;;</span>
   <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>           <span class="co1">; IX apunta al mapa </span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>                   <span class="co1">; B = ALTO_EN_TILES (para bucle altura)</span>
&nbsp;
drawm8_yloop:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Guardamos el valor de B</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>         <span class="co1">; A = ALTO_EN_TILES</span>
   <span class="kw1">SUB</span> <span class="kw2">B</span>                     <span class="co1">; A = ALTO - iteracion_bucle = Y actual</span>
                             <span class="co1">;;; NUEVO: Eliminamos RLCA (no multiplicar Y*2)</span>
&nbsp;
   <span class="co1">;;; Calculamos la direccion destino en pantalla como</span>
   <span class="co1">;;; DIR_PANT = DIRECCION(X_INICIAL, Y_INICIAL + Y)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>       <span class="co1">; B = DB_COORD_Y y C = DB_COORD_X</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                   <span class="co1">; HL = DIR_PANTALLA(X_INICIAL,Y_INICIAL+Y*2)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DM_WIDTH<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>                   <span class="co1">; B = ANCHO_EN_TILES</span>
&nbsp;
drawm8_xloop:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Nos guardamos el contador del bucle</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; Leemos un byte del mapa   </span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>                    <span class="co1">; Apuntamos al siguiente byte del mapa</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">255</span>                    <span class="co1">; Bloque especial a saltar: no se dibuja</span>
   <span class="kw1">JP</span> Z, drawm8_next
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                ; Nos guardamos una copia del bloque en A'</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*8)</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                 <span class="co1">; Intercambiamos DE y HL (DE=destino)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">HL</span>                <span class="co1">;;; NUEVO: NUM_SPRITE*8 en lugar de *32</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = BC + HL = DM_SPRITES + (DM_NUMSPR * 8)</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                 <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                   <span class="co1">; Guardamos el puntero a pantalla recien calculado</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
&nbsp;
   <span class="co1">;;; Impresion de los primeros 2 bloques horizontales del tile</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
&nbsp;
drawm8_loop:                 <span class="co1">;;; NUEVO: Bucle de impresion de 1 solo bloque</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>                     <span class="co1">; Hay que sumar 256 para ir al siguiente scanline</span>
   <span class="kw1">DJNZ</span> drawm8_loop
&nbsp;
   <span class="co1">;;; En este punto, los 8 scanlines del tile estan dibujados.</span>
&nbsp;
   <span class="co1">;;;;;; Impresion de la parte de atributos del tile ;;;;;;</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperar puntero a inicio de tile</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                   <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">L</span>                   <span class="co1">; DE tiene el offset del attr de HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                ; Recuperamos el bloque del mapa desde A'</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>                   <span class="co1">;;; NUEVO: HL = HL+DM_NUMSPR (NO *4)</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = HL+DM_NUMSPR = Origen de atributo</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">;;; NUEVO: Impresion de un unico atributo.</span>
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperamos el puntero al inicio</span>
&nbsp;
drawm8_next:
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; Avanzamos al siguiente tile en pantalla</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">BC</span>                    <span class="co1">; Recuperamos el contador para el bucle</span>
   <span class="kw1">DEC</span> <span class="kw2">B</span>                     <span class="co1">; DJNZ se sale de rango, hay que usar DEC+JP</span>
   <span class="kw1">JP</span> NZ, drawm8_xloop
&nbsp;
   <span class="co1">;;; En este punto, hemos dibujado ANCHO tiles en pantalla (1 fila)</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">DEC</span> <span class="kw2">B</span>                     <span class="co1">; Bucle vertical</span>
   <span class="kw1">JP</span> NZ, drawm8_yloop
&nbsp;
   <span class="kw1">RET</span></pre>

<p>
<br>

</p>

</div>

<h2 id="el-mapa-como-conjunto-de-pantallas">El mapa como conjunto de pantallas</h2>
<div class="level2">

<p>
 Ya conocemos la forma de diseñar e imprimir pantallas individuales de
mapeado, pero seguimos necesitando agrupar estas pantallas para componer
 un mapa de tamaño superior al del área de visión del jugador. En esta
sección veremos las estructuras de datos necesarias para definir el
mapeado total del juego así como la interconexión entre las diferentes
pantallas.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit10" id="estructura-de-datos-del-mapa">Estructura de datos del mapa</h3>
<div class="level3">

<p>
 Un mapa de tiles es la representación de un mapeado mediante la
utilización de tiles, donde el ancho y alto del mapa es mayor que el
tamaño de una pantalla individual.
</p>

<p>
 Las pantallas se interconectan formando un mapa. Esta conexión puede ser:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Estática: El jugador cambia de una
pantalla a otra al acabar el nivel, sin que las pantallas estén
“conectadas” realmente entre sí salvo por el número de nivel actual
(Ejemplo: Manic Miner, Sokoban, Bubble Bobble, Puzznic, Plotting…).
</li>
<li> Lineal en un sólo eje: Las pantallas
 se agrupan una a continuación de la otra con desarrollo del juego en
una dirección, ya sea izquierda-derecha (R-Type, Game Over, Target
Renegade…) o arriba-abajo (Flying Shark, Commando…).
</li>
<li> Lineal en dos ejes: Las pantallas se
 agrupan en forma de mapa bidimensional, permitiendo al jugador moverse
en el mapeado hacia arriba, abajo, izquierda o derecha (Sabre Wulf, Las
Tres Luces de Glaurung, Atic Atac, Sir Fred…).
</li>
</ul>

<p>
<br>

</p>

<p>
 La <em>pantalla</em> es una <em>ventana</em> dentro del mapeado, por lo
 que resulta necesario disponer de una estructura de datos que nos
permita representar los 3 modelos de mapa que acabamos de describir.
</p>

<p>
 Hay 2 posibilidades de agrupación de las pantallas: como un <strong>array de pantallas</strong>, o como una <strong>matriz global de mapeado</strong>.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit11" id="mapa-como-array-de-pantallas">Mapa como array de pantallas</h3>
<div class="level3">

<p>
 El mapa como array de pantallas consiste en la creación de un array con
 las direcciones de datos de cada pantalla de forma que podamos
direccionarlo con la variable Pantalla_Actual para obtener la dirección
donde están los datos a imprimir.
</p>

<p>
 Para hacer uso de este sistema debemos almacenar cada pantalla en
memoria con una etiqueta identificativa para nuestro programa
ensamblador:
</p>
<pre class="code z80">Pantalla_Inicio:
  DB <span class="re1">0</span>, <span class="re1">0</span>, <span class="re1">0</span>, <span class="nu0">3</span>, <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
Pantalla_Salon:
  DB <span class="re1">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
Pantalla_Pasillo:
  DB <span class="nu0">2</span>, <span class="nu0">2</span>, <span class="nu0">2</span>, <span class="nu0">2</span>, <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
Pantalla_Escalera:
  DB <span class="nu0">4</span>, <span class="nu0">4</span>, <span class="nu0">5</span>, <span class="re1">1</span>, <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
<span class="br0">(</span>...<span class="br0">)</span></pre>

<p>
 A continuación, definimos una tabla “Mapa” que contenga las direcciones de inicio de los datos de cada pantalla:
</p>
<pre class="code z80">Mapa:
  DW Pantalla_Inicio         <span class="co1">; Pantalla 0</span>
  DW Pantalla_Salon          <span class="co1">; Pantalla 1</span>
  DW Pantalla_Pasillo        <span class="co1">; Pantalla 2</span>
  DW Pantalla_Escalera       <span class="co1">; Pantalla 3</span>
  <span class="br0">(</span>...<span class="br0">)</span>                      <span class="co1">; (etc...)</span>
  DW <span class="re1">0000</span>                    <span class="co1">; Fin de pantalla</span></pre>

<p>
 Nuestro juego almacenará el identificador de la pantalla actual en una
variable de programa (por ejemplo, ID_PANTALLA). De esta forma podemos
acceder a los datos de cada pantalla utilizando ID_PANTALLA como índice
en esta tabla:
</p>
<pre class="code">DIR_DATOS_PANTALLA = Mapa[ ID_PANTALLA ]</pre>

<p>
 O lo que es lo mismo, desplazándonos 2 bytes desde el inicio de nuestro
 mapa (ya que cada dirección ocupa 2 bytes) y leyendo el contenido de la
 dirección resultante:
</p>
<pre class="code">DIR_DATOS_PANTALLA = [ Mapa + (ID_PANTALLA * 2) ]</pre>

<p>
 Traducido a código, para obtener la dirección donde se aloja la
pantalla actual de juego, asumiendo que su identificador 0-N estuviera
en la variable de memoria de 8 bits <em>pantalla_actual</em>:
</p>
<pre class="code z80">  <span class="co1">;;; Calculamos la posicion de "pantalla_actual" en al tabla</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, Mapa                     <span class="co1">; BC = Inicio de la tabla Mapa</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>pantalla_actual<span class="br0">)</span>         <span class="co1">; A = Pantalla actual</span>
  <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>                         <span class="co1">; HL = Pantalla actual</span>
  <span class="kw1">SLA</span> <span class="kw2">L</span>
  <span class="kw1">RL</span>  <span class="kw2">H</span>                           <span class="co1">; HL = Pantalla actual * 2</span>
  <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                      <span class="co1">; HL = Mapa + (Pantalla actual * 2)</span>
&nbsp;
  <span class="co1">;;; Ahora leemos de (HL) la dirección de dibujado en el mismo HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                      <span class="co1">; Leemos la parte baja de la direccion en A</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>                          <span class="co1">; ... para no corromper HL y poder leer ...</span>
  <span class="kw1">PUSH</span> <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                      <span class="co1">; ... la parte alta sobre H ...</span>
  <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAP<span class="br0">)</span>, <span class="kw2">HL</span>                 <span class="co1">; Almacenamos el mapa a imprimir</span>
  <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>              <span class="co1">; Imprimimos el mapa</span></pre>

<p>
 Para un juego de pantallas no conectadas (tipo Manic Miner o Sokoban),
el movimiento de una pantalla a otra se basaría en incrementar el valor
de ID_PANTALLA cada vez que el jugador progrese un nivel en el juego, o
poner ID_PANTALLA = 0 cuando se finalice el juego o se inicie una nueva
partida.
</p>

<p>
 En juegos con desplazamiento en una única dirección (R-Type, Flying
Shark, Game Over…), el desplazamiento a la pantalla anterior o siguiente
 se realizará decrementando ID_PANTALLA si ID_PANTALLA no es cero
(límite izquierdo/inferior), o incrementando ID_PANTALLA si el valor
Mapa[ID_PANTALLA] es menor que el número máximo de pantallas (límite
derecho/superior).
</p>

<p>
 Para juegos con mapeados bidimensionales que requieran especificar una
conexión concreta entre pantallas, podemos agregar a nuestro vector de
mapeado bytes adicionales que indiquen los identificadores de las
pantallas a las que deberíamos movernos si vamos en una determinada
dirección.
</p>

<p>
 Por ejemplo, en un hipotético juego que se desarrolle en una sóla
dirección (ej: izquierda-derecha) necesitaremos almacenar los IDs de las
 pantallas que tenemos a izquierda y a derecha de la pantalla actual:
</p>
<pre class="code z80"><span class="co1">;;; Vector de direcciones de pantalla.</span>
<span class="co1">;;; Contiene la direccion de cada pantalla en orden de ID,</span>
<span class="co1">;;; seguido de los IDs de las pantallas de su izquierda y</span>
<span class="co1">;;; su derecha. Se utiliza -1 para definir que no hay</span>
<span class="co1">;;; conexion con otras pantallas:</span>
<span class="co1">;;;</span>
<span class="co1">;;; Formato de cada pantalla + conexiones: </span>
<span class="co1">;;;</span>
<span class="co1">;;;  DW DIR_DATOSPANTALLA</span>
<span class="co1">;;;  DB ID_IZQUIERDA, ID_DERECHA</span>
&nbsp;
Mapa:
  DW Pantalla_Inicio            <span class="co1">; ID = 0</span>
  DB <span class="sy0">-</span><span class="re1">1</span>, <span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 0</span>
  DW Pantalla_Salon             <span class="co1">; ID = 1 </span>
  DB <span class="re1">0</span>, <span class="nu0">2</span>                       <span class="co1">; Conexiones izq y derecha ID 1</span>
  DW Pantalla_Pasillo           <span class="co1">; ID = 2</span>
  DB <span class="re1">1</span>, <span class="nu0">3</span>                       <span class="co1">; Conexiones izq y derecha ID 2</span>
  DW Pantalla_Escalera          <span class="co1">; ID = 3</span>
  DB <span class="nu0">3</span>, <span class="sy0">-</span><span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 3</span>
  <span class="br0">(</span>...<span class="br0">)</span></pre>

<p>
 Para acceder ahora a los datos de una pantalla debemos desplazarnos 2
bytes por la dirección y 2 bytes por los 2 identificadores, es decir, un
 total de 4 bytes:
</p>
<pre class="code">DIR_DATOS_PANTALLA    = [ Mapa + (ID_PANTALLA * 4) ]
ID_PANTALLA_IZQUIERDA = [ Mapa + (ID_PANTALLA * 4) + 2 ]
ID_PANTALLA_DERECHA   = [ Mapa + (ID_PANTALLA * 4) + 3 ]</pre>

<p>
 Traducido a código, basta con multiplicar ID_PANTALLA por 2, 4 ó 6
(según la cantidad de IDs de conexión que tengamos definidos en el
mapa), apuntar HL, DE o IX a “Mapa”, sumarle el valor de la
multiplicación y leer los 6 bytes consecutivos incrementando este
puntero.
</p>
<pre class="code z80">BYTES_POR_PANTALLA     <span class="kw3">EQU</span>   <span class="nu0">4</span>
RUTINA_ROM_HL_POR_DE   <span class="kw3">EQU</span>   <span class="sy0">$</span>3<span class="re1">0</span>A9
&nbsp;
<span class="co1">;------------------------------------------------------------</span>
<span class="co1">; Obtener direccion donde se alojan los datos de la pantalla</span>
<span class="co1">; Entrada: </span>
<span class="co1">;    L = pantalla</span>
<span class="co1">;   BC = Mapa (direccion base)</span>
<span class="co1">; Salida:</span>
<span class="co1">;   HL = Direccion de datos de la pantalla</span>
<span class="co1">;------------------------------------------------------------</span>
Get_Screen_Pointer:
  <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="re1">0</span>
  <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">H</span>                         <span class="co1">; HL = PANTALLA</span>
  <span class="kw1">LD</span> <span class="kw2">E</span>, BYTES_POR_PANTALLA        <span class="co1">; DE = BYTES POR PANTALLA</span>
  <span class="kw1">CALL</span> RUTINA_ROM_HL_POR_DE       <span class="co1">; HL = HL * DE</span>
  <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                      <span class="co1">; Lo sumamos al inicio del MAPA</span>
  <span class="kw1">RET</span>                             <span class="co1">; HL = MAPA + (PANTALLA*BYTES)</span></pre>

<p>
 Para realizar la multiplicación hemos utilizado la rutina HL=HL*DE de
la ROM del Spectrum. Si no estamos en un Spectrum sino que estamos
programando para otro sistema Z80, bastará con llamar a la rutina de
multiplicación adecuada.
</p>

<p>
 Podríamos haber realizado la multiplicación por 4 mediante
desplazamientos, pero utilizando una rutina de multiplicación nos
aseguramos que Get_Screen_Pointer pueda ser utilizado para mapas que
definan más conexiones.
</p>

<p>
 Ahora ya podemos acceder a los datos de una pantalla concreta:
</p>
<pre class="code z80">  <span class="co1">;;; En el inicio del programa...</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_gfx
  <span class="kw1">LD</span> <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_attr
  <span class="kw1">LD</span> <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_WIDTH<span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; ANCHO</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">2</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>, <span class="kw2">A</span>               <span class="co1">; ALTO</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; X = Y = 0</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>              <span class="co1">; Establecemos valores llamada</span>
&nbsp;
  <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
  <span class="co1">;;; En el bucle principal de nuestro programa:</span>
DibujarPantalla:
  <span class="kw1">LD</span> <span class="kw2">BC</span>, Mapa
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>pantalla_actual<span class="br0">)</span>
  <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
  <span class="kw1">CALL</span> Get_Screen_Pointer         <span class="co1">; HL = Datos de la pantalla</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                      <span class="co1">; Leemos la parte baja de la direccion en A</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>                          <span class="co1">; ... para no corromper HL y poder leer ...</span>
  <span class="kw1">PUSH</span> <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                      <span class="co1">; ... la parte alta sobre H ...</span>
  <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAP<span class="br0">)</span>, <span class="kw2">HL</span>                 <span class="co1">; Almacenamos el mapa a imprimir</span>
  <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>              <span class="co1">; Imprimimos el mapa</span>
&nbsp;
  <span class="kw1">POP</span> <span class="kw2">HL</span>                          <span class="co1">; Recuperamos el puntero a datos de pantalla</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>                          <span class="co1">; Avanzamos hasta el primer ID de conexion</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                      <span class="co1">; Leemos conexion izquierda</span>
  <span class="kw1">LD</span> <span class="br0">(</span>con_izquierda<span class="br0">)</span>, <span class="kw2">A</span>           <span class="co1">; la almacenamos</span>
  <span class="kw1">INC</span> <span class="kw2">HL</span>                          <span class="co1">; Avanzamos hasta el segundo ID de conexion</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                      <span class="co1">; Leemos conexion a derecha</span>
  <span class="kw1">LD</span> <span class="br0">(</span>con_derecha<span class="br0">)</span>, <span class="kw2">A</span>             <span class="co1">; la almacenamos</span></pre>

<p>
 Con los datos en las variables <em>con_izquierda</em> y <em>con_derecha</em> podemos movernos a una de las 2 pantallas cambiando el valor de <em>pantalla_actual</em> al de la pantalla correspondiente.
</p>

<p>
 Nótese que la “costosa” multiplicación genérica se puede sustituir por
desplazamientos (*2, *4…) si separamos la tabla de pantallas en una
tabla de direcciones y otra de conexiones:
</p>
<pre class="code z80">Mapa:
  DW Pantalla_Inicio            <span class="co1">; ID = 0</span>
  DW Pantalla_Salon             <span class="co1">; ID = 1 </span>
  DW Pantalla_Pasillo           <span class="co1">; ID = 2</span>
  DW Pantalla_Escalera          <span class="co1">; ID = 3</span>
  <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
Conexiones:
  DB <span class="sy0">-</span><span class="re1">1</span>, <span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 0</span>
  DB <span class="re1">0</span>, <span class="nu0">2</span>                       <span class="co1">; Conexiones izq y derecha ID 1</span>
  DB <span class="re1">1</span>, <span class="nu0">3</span>                       <span class="co1">; Conexiones izq y derecha ID 2</span>
  DB <span class="nu0">3</span>, <span class="sy0">-</span><span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 3</span>
  <span class="br0">(</span>...<span class="br0">)</span></pre>

<p>
 De esta forma podemos calcular las posiciones de los datos que
necesitamos con simples operaciones de desplazamiento. No obstante,
tener los datos de las pantallas separados en 2 o más tablas es más
“complicado” de mantener manualmente a menos que estemos generado estas
estructuras de mapa con algún programa propio de diseño y exportación de
 mapeados que nos permita su exportación a este formado. Teniendo los
datos por separado es más “complicado” (o, al menos, no tan intuitivo)
hacer cambios manuales en el código.
</p>

<p>
 Si estuvieramos hablando de un juego con “scroll” de pantallas en las 4
 direcciones, bastaría con definir 4 identificadores de conexión tras
cada dirección de pantalla, y obtener los datos de cada pantalla
saltando 2+1+1+1+1 = 6 bytes por cada pantalla:
</p>
<pre class="code">DIR_DATOS_PANTALLA    = [ Mapa + (ID_PANTALLA * 6) ]
ID_PANTALLA_IZQUIERDA = [ Mapa + (ID_PANTALLA * 4) + 2 ]
ID_PANTALLA_DERECHA   = [ Mapa + (ID_PANTALLA * 4) + 3 ]
ID_PANTALLA_ARRIBA    = [ Mapa + (ID_PANTALLA * 4) + 4 ]
ID_PANTALLA_ABAJO     = [ Mapa + (ID_PANTALLA * 4) + 5 ]</pre>

<p>
 (O, en caso de usar tablas separadas, se realizaría un desplazamiento a
 la izquierda para multiplicar por 2 en la tabla de direcciones, y 2
desplazamientos para multiplicar por 4 en la de conexiones, como ya
hemos visto en un ejemplo anterior).
</p>

<p>
 El movimiento por el mapa se basaría en establecer ID_PANTALLA a
cualquiera de los cuatro valores siempre que estos sean distintos de 255
 (-1).
</p>

<p>
 Nótese que estamos asumiendo que no hay más de 254 pantallas. En caso
de requerir un mayor número de pantallas, el identificador de tile
deberá ser de 16 bits por lo que la definición de los identificadores de
 conexión sería de tipo DW en lugar de DB y cambiarían los valores de
las multiplicaciones:
</p>
<pre class="code z80">Mapa:
  DW Pantalla_Inicio            <span class="co1">; ID = 0</span>
  DW <span class="sy0">-</span><span class="re1">1</span>, <span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 0</span></pre>

<p>
 Multiplicamos por 6 ya que ahora cada pantalla ocupa 6 bytes (2 de la dirección y 4 de los identificadores de conexión).
</p>

<p>
 Si necesitaramos definir más datos de la pantalla (como por ejemplo, el
 “título” de la misma, al estilo Manic Miner), podríamos añadir a
nuestra estructura 2 bytes con la dirección en memoria de una cadena de
texto (una dirección para cada pantalla individual del mapa.) Esto
implicaría modificar la cantidad de bytes por los que se multiplica para
 obtener la dirección que contiene los datos de una pantalla concreta:
</p>
<pre class="code z80"><span class="co1">;;; Vector de direcciones de pantalla.</span>
Mapa:
  DW Pantalla_Inicio            <span class="co1">; ID = 0</span>
  DB <span class="sy0">-</span><span class="re1">1</span>, <span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 0</span>
  DW titulo_inicio              <span class="co1">; Direccion de la cadena de titulo</span>
  DW Pantalla_Salon             <span class="co1">; ID = 1 </span>
  DB <span class="re1">0</span>, <span class="nu0">2</span>                       <span class="co1">; Conexiones izq y derecha ID 1</span>
  DW titulo_salon               <span class="co1">; Direccion de la cadena de titulo</span>
  DW Pantalla_Pasillo           <span class="co1">; ID = 2</span>
  DB <span class="re1">1</span>, <span class="nu0">3</span>                       <span class="co1">; Conexiones izq y derecha ID 2</span>
  DW titulo_pasillo
  DW Pantalla_Escalera          <span class="co1">; ID = 3</span>
  DW titulo_escalera
  DB <span class="nu0">3</span>, <span class="sy0">-</span><span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 3</span>
  <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
titulo_inicio   DB <span class="st0">"La pantalla de inicio"</span>, <span class="re1">0</span>
titulo_salon    DB <span class="st0">"El salon"</span>, <span class="re1">0</span>
titulo_pasillo  DB <span class="st0">"El pasillo"</span>, <span class="re1">0</span>
titulo_escalera DB <span class="st0">"La escalera"</span>, <span class="re1">0</span></pre>

<p>
 Con estos 2 bytes adicionales de nombre por cada pantalla a los 4 que
ya se utilizaban, el anterior ejemplo requeriría el siguiente cálculo
para acceder a los datos de una pantalla concreta:
</p>
<pre class="code">DIR_DATOS_PANTALLA    = [ Mapa + (ID_PANTALLA * 6) ]
ID_PANTALLA_IZQUIERDA = [ Mapa + (ID_PANTALLA * 6) + 2 ]
ID_PANTALLA_DERECHA   = [ Mapa + (ID_PANTALLA * 6) + 3 ]
TITULO_PANTALLA       = [ Mapa + (ID_PANTALLA * 6) + 4 ]</pre>

<p>
 De nuevo, como vimos antes, es posible mantener los datos las pantallas
 en diferentes tablas (tabla de direccion de datos, tabla de conexiones,
 tabla de títulos) para facilitar el acceso a los mismos vía operaciones
 de desplazamiento, aunque si la obtención de estos datos no es
prioritaria, el poder acceder a ellos mediante una única operación y un
único puntero puede acabar resultando más rápido (o simplemente, cómodo)
 que en múltiples tablas.
</p>

<p>
<br>

<br>

<strong>Repetición de pantallas</strong>
<br>

<br>

</p>

<p>
 Gracias a nuestro mapa definido como “vector” de pantallas podemos
repetir pantallas en nuestro mapeado sin duplicar los datos gráficos.
</p>

<p>
 Por ejemplo, si en nuestro hipotético juego de desarrollo lineal
izquierda-derecha tenemos 3 pasillos iguales, podemos duplicar las
entradas de pantalla con diferentes identificadores de conexión:
</p>
<pre class="code z80">Mapa:
  DW Pantalla_Inicio            <span class="co1">; ID = 0</span>
  DB <span class="sy0">-</span><span class="re1">1</span>, <span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 0</span>
  DW Pantalla_Salon             <span class="co1">; ID = 1 </span>
  DB <span class="re1">0</span>, <span class="nu0">2</span>                       <span class="co1">; Conexiones izq y derecha ID 1</span>
  DW Pantalla_Pasillo           <span class="co1">; ID = 2</span>
  DB <span class="re1">1</span>, <span class="nu0">3</span>                       <span class="co1">; Conexiones izq y derecha ID 2</span>
  DW Pantalla_Pasillo           <span class="co1">; ID = 3</span>
  DB <span class="nu0">2</span>, <span class="nu0">4</span>                       <span class="co1">; Conexiones izq y derecha ID 3</span>
  DW Pantalla_Pasillo           <span class="co1">; ID = 4</span>
  DB <span class="nu0">3</span>, <span class="nu0">5</span>                       <span class="co1">; Conexiones izq y derecha ID 4</span>
  DW Pantalla_Escalera          <span class="co1">; ID = 5</span>
  DB <span class="nu0">4</span>, <span class="sy0">-</span><span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 5</span>
  <span class="br0">(</span>...<span class="br0">)</span></pre>

<p>
 De esta forma hemos definido 3 pantallas de nuestro juego mediante un
mismo bloque de datos de tiles. Hemos creado 3 “pasillos” consecutivos, y
 nada nos impide volver a utilizar este mismo bloque en otros áreas del
mapeado que también tengan pasillos.
</p>

<p>
 Con este tipo de trucos podemos exprimir la escasa memoria de nuestro Spectrum y crear mapeados de gran tamaño.
</p>

<p>
<br>

<br>

<strong>Transiciones entre 2 pantallas de mapa</strong>
<br>

<br>

</p>

<p>
 Cuando el jugador pasa de una pantalla a otra debemos realizar el
borrado de la pantalla en curso y la impresión de la nueva. Para
realizar esto tenemos diferentes opciones:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li> Transición abrupta: Simplemente
realizamos un borrado del área de pantalla donde se dibuja el mapa y
trazamos sobre ese área los datos de la siguiente pantalla. Es el método
 más común (y el más rápido), utilizado en la mayoría de juegos.
</li>
<li> Fundido de pantalla: Realizamos un
fundido de la pantalla actual a negro, dibujamos la nueva pantalla con
atributos a negro, y realizamos un fundido desde negro a los nuevos
atributos.
</li>
<li> Scroll de pantallas: Realizamos un
scroll entre la pantalla que sale y la que entra. Consiste en realizar
una “salida” de la pantalla actual en la dirección contraria de los
límites cruzados por el personaje (por ejemplo: si éste sale por la
derecha, scrolleamos la pantalla actual hacia la izquierda), de forma
que para cada línea de la pantalla saliente aparezca por la derecha una
línea del mapa entrante (la nueva pantalla actual). Este scroll, que
debe de ser rápido para no ralentizar el cambio de pantallas en el
juego, requiere la realización de 4 rutinas específicas que realicen
scroll de una porción de la pantalla y que permitan dibujar N filas o N
columnas de la nueva pantalla entrante a partir de una posición (x,y)
dada.
</li>
</ul>

<p>
<br>

</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit12" id="el-mapa-como-array-global-de-mapeado">El mapa como array global de mapeado</h3>
<div class="level3">

<p>
 Existe una alternativa a la definir cada pantalla de juego por
separado, y es la de disponer de una matriz global que comprenda todo el
 mapeado. Esta matriz contiene todos los datos de las pantallas del
mapa, linealmente:
</p>
<pre class="code z80"><span class="co1">;;; Sea un juego de 8x8 bloques por pantalla</span>
<span class="co1">;;; formado por un mapa de 2x2 pantallas.</span>
<span class="co1">;;;</span>
<span class="co1">;;; Sean "A" los datos de la primera pantalla.</span>
<span class="co1">;;; Sean "B" los datos de la segunda pantalla.</span>
<span class="co1">;;; Sean "C" los datos de la tercera pantalla.</span>
<span class="co1">;;; Sean "D" los datos de la tercera pantalla.</span>
&nbsp;
Mapa
 DB <span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>
 DB <span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>
 DB <span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>
 DB <span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>
 DB <span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>
 DB <span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>
 DB <span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>
 DB <span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">A</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>,<span class="kw2">B</span>
 DB <span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>
 DB <span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>
 DB <span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>
 DB <span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>
 DB <span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>
 DB <span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>
 DB <span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>
 DB <span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">C</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span>,<span class="kw2">D</span></pre>

<p>
 Nosotros sólo vemos un área de 8×8 bloques del anterior mapeado, que
inicialmente podría ser, por ejemplo, la que comprende todos los bloques
 “A”. Se utiliza un puntero 2D “xmapa,ymapa” o uno lineal (mapa_pos)
para conocer la posición de la “ventana de visión” de 8×8 bloques (en
nuestro ejemplo) dentro del mapa.
</p>

<p>
 Podemos “movernos” en el mapa simplemente modificando las coordenadas
del puntero de la ventana de visión y redibujando en pantalla el área de
 8×8 bloques que comienza en dicho puntero.
</p>

<p>
 Por ejemplo, supongamos que la posición inicial del área de visión es
(0,0), con lo que la primera pantalla impresa serán los 8×8 bloques “A”
del ejemplo. Para avanzar hacia la derecha basta con incrementar el
puntero “xmapa” con lo que la siguiente impresión de la pantalla
mostrará 7 columnas “A” y una columna “B” en el extremo derecho de la
pantalla.
</p>

<p>
 La impresión de este tipo de pantallas requiere una rutina similar a
las rutinas de impresión sin agrupación que ya hemos visto
(DrawMap_16x16), pero modificada en los siguientes términos:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> Cambio 1: Debe de calcular la posición inicial de lectura de datos para la impresión como <strong>Mapa + (ymapa*ANCHO_MAPA) + xmapa</strong>.</div>
</li>
<li><div class="li"> Cambio 2: Una vez impreso un
scanline horizontal de ANCHO_PANTALLA datos, debe de avanzar el registro
 usado como puntero de datos en el mapa un total de <strong>ANCHO_MAPA-ANCHO_PANTALLA</strong> bytes (para posicionarse en el siguiente scanline de datos del mapa).</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 La rutina de impresión de este tipo de mapas tiene el primero de los cambios descritos al principio de la misma:
</p>
<pre class="code z80">DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Map:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>           <span class="co1">; IX apunta al mapa </span>
&nbsp;
   <span class="co1">;;; NUEVO: Posicionamos el puntero de mapa en posicion inicial.</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_MAPY<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, ANCHO_MAPA_TILES
   <span class="kw1">CALL</span> MULT_HL_POR_DE       <span class="co1">; HL = (ANCHO_MAPA * MAPA_Y)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_MAPX<span class="br0">)</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = MAPA_X + (ANCHO_MAPA * MAPA_Y)</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">IX</span>, <span class="kw2">DE</span>                <span class="co1">; IX = Inicio_Mapa + HL</span>
   <span class="co1">;;; FIN NUEVO</span></pre>

<p>
 El segundo de los cambios está localizado al final de la rutina, al final de cada iteración de scanline horizontal:
</p>
<pre class="code z80">   <span class="co1">;;; NUEVO: Incrementar puntero de mapa a siguiente linea</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, ANCHO_MAPA_TILES <span class="sy0">-</span> ANCHO_PANTALLA
   <span class="kw1">ADD</span> <span class="kw2">IX</span>, <span class="kw2">BC</span>
   <span class="co1">;;; FIN NUEVO</span>
&nbsp;
   <span class="co1">;;; En este punto, hemos dibujado ANCHO tiles en pantalla (1 fila)</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">DEC</span> <span class="kw2">B</span>                     <span class="co1">; Bucle vertical</span>
   <span class="kw1">JP</span> NZ, drawmg<span class="re1">1</span><span class="nu0">6</span>_yloop
&nbsp;
   <span class="kw1">RET</span></pre>

<p>
 La rutina completa es la siguiente:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
DM_SPRITES  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">2</span><span class="re1">0</span>
DM_ATTRIBS  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">22</span>
DM_MAP      <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">24</span>
DM_COORD_X  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">26</span>
DM_COORD_Y  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">27</span>
DM_WIDTH    <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">28</span>
DM_HEIGHT   <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">29</span>
DM_MAPX     <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">3</span><span class="re1">0</span>
DM_MAPY     <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">32</span>
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Algunos valores hardcodeados para el ejemplo, en la rutina</span>
<span class="co1">; final se puede utilizar DM_WIDTH y DM_HEIGHT.</span>
<span class="co1">;-------------------------------------------------------------</span>
ANCHO_MAPA_TILES       <span class="kw3">EQU</span>   <span class="nu0">32</span>
ALTO_MAPA_TILES        <span class="kw3">EQU</span>   <span class="nu0">24</span>
ANCHO_PANTALLA         <span class="kw3">EQU</span>   <span class="re1">1</span><span class="nu0">4</span>
ALTO_PANTALLA          <span class="kw3">EQU</span>   <span class="re1">11</span>
&nbsp;
<span class="co1">;;; Rutina de la ROM del Spectrum, en otros sistemas </span>
<span class="co1">;;; sustituir por una rutina especifica de multiplicacion</span>
MULT_HL_POR_DE         <span class="kw3">EQU</span>   <span class="sy0">$</span>3<span class="re1">0</span>A9
&nbsp;
&nbsp;
<span class="co1">;---------------------------------------------------------------</span>
<span class="co1">; DrawMap_16x16_Map:</span>
<span class="co1">; Imprime una pantalla de tiles de 16x16 pixeles.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion             Parametro</span>
<span class="co1">; --------------------------------------------------------------</span>
<span class="co1">; DM_SPRITES (2 bytes)  Direccion de la tabla de tiles.</span>
<span class="co1">; DM_ATTRIBS (2 bytes)  Direccion de la tabla de atributos.</span>
<span class="co1">; DM_MAP     (2 bytes)  Direccion de la pantalla en memoria.</span>
<span class="co1">; DM_COORD_X (1 byte)   Coordenada X-Inicial en baja resolucion.</span>
<span class="co1">; DM_COORD_Y (1 byte)   Coordenada Y-Inicial en baja resolucion.</span>
<span class="co1">; DM_WIDTH   (1 byte)   Ancho del mapa en tiles</span>
<span class="co1">; DM_HEIGHT  (1 byte)   Alto del mapa en tiles</span>
<span class="co1">; DM_MAPX    (2 bytes)  Coordenada X en mapa.</span>
<span class="co1">; DM_MAPY    (2 bytes)  Coordenada Y en mapa.</span>
<span class="co1">;---------------------------------------------------------------</span>
DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Map:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>           <span class="co1">; IX apunta al mapa </span>
&nbsp;
   <span class="co1">;;; NUEVO: Posicionamos el puntero de mapa en posicion inicial.</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_MAPY<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, ANCHO_MAPA_TILES
   <span class="kw1">CALL</span> MULT_HL_POR_DE       <span class="co1">; HL = (ANCHO_MAPA * MAPA_Y)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_MAPX<span class="br0">)</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = MAPA_X + (ANCHO_MAPA * MAPA_Y)</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>
   <span class="kw1">ADD</span> <span class="kw2">IX</span>, <span class="kw2">DE</span>                <span class="co1">; IX = Inicio_Mapa + HL</span>
   <span class="co1">;;; FIN NUEVO</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>                   <span class="co1">; B = ALTO_EN_TILES (para bucle altura)</span>
&nbsp;
drawmg<span class="re1">1</span><span class="nu0">6</span>_yloop:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Guardamos el valor de B</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>         <span class="co1">; A = ALTO_EN_TILES</span>
   <span class="kw1">SUB</span> <span class="kw2">B</span>                     <span class="co1">; A = ALTO - iteracion_bucle = Y actual</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = Y * 2</span>
&nbsp;
   <span class="co1">;;; Calculamos la direccion destino en pantalla como</span>
   <span class="co1">;;; DIR_PANT = DIRECCION(X_INICIAL, Y_INICIAL + Y*2)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>       <span class="co1">; B = DB_COORD_Y y C = DB_COORD_X</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="sy0">$</span><span class="re1">1</span><span class="nu0">8</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="sy0">$</span>4<span class="re1">0</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
   <span class="kw1">AND</span> <span class="nu0">7</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>                   <span class="co1">; HL = DIR_PANTALLA(X_INICIAL,Y_INICIAL+Y*2)</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DM_WIDTH<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>                   <span class="co1">; B = ANCHO_EN_TILES</span>
&nbsp;
drawmg<span class="re1">1</span><span class="nu0">6</span>_xloop:
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>                   <span class="co1">; Nos guardamos el contador del bucle</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; Leemos un byte del mapa   </span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>                    <span class="co1">; Apuntamos al siguiente byte del mapa</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">255</span>                    <span class="co1">; Bloque especial a saltar: no se dibuja</span>
   <span class="kw1">JP</span> Z, drawmg<span class="re1">1</span><span class="nu0">6</span>_next
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                ; Nos guardamos una copia del bloque en A'</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">B</span>
&nbsp;
   <span class="co1">;;; Calcular posicion origen (array sprites) en HL como:</span>
   <span class="co1">;;;     direccion = base_sprites + (NUM_SPRITE*32)</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                 <span class="co1">; Intercambiamos DE y HL (DE=destino)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="re1">0</span>
   <span class="kw1">SRL</span> <span class="kw2">A</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>
   <span class="kw1">RRA</span>
   <span class="kw1">RR</span> <span class="kw2">L</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = BC + HL = DM_SPRITES + (DM_NUMSPR * 32)</span>
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>                 <span class="co1">; Intercambiamos DE y HL (DE=origen, HL=destino)</span>
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>                   <span class="co1">; Guardamos el puntero a pantalla recien calculado</span>
   <span class="kw1">PUSH</span> <span class="kw2">HL</span>
&nbsp;
   <span class="co1">;;; Impresion de los primeros 2 bloques horizontales del tile</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
drawmg<span class="re1">1</span><span class="nu0">6</span>_loop<span class="re1">1</span>:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; Incrementar puntero en pantalla</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Bloque 2: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>                     <span class="co1">; Hay que sumar 256 para ir al siguiente scanline</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>                     <span class="co1">; pero hay que restar el INC L que hicimos.</span>
   <span class="kw1">DJNZ</span> drawmg<span class="re1">1</span><span class="nu0">6</span>_loop<span class="re1">1</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; Decrementar el ultimo incrementado en el bucle</span>
&nbsp;
   <span class="co1">; Avanzamos HL 1 scanline (codigo de incremento de HL en 1 scanline)</span>
   <span class="co1">; desde el septimo scanline de la fila Y+1 al primero de la Y+2</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">3</span><span class="re1">1</span>
   <span class="kw1">LD</span> <span class="kw2">L</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> <span class="kw2">C</span>, drawmg<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
   <span class="kw1">SUB</span> <span class="nu0">8</span>
   <span class="kw1">LD</span> <span class="kw2">H</span>, <span class="kw2">A</span>
drawmg<span class="re1">1</span><span class="nu0">6</span>_nofix_abajop:
&nbsp;
   <span class="co1">;;; Impresion de los segundos 2 bloques horizontales:</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="nu0">8</span>
drawmg<span class="re1">1</span><span class="nu0">6</span>_loop2:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Bloque 1: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; Incrementar puntero en pantalla</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Bloque 2: Leemos dato del sprite</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Copiamos dato a pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementar puntero en sprite</span>
   <span class="kw1">INC</span> <span class="kw2">H</span>                     <span class="co1">; Hay que sumar 256 para ir al siguiente scanline</span>
   <span class="kw1">DEC</span> <span class="kw2">L</span>                     <span class="co1">; pero hay que restar el INC L que hicimos.</span>
   <span class="kw1">DJNZ</span> drawmg<span class="re1">1</span><span class="nu0">6</span>_loop2
&nbsp;
   <span class="co1">;;; En este punto, los 16 scanlines del tile estan dibujados.</span>
&nbsp;
   <span class="co1">;;;;;; Impresion de la parte de atributos del tile ;;;;;;</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperar puntero a inicio de tile</span>
&nbsp;
   <span class="co1">;;; Calcular posicion destino en area de atributos en DE.</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>                   <span class="co1">; Codigo de Get_Attr_Offset_From_Image</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">AND</span> <span class="nu0">3</span>
   <span class="kw1">OR</span> <span class="sy0">$</span>58
   <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">L</span>                   <span class="co1">; DE tiene el offset del attr de HL</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>
   <span class="kw1">EX</span> <span class="kw2">AF</span>, <span class="kw2">AF</span><span class="st0">'                ; Recuperamos el bloque del mapa desde A'</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="re1">0</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>
   <span class="kw1">ADD</span> <span class="kw2">HL</span>, <span class="kw2">BC</span>                <span class="co1">; HL = HL+HL=(DM_NUMSPR*4) = Origen de atributo</span>
&nbsp;
   <span class="kw1">LDI</span>
   <span class="kw1">LDI</span>                       <span class="co1">; Imprimimos la primeras fila de atributos</span>
&nbsp;
   <span class="co1">;;; Avance diferencial a la siguiente linea de atributos</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">E</span>                   <span class="co1">; A = E</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="nu0">3</span><span class="re1">0</span>                 <span class="co1">; Sumamos A = A + 30 mas los 2 INCs de LDI.</span>
   <span class="kw1">LD</span> <span class="kw2">E</span>, <span class="kw2">A</span>                   <span class="co1">; Guardamos en E (E = E+30 + 2 por LDI=E+32)</span>
   <span class="kw1">JR</span> NC, drawmg<span class="re1">1</span><span class="nu0">6</span>_att_noinc
   <span class="kw1">INC</span> <span class="kw2">D</span>
drawmg<span class="re1">1</span><span class="nu0">6</span>_att_noinc:
   <span class="kw1">LDI</span>
   <span class="kw1">LDI</span>                       <span class="co1">; Imprimimos la segunda fila de atributos</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">HL</span>                    <span class="co1">; Recuperamos el puntero al inicio</span>
&nbsp;
drawmg<span class="re1">1</span><span class="nu0">6</span>_next:
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; Avanzamos al siguiente tile en pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">L</span>                     <span class="co1">; horizontalmente</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">BC</span>                    <span class="co1">; Recuperamos el contador para el bucle</span>
   <span class="kw1">DEC</span> <span class="kw2">B</span>                     <span class="co1">; DJNZ se sale de rango, hay que usar DEC+JP</span>
   <span class="kw1">JP</span> NZ, drawmg<span class="re1">1</span><span class="nu0">6</span>_xloop
&nbsp;
   <span class="co1">;;; NUEVO: Incrementar puntero de mapa a siguiente linea</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, ANCHO_MAPA_TILES <span class="sy0">-</span> ANCHO_PANTALLA
   <span class="kw1">ADD</span> <span class="kw2">IX</span>, <span class="kw2">BC</span>
   <span class="co1">;;; FIN NUEVO</span>
&nbsp;
   <span class="co1">;;; En este punto, hemos dibujado ANCHO tiles en pantalla (1 fila)</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>
   <span class="kw1">DEC</span> <span class="kw2">B</span>                     <span class="co1">; Bucle vertical</span>
   <span class="kw1">JP</span> NZ, drawmg<span class="re1">1</span><span class="nu0">6</span>_yloop
&nbsp;
   <span class="kw1">RET</span></pre>

<p>
 Además es necesario realizar rutinas adicionales que gestionen el
movimiento por pantalla alterando DM_MAPX y DM_MAPY sin permitir
incrementarlos más allá de (Ancho_Mapa-Ancho_Pantalla) y
(Alto_Mapa-Alto_Pantalla) o decrementarlos por debajo de cero:
</p>
<pre class="code z80"><span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Incrementar la variable DM_MAPX para scrollear a la derecha.</span>
<span class="co1">;-------------------------------------------------------------</span>
Map_Inc_X:
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_MAPX<span class="br0">)</span>
&nbsp;
  <span class="co1">;;; Comparacion 16 bits de HL y (ANCHO_MAPA-ANCHO_PANTALLA)</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
  <span class="kw1">CP</span> <span class="br0">(</span>ANCHO_MAPA_TILES<span class="sy0">-</span>ANCHO_PANTALLA<span class="br0">)</span> <span class="sy0">/</span> <span class="nu0">256</span>
  <span class="kw1">RET</span> NZ
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
  <span class="kw1">CP</span> <span class="br0">(</span>ANCHO_MAPA_TILES<span class="sy0">-</span>ANCHO_PANTALLA<span class="br0">)</span> <span class="sy0">%</span> <span class="nu0">256</span>
  <span class="kw1">RET</span> Z
&nbsp;
  <span class="kw1">INC</span> <span class="kw2">HL</span>                     <span class="co1">; No eran iguales, podemos incrementar.</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAPX<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Incrementar la variable DM_MAPY para scrollear hacia abajo.</span>
<span class="co1">;-------------------------------------------------------------</span>
Map_Inc_Y:
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_MAPY<span class="br0">)</span>
&nbsp;
  <span class="co1">;;; Comparacion 16 bits de HL y (ALTO_MAPA-ALTO_PANTALLA)</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
  <span class="kw1">CP</span> <span class="br0">(</span>ALTO_MAPA_TILES<span class="sy0">-</span>ALTO_PANTALLA<span class="br0">)</span> <span class="sy0">/</span> <span class="nu0">256</span>
  <span class="kw1">RET</span> NZ
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
  <span class="kw1">CP</span> <span class="br0">(</span>ALTO_MAPA_TILES<span class="sy0">-</span>ALTO_PANTALLA<span class="br0">)</span> <span class="sy0">%</span> <span class="nu0">256</span>
  <span class="kw1">RET</span> Z
&nbsp;
  <span class="kw1">INC</span> <span class="kw2">HL</span>                     <span class="co1">; No eran iguales, podemos incrementar.</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAPY<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Decrementar la variable DM_MAPX para scrollear a la izq.</span>
<span class="co1">;-------------------------------------------------------------</span>
Map_Dec_X:
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_MAPX<span class="br0">)</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
  <span class="kw1">AND</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> NZ, mapdecx_doit        <span class="co1">; Verificamos que DM_MAPX no sea 0</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
  <span class="kw1">AND</span> <span class="kw2">A</span>
  <span class="kw1">RET</span> Z
mapdecx_doit:
  <span class="kw1">DEC</span> <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAPX<span class="br0">)</span>, <span class="kw2">HL</span>           <span class="co1">; No es cero, podemos decrementar</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Decrementar la variable DM_MAPY para scrollear hacia arriba.</span>
<span class="co1">;-------------------------------------------------------------</span>
Map_Dec_Y:
  <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_MAPY<span class="br0">)</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">H</span>
  <span class="kw1">AND</span> <span class="kw2">A</span>
  <span class="kw1">JR</span> NZ, mapdecy_doit        <span class="co1">; Verificamos que DM_MAPX no sea 0</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">L</span>
  <span class="kw1">AND</span> <span class="kw2">A</span>
  <span class="kw1">RET</span> Z
mapdecy_doit:
  <span class="kw1">DEC</span> <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAPY<span class="br0">)</span>, <span class="kw2">HL</span>           <span class="co1">; No es cero, podemos decrementar</span>
  <span class="kw1">RET</span></pre>

<p>
 El incremento de DM_MAPX y DM_MAPY requiere verificar que ninguna de
las 2 variables excede ANCHO_MAPA-ANCHO_PANTALLA y
ALTO_MAPA-ALTO_PANTALLA respectivamente. Sus decrementos requieren
comprobar que el valor actual de estas variables no es cero.
</p>

<p>
 Utilicemos las anteriores rutinas en un programa de ejemplo en el que
podemos mover una ventana de 14×11 bloques a través de un mapa de 32×24
tiles usando las teclas O, P, Q y A:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo impresion mapa de 16x16 desde array global</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_gfx
  <span class="kw1">LD</span> <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_attr
  <span class="kw1">LD</span> <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, mapa_ejemplo
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAP<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, ANCHO_PANTALLA
  <span class="kw1">LD</span> <span class="br0">(</span>DM_WIDTH<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, ALTO_PANTALLA
  <span class="kw1">LD</span> <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAPX<span class="br0">)</span>, <span class="kw2">A</span>            <span class="co1">; Establecemos MAPX, MAPY iniciales = 0</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAPY<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
redraw:
  <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Map     <span class="co1">; Imprimir pantalla de mapa</span>
&nbsp;
bucle:
  <span class="kw1">CALL</span> LEER_TECLADO          <span class="co1">; Leemos el estado de O, P, Q, A</span>
&nbsp;
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>                   <span class="co1">; Modificamos MAPX y MAPY segun OPQA</span>
  <span class="kw1">JR</span> Z, nopulsada_q
  <span class="kw1">CALL</span> Map_Dec_Y
  <span class="kw1">JR</span> redraw
nopulsada_q:
  <span class="kw1">BIT</span> <span class="re1">1</span>, <span class="kw2">A</span>
  <span class="kw1">JR</span> Z, nopulsada_a
  <span class="kw1">CALL</span> Map_Inc_Y
  <span class="kw1">JR</span> redraw
nopulsada_a:
  <span class="kw1">BIT</span> <span class="nu0">2</span>, <span class="kw2">A</span>
  <span class="kw1">JR</span> Z, nopulsada_p
  <span class="kw1">CALL</span> Map_Inc_X
  <span class="kw1">JR</span> redraw
nopulsada_p:
  <span class="kw1">BIT</span> <span class="nu0">3</span>, <span class="kw2">A</span>
  <span class="kw1">JR</span> Z, nopulsada_o
  <span class="kw1">CALL</span> Map_Dec_X
  <span class="kw1">JR</span> redraw
nopulsada_o:
  <span class="kw1">JR</span> bucle
&nbsp;
loop:
  <span class="kw1">JR</span> loop
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; LEER_TECLADO: Lee el estado de O, P, Q, A, y devuelve</span>
<span class="co1">; en A el estado de las teclas (1=pulsada, 0=no pulsada).</span>
<span class="co1">; El byte está codificado tal que:</span>
<span class="co1">;</span>
<span class="co1">; BITS            3    2     1   0</span>
<span class="co1">; SIGNIFICADO   LEFT RIGHT DOWN  UP</span>
<span class="co1">;-------------------------------------------------------------</span>
LEER_TECLADO:
  <span class="kw1">LD</span> <span class="kw2">D</span>, <span class="re1">0</span>
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>FBFE
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>                   <span class="co1">; Leemos la tecla Q</span>
  <span class="kw1">JR</span> NZ, Control_no_up       <span class="co1">; No pulsada, no cambiamos nada en D</span>
  <span class="kw1">SET</span> <span class="re1">0</span>, <span class="kw2">D</span>                   <span class="co1">; Pulsada, ponemos a 1 el bit 0</span>
Control_no_up:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>FDFE
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>                   <span class="co1">; Leemos la tecla A</span>
  <span class="kw1">JR</span> NZ, Control_no_down     <span class="co1">; No pulsada, no cambianos nada en D</span>
  <span class="kw1">SET</span> <span class="re1">1</span>, <span class="kw2">D</span>                   <span class="co1">; Pulsada, ponemos a 1 el bit 1</span>
Control_no_down:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="sy0">$</span>DFFE
  <span class="kw1">IN</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">C</span><span class="br0">)</span>
  <span class="kw1">BIT</span> <span class="re1">0</span>, <span class="kw2">A</span>                   <span class="co1">; Leemos la tecla P</span>
  <span class="kw1">JR</span> NZ, Control_no_right    <span class="co1">; No pulsada</span>
  <span class="kw1">SET</span> <span class="nu0">2</span>, <span class="kw2">D</span>                   <span class="co1">; Pulsada, ponemos a 1 el bit 2</span>
Control_no_right:
                             <span class="co1">; BC ya vale $DFFE, (O y P en misma fila)</span>
  <span class="kw1">BIT</span> <span class="re1">1</span>, <span class="kw2">A</span>                   <span class="co1">; Tecla O</span>
  <span class="kw1">JR</span> NZ, Control_no_left
  <span class="kw1">SET</span> <span class="nu0">3</span>, <span class="kw2">D</span>
Control_no_left:
&nbsp;
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">D</span>                    <span class="co1">; Devolvemos en A el estado de las teclas</span>
  <span class="kw1">RET</span>
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
DM_SPRITES  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">2</span><span class="re1">0</span>
DM_ATTRIBS  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">22</span>
DM_MAP      <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">24</span>
DM_COORD_X  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">26</span>
DM_COORD_Y  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">27</span>
DM_WIDTH    <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">28</span>
DM_HEIGHT   <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">29</span>
DM_MAPX     <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">3</span><span class="re1">0</span>
DM_MAPY     <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">32</span>
&nbsp;
<span class="co1">;-------------------------------------------------------------</span>
<span class="co1">; Algunos valores hardcodeados para el ejemplo, en la rutina</span>
<span class="co1">; final se puede utilizar DM_WIDTH y DM_HEIGHT.</span>
<span class="co1">;-------------------------------------------------------------</span>
ANCHO_MAPA_TILES       <span class="kw3">EQU</span>   <span class="nu0">32</span>
ALTO_MAPA_TILES        <span class="kw3">EQU</span>   <span class="nu0">24</span>
ANCHO_PANTALLA         <span class="kw3">EQU</span>   <span class="re1">1</span><span class="nu0">4</span>
ALTO_PANTALLA          <span class="kw3">EQU</span>   <span class="re1">11</span>
&nbsp;
<span class="co1">;;; Rutina de la ROM del Spectrum, en otros sistemas </span>
<span class="co1">;;; sustituir por una rutina especifica de multiplicacion</span>
MULT_HL_POR_DE         <span class="kw3">EQU</span>   <span class="sy0">$</span>3<span class="re1">0</span>A9
&nbsp;
<span class="co1">;-----------------------------------------------------------------------</span>
<span class="co1">;;; Nuestra pantalla de ejemplo de 32x24 bloques:</span>
<span class="co1">;-----------------------------------------------------------------------</span>
mapa_ejemplo:
  DEFB <span class="re1">1</span>,<span class="nu0">2</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="nu0">2</span>,<span class="re1">1</span>,<span class="nu0">2</span>,<span class="re1">1</span>,<span class="nu0">2</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="nu0">2</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="nu0">2</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="nu0">4</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">4</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">2</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>
  DEFB <span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span>,<span class="re1">1</span></pre>

<p>
 Veamos una captura del resultado del anterior ejemplo después de moverse a través del mapeado:
</p>

<p>
<br>

<img src="img/gfx5_maparray.png" class="mediacenter" alt=" Moviendose por un mapa en array global "/>
<br>

</p>

<p>
 El anterior ejemplo es meramente ilustrativo del uso de la rutina de
impresión: para un juego basado en scroll (como simula el ejemplo con la
 pulsación de teclas) resultará mucho más rápido y eficiente realizar un
 scroll del contenido del área de juego y trazar sólo la fila o columna
de datos que “entra” en el área de visión del jugador.
</p>

<p>
 Para esta implementación serían necesarias 4 rutinas de scroll de una
porción de videomemoria, según el tipo de movimiento, y la impresión en
la primera/última fila/columna de visión del dato de la pantalla
entrante. Sigue siendo necesario modificar DM_MAPX y DM_MAPY.
</p>

<p>
 El scroll mediante instrucciones de transferencia de N-1 FILAS o N-1
COLUMNAS de pantalla  gráfica y de atributos resultará bastante más
rápido y eficiente que la rutina de impresión de sprites integrada en
DrawMap, al no tener que realizar apenas cálculos.
</p>

<p>
 Como desventaja principal de los mapeados basados en arrays globales de
 tiles, en este tipo de mapeados no podemos utilizar de una forma
inmediata las técnicas de “agrupación” o “compresión” que veremos a
continuación.
</p>

<p>
<br>

</p>

</div>

<h2 id="mapeados-diferenciales">Mapeados diferenciales</h2>
<div class="level2">

<p>
 Las pantallas de tamaño fijo almacenan la información tanto de los
bloques “no dibujables” (fondos transparentes o sólidos) como de los
dibujables (los gráficos que forman la pantalla en sí misma). Esto
supone un pequeño desperdicio de memoria ya que almacenamos en el array
de la pantalla datos que finalmente no vamos a utilizar y que no
aparecerán en pantalla.
</p>

<p>
 Una pantalla de 16×12 tiles que ocupe todo el área visible ocupa 192
bytes, lo que nos permite un total de 85 pantallas en 16 KB de memoria.
Si tenemos en cuenta que necesitamos espacio para los gráficos de
personajes y enemigos, el tileset, fuentes de texto, código del
programa, textos, sonido, variables, nos encontramos con que se
establece un límite de cantidad de pantallas que podemos incorporar en
nuestro programa en función de la memoria libre que nos queda tras
incorporar todos los elementos del mismo.
</p>

<p>
 Para reducir el espacio que ocupan nuestras pantallas y por tanto poder
 incluir más pantallas en la misma cantidad de memoria podemos utilizar
diferentes métodos de codificación.
</p>

<p>
 Uno de ellos podría basarse en la compresión por diferentes algoritmos
del mapeado considerado globalmente: si tomamos todo el bloque de datos
con información sobre las pantallas y lo comprimimos antes de salvarlo a
 cintar y lo descomprimimos al vuelo durante su carga reducimos la
ocupación del binario resultante en cinta pero no de la ocupación de
datos en memoria.
</p>

<p>
 Por esto, lo mejor es codificar o “comprimir” cada pantalla en sí misma y que la rutina de impresión la desempaquete al vuelo.
</p>

<p>
 La técnica que vamos a ver no es una compresión en sí misma sino que se
 basa en no almacenar en el vector de datos de la pantalla los datos en
blanco/transparentes. Los datos de la pantalla incluirán sólo los tiles
que deben de ser dibujados.
</p>

<p>
 Si tenemos una fila de 16 tiles pero sólo 5 de ellos deben de ser
dibujados, es absurdo almacenar la información de los 11 tiles “en
blanco”. A continuación veremos diferentes formas de codificar los datos
 de los tiles “reales” y descartar los tiles “vacíos”.
</p>

<p>
 Aunque los mapeados diferenciales consiguen su mayor compresión
incluyendo técnicas de repetición de tiles y de patrones, nosotros vamos
 a considerar las técnicas de compresión básica basadas simplemente en
descartado de tiles fondo/transparentes y en agrupación de scanlines.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit14" id="mapeados-diferenciales-con-un-unico-tileset">Mapeados diferenciales con un único tileset</h3>
<div class="level3">

<p>
 En las técnicas de mapeados diferenciales, el mapa no cambia: incluye
(como mínimo) las direcciones de las pantallas y las conexiones entre
las mismas. Lo que sí que se ve modificada es la estructura de la
pantalla, que ahora no tiene un tamaño fijo (al no ser ya una matriz de
Ancho*Alto tiles).
</p>

<p>
 Este tamaño variable requiere finalizar los datos de la pantalla con un
 identificador para informar a las rutinas de impresión de cuándo deben
terminar su ejecución. En nuestro caso finalizaremos las pantallas con
un valor 255 (-1).
</p>

<p>
 A la hora de codificar las pantallas, podemos optar por diferentes “algoritmos”:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Codificación básica</strong>:
 se almacenan en el vector “pantalla” los datos de cada tile que
realmente deba de ser impreso. Los datos mínimos necesarios son la
coordenada X, la coordenada Y y el identificador de tile.</div>
</li>
<li><div class="li"> <strong>Codificación por agrupación horizontal</strong>:
 Para evitar incluir la coordenada X e Y en cada tile, podemos agrupar
tiles consecutivos horizontalmente y marcar sólo la posición del
primero, ahorrando 2 bytes por cada tile que le sigue.</div>
</li>
<li><div class="li"> <strong>Codificación por agrupación vertical</strong>:
 Para evitar incluir la coordenada X e Y en cada tile, podemos agrupar
tiles consecutivos verticalmente y marcar sólo la posición del primero,
ahorrando 2 bytes por cada tile bajo él.</div>
</li>
<li><div class="li"> <strong>Codificación por agrupación mixta</strong>:
 Cada tile se codifica por agrupación horizontal o vertical según
produzca un mayor o menor ahorro de tamaño. La pantalla contiene primero
 los scanlines horizontales, seguidos de un byte de valor 254, y después
 los scanlines verticales.</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 Veamos en detalle todos estos tipos de codificación.
</p>

<p>
<br>

</p>

</div>

<h4 id="mapeado-diferencial-basico-sin-agrupacion">Mapeado diferencial básico (sin agrupación)</h4>
<div class="level4">

<p>
 Implementaremos codificación básica por scanlines horizontales,
verticales, y mixtos utilizando un pequeño programa en python creado
específicamente para este capítulo. Con él codificaremos la pantalla 1
de Sokoban.
</p>

<p>
 A esta pantalla tendremos que realizarle una pequeña modificación para
mostrar las bondades de la codificación: eliminar los tiles
transparentes para que podamos codificarla ignorando los tiles vacíos.
</p>

<p>
 Si nos fijamos en cualquier juego de plataformas, shooter, aventura,
etc, veremos que, al contrario que en las pantallas de ejemplo de
Sokoban, no existen bloques transparentes y que la gran mayoría de los
bloques en pantalla son o bien “vacíos” (fondo sólido) o bien
“transparentes” (fondo no sólido), siendo esos bloques el área por donde
 se mueve el personaje y los enemigos. En la mayoría de juegos, pues,
hay bloques vacíos o transparentes pero no de ambos tipos.
</p>

<p>
 Para mostrar el nivel de compresión que se conseguiría en un juego
basado en tiles, supongamos que nuestro juego de ejemplo (Sokoban) no
tuviera transparencias y el fondo del área de juego fuera totalmente
plana (un mismo color) con lo que pudieramos ignorar la impresión de
bloques 0 en lugar de la de los bloques 255:
</p>

<p>
 Introducimos los datos del nivel 1 (cambiando los tiles transparentes
por ceros, tal y como sería la pantalla de cualquier otro juego) en un
fichero <strong>pantalla.dat</strong> con el siguiente formato:
</p>
<pre class="code z80">sokoban_LEVEL<span class="re1">1</span>:
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">1</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">6</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">1</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">4</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="nu0">7</span>,<span class="nu0">5</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="nu0">5</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>
  DEFB <span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span>,<span class="re1">0</span></pre>

<p>
 Veamos el código de nuestro sencillo programa de “compresión/codificación” realizado en lenguaje python:
</p>
<pre class="code python"><span class="co1">#!/usr/bin/python</span>
<span class="co1">#</span>
<span class="co1"># Convierte una pantalla de mapa en pantalla codificada por</span>
<span class="co1"># codif. basica, scanlines horizontales, verticales o mixtos.</span>
<span class="co1"># Permite agrupacion de coordenadas XY en un mismo byte con</span>
<span class="co1"># el flag -a.</span>
<span class="co1">#</span>
&nbsp;
<span class="kw1">import</span> <span class="kw3">os</span><span class="sy0">,</span> <span class="kw3">sys</span>
&nbsp;
<span class="co1"># Variables de configuracion del script</span>
ANCHO_MAPA <span class="sy0">=</span> <span class="nu0">16</span>
ALTO_MAPA <span class="sy0">=</span> <span class="nu0">12</span>
IGNORE_VALUES <span class="sy0">=</span> <span class="nu0">0</span>
BLANK <span class="sy0">=</span> <span class="nu0">0</span>
agrupar_xy <span class="sy0">=</span> <span class="nu0">0</span>
&nbsp;
MIXTA_CODIF_HORIZ  <span class="sy0">=</span> <span class="nu0">0</span>
MIXTA_CODIF_VERT   <span class="sy0">=</span> <span class="nu0">1</span>
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">def</span> Uso<span class="br0">(</span><span class="br0">)</span>:
   <span class="kw1">print</span> <span class="st0">"<span class="es0">\n</span>Uso:"</span><span class="sy0">,</span> <span class="kw3">sys</span>.<span class="me1">argv</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> <span class="st0">"TIPO_CODIFICACION [-a] nombre_fichero"</span>
   <span class="kw1">print</span> <span class="st0">"<span class="es0">\n</span>  Flag TIPO_CODIFICACION:<span class="es0">\n</span>"</span>
   <span class="kw1">print</span> <span class="st0">"    Basica = -b"</span>
   <span class="kw1">print</span> <span class="st0">"    Scanlines horizontales = -h"</span>
   <span class="kw1">print</span> <span class="st0">"    Scanlines verticales= -v"</span>
   <span class="kw1">print</span> <span class="st0">"    Scanlines horizontales = -h"</span>
   <span class="kw1">print</span> <span class="st0">"    Mixta horizontales/verticales = -m<span class="es0">\n</span>"</span>
   <span class="kw1">print</span> <span class="st0">"    Flag opcional -a: (por defecto = off)"</span>
   <span class="kw1">print</span> <span class="st0">"    Agrupar coordenadas X e Y en un mismo byte = -a<span class="es0">\n</span>"</span>
&nbsp;
   <span class="kw3">sys</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span>
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">def</span> Consecutivos_Horiz<span class="br0">(</span> x<span class="sy0">,</span> y<span class="sy0">,</span> pantalla<span class="sy0">,</span> ancho <span class="br0">)</span>:
   cuales <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
   tiles <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
   <span class="kw1">while</span> <span class="br0">(</span>x <span class="sy0">&lt;</span> ancho<span class="br0">)</span> <span class="kw1">and</span> <span class="br0">(</span> pantalla<span class="br0">[</span>y<span class="br0">]</span><span class="br0">[</span>x<span class="br0">]</span> <span class="sy0">!=</span> IGNORE_VALUES <span class="br0">)</span>:
      cuales.<span class="me1">append</span><span class="br0">(</span> x <span class="br0">)</span>
      cuales.<span class="me1">append</span><span class="br0">(</span> y <span class="br0">)</span>
      tiles.<span class="me1">append</span><span class="br0">(</span>pantalla<span class="br0">[</span><span class="kw2">int</span><span class="br0">(</span>y<span class="br0">)</span><span class="br0">]</span><span class="br0">[</span><span class="kw2">int</span><span class="br0">(</span>x<span class="br0">)</span><span class="br0">]</span><span class="br0">)</span>
      x +<span class="sy0">=</span> <span class="nu0">1</span>
   <span class="kw1">return</span> cuales<span class="sy0">,</span> tiles
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">def</span> Consecutivos_Vert<span class="br0">(</span> x<span class="sy0">,</span> y<span class="sy0">,</span> pantalla<span class="sy0">,</span> alto <span class="br0">)</span>:
   cuales <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
   tiles <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
   <span class="kw1">while</span> <span class="br0">(</span>y <span class="sy0">&lt;</span> alto<span class="br0">)</span> <span class="kw1">and</span> <span class="br0">(</span> pantalla<span class="br0">[</span>y<span class="br0">]</span><span class="br0">[</span>x<span class="br0">]</span> <span class="sy0">!=</span> IGNORE_VALUES <span class="br0">)</span>:
      cuales.<span class="me1">append</span><span class="br0">(</span> x <span class="br0">)</span>
      cuales.<span class="me1">append</span><span class="br0">(</span> y <span class="br0">)</span>
      tiles.<span class="me1">append</span><span class="br0">(</span>pantalla<span class="br0">[</span>y<span class="br0">]</span><span class="br0">[</span>x<span class="br0">]</span><span class="br0">)</span>
      y +<span class="sy0">=</span> <span class="nu0">1</span>
   <span class="kw1">return</span> cuales<span class="sy0">,</span> tiles
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">def</span> Borrar_Consecutivos<span class="br0">(</span> pantalla<span class="sy0">,</span> lista <span class="br0">)</span>:
   <span class="kw1">for</span> i <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span><span class="kw2">len</span><span class="br0">(</span>lista<span class="br0">)</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">)</span>:
      x <span class="sy0">=</span> lista<span class="br0">[</span>i<span class="br0">]</span>
      y <span class="sy0">=</span> lista<span class="br0">[</span>i+<span class="nu0">1</span><span class="br0">]</span>
      pantalla<span class="br0">[</span>y<span class="br0">]</span><span class="br0">[</span>x<span class="br0">]</span> <span class="sy0">=</span> BLANK
   <span class="kw1">return</span> pantalla
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">def</span> Codificacion_Horiz_o_Vert<span class="br0">(</span> pantalla <span class="br0">)</span>:
&nbsp;
   COORD_Y <span class="sy0">=</span> <span class="nu0">0</span>
   mapa_codificado <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
&nbsp;
   <span class="co1"># Procesamos la matriz de datos (la pantalla) segun la codificacion:</span>
   <span class="kw1">for</span> y <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>ALTO_MAPA<span class="br0">)</span>:
      COORD_X <span class="sy0">=</span> <span class="nu0">0</span>
&nbsp;
      <span class="co1"># Procesar los valores separados por coma:</span>
      <span class="kw1">for</span> valor <span class="kw1">in</span> pantalla<span class="br0">[</span>y<span class="br0">]</span>:
         <span class="kw1">if</span> codificacion <span class="sy0">==</span> <span class="st0">"-b"</span>:
            <span class="kw1">if</span> valor <span class="sy0">!=</span> IGNORE_VALUES:
               <span class="kw1">if</span> agrupar_xy <span class="sy0">==</span> <span class="nu0">0</span>:
                  mapa_codificado.<span class="me1">append</span><span class="br0">(</span> COORD_X <span class="br0">)</span>
                  mapa_codificado.<span class="me1">append</span><span class="br0">(</span> COORD_Y <span class="br0">)</span>
               <span class="kw1">else</span>:
                  mapa_codificado.<span class="me1">append</span><span class="br0">(</span> <span class="br0">(</span>COORD_X*<span class="nu0">16</span><span class="br0">)</span> + COORD_Y <span class="br0">)</span>
               mapa_codificado.<span class="me1">append</span><span class="br0">(</span> valor <span class="br0">)</span>
         <span class="kw1">elif</span> codificacion <span class="sy0">==</span> <span class="st0">"-h"</span> <span class="kw1">or</span> codificacion <span class="sy0">==</span> <span class="st0">"-v"</span>:
            <span class="kw1">if</span> valor <span class="sy0">!=</span> IGNORE_VALUES:
               <span class="kw1">if</span> agrupar_xy <span class="sy0">==</span> <span class="nu0">0</span>:
                  mapa_codificado.<span class="me1">append</span><span class="br0">(</span> COORD_X <span class="br0">)</span>
                  mapa_codificado.<span class="me1">append</span><span class="br0">(</span> COORD_Y <span class="br0">)</span>
               <span class="kw1">else</span>:
                  mapa_codificado.<span class="me1">append</span><span class="br0">(</span> <span class="br0">(</span>COORD_X*<span class="nu0">16</span><span class="br0">)</span> + COORD_Y <span class="br0">)</span>
               <span class="kw1">if</span> codificacion <span class="sy0">==</span> <span class="st0">"-h"</span>:
                  a<span class="sy0">,</span> b <span class="sy0">=</span> Consecutivos_Horiz<span class="br0">(</span>COORD_X<span class="sy0">,</span> COORD_Y<span class="sy0">,</span> pantalla<span class="sy0">,</span> ANCHO_MAPA<span class="br0">)</span>
               <span class="kw1">else</span>:
                  a<span class="sy0">,</span> b <span class="sy0">=</span> Consecutivos_Vert<span class="br0">(</span>COORD_X<span class="sy0">,</span> COORD_Y<span class="sy0">,</span> pantalla<span class="sy0">,</span> ALTO_MAPA<span class="br0">)</span>
               pantalla <span class="sy0">=</span> Borrar_Consecutivos<span class="br0">(</span> pantalla<span class="sy0">,</span> a <span class="br0">)</span>
               mapa_codificado.<span class="me1">extend</span><span class="br0">(</span> b <span class="br0">)</span>
               mapa_codificado.<span class="me1">append</span><span class="br0">(</span> <span class="nu0">255</span> <span class="br0">)</span><span class="sy0">;</span>
         COORD_X +<span class="sy0">=</span> <span class="nu0">1</span>
      COORD_Y +<span class="sy0">=</span> <span class="nu0">1</span>
&nbsp;
   <span class="kw1">return</span> mapa_codificado
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">def</span> Tiles_Pendientes<span class="br0">(</span> pantalla <span class="br0">)</span>:
   cuantos <span class="sy0">=</span> <span class="nu0">0</span>
   <span class="kw1">for</span> y <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span><span class="kw2">len</span><span class="br0">(</span>pantalla<span class="br0">)</span><span class="br0">)</span>:
      <span class="kw1">for</span> value <span class="kw1">in</span> pantalla<span class="br0">[</span>y<span class="br0">]</span>:
         <span class="kw1">if</span> value <span class="sy0">!=</span> IGNORE_VALUES:
            cuantos +<span class="sy0">=</span> <span class="nu0">1</span>
   <span class="kw1">return</span> cuantos
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">def</span> Coordenadas_Mayor_Valor<span class="br0">(</span> matriz <span class="br0">)</span>:
   maxx<span class="sy0">,</span> maxy<span class="sy0">,</span> maxv <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span>
&nbsp;
   <span class="kw1">for</span> y <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span><span class="kw2">len</span><span class="br0">(</span>matriz<span class="br0">)</span><span class="br0">)</span>:
      <span class="kw1">for</span> x <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="kw2">len</span><span class="br0">(</span>matriz<span class="br0">[</span>y<span class="br0">]</span><span class="br0">)</span><span class="br0">)</span>:
         valor <span class="sy0">=</span> matriz<span class="br0">[</span>y<span class="br0">]</span><span class="br0">[</span>x<span class="br0">]</span>
         <span class="kw1">if</span> valor <span class="sy0">!=</span> IGNORE_VALUES <span class="kw1">and</span> valor <span class="sy0">&gt;</span> maxv:
            maxv <span class="sy0">=</span> valor
            maxx <span class="sy0">=</span> x
            maxy <span class="sy0">=</span> y
&nbsp;
   <span class="kw1">return</span> maxx<span class="sy0">,</span> maxy<span class="sy0">,</span> maxv
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">def</span> Codificacion_Mixta<span class="br0">(</span> pantalla <span class="br0">)</span>:
&nbsp;
   mapa_codificado_h <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
   mapa_codificado_v <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
   mapa_codificado <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
&nbsp;
   <span class="co1"># Repetir hasta que no queden tiles que codificar:</span>
   <span class="kw1">while</span> Tiles_Pendientes<span class="br0">(</span>pantalla<span class="br0">)</span> <span class="sy0">!=</span> <span class="nu0">0</span>:
&nbsp;
      <span class="co1"># Construir 2 tablas con la cantidad de tiles horizontales y</span>
      <span class="co1"># verticales que salen de codificar cada posicion:</span>
      horizontales <span class="sy0">=</span> <span class="br0">[</span> <span class="br0">[</span> <span class="nu0">0</span> <span class="kw1">for</span> i <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>ANCHO_MAPA<span class="br0">)</span> <span class="br0">]</span> <span class="kw1">for</span> j <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>ALTO_MAPA<span class="br0">)</span> <span class="br0">]</span>
      verticales <span class="sy0">=</span> <span class="br0">[</span> <span class="br0">[</span> <span class="nu0">0</span> <span class="kw1">for</span> i <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>ANCHO_MAPA<span class="br0">)</span> <span class="br0">]</span> <span class="kw1">for</span> j <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>ALTO_MAPA<span class="br0">)</span> <span class="br0">]</span>
&nbsp;
      COORD_Y <span class="sy0">=</span> <span class="nu0">0</span>
      <span class="kw1">for</span> y <span class="kw1">in</span> <span class="kw2">range</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>ALTO_MAPA<span class="br0">)</span>:
         COORD_X <span class="sy0">=</span> <span class="nu0">0</span>
         <span class="kw1">for</span> valor <span class="kw1">in</span> pantalla<span class="br0">[</span>y<span class="br0">]</span>:
            <span class="kw1">if</span> valor <span class="sy0">!=</span> IGNORE_VALUES:
               a<span class="sy0">,</span> b <span class="sy0">=</span> Consecutivos_Horiz<span class="br0">(</span>COORD_X<span class="sy0">,</span> COORD_Y<span class="sy0">,</span> pantalla<span class="sy0">,</span> ANCHO_MAPA<span class="br0">)</span>
               c<span class="sy0">,</span> d <span class="sy0">=</span> Consecutivos_Vert<span class="br0">(</span>COORD_X<span class="sy0">,</span> COORD_Y<span class="sy0">,</span> pantalla<span class="sy0">,</span> ALTO_MAPA<span class="br0">)</span>
               horizontales<span class="br0">[</span>COORD_Y<span class="br0">]</span><span class="br0">[</span>COORD_X<span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">len</span><span class="br0">(</span>b<span class="br0">)</span>
               verticales<span class="br0">[</span>COORD_Y<span class="br0">]</span><span class="br0">[</span>COORD_X<span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">len</span><span class="br0">(</span>d<span class="br0">)</span>
            COORD_X +<span class="sy0">=</span> <span class="nu0">1</span>
         COORD_Y +<span class="sy0">=</span> <span class="nu0">1</span>
&nbsp;
      <span class="co1"># Una vez construida la tabla, buscar la posicion X,Y que</span>
      <span class="co1"># tiene el valor mas alto y codificarla</span>
      max_hx<span class="sy0">,</span> max_hy<span class="sy0">,</span> maxh_v <span class="sy0">=</span> Coordenadas_Mayor_Valor<span class="br0">(</span> horizontales <span class="br0">)</span>
      max_vx<span class="sy0">,</span> max_vy<span class="sy0">,</span> maxv_v <span class="sy0">=</span> Coordenadas_Mayor_Valor<span class="br0">(</span> verticales <span class="br0">)</span>
&nbsp;
      <span class="co1"># Codificar con horizontal o vertical segun cual sea el mayor</span>
      <span class="kw1">if</span> maxh_v <span class="sy0">&gt;=</span> maxv_v:
         <span class="kw1">if</span> agrupar_xy <span class="sy0">==</span> <span class="nu0">0</span>:
            mapa_codificado_h.<span class="me1">append</span><span class="br0">(</span> max_hx <span class="br0">)</span>
            mapa_codificado_h.<span class="me1">append</span><span class="br0">(</span> max_hy <span class="br0">)</span>
         <span class="kw1">else</span>:
            mapa_codificado_h.<span class="me1">append</span><span class="br0">(</span> <span class="br0">(</span>max_hx*<span class="nu0">16</span><span class="br0">)</span> + max_hy <span class="br0">)</span>
         a<span class="sy0">,</span> b <span class="sy0">=</span> Consecutivos_Horiz<span class="br0">(</span>max_hx<span class="sy0">,</span> max_hy<span class="sy0">,</span> pantalla<span class="sy0">,</span> ANCHO_MAPA<span class="br0">)</span>
         pantalla <span class="sy0">=</span> Borrar_Consecutivos<span class="br0">(</span> pantalla<span class="sy0">,</span> a <span class="br0">)</span>
         mapa_codificado_h.<span class="me1">extend</span><span class="br0">(</span> b <span class="br0">)</span>
         mapa_codificado_h.<span class="me1">append</span><span class="br0">(</span> <span class="nu0">255</span> <span class="br0">)</span>
      <span class="kw1">else</span>:
         <span class="kw1">if</span> agrupar_xy <span class="sy0">==</span> <span class="nu0">0</span>:
            mapa_codificado_v.<span class="me1">append</span><span class="br0">(</span> max_vx <span class="br0">)</span>
            mapa_codificado_v.<span class="me1">append</span><span class="br0">(</span> max_vy <span class="br0">)</span>
         <span class="kw1">else</span>:
            mapa_codificado_h.<span class="me1">append</span><span class="br0">(</span> <span class="br0">(</span>max_vx*<span class="nu0">16</span><span class="br0">)</span> + max_vy <span class="br0">)</span>
         c<span class="sy0">,</span> d <span class="sy0">=</span> Consecutivos_Vert<span class="br0">(</span>max_vx<span class="sy0">,</span> max_vy<span class="sy0">,</span> pantalla<span class="sy0">,</span> ALTO_MAPA<span class="br0">)</span>
         pantalla <span class="sy0">=</span> Borrar_Consecutivos<span class="br0">(</span> pantalla<span class="sy0">,</span> c <span class="br0">)</span>
         mapa_codificado_v.<span class="me1">extend</span><span class="br0">(</span> d <span class="br0">)</span>
         mapa_codificado_v.<span class="me1">append</span><span class="br0">(</span> <span class="nu0">255</span> <span class="br0">)</span>
&nbsp;
   <span class="co1"># Sacamos las codificaciones en orden: primero horizontales, luego 254</span>
   <span class="co1"># tras eliminar el 255 final de las horizontales, y luego verticales.</span>
   <span class="kw1">if</span> mapa_codificado_h <span class="sy0">!=</span> <span class="br0">[</span><span class="br0">]</span>:
      mapa_codificado.<span class="me1">extend</span><span class="br0">(</span>mapa_codificado_h<span class="br0">[</span>:-<span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
&nbsp;
   mapa_codificado.<span class="me1">append</span><span class="br0">(</span> <span class="nu0">254</span> <span class="br0">)</span>
&nbsp;
   <span class="kw1">if</span> mapa_codificado_v <span class="sy0">!=</span> <span class="br0">[</span><span class="br0">]</span>:
      mapa_codificado.<span class="me1">extend</span><span class="br0">(</span>mapa_codificado_v<span class="br0">)</span>
&nbsp;
   <span class="kw1">return</span> mapa_codificado
&nbsp;
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">def</span> Imprimir_Resultados<span class="br0">(</span> codificacion<span class="sy0">,</span> mapa_codificado <span class="br0">)</span>:
   <span class="kw1">print</span> <span class="st0">" ; Flag codificacion:"</span><span class="sy0">,</span> codificacion<span class="sy0">,</span> <span class="st0">"-a"</span> * agrupar_xy
   <span class="kw1">print</span> <span class="st0">" ; Resultado:"</span><span class="sy0">,</span> <span class="kw2">len</span><span class="br0">(</span>mapa_codificado<span class="br0">)</span><span class="sy0">,</span> <span class="st0">"Bytes"</span>
   <span class="co1"># Imprimimos los resultados de la codificacion</span>
   CONTADOR_DB <span class="sy0">=</span> -<span class="nu0">1</span>
   <span class="kw1">for</span> valor <span class="kw1">in</span> mapa_codificado:
      CONTADOR_DB +<span class="sy0">=</span> <span class="nu0">1</span>
      <span class="kw1">if</span> CONTADOR_DB <span class="sy0">==</span> <span class="nu0">0</span>:
         <span class="kw1">print</span> <span class="st0">" DB"</span><span class="sy0">,</span> <span class="kw2">str</span><span class="br0">(</span>valor<span class="br0">)</span><span class="sy0">,</span>
      <span class="kw1">elif</span> CONTADOR_DB <span class="sy0">==</span> <span class="nu0">11</span>:
         <span class="kw1">print</span> <span class="st0">","</span><span class="sy0">,</span> <span class="kw2">str</span><span class="br0">(</span>valor<span class="br0">)</span>
         CONTADOR_DB <span class="sy0">=</span> -<span class="nu0">1</span>
      <span class="kw1">else</span>:
         <span class="kw1">print</span> <span class="st0">","</span><span class="sy0">,</span> <span class="kw2">str</span><span class="br0">(</span>valor<span class="br0">)</span><span class="sy0">,</span>
&nbsp;
&nbsp;
<span class="co1">#-----------------------------------------------------------------------</span>
<span class="kw1">if</span> __name__ <span class="sy0">==</span> <span class="st0">'__main__'</span>:
&nbsp;
   <span class="co1"># Variables que utilizaremos </span>
   pantalla <span class="sy0">=</span> <span class="br0">[</span><span class="br0">]</span>
   COORD_X <span class="sy0">=</span> <span class="nu0">0</span>
   COORD_Y <span class="sy0">=</span> <span class="nu0">0</span>
&nbsp;
   <span class="co1"># Comprobar numero de argumentos + recoger y validar parametros:</span>
   <span class="kw1">if</span> <span class="kw2">len</span><span class="br0">(</span> <span class="kw3">sys</span>.<span class="me1">argv</span> <span class="br0">)</span> <span class="sy0">&lt;</span> <span class="nu0">3</span>:
      Uso<span class="br0">(</span><span class="br0">)</span>
&nbsp;
   <span class="kw1">if</span> <span class="st0">"-a"</span> <span class="kw1">in</span> <span class="kw3">sys</span>.<span class="me1">argv</span>:
      agrupar_xy <span class="sy0">=</span> <span class="nu0">1</span>
      args <span class="sy0">=</span> <span class="br0">[</span> arg <span class="kw1">for</span> arg <span class="kw1">in</span> <span class="kw3">sys</span>.<span class="me1">argv</span> <span class="kw1">if</span> arg <span class="sy0">!=</span> <span class="st0">'-a'</span> <span class="br0">]</span>
   <span class="kw1">else</span>:
      args <span class="sy0">=</span> <span class="kw3">sys</span>.<span class="me1">argv</span><span class="br0">[</span>:<span class="br0">]</span>
&nbsp;
   <span class="kw1">if</span> args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'-'</span>:
      codificacion<span class="sy0">=</span>args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span>
      fichero<span class="sy0">=</span>args<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span>
   <span class="kw1">elif</span> args<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'-'</span>:
      codificacion<span class="sy0">=</span>args<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span>
      fichero<span class="sy0">=</span>args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span>
   <span class="kw1">else</span>:
      Uso<span class="br0">(</span><span class="br0">)</span>
&nbsp;
   <span class="kw1">if</span> codificacion<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="kw1">not</span> <span class="kw1">in</span> <span class="st0">"bhvm"</span>:
      Uso<span class="br0">(</span><span class="br0">)</span>
&nbsp;
   <span class="co1"># Abrir el fichero de pantalla:</span>
   <span class="kw1">try</span>:
      fich <span class="sy0">=</span> <span class="kw2">open</span><span class="br0">(</span> fichero <span class="br0">)</span>
   <span class="kw1">except</span>:
      <span class="kw1">print</span> <span class="st0">"No se pudo abrir "</span><span class="sy0">,</span> <span class="kw3">sys</span>.<span class="me1">argv</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span>
      <span class="kw3">sys</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span>
&nbsp;
   <span class="co1"># Procesar el fichero "linea a linea"</span>
   <span class="kw1">for</span> linea <span class="kw1">in</span> fich.<span class="me1">readlines</span><span class="br0">(</span><span class="br0">)</span>:
&nbsp;
     pantalla.<span class="me1">append</span><span class="br0">(</span> <span class="br0">[</span><span class="br0">]</span> <span class="br0">)</span>
&nbsp;
     <span class="co1"># Eliminamos todo lo que no sean numeros, coma, y retorno de carro</span>
     linea <span class="sy0">=</span> <span class="kw2">filter</span><span class="br0">(</span><span class="kw1">lambda</span> c: c <span class="kw1">in</span> <span class="st0">"0123456789,"</span> + <span class="kw2">chr</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span> + <span class="kw2">chr</span><span class="br0">(</span><span class="nu0">13</span><span class="br0">)</span><span class="sy0">,</span> linea<span class="br0">)</span>
&nbsp;
     <span class="co1"># Si encontramos una coma en la linea, procesarla:</span>
     <span class="kw1">if</span> <span class="st0">','</span> <span class="kw1">in</span> linea:
&nbsp;
        <span class="co1"># Partimos la linea en valores separados por comas:</span>
        linea <span class="sy0">=</span> linea.<span class="me1">strip</span><span class="br0">(</span><span class="br0">)</span>
        rows <span class="sy0">=</span> linea.<span class="me1">split</span><span class="br0">(</span><span class="st0">','</span><span class="br0">)</span>
        <span class="kw1">if</span> <span class="kw2">len</span><span class="br0">(</span>rows<span class="br0">)</span> <span class="sy0">!=</span> ANCHO_MAPA:
          <span class="kw1">print</span> <span class="st0">"ERROR: Ancho ="</span><span class="sy0">,</span> <span class="kw2">len</span><span class="br0">(</span>rows<span class="br0">)</span><span class="sy0">,</span> <span class="st0">"valores. Esperados ="</span><span class="sy0">,</span> ANCHO_MAPA
          <span class="kw1">print</span> <span class="st0">"Finalizando programa: Por fvor corrija el fichero de datos."</span>
          <span class="kw3">sys</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span>
&nbsp;
        rows <span class="sy0">=</span> <span class="br0">[</span><span class="kw2">int</span><span class="br0">(</span>value<span class="br0">)</span> <span class="kw1">for</span> value <span class="kw1">in</span> rows<span class="br0">]</span>
        pantalla<span class="br0">[</span> COORD_Y <span class="br0">]</span>.<span class="me1">extend</span><span class="br0">(</span> rows <span class="br0">)</span>
&nbsp;
        COORD_Y +<span class="sy0">=</span> <span class="nu0">1</span>
   <span class="co1"># Fin lectura datos fichero</span>
&nbsp;
   <span class="kw1">if</span> COORD_Y <span class="sy0">!=</span> ALTO_MAPA:
      <span class="kw1">print</span> <span class="st0">"ERROR: Alto ="</span><span class="sy0">,</span> COORD_Y+<span class="nu0">1</span><span class="sy0">,</span> <span class="st0">"lineas. Esperados ="</span><span class="sy0">,</span> ALTO_MAPA
      <span class="kw1">print</span> <span class="st0">"Finalizando programa: Por fvor corrija el fichero de datos."</span>
      <span class="kw3">sys</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span>
&nbsp;
   <span class="kw1">if</span> codificacion <span class="kw1">in</span> <span class="br0">[</span> <span class="st0">"-h"</span><span class="sy0">,</span> <span class="st0">"-v"</span><span class="sy0">,</span> <span class="st0">"-b"</span> <span class="br0">]</span>:
      mapa_codificado <span class="sy0">=</span> Codificacion_Horiz_o_Vert<span class="br0">(</span> pantalla <span class="br0">)</span>
   <span class="kw1">elif</span> codificacion <span class="sy0">==</span> <span class="st0">'-m'</span>:
      mapa_codificado <span class="sy0">=</span> Codificacion_Mixta<span class="br0">(</span> pantalla <span class="br0">)</span>
&nbsp;
   <span class="co1"># Acabamos el mapa con el valor de fin de mapa</span>
   mapa_codificado.<span class="me1">append</span><span class="br0">(</span> <span class="nu0">255</span> <span class="br0">)</span>
&nbsp;
   <span class="co1"># Imprimimos los resultados</span>
   Imprimir_Resultados<span class="br0">(</span> codificacion<span class="sy0">,</span> mapa_codificado<span class="br0">)</span></pre>

<p>
 Ejecutamos el script de conversión mediante codificación básica (flag -b):
</p>
<pre class="code z80"><span class="sy0">$</span> .<span class="sy0">/</span>codificar_pantalla.py <span class="sy0">-</span><span class="kw2">b</span> pantalla.dat
 <span class="co1">; Flag codificacion: -b</span>
 <span class="co1">; Resultado: 106 Bytes</span>
 DB <span class="nu0">6</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">7</span> , <span class="re1">1</span> , <span class="nu0">3</span> , <span class="nu0">8</span> , <span class="re1">1</span> , <span class="re1">1</span> , <span class="nu0">9</span> , <span class="re1">1</span> , <span class="nu0">4</span>
 DB <span class="nu0">4</span> , <span class="nu0">2</span> , <span class="re1">1</span> , <span class="nu0">5</span> , <span class="nu0">2</span> , <span class="nu0">2</span> , <span class="nu0">6</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">9</span> , <span class="nu0">2</span> , <span class="nu0">5</span>
 DB <span class="re1">10</span> , <span class="nu0">2</span> , <span class="nu0">4</span> , <span class="nu0">4</span> , <span class="nu0">3</span> , <span class="nu0">4</span> , <span class="nu0">6</span> , <span class="nu0">3</span> , <span class="nu0">6</span> , <span class="nu0">7</span> , <span class="nu0">3</span> , <span class="nu0">6</span>
 DB <span class="re1">10</span> , <span class="nu0">3</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">7</span> , <span class="nu0">4</span> , <span class="nu0">6</span> , <span class="re1">10</span> , <span class="nu0">4</span> , <span class="nu0">4</span>
 DB <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="re1">10</span> , <span class="nu0">5</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">6</span> , <span class="nu0">5</span> , <span class="nu0">5</span> , <span class="nu0">6</span> , <span class="nu0">2</span>
 DB <span class="nu0">6</span> , <span class="nu0">6</span> , <span class="nu0">3</span> , <span class="nu0">9</span> , <span class="nu0">6</span> , <span class="nu0">2</span> , <span class="re1">10</span> , <span class="nu0">6</span> , <span class="nu0">3</span> , <span class="nu0">6</span> , <span class="nu0">7</span> , <span class="re1">1</span>
 DB <span class="re1">10</span> , <span class="nu0">7</span> , <span class="nu0">4</span> , <span class="nu0">6</span> , <span class="nu0">8</span> , <span class="nu0">4</span> , <span class="nu0">7</span> , <span class="nu0">8</span> , <span class="nu0">7</span> , <span class="nu0">8</span> , <span class="nu0">8</span> , <span class="nu0">7</span>
 DB <span class="nu0">9</span> , <span class="nu0">8</span> , <span class="nu0">7</span> , <span class="re1">10</span> , <span class="nu0">8</span> , <span class="nu0">5</span> , <span class="nu0">6</span> , <span class="nu0">9</span> , <span class="nu0">5</span> , <span class="nu0">7</span> , <span class="nu0">9</span> , <span class="nu0">2</span>
 DB <span class="nu0">8</span> , <span class="nu0">9</span> , <span class="nu0">3</span> , <span class="nu0">9</span> , <span class="nu0">9</span> , <span class="nu0">2</span> , <span class="re1">10</span> , <span class="nu0">9</span> , <span class="nu0">3</span>, <span class="nu0">255</span></pre>

<p>
 La codificación muestra, por ejemplo, cómo en la columna 6, fila 1, hay
 un tile 2 (lo cual es correcto). Le sigue un tile 3 en (7,1), etc. Las
filas y columnas se numeran desde cero y los valores 0 se ignoran (no se
 codifican).
</p>

<p>
 El mapa acaba con un valor 255. Dado que las diferentes pantallas de
juego no van a tener un tamaño fijo y común, es necesario este byte de
fin de pantalla para que nuestra rutina pueda determinar cuándo se ha
finalizado la impresión.
</p>

<p>
 El script codifica esta pantalla con 106 bytes cuando el tamaño
original era de 192, consiguiendo una compresión de aprox. el 46% (casi
la mitad de tamaño). Esto quiere decir que el mapeado de nuestro
programa podría ser (manteniendo este ratio de compresión en todas las
pantallas), hasta casi el doble de grande que el mapa máximo actual.
</p>

<p>
 Veamos a continuación una sencilla rutina que permitiría imprimir un
mapa con este tipo de codificación. La rutina se basa en recorrer el
array de datos de pantalla obtenido el valor X, Y y de TILE y llamando a
 DrawSprite16x16 para la impresión de cada tile:
</p>
<pre class="code z80"><span class="co1">;---------------------------------------------------------------</span>
<span class="co1">; DrawMap_16x16_Cod_Basica:</span>
<span class="co1">; Imprime una pantalla de tiles de 16x16 pixeles.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion             Parametro</span>
<span class="co1">; --------------------------------------------------------------</span>
<span class="co1">; DM_SPRITES (2 bytes)  Direccion de la tabla de tiles.</span>
<span class="co1">; DM_ATTRIBS (2 bytes)  Direccion de la tabla de atributos.</span>
<span class="co1">; DM_MAP     (2 bytes)  Direccion de la pantalla en memoria.</span>
<span class="co1">; DM_COORD_X (1 byte)   Coordenada X-Inicial en baja resolucion.</span>
<span class="co1">; DM_COORD_Y (1 byte)   Coordenada Y-Inicial en baja resolucion.</span>
<span class="co1">; DM_WIDTH   (1 byte)   Ancho del mapa en tiles</span>
<span class="co1">; DM_HEIGHT  (1 byte)   Alto del mapa en tiles</span>
<span class="co1">;---------------------------------------------------------------</span>
DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Basica:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (graficos)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (atributos)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>       <span class="co1">; B = Y_INICIO, C = X_INICIO</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>           <span class="co1">; DE apunta al mapa </span>
&nbsp;
drawm<span class="re1">1</span>6cb_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leemos el valor de COORD_X_TILE</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Apuntamos al siguiente byte del mapa</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">255</span>                    <span class="co1">; Bloque especial fin de pantalla</span>
   <span class="kw1">RET</span> Z                     <span class="co1">; En ese caso, salir</span>
&nbsp;
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                  <span class="co1">; A = (X_INICIO + COORD_X_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (X_INICIO + COORD_X_TILE) * 2</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>        <span class="co1">; Establecemos COORD_X a imprimir tile</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leemos el valor de COORD_Y_TILE</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                  <span class="co1">; A = (X_INICIO + COORD_X_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>        <span class="co1">; Establecemos COORD_Y a imprimir tile</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leemos el valor del TILE</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el TILE</span>
&nbsp;
   <span class="kw1">EXX</span>                       <span class="co1">; Preservar todos los registros en shadows</span>
   <span class="kw1">CALL</span> DrawSprite_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_LD  <span class="co1">; Imprimir el tile con los parametros</span>
   <span class="kw1">EXX</span>                       <span class="co1">; Recuperar valores de los registros</span>
&nbsp;
   <span class="kw1">JR</span> drawm<span class="re1">1</span>6cb_loop         <span class="co1">; Repetimos hasta encontrar el 255</span></pre>

<p>
 Este tipo de rutina de impresión puede no ser tan rápida como una
específica con el mapa en formato crudo pero supone un gran ahorro de
memoria y es posible que la diferencia de velocidad no sea importante o
perceptible. Hablamos de unas diferencias de tiempos de impresión que
siempre que no tratemos con un juego basado en scroll serán
imperceptibles por el usuario: alguien que juegue al Manic Miner no
podrá determinar si la pantalla en la que va a jugar durante varios
minutos ha sido dibujada en 0.03 o en 0.10 segundos. Aunque una rutina
tardara el triple que la otra, 1 décima de segundo de tiempo total de
impresión es inapreciable para el usuario.
</p>

<p>
 Por otra parte, como ya no estamos dibujando los bloques 0, antes de
llamar a la rutina de dibujado diferencial es necesario borrar el
contenido del área donde vamos a dibujar con el color plano del bloque 0
 para que el resultado de la impresión incluya los bloques vacíos en
aquellas áreas en que no dibujamos. Es decir, vaciaremos los “bloques
vacíos” borrando inicialmente la pantalla antes de realizar la impresión
 de los “bloques con datos”.
</p>

<p>
 Para borrar este área de pantalla podemos utilizar un simple borrado de
 atributos (establecer todos los atributos a cero) siempre y cuando los
personajes del juego que se moverán sobre las áreas “vacías” se dibujen
mediante transferencia y no mediante operaciones lógicas. Recordemos que
 si hemos borrado mediante atributos en negro estas áreas están vacías
de color pero no de contenido gráfico y la impresión con OR haría
aparecer el antiguo contenido gráfico de la pantalla. En el caso de
impresión de sprites con OR sobre el área “vacía” del mapa sería
necesario realizar el borrado previo a la impresión del mapa no como
borrado de atributos sino como borrado de zona gráfica y de atributos.
</p>

<p>
 El siguiente programa ejemplo hace uso de la anterior rutina:
</p>
<pre class="code z80">  <span class="co1">; Ejemplo impresion mapa de 16x16 codificacion basica</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="co1">;;; Borramos la pantalla (graficos y atributos)</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">CALL</span> ClearScreen
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">CALL</span> ClearAttributes
&nbsp;
  <span class="co1">;;; Establecer valores de llamada:</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_gfx
  <span class="kw1">LD</span> <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban<span class="re1">1</span>_attr
  <span class="kw1">LD</span> <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">HL</span>, sokoban_LEVEL<span class="re1">1</span>_codif_basica
  <span class="kw1">LD</span> <span class="br0">(</span>DM_MAP<span class="br0">)</span>, <span class="kw2">HL</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">6</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_WIDTH<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="re1">1</span><span class="nu0">2</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_HEIGHT<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">XOR</span> <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>
  <span class="kw1">LD</span> <span class="br0">(</span>DM_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
  <span class="co1">;;; Impresion de pantalla por codificacion basica</span>
  <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Basica
&nbsp;
loop:
  <span class="kw1">JR</span> loop
&nbsp;
DM_SPRITES  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">2</span><span class="re1">0</span>
DM_ATTRIBS  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">22</span>
DM_MAP      <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">24</span>
DM_COORD_X  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">26</span>
DM_COORD_Y  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">27</span>
DM_WIDTH    <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">28</span>
DM_HEIGHT   <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">00</span><span class="nu0">29</span>
&nbsp;
DS_SPRITES  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">0000</span>
DS_ATTRIBS  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">2</span>
DS_COORD_X  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">4</span>
DS_COORD_Y  <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">5</span>
DS_NUMSPR   <span class="kw3">EQU</span>  <span class="nu0">5</span><span class="re1">000</span><span class="nu0">6</span></pre>

<p>
 El resultado de la ejecución es el siguiente:
</p>

<p>
<br>

<img src="img/gfx5_codifb.png" class="mediacenter" alt=" Codificación básica "/>
<br>

</p>

<p>
<br>

<br>

</p>

</div>

<h4 id="mapeado-diferencial-con-agrupacion-por-scanlines">Mapeado diferencial con agrupación por scanlines</h4>
<div class="level4">

<p>
 La pega de la técnica de codificación básica es que por cada bloque a
imprimir estamos añadiendo 2 bytes de datos (coordenada X y coordenada
Y) por lo que si más de 1/3 de los bloques totales de la pantalla son
tiles a imprimir obtenemos una pantalla con más tamaño que la original.
</p>

<p>
 La solución es codificar tiles “consecutivos” de forma que sólo haya
que indicar una coordenada X e Y iniciales para cada “fila” o “columna”
de tiles gráficos. De esta forma, 4 tiles gráficos consecutivos se
codificarían como:
</p>
<pre class="code z80">  DB coordenada_x_primer_tile, coordenada_y_primer_tile,
  DB tile<span class="re1">1</span>, tile2, tile3, tile4, <span class="nu0">255</span>
  <span class="co1">; (255 = byte de fin de "scanline")</span></pre>

<p>
 Codificar estos 4 tiles con codificación básica hubiera requerido 4*3 =
 12 bytes, pero mediante este sistema se requieren sólo 7.
</p>

<p>
 La agrupación de tiles la podemos hacer buscando “conjuntos de tiles
horizontales” o “verticales”. Según el tipo de “scanline de tiles” que
generemos, necesitaremos codificar la pantalla de una forma o de otra y
utilizar una rutina de impresión u otra.
</p>

<p>
 Al final de nuestra pantalla necesitaremos un valor 255 adicional para
que la rutina de impresión, al recogerlo como coordenada X, detecta la
finalización de la misma.
</p>

<p>
<br>

<br>

<strong>Mapeado diferencial con agrupación por scanlines horizontales</strong>
<br>

</p>

<p>
 El script codificador en python que hemos visto en el apartado de codificación básica permite, mediante el flag “<strong>-h</strong>”
 codificar la pantalla buscando ristras de tiles horizontales
consecutivos y codificándolos de esta forma. Nótese que un sólo tile
sería codificado como una ristra de tamaño 1 (x, y, tile, 255).
</p>

<p>
 Para empezar, se certifica que una codificación basada en scanlines
horizontales de tiles da una pantalla codificada resultante más
reducida:
</p>
<pre class="code z80"><span class="sy0">$</span> .<span class="sy0">/</span>codificar_pantalla.py <span class="sy0">-</span><span class="kw2">h</span> pantalla.dat
 <span class="co1">; Flag codificacion: -h</span>
 <span class="co1">; Resultado: 87 Bytes</span>
 DB <span class="nu0">6</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="nu0">2</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">3</span>
 DB <span class="nu0">255</span> , <span class="nu0">9</span> , <span class="nu0">2</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="nu0">3</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">3</span>
 DB <span class="nu0">6</span> , <span class="nu0">6</span> , <span class="nu0">255</span> , <span class="re1">10</span> , <span class="nu0">3</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">7</span>
 DB <span class="nu0">4</span> , <span class="nu0">6</span> , <span class="nu0">255</span> , <span class="re1">10</span> , <span class="nu0">4</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="re1">10</span>
 DB <span class="nu0">5</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="nu0">6</span> , <span class="nu0">5</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">9</span> , <span class="nu0">6</span> , <span class="nu0">2</span>
 DB <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">7</span> , <span class="re1">1</span> , <span class="nu0">255</span> , <span class="re1">10</span> , <span class="nu0">7</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">8</span>
 DB <span class="nu0">4</span> , <span class="nu0">7</span> , <span class="nu0">7</span> , <span class="nu0">7</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">9</span> , <span class="nu0">5</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">2</span>
 DB <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">255</span></pre>

<p>
 Con esta codificación la pantalla original de 192 bytes que ocupaba 106
 bytes con codificación básica pasa a requerir sólo 87 bytes mediante
ristras de scanlines horizontales de tiles, lo que representa un 55% de
compresión.
</p>

<p>
 Veamos un ejemplo de rutina para imprimir este tipo de pantallas codificadas:
</p>
<pre class="code z80"><span class="co1">;---------------------------------------------------------------</span>
<span class="co1">; DrawMap_16x16_Cod_Horiz:</span>
<span class="co1">; Imprime una pantalla de tiles de 16x16 pixeles.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion             Parametro</span>
<span class="co1">; --------------------------------------------------------------</span>
<span class="co1">; DM_SPRITES (2 bytes)  Direccion de la tabla de tiles.</span>
<span class="co1">; DM_ATTRIBS (2 bytes)  Direccion de la tabla de atributos.</span>
<span class="co1">; DM_MAP     (2 bytes)  Direccion de la pantalla en memoria.</span>
<span class="co1">; DM_COORD_X (1 byte)   Coordenada X-Inicial en baja resolucion.</span>
<span class="co1">; DM_COORD_Y (1 byte)   Coordenada Y-Inicial en baja resolucion.</span>
<span class="co1">; DM_WIDTH   (1 byte)   Ancho del mapa en tiles</span>
<span class="co1">; DM_HEIGHT  (1 byte)   Alto del mapa en tiles</span>
<span class="co1">;---------------------------------------------------------------</span>
DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Horiz:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (graficos)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (atributos)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>       <span class="co1">; B = Y_INICIO, C = X_INICIO</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>           <span class="co1">; DE apunta al mapa </span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, DS_COORD_X
&nbsp;
drawm<span class="re1">1</span>6ch_read:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leemos el valor de COORD_X_TILE</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Apuntamos al siguiente byte del mapa</span>
&nbsp;
drawm<span class="re1">1</span>6ch_loop:
   <span class="kw1">CP</span> <span class="nu0">255</span>                    <span class="co1">; Bloque especial fin de pantalla</span>
   <span class="kw1">RET</span> Z                     <span class="co1">; En ese caso, salir</span>
&nbsp;
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                  <span class="co1">; A = (X_INICIO + COORD_X_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (X_INICIO + COORD_X_TILE) * 2</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Establecemos COORD_X a imprimir tile</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leemos el valor de COORD_Y_TILE</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                  <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_Y<span class="br0">)</span>, <span class="kw2">A</span>        <span class="co1">; Establecemos COORD_Y a imprimir tile</span>
&nbsp;
   <span class="co1">;;; Bucle impresion de todos los tiles del scanline (aunque sea 1 solo)</span>
&nbsp;
drawm<span class="re1">1</span>6ch_tileloop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leemos el valor del TILE de pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementamos puntero</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">255</span>
   <span class="kw1">JR</span> Z, drawm<span class="re1">1</span>6ch_read      <span class="co1">; Si es fin de tile codificado, fin bucle</span>
&nbsp;
   <span class="kw1">LD</span> <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el TILE</span>
&nbsp;
   <span class="kw1">EXX</span>                       <span class="co1">; Preservar todos los registros en shadows</span>
   <span class="kw1">CALL</span> DrawSprite_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_LD  <span class="co1">; Imprimir el tile con los parametros</span>
   <span class="kw1">EXX</span>                       <span class="co1">; Recuperar valores de los registros</span>
&nbsp;
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                  <span class="co1">; Avanzamos al siguiente tile</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                  <span class="co1">; COORD_X = COORD_X + 2</span>
&nbsp;
   <span class="kw1">JR</span> drawm<span class="re1">1</span>6ch_tileloop     <span class="co1">; Repetimos hasta encontrar el 255</span></pre>

<p>
<br>

<br>

<strong>Mapeado diferencial con agrupación por scanlines verticales</strong>
<br>

</p>

<p>
 Según el tipo de pantalla que estemos codificando, es posible que
existan más agrupaciones de bloques en “scanlines verticales” (columnas
de bloques) que horizontales (filas de bloques). En ese caso, puede
convenirmos codificar los bloques por scanlines verticales.
</p>

<p>
 Si utilizamos el script en python con el flag <strong>-v</strong> sobre la pantalla de ejemplo, obtenemos la siguiente pantalla codificada:
</p>
<pre class="code z80"><span class="sy0">$</span> .<span class="sy0">/</span>codificar_pantalla.py <span class="sy0">-</span>v pantalla.dat
 <span class="co1">; Flag codificacion: -v  :</span>
 <span class="co1">; Resultado: 78 Bytes</span>
 DB <span class="nu0">6</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">6</span> , <span class="nu0">255</span> , <span class="nu0">7</span> , <span class="re1">1</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">8</span> , <span class="re1">1</span>
 DB <span class="re1">1</span> , <span class="nu0">255</span> , <span class="nu0">9</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="nu0">2</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">5</span>
 DB <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">5</span> , <span class="nu0">2</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="re1">10</span> , <span class="nu0">2</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">4</span>
 DB <span class="nu0">5</span> , <span class="nu0">3</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">7</span> , <span class="nu0">3</span> , <span class="nu0">6</span> , <span class="nu0">6</span> , <span class="nu0">255</span> , <span class="nu0">5</span>
 DB <span class="nu0">6</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">6</span> , <span class="nu0">3</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">9</span> , <span class="nu0">6</span>
 DB <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">7</span> , <span class="nu0">8</span> , <span class="nu0">7</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">8</span> , <span class="nu0">8</span> , <span class="nu0">7</span> , <span class="nu0">3</span> , <span class="nu0">255</span>
 DB <span class="nu0">9</span> , <span class="nu0">8</span> , <span class="nu0">7</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">255</span></pre>

<p>
 En este caso tenemos un tamaño de pantalla de 78 bytes, todavía menor
que la codificación por scanlines horizontales. Para otras pantallas y
casos el resultado de la codificación podría ser mejor con scanlines
horizontales.
</p>

<p>
 A continuación se transcribe la rutina de impresión de una pantalla codificada en scanlines verticales:
</p>
<pre class="code z80"><span class="co1">;---------------------------------------------------------------</span>
<span class="co1">; DrawMap_16x16_Cod_Vert:</span>
<span class="co1">; Imprime una pantalla de tiles de 16x16 pixeles.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion             Parametro</span>
<span class="co1">; --------------------------------------------------------------</span>
<span class="co1">; DM_SPRITES (2 bytes)  Direccion de la tabla de tiles.</span>
<span class="co1">; DM_ATTRIBS (2 bytes)  Direccion de la tabla de atributos.</span>
<span class="co1">; DM_MAP     (2 bytes)  Direccion de la pantalla en memoria.</span>
<span class="co1">; DM_COORD_X (1 byte)   Coordenada X-Inicial en baja resolucion.</span>
<span class="co1">; DM_COORD_Y (1 byte)   Coordenada Y-Inicial en baja resolucion.</span>
<span class="co1">; DM_WIDTH   (1 byte)   Ancho del mapa en tiles</span>
<span class="co1">; DM_HEIGHT  (1 byte)   Alto del mapa en tiles</span>
<span class="co1">;---------------------------------------------------------------</span>
DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Vert:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (graficos)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (atributos)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>       <span class="co1">; B = Y_INICIO, C = X_INICIO</span>
   <span class="kw1">LD</span> <span class="kw2">DE</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>           <span class="co1">; DE apunta al mapa </span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, DS_COORD_Y         <span class="co1">; CAMBIO: Ahora HL apunta a la variable Y</span>
&nbsp;
drawm<span class="re1">1</span>6cv_read:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leemos el valor de COORD_X_TILE</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Apuntamos al siguiente byte del mapa</span>
&nbsp;
drawm<span class="re1">1</span>6cv_loop:
   <span class="kw1">CP</span> <span class="nu0">255</span>                    <span class="co1">; Bloque especial fin de pantalla</span>
   <span class="kw1">RET</span> Z                     <span class="co1">; En ese caso, salir</span>
&nbsp;
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                  <span class="co1">; A = (X_INICIO + COORD_X_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (X_INICIO + COORD_X_TILE) * 2</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_COORD_X<span class="br0">)</span>, <span class="kw2">A</span>        <span class="co1">; CAMBIO: Establecemos COORD_X a imprimir tile</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leemos el valor de COORD_Y_TILE</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                  <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; CAMBIO: Establecemos COORD_Y a imprimir tile</span>
&nbsp;
   <span class="co1">;;; Bucle impresion de todos los tiles del scanline (aunque sea 1 solo)</span>
&nbsp;
drawm<span class="re1">1</span>6cv_tileloop:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>                <span class="co1">; Leemos el valor del TILE de pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>                    <span class="co1">; Incrementamos puntero</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">255</span>
   <span class="kw1">JR</span> Z, drawm<span class="re1">1</span>6cv_read      <span class="co1">; Si es fin de tile codificado, fin bucle</span>
&nbsp;
   <span class="kw1">LD</span> <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el TILE</span>
&nbsp;
   <span class="kw1">EXX</span>                       <span class="co1">; Preservar todos los registros en shadows</span>
   <span class="kw1">CALL</span> DrawSprite_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_LD  <span class="co1">; Imprimir el tile con los parametros</span>
   <span class="kw1">EXX</span>                       <span class="co1">; Recuperar valores de los registros</span>
&nbsp;
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                  <span class="co1">; COORD_Y = COORD_Y + 2</span>
&nbsp;
   <span class="kw1">JR</span> drawm<span class="re1">1</span>6cv_tileloop     <span class="co1">; Repetimos hasta encontrar el 255</span></pre>

<p>
<br>

<br>

<strong>Mapeado diferencial con agrupación mixta</strong>
<br>

</p>

<p>
 Finalmente, cabe la posibilidad de que en una misma pantalla nos
encontremos “filas” de tiles y “columnas” de tiles que convenga
codificar con un método u otro.
</p>

<p>
 Por ejemplo, cabe la posibilidad de que en 3 tiles horizontales
consecutivos nos encontremos con el que el de el medio forme parte de
una fila vertical de tiles de gran tamaño, por lo que nos interesará
codificar ese tile como scanline vertical antes que los 3 como
horizontal.
</p>

<p>
 El formato de salida que vamos a utilizar en las pantallas será el siguiente:
</p>

<p>
 El codificador debe codificar todos los scanlines horizontales de tiles
 acabados en el identificador de fin de scanline 255 menos el último, el
 cual acabará con un valor 254. A continuación almacenará todos los
scanlines verticales de tiles acabados en 255. Un valor 255 final
indicará el fin de pantalla.
</p>

<p>
 El valor 254 permite a la rutina de impresión saber cuándo hemos
acabado de imprimir los scanlines horizontales y le indica que debe
interpretar todos los scanlines restantes como verticales. De esta forma
 nos ahorramos el tener que incluir un byte con el tipo de codificación
precediendo a cada scanline, y ahorrando así 1 byte adicional por
“agrupación”.
</p>

<p>
 Como desventaja, nuestro tileset sólo puede contener ahora 254 tiles (0-253).
</p>

<p>
 Nuestro script de conversión en Python, con el flag “<strong>-m</strong>”,
 calcula todas las posibilidades de codificación de cada tile y los
procesa en orden de mayor a menor cantidad de tiles agrupados para
codificar toda la pantalla en un formato mixto donde cada ristra de
datos de la pantalla tendría el siguiente aspecto:
</p>
<pre class="code z80">Pantalla:
  DB coordenada_x_primer_tile_horiz, coordenada_y_primer_tile_horiz,
  DB tile<span class="re1">1</span>, tile2, <span class="br0">(</span>...<span class="br0">)</span>, tileN, <span class="nu0">255</span>
  DB coordenada_x_primer_tile_horiz, coordenada_y_primer_tile_horiz,
  DB tile<span class="re1">1</span>, tile2, <span class="br0">(</span>...<span class="br0">)</span>, tileN, <span class="nu0">254</span>
  DB coordenada_x_primer_tile_vert, coordenada_y_primer_tile_vert,
  DB tile<span class="re1">1</span>, tile2, <span class="br0">(</span>...<span class="br0">)</span>, tileN, <span class="nu0">255</span>
  DB coordenada_x_primer_tile_vert, coordenada_y_primer_tile_vert,
  DB tile<span class="re1">1</span>, tile2, <span class="br0">(</span>...<span class="br0">)</span>, tileN, <span class="nu0">255</span>
  DB <span class="nu0">255</span>
&nbsp;
  <span class="co1">; Donde:</span>
  <span class="co1">; 255 como coordenada_x = fin de pantalla.</span>
  <span class="co1">; 255 a final de scanline = byte de fin de "scanline"</span>
  <span class="co1">; 254 a final de scanline = cambio de codificacion de horizontal a vertical</span></pre>

<p>
 Veamos la compresión de la pantalla de Sokoban que hemos venido utilizando como ejemplo:
</p>
<pre class="code z80"><span class="sy0">$</span> .<span class="sy0">/</span>codificar_pantalla.py <span class="sy0">-</span>m pantalla.dat
 <span class="co1">; Flag codificacion: -m</span>
 <span class="co1">; Resultado: 72 Bytes</span>
 DB <span class="nu0">6</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">8</span> , <span class="nu0">4</span> , <span class="nu0">7</span> , <span class="nu0">7</span>
 DB <span class="nu0">7</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">9</span> , <span class="nu0">5</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">5</span> , <span class="nu0">2</span> , <span class="nu0">2</span>
 DB <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">3</span> , <span class="nu0">6</span> , <span class="nu0">6</span> , <span class="nu0">255</span> , <span class="nu0">5</span> , <span class="nu0">6</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">255</span>
 DB <span class="nu0">9</span> , <span class="nu0">2</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">7</span> , <span class="nu0">4</span> , <span class="nu0">6</span> , <span class="nu0">255</span> , <span class="nu0">9</span> , <span class="nu0">6</span> , <span class="nu0">2</span> , <span class="nu0">255</span>
 DB <span class="nu0">6</span> , <span class="nu0">7</span> , <span class="re1">1</span> , <span class="nu0">254</span> , <span class="re1">10</span> , <span class="nu0">2</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">3</span> , <span class="nu0">4</span>
 DB <span class="nu0">5</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="nu0">2</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">255</span></pre>

<p>
 Hemos reducido el tamaño de la pantalla codificada de 192 bytes a 72
bytes (6 bytes menos que la mejor de las anteriores codificaciones, la
vertical).
</p>

<p>
 Aunque 6 bytes pueda parecer un valor insignificante, 100 pantallas de
juego con el mismo ahorro supone una reducción de 600 bytes lo que
permitiría añadir 8 pantallas de juego más, o tal vez más código, sonido
 o gráficos.
</p>

<p>
 Esta rutina producirá generalmente codificaciones mejores que las
únicamente horizontales o verticales en pantallas con “formas” variadas.
 Lo ideal es codificar cada pantalla con el tipo de codificación que
mejores resultados obtenga y utilizar una rutina de impresión que llame a
 una de las 3 rutinas (horizontal, vertical o mixta) según cómo se haya
codificado la pantalla.
</p>

<p>
 La rutina de impresión de este tipo de codificación es una fusión entre
 las 2 rutinas anteriores, donde usaremos en esta ocasión IX para
acceder al mapeado y HL y DE apuntarán a las coordenadas X e Y para los 2
 posibles bucles de impresión que se utilizarán en función de si estamos
 imprimiendo scanlines horizontales o verticales.
</p>

<p>
 Concretamente, tomamos como base la rutina de impresión de scanlines
horizontales y utilizamos un sencillo truco para convertirla en la
rutina de impresión de scanlines verticales. Lo haremos mediante <strong>código automodificable</strong> (self-modifying code).
</p>

<p>
 Primero, cargamos en HL la dirección de la variable COORD_X y en DE la dirección de la variable COORD_Y:
</p>
<pre class="code z80">   <span class="kw1">LD</span> <span class="kw2">DE</span>, DS_COORD_Y         <span class="co1">; DE apunta a la coordenada Y</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, DS_COORD_X         <span class="co1">; HL apunta a la coordenada X</span></pre>

<p>
 Despues, incluímos 2 instrucciones <strong>NOP</strong> (de 1 byte, con opcode 0), antes y después de los <strong>INC (HL)</strong>
 que producen el incremento de la coordenada apuntada por HL (COORD_X).
Además, establecemos 2 etiquetas del programa ensamblador en las
posiciones de los 2 NOPs para poder referenciar la dirección de memoria
donde se han ensamblado estos NOPs en el código:
</p>
<pre class="code z80">drawm<span class="re1">1</span>6cm_dir<span class="re1">1</span>:
   <span class="kw1">NOP</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                  <span class="co1">; COORD = COORD + 2</span>
drawm<span class="re1">1</span>6cm_dir2:
   <span class="kw1">NOP</span></pre>

<p>
 Cuando entramos por primera vez en la rutina, y comenzamos a procesar
“scanlines”, sabemos que son todos horizontales hasta que encontremos el
 valor “254” (cambio de horizontales a verticales), por lo que nuestra
rutina de impresión de tiles en bucle horizontal funciona adecuadamente:
 se ejecuta un NOP (que no tiene ningún efecto salvo el consumo de 4
ciclos de reloj), después los 2 INC (HL) y luego otro NOP, lo que
produce el incremento de COORD_X en 2 unidades (HL apunta a COORD_X).
</p>

<p>
 Cuando la rutina encuentra un valor 254 como “fin de scanline” debe de
cambiar al modo de impresión vertical, por lo que dentro del bucle de
procesado del scanline añadimos el siguiente código:
</p>
<pre class="code z80">drawm<span class="re1">1</span>6cm_tileloop:
&nbsp;
   <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">254</span>
   <span class="kw1">JR</span> Z, drawm<span class="re1">1</span>6cm_switch    <span class="co1">; Codigo 254 -&gt; cambiar a codif. vertical</span>
&nbsp;
   <span class="br0">(</span>...<span class="br0">)</span>
&nbsp;
drawm<span class="re1">1</span>6cm_switch:
   <span class="co1">;;; Cambio de codificacion de horizontal a vertical:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>EB                 <span class="co1">; Opcode de EX DE, HL</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cm_dir<span class="re1">1</span><span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; Lo escribimos sobre los NOPs</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cm_dir2<span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">JR</span> drawm<span class="re1">1</span>6cm_read</pre>

<p>
 Es decir, cuando se encuentra un valor 254 como fin de scanline saltamos a drawm16cm_switch, la cual escribe un valor <strong>$EB</strong> (EX DE, HL) en las posiciones de memoria donde antes había un NOP, cambiando la porción de código que habíamos visto antes por:
</p>
<pre class="code z80">drawm<span class="re1">1</span>6cm_dir<span class="re1">1</span>:
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                  <span class="co1">; COORD = COORD + 2</span>
drawm<span class="re1">1</span>6cm_dir2:
   <span class="kw1">EX</span> <span class="kw2">DE</span>, <span class="kw2">HL</span></pre>

<p>
 Esto provoca que, a partir de haber encontrado el 254 y hasta que
finalice la rutina (código 255 de fin de pantalla), los INC (HL)
incrementen COORD_Y (debido al EX DE, HL) en lugar de COORD_X,
convirtiendo la rutina en un sistema de impresión de scanlines
horizontales.
</p>

<p>
 Cuando salimos de la rutina, esta se queda con los valores de “EX DE,
HL” en memoria, por lo que la siguiente vez que sea llamada tenemos que
asegurarnos de que vuelven a estar los NOPs en su lugar, porque las
pantallas siempre empiezan por scanlines horizontales. Para lograr esto,
 nuestra rutina debe empezar por la colocación del “NOP” en las
direcciones apuntadas por las etiquetas:
</p>
<pre class="code z80">DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Mixta:
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>                     <span class="co1">; Opcode de "NOP"</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cm_dir<span class="re1">1</span><span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; Almacenar en la posicion de las labels</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cm_dir2<span class="br0">)</span>, <span class="kw2">A</span></pre>

<p>
 Veamos el código completo de la rutina de impresión mixta:
</p>
<pre class="code z80"><span class="co1">;---------------------------------------------------------------</span>
<span class="co1">; DrawMap_16x16_Cod_Mixta:</span>
<span class="co1">; Imprime una pantalla de tiles de 16x16 pixeles.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion             Parametro</span>
<span class="co1">; --------------------------------------------------------------</span>
<span class="co1">; DM_SPRITES (2 bytes)  Direccion de la tabla de tiles.</span>
<span class="co1">; DM_ATTRIBS (2 bytes)  Direccion de la tabla de atributos.</span>
<span class="co1">; DM_MAP     (2 bytes)  Direccion de la pantalla en memoria.</span>
<span class="co1">; DM_COORD_X (1 byte)   Coordenada X-Inicial en baja resolucion.</span>
<span class="co1">; DM_COORD_Y (1 byte)   Coordenada Y-Inicial en baja resolucion.</span>
<span class="co1">; DM_WIDTH   (1 byte)   Ancho del mapa en tiles</span>
<span class="co1">; DM_HEIGHT  (1 byte)   Alto del mapa en tiles</span>
<span class="co1">;---------------------------------------------------------------</span>
DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Mixta:
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>                     <span class="co1">; Opcode de "NOP"</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cm_dir<span class="re1">1</span><span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; Almacenar en la posicion de labels</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cm_dir2<span class="br0">)</span>, <span class="kw2">A</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (graficos)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (atributos)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>       <span class="co1">; B = Y_INICIO, C = X_INICIO</span>
   <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>           <span class="co1">; DE apunta al mapa </span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">DE</span>, DS_COORD_Y         <span class="co1">; DE apunta a la coordenada Y</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, DS_COORD_X         <span class="co1">; HL apunta a la coordenada X</span>
&nbsp;
drawm<span class="re1">1</span>6cm_read:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; Leemos el valor de COORD_X_TILE</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>                    <span class="co1">; Apuntamos al siguiente byte del mapa</span>
&nbsp;
drawm<span class="re1">1</span>6cm_loop:
   <span class="kw1">CP</span> <span class="nu0">255</span>                    <span class="co1">; Bloque especial fin de pantalla</span>
   <span class="kw1">RET</span> Z                     <span class="co1">; En ese caso, salir</span>
&nbsp;
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                  <span class="co1">; A = (X_INICIO + COORD_X_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (X_INICIO + COORD_X_TILE) * 2</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Establecemos COORD_X a imprimir tile</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; Leemos el valor de COORD_Y_TILE</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                  <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Establecemos COORD_Y a imprimir tile</span>
&nbsp;
   <span class="co1">;;; Bucle impresion vertical de los N tiles del scanline</span>
drawm<span class="re1">1</span>6cm_tileloop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; Leemos el valor del TILE de pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>                    <span class="co1">; Incrementamos puntero</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">255</span>
   <span class="kw1">JR</span> Z, drawm<span class="re1">1</span>6cm_read      <span class="co1">; Si es fin de tile codificado, fin bucle</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">254</span>
   <span class="kw1">JR</span> Z, drawm<span class="re1">1</span>6cm_switch    <span class="co1">; Codigo 254 -&gt; cambiar a codif. vertical</span>
&nbsp;
   <span class="kw1">LD</span> <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el TILE</span>
   <span class="kw1">EXX</span>                       <span class="co1">; Preservar todos los registros en shadows</span>
   <span class="kw1">CALL</span> DrawSprite_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_LD  <span class="co1">; Imprimir el tile con los parametros</span>
   <span class="kw1">EXX</span>                       <span class="co1">; Recuperar valores de los registros</span>
&nbsp;
drawm<span class="re1">1</span>6cm_dir<span class="re1">1</span>:              <span class="co1">; Etiqueta con la direccion del NOP</span>
   <span class="kw1">NOP</span>                       <span class="co1">; NOP-&gt;INC COORD_X,  EX DE,HL-&gt;INC COORD_Y</span>
&nbsp;
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                  <span class="co1">; COORD = COORD + 2</span>
&nbsp;
drawm<span class="re1">1</span>6cm_dir2:              <span class="co1">; Etiqueta con la direccion del NOP</span>
   <span class="kw1">NOP</span>                       <span class="co1">; NOP-&gt;INC COORD_X,  EX DE,HL-&gt;INC COORD_Y</span>
&nbsp;
   <span class="kw1">JR</span> drawm<span class="re1">1</span>6cm_tileloop     <span class="co1">; Repetimos hasta encontrar el 255</span>
&nbsp;
drawm<span class="re1">1</span>6cm_switch:
   <span class="co1">;;; Cambio de codificacion de horizontal a vertical:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>EB                 <span class="co1">; Opcode de EX DE, HL</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cm_dir<span class="re1">1</span><span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; Ahora se hace el EX DE, HL y por lo tanto</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cm_dir2<span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; INC (HL) incrementa COORD_Y en vez de X</span>
   <span class="kw1">JR</span> drawm<span class="re1">1</span>6cm_read         <span class="co1">; Volvemos al bucle de lectura</span></pre>

<p>
 Con el sistema de “automodificación de código” nos ahorramos el
disponer de 2 porciones de código para realizar una misma tarea en la
que cambia algún salto o alguna instrucción específica.
</p>

<p>
 Esta técnica sirve para gran cantidad de optimizaciones en rutinas de
este tipo: podemos por ejemplo en algunas rutinas modificar el código en
 memoria para evitar saltos (reemplazar la instruccion de comparacion o
de salto por instrucciones que no lo provoquen o por NOPs) o evitar la
duplicación de código.
</p>

<p>
<br>

<br>

<strong>Codificar X e Y en un único byte</strong>
<br>

<br>

</p>

<p>
 Veamos una modificación del script/programa de codificación y de la
rutinas de impresión que nos van a resultar realmente útiles siempre que
 nuestro mapa no esté formado por tiles de 8×8 píxeles.
</p>

<p>
 Si el tamaño en tiles de nuestra pantalla de juego es menor que 16×16
bloques podemos codificar las coordenadas X e Y en un mismo byte.
</p>

<p>
 Al ser el mapa de tamaño menor que 16×16, ambas coordenadas pueden ir
en el rango 0 a 15, por lo que cada una de las 2 coordenadas puede ser
codificada en 4 bits. De esta forma, nuestro script codificador puede
componer un byte de posición con la coordenada X en el nibble alto de un
 byte y la coordenada Y en el nibble bajo del mismo (o a la inversa).
</p>

<p>
 De esta forma ahorramos 1 byte por cada scanline codificado, un ahorro que puede ser bastante significativo.
</p>

<p>
 La modificación realizada en nuestro script codificador ha sido el
cambiar en todos los métodos de codificación las 2 líneas siguientes:
</p>
<pre class="code z80">  mapa_codificado.append<span class="br0">(</span> X <span class="br0">)</span>
  mapa_codificado.append<span class="br0">(</span> Y <span class="br0">)</span></pre>

<p>
 por:
</p>
<pre class="code z80">  mapa_codificado.append<span class="br0">(</span> <span class="br0">(</span>X <span class="sy0">*</span> <span class="re1">1</span><span class="nu0">6</span><span class="br0">)</span> <span class="sy0">+</span> Y <span class="br0">)</span></pre>

<p>
 Aunque hemos dicho que el tamaño máximo del mapa será de 16×16, la
realidad es que puede ser como máximo de 16×14, ya que si ambas
coordenadas X e Y valen 15 ($F), el byte resultante compuesto sería $FF
que es el código de final de pantalla. De la misma forma, si X vale 15 e
 Y vale 14, el valor resultante, $FE, sería confundido por la rutina
mixta con el código especial de cambio de scanlines horizontales a
verticales.
</p>

<p>
 Así, con un mapa de 16×14, el máximo tamaño de pantalla que podemos ocupar según las dimensiones de cada tile serían:
</p>
<div class="table-responsive sectionedit15"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Tamaño de mapa </th><th class="col1"> Tamaño de tile </th><th class="col2"> Ancho de pantalla </th><th class="col3"> Alto de pantalla </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 16×14 </td><td class="col1"> 8×8 </td><td class="col2"> 128 píxeles </td><td class="col3"> 112 píxeles </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 16×12 </td><td class="col1"> 16×16 </td><td class="col2"> 256 píxeles </td><td class="col3"> 192 píxeles </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 8×6 </td><td class="col1"> 32×32 </td><td class="col2"> 256 píxeles </td><td class="col3"> 192 píxeles </td>
	</tr>
</tbody></table></div>

<p>
 Las dimensiones que podemos ver en la tabla hacen esta optimización inusable para juegos con tiles de 8×8 pixeles.
</p>

<p>
 Por otra parte, recordemos que debemos modificar la rutina para que
separe los bytes de COORD_X y COORD_Y en 2 valores diferentes, lo que
supone un pequeño tiempo adicional de procesado por cada scanline.
</p>

<p>
 Nuestra pantalla de pruebas es de 16×12, por lo que podemos perfectamente codificarla con esta técnica, utilizando el flag <strong>-a</strong>, además del tipo de codificación:
</p>
<pre class="code z80"><span class="sy0">$</span> .<span class="sy0">/</span>codificar_pantalla.py <span class="sy0">-</span>m <span class="sy0">-</span><span class="kw2">a</span> pantalla.dat
 <span class="co1">; Flag codificacion: -m -a</span>
 <span class="co1">; Resultado: 60 Bytes</span>
 DB <span class="nu0">97</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="re1">10</span><span class="nu0">4</span> , <span class="nu0">4</span> , <span class="nu0">7</span> , <span class="nu0">7</span> , <span class="nu0">7</span> , <span class="nu0">255</span>
 DB <span class="re1">10</span><span class="nu0">5</span> , <span class="nu0">5</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">82</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">99</span> , <span class="nu0">6</span>
 DB <span class="nu0">6</span> , <span class="nu0">255</span> , <span class="nu0">86</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="re1">1</span><span class="nu0">46</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="re1">11</span><span class="nu0">6</span> , <span class="nu0">6</span> , <span class="nu0">255</span>
 DB <span class="re1">1</span><span class="nu0">5</span><span class="re1">0</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="re1">10</span><span class="nu0">3</span> , <span class="re1">1</span> , <span class="nu0">254</span> , <span class="re1">1</span><span class="nu0">62</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">3</span>
 DB <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">66</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">255</span></pre>

<p>
 En esta ocasión hemos obtenido la pantalla codificada con un total de
60 bytes, ya que nos hemos ahorrado 1 byte por cada scanline codificado.
</p>

<p>
 Podemos modificar cualquiera de las rutinas de impresión que hemos
visto para adaptarlas al uso de coordenadas X e Y en un mismo byte,
simplemente cambiando el código que recoge desde el mapa ambas
coordenadas.
</p>

<p>
 Cambiamos:
</p>
<pre class="code z80">   <span class="co1">;;; (venimos del LD A, (IX+0) / INC IX de la coordenada X)</span>
&nbsp;
   <span class="co1">;;; Sumamos la coordenada X recogida y obtenemos desde el mapa la Y:</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                  <span class="co1">; A = (X_INICIO + COORD_X_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (X_INICIO + COORD_X_TILE) * 2</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Establecemos COORD_X a imprimir tile</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; Leemos el valor de COORD_Y_TILE</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                  <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Establecemos COORD_Y a imprimir tile</span></pre>

<p>
 por:
</p>
<pre class="code z80">   <span class="kw1">PUSH</span> <span class="kw2">AF</span>
   <span class="kw1">AND</span> <span class="re1">%11110000</span>             <span class="co1">; Nos quedamos con la parte alta (COORD_X)</span>
   <span class="kw1">RRCA</span>                      <span class="co1">; Pasamos parte alta a parte baja</span>
   <span class="kw1">RRCA</span>                      <span class="co1">; con 4 desplazamientos</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>                      <span class="co1">; Ya podemos sumar:</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                  <span class="co1">; A = (X_INICIO + COORD_X_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (X_INICIO + COORD_X_TILE) * 2</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Establecemos COORD_X a imprimir tile</span>
&nbsp;
   <span class="kw1">POP</span> <span class="kw2">AF</span>
   <span class="kw1">AND</span> <span class="re1">%00001111</span>             <span class="co1">; Nos quedamos con la parte baja (COORD_Y)</span>
&nbsp;
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                  <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Establecemos COORD_Y a imprimir tile</span></pre>

<p>
 De la rutina original hemos eliminado las instrucciones “<strong>LD A, (IX+0)</strong>” e “<strong>INC IX</strong>”
 (29 ciclos de reloj menos) y hemos añadido PUSH/POP AF e instrucciones
AND y RLCA (51 ciclos de reloj más) resultando en una rutina que es 22
ciclos de reloj más lenta por scanline. Pero a cambio de estos 22 ciclos
 de reloj se pueden producir grandes ahorros en las pantallas
resultantes.
</p>

<p>
 La rutina de impresión de 16×16 Mixta con coordenadas X e Y codificadas en un mismo byte quedaría como el código que sigue:
</p>
<pre class="code z80"><span class="co1">;---------------------------------------------------------------</span>
<span class="co1">; DrawMap_16x16_Cod_Mixta_XY: (X e Y codificados en mismo byte)</span>
<span class="co1">; Imprime una pantalla de tiles de 16x16 pixeles.</span>
<span class="co1">;</span>
<span class="co1">; Entrada (paso por parametros en memoria):</span>
<span class="co1">; Direccion             Parametro</span>
<span class="co1">; --------------------------------------------------------------</span>
<span class="co1">; DM_*  = Variables de MAPA</span>
<span class="co1">; DS_*  = Variables de SPRITE</span>
<span class="co1">;---------------------------------------------------------------</span>
DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Mixta_XY:
&nbsp;
   <span class="kw1">XOR</span> <span class="kw2">A</span>                     <span class="co1">; Opcode de "NOP"</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cmxy_dir<span class="re1">1</span><span class="br0">)</span>, <span class="kw2">A</span>  <span class="co1">; Almacenar en la posicion de las labels</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cmxy_dir2<span class="br0">)</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_SPRITES<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_SPRITES<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (graficos)</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_ATTRIBS<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DS_ATTRIBS<span class="br0">)</span>, <span class="kw2">HL</span>       <span class="co1">; Establecer tileset (atributos)</span>
   <span class="kw1">LD</span> <span class="kw2">BC</span>, <span class="br0">(</span>DM_COORD_X<span class="br0">)</span>       <span class="co1">; B = Y_INICIO, C = X_INICIO</span>
   <span class="kw1">LD</span> <span class="kw2">IX</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>           <span class="co1">; DE apunta al mapa </span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">DE</span>, DS_COORD_Y         <span class="co1">; DE apunta a la coordenada Y</span>
   <span class="kw1">LD</span> <span class="kw2">HL</span>, DS_COORD_X         <span class="co1">; HL apunta a la coordenada X</span>
&nbsp;
drawm<span class="re1">1</span>6cmxy_read:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; Leemos el valor de COORDENADAS</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>                    <span class="co1">; Apuntamos al siguiente byte del mapa</span>
&nbsp;
drawm<span class="re1">1</span>6cmxy_loop:
   <span class="kw1">CP</span> <span class="nu0">255</span>                    <span class="co1">; Bloque especial fin de pantalla</span>
   <span class="kw1">RET</span> Z                     <span class="co1">; En ese caso, salir</span>
&nbsp;
   <span class="kw1">PUSH</span> <span class="kw2">AF</span>                   <span class="co1">; Extraccion de coordenadas XY en X e Y</span>
   <span class="kw1">AND</span> <span class="re1">%11110000</span>             <span class="co1">; Nos quedamos con la parte alta (COORD_X)</span>
   <span class="kw1">RRCA</span>                      <span class="co1">; Pasamos parte alta a parte baja</span>
   <span class="kw1">RRCA</span>                      <span class="co1">; con 4 desplazamientos</span>
   <span class="kw1">RRCA</span>
   <span class="kw1">RRCA</span>                      <span class="co1">; Ya podemos sumar</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                  <span class="co1">; A = (X_INICIO + COORD_X_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (X_INICIO + COORD_X_TILE) * 2</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Establecemos COORD_X a imprimir tile</span>
   <span class="kw1">POP</span> <span class="kw2">AF</span>
   <span class="kw1">AND</span> <span class="re1">%00001111</span>             <span class="co1">; Nos quedamos con la parte baja (COORD_Y)</span>
   <span class="kw1">ADD</span> <span class="kw2">A</span>, <span class="kw2">B</span>                  <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">RLCA</span>                      <span class="co1">; A = (Y_INICIO + COORD_Y_TILE)</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                <span class="co1">; Establecemos COORD_Y a imprimir tile</span>
&nbsp;
   <span class="co1">;;; Bucle impresion vertical de los N tiles del scanline</span>
drawm<span class="re1">1</span>6cmxy_tileloop:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">IX</span><span class="sy0">+</span><span class="re1">0</span><span class="br0">)</span>              <span class="co1">; Leemos el valor del TILE de pantalla</span>
   <span class="kw1">INC</span> <span class="kw2">IX</span>                    <span class="co1">; Incrementamos puntero</span>
&nbsp;
   <span class="kw1">CP</span> <span class="nu0">255</span>
   <span class="kw1">JR</span> Z, drawm<span class="re1">1</span>6cmxy_read    <span class="co1">; Si es fin de tile codificado, fin bucle</span>
   <span class="kw1">CP</span> <span class="nu0">254</span>
   <span class="kw1">JR</span> Z, drawm<span class="re1">1</span>6cmxy_switch  <span class="co1">; Codigo 254 -&gt; cambiar a codif. vertical</span>
&nbsp;
   <span class="kw1">LD</span> <span class="br0">(</span>DS_NUMSPR<span class="br0">)</span>, <span class="kw2">A</span>         <span class="co1">; Establecemos el TILE</span>
   <span class="kw1">EXX</span>                       <span class="co1">; Preservar todos los registros en shadows</span>
   <span class="kw1">CALL</span> DrawSprite_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_LD  <span class="co1">; Imprimir el tile con los parametros</span>
   <span class="kw1">EXX</span>                       <span class="co1">; Recuperar valores de los registros</span>
&nbsp;
drawm<span class="re1">1</span>6cmxy_dir<span class="re1">1</span>:            <span class="co1">; Etiqueta con la direccion del NOP</span>
   <span class="kw1">NOP</span>                       <span class="co1">; NOP-&gt;INC COORD_X,  EX DE,HL-&gt;INC COORD_Y</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
   <span class="kw1">INC</span> <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                  <span class="co1">; COORD = COORD + 2</span>
drawm<span class="re1">1</span>6cmxy_dir2:            <span class="co1">; Etiqueta con la direccion del NOP</span>
   <span class="kw1">NOP</span>                       <span class="co1">; NOP-&gt;INC COORD_X,  EX DE,HL-&gt;INC COORD_Y</span>
   <span class="kw1">JR</span> drawm<span class="re1">1</span>6cmxy_tileloop   <span class="co1">; Repetimos hasta encontrar el 255</span>
&nbsp;
drawm<span class="re1">1</span>6cmxy_switch:
   <span class="co1">;;; Cambio de codificacion de horizontal a vertical:</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="sy0">$</span>EB                 <span class="co1">; Opcode de EX DE, HL</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cmxy_dir<span class="re1">1</span><span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; Ahora se hace el EX DE, HL y por lo tanto</span>
   <span class="kw1">LD</span> <span class="br0">(</span>drawm<span class="re1">1</span>6cmxy_dir2<span class="br0">)</span>, <span class="kw2">A</span>    <span class="co1">; INC (HL) incrementa COORD_Y en vez de X</span>
   <span class="kw1">JR</span> drawm<span class="re1">1</span>6cmxy_read</pre>

<p>
<br>

<br>

<strong>Codificar 2 tiles en un mismo byte</strong>
<br>

<br>

</p>

<p>
 Si tenemos menos de 16 tiles podemos codificar 2 tiles en un mismo
byte, suponiendo un ahorro de memoria de un 50%. Esto limita mucho la
riqueza gráfica del juego resultante a menos que dispongamos de
diferentes tilesets gráficos y que cada pantalla pueda tener asociado un
 set diferente, lo que nos limitaría de forma efectiva a 16 tiles
diferentes <strong>por pantalla</strong>.
</p>

<p>
 La estructura de pantalla (o la de mapa) debería contener un
“identificador de tileset” con el que referenciar al conjunto de tiles
que se usará para imprimirla.
</p>

<p>
<br>

<br>

<strong>Mapeado diferencial con diferentes codificaciones</strong>
<br>

<br>

</p>

<p>
 Como para cada pantalla puede ser más apropiado un tipo de codificación
 que otro, podemos codificar cada una de ellas con el método que resulte
 más adecuado y alterar nuestro el mapa o la propia pantalla para que
almacene también la información de tipo de codificación.
</p>

<p>
 La forma más sencilla es que el primer byte de la pantalla contenga el tipo de codificación utilizado.
</p>

<p>
 Una rutina “wrapper” (o “envoltorio”) de impresión de pantalla
obtendría del mapa la dirección de la pantalla en HL o DE, leería el
tipo de codificación utilizado (primer byte de la pantalla),
incrementaría HL o DE, almacenaría el valor resultante en (DM_MAP) y
llamaría a la función de impresión adecuada según el tipo de
codificación que acabamos de leer.
</p>

<p>
 Como ID de codificación se podría utilizar, por ejemplo:
</p>
<pre class="code z80">MAP_CODIF_NONE     <span class="kw3">EQU</span> <span class="re1">0</span>
MAP_CODIF_HORIZ    <span class="kw3">EQU</span> <span class="re1">1</span>
MAP_CODIF_VERT     <span class="kw3">EQU</span> <span class="nu0">2</span>
MAP_CODIF_MIXTA    <span class="kw3">EQU</span> <span class="nu0">3</span>
MAP_CODIF_BASICA   <span class="kw3">EQU</span> <span class="nu0">4</span></pre>

<p>
 Es difícil que la codificación básica sea más óptima que ninguna de las
 anteriores a menos que apenas haya bloques “transparentes” o “vacíos”,
pero aún así se ha contemplado su uso en la rutina. Hemos incluído
también la posibilidad de utilizar una pantalla sin agrupación indicando
 MAP_CODIF_NONE al inicio de la misma.
</p>
<pre class="code z80"><span class="co1">;---------------------------------------------------------------</span>
<span class="co1">; Llama a la rutina Draw_Map adecuada segun el tipo de</span>
<span class="co1">; codificacion de la pantalla apuntada en (DM_MAP).</span>
<span class="co1">;---------------------------------------------------------------</span>
DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Codificada:
   <span class="kw1">LD</span> <span class="kw2">HL</span>, <span class="br0">(</span>DM_MAP<span class="br0">)</span>            <span class="co1">; HL apunta al mapa </span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                 <span class="co1">; Leemos tipo de codificacion</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                     <span class="co1">; Incrementamos puntero (a datos)</span>
   <span class="kw1">LD</span> <span class="br0">(</span>DM_MAP<span class="br0">)</span>, <span class="kw2">HL</span>            <span class="co1">; Guardamos el valor en DM_MAP</span>
&nbsp;
   <span class="kw1">AND</span> <span class="kw2">A</span>                      <span class="co1">; Es A == 0? (MAP_CODIF_NONE)</span>
   <span class="kw1">JR</span> NZ, dm<span class="re1">1</span>6c_nocero        <span class="co1">; No</span>
   <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>
   <span class="kw1">RET</span>
&nbsp;
dm<span class="re1">1</span>6c_nocero:
   <span class="kw1">CP</span> MAP_CODIF_HORIZ         <span class="co1">; Es A == MAP_CODIF_HORIZ?</span>
   <span class="kw1">JR</span> NZ, dm<span class="re1">1</span>6c_nohoriz       <span class="co1">; No, saltar</span>
   <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Horiz
   <span class="kw1">RET</span>
&nbsp;
dm<span class="re1">1</span>6c_nohoriz:
   <span class="kw1">CP</span> MAP_CODIF_VERT          <span class="co1">; Es A == MAP_CODIF_VERT?</span>
   <span class="kw1">JR</span> NZ, dm<span class="re1">1</span>6c_novert        <span class="co1">; No, saltar</span>
   <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Vert
   <span class="kw1">RET</span>
&nbsp;
dm<span class="re1">1</span>6c_novert:
   <span class="kw1">CP</span> MAP_CODIF_MIXTA         <span class="co1">; Es A == MAP_CODIF_MIXTA?</span>
   <span class="kw1">JR</span> NZ, dm<span class="re1">1</span>6c_nomixta       <span class="co1">; No, saltar</span>
   <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Mixta
   <span class="kw1">RET</span>
&nbsp;
dm<span class="re1">1</span>6c_nomixta:                <span class="co1">; Entonces es basica.</span>
   <span class="kw1">CALL</span> DrawMap_<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>_Cod_Basica
   <span class="kw1">RET</span></pre>

<p>
 (También habríamos podido basar el salto en una tabla de salto, tal y como vimos en el capítulo dedicado a las <em>Fuentes de texto</em>, sección de <em>Impresión de cadenas con códigos de control</em>).
</p>

<p>
 Quedaría como responsabilidad del programador (o de un sencillo script)
 el codificar cada pantalla de las diferentes formas posibles y grabar
en el fichero de datos de pantallas final el resultado más óptimo
precedido del byte de tipo de codificación.
</p>

<p>
 En cualquier caso, si detectamos que la técnica de compresión mixta
obtiene mejores resultados para la gran mayoría de las pantallas,
podemos optar por codificar todo con el algoritmo mixto (aunque algunas
pantallas pudieran ocupar más con este método que con otro, serían una
minoría) y así evitar la inclusión de las otras rutinas de impresión y
la rutina DrawMap_16x16_Codificada que acabamos de ver. Esta será,
probablemente, la mejor de las opciones si el espacio ahorrado por
codificar cada pantalla con un sistema diferente es menor que la
inclusión en nuestro programa de las 4 rutinas (básica, horizontal,
vertical, mixta) y la rutina wrapper que acabamos de ver. Además,
también ganaremos algo de tiempo en la impresión de las pantallas al
saltarnos la ejecución de la  rutina wrapper.
</p>

<p>
<br>

<br>

<strong>Pantallas con blancos y transparencias</strong>
<br>

<br>

</p>

<p>
 En el caso de la compresión básica no conseguíamos mejoras de tamaño en
 las pantallas si existían bloques transparentes (255) además de bloques
 vacíos (0), ya que nosotros sólo podíamos considerar a nivel de
codificación uno de los 2 como “bloque no dibujable”.
</p>

<p>
 Lo bueno de las técnicas de codificación por scanlines horizontales,
verticales o mixtos es que los bloques vacíos o los transparentes (según
 nos interese en el juego) se pueden codificar junto a los bloques
normales, modificando las variables IGNORE_VALUES y BLANK del script de
codificación en python.
</p>

<p>
 Concretamente, tenemos que establecer ambas variables con el
identificador de tile que queremos  “ignorar” (y por lo tanto no
codificar).
</p>

<p>
 Aunque esto pueda implicar algunos bytes extra en la pantalla
resultante, nos permite volver a tener transparencia en nuestro juego.
En algunos casos, los “bloques vacíos” permiten unir 2 o más de los
antiguos scanlines (antes separados por los blancos) con lo que se
incrementa el ratio de compresión todavía más.
</p>

<p>
 Por ejemplo, codificando la primera pantalla de Sokoban con sus
transparencias obtenemos los siguientes valores para, por ejemplo, la
codificación horizontal:
</p>
<pre class="code z80"><span class="sy0">$</span> grep <span class="sy0">-</span><span class="kw2">E</span> <span class="st0">"^(IGNORE_VALUES|BLANK)"</span> codificar_pantalla.py
IGNORE_VALUES = <span class="nu0">255</span>
BLANK = <span class="nu0">255</span>
&nbsp;
<span class="sy0">$</span> .<span class="sy0">/</span>codificar_pantalla.py <span class="sy0">-</span>m <span class="sy0">-</span><span class="kw2">a</span> pantalla2.dat
 <span class="co1">; Flag codificacion: -m -a</span>
 <span class="co1">; Resultado: 69 Bytes</span>
 DB <span class="nu0">97</span> , <span class="re1">11</span><span class="nu0">3</span> , <span class="re1">1</span><span class="nu0">29</span> , <span class="re1">1</span><span class="nu0">45</span> , <span class="re1">1</span><span class="nu0">62</span> , <span class="nu0">66</span> , <span class="nu0">254</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">6</span> , <span class="re1">0</span> , <span class="re1">0</span>
 DB <span class="nu0">3</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">3</span> , <span class="re1">0</span> , <span class="nu0">6</span> , <span class="nu0">6</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="re1">0</span>
 DB <span class="nu0">7</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="re1">1</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="nu0">7</span> , <span class="nu0">3</span>
 DB <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="nu0">2</span> , <span class="re1">0</span> , <span class="nu0">7</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">4</span>
 DB <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">3</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="re1">1</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">4</span>
 DB <span class="nu0">5</span> , <span class="nu0">255</span> , <span class="nu0">2</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="re1">0</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">255</span></pre>

<p>
 En este caso, los bloques “0” (fondo negro) se han codificado junto a
los demás bloques normales (mejorando la “compresión”) y los bloques 255
 (transparentes) no, por lo que si en los ejemplos anteriores eliminamos
 el ClearScreen() y lanzamos el DrawMap correspondiente, obtenemos la
siguiente pantalla:
</p>

<p>
<br>

<img src="img/gfx5_transp.png" class="mediacenter" alt=" Codificando los blancos pero no las transparencias "/>
<br>

</p>

<p>
 No hay colisión entre el 255 “transparente” y el 255 “fin de scanline”
porque el codificador lo que ha hecho es, precisamente, no codificar los
 bloques 255 con lo que estos no aparecen en la pantalla resultante. Por
 contra, sí que es necesario incluir los bloques 0 ya que pretendemos
que sean dibujados para “tapar” el fondo (por eso se ha cambiando BLANK e
 IGNORE_VALUES en el script codificador, cambiando 0 por 255).
</p>

<p>
<br>

<br>

<strong>Efectos sobre los tiles adyacentes al fondo</strong>
<br>

<br>

</p>

<p>
 Otro efecto interesante para mejorar la riqueza gráfica de un juego es
generar una “sombra” para aquellos tiles que estén cercanos a otros
tiles definidos como “fondo”.
</p>

<p>
 Por ejemplo, la siguiente captura de pantalla de un juego de los <em>Mojon Twins</em>
 muestra cómo los muros verticales rojos cercanos a la “bellota”
proyectan hacia la derecha, sobre el suelo “morado”, una sombra generada
 durante el proceso de trazado de la pantalla. Esta sombra hace que los
tiles de suelo cercanos al muro sean diferentes del resto de tiles de
suelo, sin necesidad de haber definido un tile específico para ello.
</p>

<p>
<br>

<img src="img/gfx5_cotbss08.png" class="mediacenter" alt=" Sombreados sobre tiles "/>
<br>

</p>

<p>
 Podemos utilizar esta técnica en caso de necesitar ahorrar memoria,
aunque lo más rápido en términos de trazado sería el disponer de tiles
específicos “con sombras” y que el mapa los tenga definidos en las
posiciones necesarias.
</p>

<p>
 El propio na_th_an nos comenta cómo utilizan esta técnica en los juego de su Colección Pretujao:
</p>
<pre class="code"> El sombreado se hace en tiempo real. Como sombreamos hacia abajo y hacia
la derecha, a la hora de pintar un tile de fondo se hace así:

Considérese un tile de 16x16 formado por 4 carácteres:

1 2
3 4


 Los carácteres 1, 2, 3, y 4 están en el tileset. Además, tenemos unos
carácteres alternativos sombreados que llamaremos 1', 2' y 3' y 4' (aunque
este no se usa, lo dejamos por temas de velocidad).

 Siendo (x, y) la posición de nuestro tile de fondo (a nivel de tiles):

- Pintamos el carácter 1 si el tile en (x-1, y-1) es fondo o el tile 1' si es obstáculo.
- Pintamos el carácter 2 si el tile en (x, y-1) es fondo o el tile 2' si es obstáculo.
- Pintamos el carácter 3 si el tile en (x-1, y) es fondo o el tile 3' si es obstáculo.
- Pintamos el carácter 4.

 Eso cubre todas las combinaciones y es realmente rápido.</pre>

<p>
<br>

<br>

</p>

</div>

<h4 id="resumen-de-resultados-de-codificaciones-empleadas">Resumen de resultados de codificaciones empleadas</h4>
<div class="level4">

<p>
 Veamos una tabla resumen de los resultados de codificar nuestra
pantalla de ejemplo (el nivel 1 de Sokoban) con diferentes técnicas.
Inclúimos además una estimación de cuánto ocuparían 100 pantallas de
juego y cuántas pantallas cabrían en 16KB de memoria asumiendo que, de
media, todas ocuparan tras su codificación tamaños parecidos del primer
nivel:
</p>

<p>
<br>

</p>
<div class="table-responsive sectionedit16"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Codificación </th><th class="col1"> Tamaño (bytes) </th><th class="col2"> Ocupación 100 pantallas </th><th class="col3"> Pantallas en 16KB </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> Datos en crudo </td><td class="col1"> 192 </td><td class="col2"> 18.7 KB </td><td class="col3"> 85 pantallas </td>
	</tr>
	<tr class="row2">
		<td class="col0"> Codificación básica </td><td class="col1"> 106 </td><td class="col2"> 10.3 KB </td><td class="col3"> 154 pantallas </td>
	</tr>
	<tr class="row3">
		<td class="col0"> Scanlines horizontales </td><td class="col1"> 87 </td><td class="col2"> 8.4 KB </td><td class="col3"> 188 pantallas </td>
	</tr>
	<tr class="row4">
		<td class="col0"> Scanlines verticales </td><td class="col1"> 78 </td><td class="col2"> 7.6 KB </td><td class="col3"> 210 pantallas </td>
	</tr>
	<tr class="row5">
		<td class="col0"> Scanlines mixtos </td><td class="col1"> 72 </td><td class="col2"> 7 KB </td><td class="col3"> 227 pantallas </td>
	</tr>
	<tr class="row6">
		<td class="col0"> Scanlines mixtos + XY agrupados </td><td class="col1"> 60 </td><td class="col2"> 5.8 KB </td><td class="col3"> 273 pantallas </td>
	</tr>
</tbody></table></div>

<p>
<br>

</p>

<p>
 Estos datos son una estimación muy general porque no todas las
pantallas de Sokoban ocuparán lo mismo una vez codificadas, pero si
utilizamos la técnica de codificación más adecuada a cada pantalla
podemos acercarnos mucho a esas 273 pantallas totales en 16 KB de
memoria, muy alejadas de las 85 que caben con los datos “en crudo”.
</p>

<p>
<br>

<br>

</p>

</div>

<h4 id="posibles-mejoras-en-el-codificador-y-las-rutinas-de-impresion">Posibles mejoras en el codificador y las rutinas de impresión</h4>
<div class="level4">

<p>
<br>

<br>

<strong>Detección de situaciones especiales de codificación mixta</strong>
<br>

<br>

</p>

<p>
 Una posible mejora sería la de modificar el script de codificación
mixta para que detecte ciertas situaciones en la que no es óptimo
actualmente. El algoritmo que se ha aplicado en el codificador es un
algoritmo genérico basado en buscar la mayor cantidad de tiles
consecutivos para una posterior codificación horizontal o vertical por
orden de cantidad de tiles. Este algoritmo no detecta determinadas
situaciones donde la mejor codificación no es la que más cantidad de
tiles consecutivos consigue.
</p>

<p>
 Por ejemplo, supongamos esta situación:
</p>
<pre class="code">0001234000
0000010000
0000010000
0000010000
0000010000
0001234000</pre>

<p>
 Tenemos dos filas horizontales de 4 bloques y una columna vertical de
5. El algoritmo utilizado determinaría que 5 es mayor que 4 por lo que
codificaría primero la columna vertical, quedando para el siguiente
ciclo de codificación esta pantalla:
</p>
<pre class="code">0001204000
0000000000
0000000000
0000000000
0000000000
0001204000</pre>

<p>
 Es decir, para codificar las 3 líneas originales hemos generado 1
ristra de bytes verticales, y ahora 4 horizontales, con sus bytes de X, Y
 y FIN DE CODIFICACION (255) para los 5 scanlines.
</p>

<p>
 Sin embargo, hubiera sido mejor codificar primero los scanlines
horizontales, aunque fueran de menor longitud de que el vertical:
</p>
<pre class="code">0001234000   --&gt; 0000000000
0000010000   --&gt; 0000010000
0000010000   --&gt; 0000010000
0000010000   --&gt; 0000010000
0000010000   --&gt; 0000010000
0001234000   --&gt; 0000000000</pre>

<p>
 De esta forma codificamos las 3 líneas en 3 “ristras” (2 horizontales
de 4 bloques y una vertical de 4 bloques), utilizando 3*3 = 9 bytes de
codificación de coordenadas y fin de scanline en lugar de los 15 del
ejemplo anterior.
</p>

<p>
 Estos son los resultados actuales que obtiene el codificador para la anterior pantalla:
</p>
<pre class="code z80"><span class="sy0">$</span> .<span class="sy0">/</span>codificar_pantalla.py <span class="sy0">-</span><span class="kw2">h</span> pantalla3.dat
 <span class="co1">; Flag codificacion: -h</span>
 <span class="co1">; Resultado: 31 Bytes</span>
 DB <span class="nu0">3</span> , <span class="re1">0</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">5</span> , <span class="re1">1</span> , <span class="re1">1</span> , <span class="nu0">255</span> , <span class="nu0">5</span>
 DB <span class="nu0">2</span> , <span class="re1">1</span> , <span class="nu0">255</span> , <span class="nu0">5</span> , <span class="nu0">3</span> , <span class="re1">1</span> , <span class="nu0">255</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="re1">1</span> , <span class="nu0">255</span> , <span class="nu0">3</span>
 DB <span class="nu0">5</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">255</span>
&nbsp;
<span class="sy0">$</span> .<span class="sy0">/</span>codificar_pantalla.py <span class="sy0">-</span>v pantalla3.dat
 <span class="co1">; Flag codificacion: -v</span>
 <span class="co1">; Resultado: 34 Bytes</span>
 DB <span class="nu0">3</span> , <span class="re1">0</span> , <span class="re1">1</span> , <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="re1">0</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">5</span> , <span class="re1">0</span> , <span class="nu0">3</span> , <span class="re1">1</span>
 DB <span class="re1">1</span> , <span class="re1">1</span> , <span class="re1">1</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="re1">0</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">3</span> , <span class="nu0">5</span> , <span class="re1">1</span>
 DB <span class="nu0">255</span> , <span class="nu0">4</span> , <span class="nu0">5</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">255</span>
&nbsp;
<span class="sy0">$</span> .<span class="sy0">/</span>codificar_pantalla.py <span class="sy0">-</span>m pantalla3.dat
 <span class="co1">; Flag codificacion: -m</span>
 <span class="co1">; Resultado: 28 Bytes</span>
 DB <span class="nu0">3</span> , <span class="re1">0</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">3</span> , <span class="nu0">5</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="re1">0</span>
 DB <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">6</span> , <span class="nu0">5</span> , <span class="nu0">4</span> , <span class="nu0">254</span> , <span class="nu0">5</span> , <span class="re1">0</span> , <span class="nu0">3</span> , <span class="re1">1</span> , <span class="re1">1</span> , <span class="re1">1</span>
 DB <span class="re1">1</span> , <span class="nu0">3</span> , <span class="nu0">255</span> , <span class="nu0">255</span></pre>

<p>
 Y este es el coste que tendría la codificación con la detección de la situación que hemos comentado:
</p>
<pre class="code z80"> <span class="co1">; Codificacion mixta con deteccion de situaciones T e I:</span>
 <span class="co1">; Resultado: 22 Bytes</span>
 DB <span class="nu0">3</span> , <span class="re1">0</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">4</span> , <span class="nu0">255</span> , <span class="nu0">3</span> , <span class="nu0">5</span> , <span class="re1">1</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="nu0">4</span>, <span class="nu0">254</span>
 DB <span class="nu0">5</span> , <span class="re1">1</span> , <span class="re1">1</span> , <span class="re1">1</span> , <span class="re1">1</span> , <span class="re1">1</span>, <span class="nu0">255</span> , <span class="nu0">255</span></pre>

<p>
 Estaríamos ganando unos pocos bytes adicionales sin cambios en nuestro programa: tan sólo mejorando el codificador.
</p>

<p>
<br>

<br>

<strong>Agrupar 2 scanlines separados por 2 o menos huecos</strong>
<br>

<br>

</p>

<p>
 Finalmente, podríamos modificar el script codificador para que detecte
las situaciones en que  tengamos 2 scanlines (horizontales o verticales)
 separados por 1 ó 2 bloques “vacíos” (transparentes).
</p>
<pre class="code z80"> <span class="re1">00011101110</span></pre>

<p>
 Codificar la anterior secuencia produciría 2 scanlines con sus bytes de
 COORD_X, COORD_Y y FIN_SCANLINE por cada fila de tiles, con un total de
 6 bytes de “datos de posicionamiento”.
</p>
<pre class="code z80"> <span class="co1">; 12 bytes</span>
 DB <span class="nu0">3</span>, <span class="re1">0</span>, <span class="re1">1</span>, <span class="re1">1</span>, <span class="re1">1</span>, <span class="nu0">255</span>, <span class="nu0">8</span>, <span class="re1">0</span>, <span class="re1">1</span>, <span class="re1">1</span>, <span class="re1">1</span>, <span class="nu0">255</span></pre>

<p>
 Si codificamos el anterior scanline usando un código especial (ej: 252)
 como “tile transparente” a ser ignorado por la rutina de impresión, nos
 ahorramos los bytes de posicionamiento del segundo scanline:
</p>
<pre class="code z80"> <span class="co1">; 10 bytes</span>
 DB <span class="nu0">3</span>, <span class="re1">0</span>, <span class="re1">1</span>, <span class="re1">1</span>, <span class="re1">1</span>, <span class="nu0">252</span>, <span class="re1">1</span>, <span class="re1">1</span>, <span class="re1">1</span>, <span class="nu0">255</span></pre>

<p>
 Si la separación entre 2 scanlines la forma 1 bloque “transparente” ,
añadimos 1 byte “252” pero eliminamos el “255” del primer scanline y el
COORD_X y COORD_Y del segundo, por lo que sumamos 1 bytes pero restamos
3, ahorrando 2 bytes.
</p>

<p>
 Si la separación entre 2 scanlines la forman 2 bloques “transparentes” ,
 añadimos 2 bytes “252” pero eliminamos el “255” del primer scanline y
el COORD_X y COORD_Y del segundo, por lo que sumamos 2 bytes pero
restamos 3, ahorrando 1 byte.
</p>

<p>
 Para más de 3 bloques transparentes no se produce ningún ahorro, sino todo lo contrario.
</p>

<p>
 La pega de esta técnica es que a cambio de 1 ó 2 bytes de ahorro en
estas situaciones pasamos a poder utilizar 252 tiles (0-251) y se
requiere un pequeño tiempo de procesado extra en la rutina para detectar
 y saltar los tiles “252”.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit17" id="mapeados-de-diferentes-tilesets">Mapeados de diferentes tilesets</h3>
<div class="level3">

<p>
 Cabe también la posibilidad de codificar las pantallas con datos de diferentes tilesets gráficos.
</p>

<p>
 En ese caso, podemos añadir a todas las posibilidades vistas hasta
ahora un “identificador de tileset” que referencie a una tabla con los
datos de los diferentes tilesets (datos gráficos, datos de atributo,
ancho y alto):
</p>
<pre class="code z80">Tabla_IDs_Tilesets:
  DW dir_tileset_gfx_<span class="re1">1</span>
  DW dir_tileset_attrib_<span class="re1">1</span>
  DB ancho_tiles_tileset<span class="re1">1</span>, alto_tiles_tileset<span class="re1">1</span>
  DW dir_tileset_gfx_2
  DW dir_tileset_attrib_2
  DB ancho_tiles_tileset2, alto_tiles_tileset2
  DW dir_tileset_gfx_3
  DW dir_tileset_attrib_3
  DB ancho_tiles_tileset3, alto_tiles_tileset3</pre>

<p>
 De esta forma podemos tener pantallas codificadas por codificación básica con tiles de diferentes tamaños:
</p>
<pre class="code z80">Pantalla<span class="re1">1</span>:
   DB ID_TILESET, X, Y, ID_TILE, ID_TILESET, X, Y, ID_TILE
   DB ID_TILESET, X, Y, ID_TILE, ID_TILESET, X, Y, ID_TILE
   DB <span class="br0">(</span>...<span class="br0">)</span>
   DB <span class="nu0">255</span> <span class="br0">(</span>fin <span class="kw2">de</span> pantalla<span class="br0">)</span></pre>

<p>
 Podemos combinar este tipo de codificación con las técnicas de
agrupación que ya hemos visto agrupando siempre tiles de un mismo tipo.
</p>

<p>
 En este caso las coordenadas X e Y de impresión deben de ser
coordenadas de pantalla y no de “mapa” ya que no todos los tiles tienen
el mismo tamaño, por lo que resulta más óptimo que el mapa indica la
posición exacta de pantalla donde va cada tile.
</p>

<p>
 Por otra parte, esta técnica añade 1 byte extra de ocupación a cada
tile, por lo que las pantallas ocuparán más que con tileset único.
</p>

<p>
 La codificación e impresión de este tipo de mapas es mucho más compleja
 que utilizar un único tileset con tiles de tamaños idénticos. No
obstante, existirán situaciones donde resulta necesario disponer de 2
tilesets o spritesets diferentes.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit18" id="mapeados-de-tiles-de-cualquier-tamano-de-bloque">Mapeados de tiles de cualquier tamaño de bloque</h3>
<div class="level3">

<p>
 Además de la posibilidad de disponer de mapeados basados en diferentes
tilesets, podemos componer las pantallas de nuestro juego a partir de
todo tipo de gráficos y tiles de tamaños diversos, pertenezcan o no a
tilesets.
</p>

<p>
 Para eso, debemos dejar de pensar en las pantallas como matrices de
tiles y visualizarlas y definirlas como “listas de sprites a dibujar”
(sean tiles o no).
</p>

<p>
 Primero debemos definir una tabla que almacene la información de todos
los elementos gráficos que pueden formar parte de una pantalla:
</p>
<pre class="code z80">Tabla_Tiles:
   DW tileset_<span class="re1">1</span>_gfx<span class="sy0">+</span><span class="br0">(</span><span class="re1">0</span><span class="sy0">*</span><span class="nu0">32</span><span class="br0">)</span>             <span class="co1">; Cada tile ocupa 8*4=32 bytes en el tileset 16x16</span>
   DW tileset_<span class="re1">1</span>_attr<span class="sy0">+</span><span class="br0">(</span><span class="re1">0</span><span class="sy0">*</span><span class="nu0">4</span><span class="br0">)</span>             <span class="co1">; Cada tile ocupa 4 atributos en el tileset 16x16</span>
   DB <span class="re1">1</span><span class="nu0">6</span>, <span class="re1">1</span><span class="nu0">6</span>
   DW tileset_<span class="re1">1</span>_gfx<span class="sy0">+</span><span class="br0">(</span><span class="re1">1</span><span class="sy0">*</span><span class="nu0">32</span><span class="br0">)</span>             <span class="co1">; Apuntamos a datos del tile 1 del tileset</span>
   DW tileset_<span class="re1">1</span>_attr<span class="sy0">+</span><span class="br0">(</span><span class="re1">1</span><span class="sy0">*</span><span class="nu0">4</span><span class="br0">)</span>
   DB <span class="re1">1</span><span class="nu0">6</span>, <span class="re1">1</span><span class="nu0">6</span>
   DW tileset_<span class="re1">1</span>_gfx<span class="sy0">+</span><span class="br0">(</span><span class="nu0">2</span><span class="sy0">*</span><span class="nu0">32</span><span class="br0">)</span>
   DW tileset_<span class="re1">1</span>_attr<span class="sy0">+</span><span class="br0">(</span><span class="nu0">2</span><span class="sy0">*</span><span class="nu0">4</span><span class="br0">)</span>
   DB <span class="re1">1</span><span class="nu0">6</span>, <span class="re1">1</span><span class="nu0">6</span>
   DW tileset_2_gfx<span class="sy0">+</span><span class="br0">(</span><span class="re1">0</span><span class="sy0">*</span><span class="nu0">8</span><span class="br0">)</span>              <span class="co1">; Cada tile ocupa 8 bytes en el tileset 8x8</span>
   DW tileset_2_attr<span class="sy0">+</span><span class="br0">(</span><span class="re1">0</span><span class="sy0">*</span><span class="re1">1</span><span class="br0">)</span>             <span class="co1">; Cada tile ocupa 1 atributo en el tileset 8x8</span>
   DB <span class="nu0">8</span>, <span class="nu0">8</span>
   DW tileset_2_gfx<span class="sy0">+</span><span class="br0">(</span><span class="re1">1</span><span class="sy0">*</span><span class="nu0">8</span><span class="br0">)</span>
   DW tileset_2_attr<span class="sy0">+</span><span class="br0">(</span><span class="re1">1</span><span class="sy0">*</span><span class="re1">0</span><span class="br0">)</span>
   DB <span class="nu0">8</span>, <span class="nu0">8</span>
   DW logotipo_gfx
   DW logotipo_attr
   DB <span class="nu0">32</span>, <span class="re1">1</span><span class="nu0">6</span>
   DW piedra_gfx
   DW piedra_attr
   DB <span class="nu0">32</span>, <span class="nu0">32</span>
   DW muro_grande_gfx
   DW muro_grande_attr
   DB <span class="nu0">64</span>, <span class="nu0">64</span>
   DW grafico_escalera_gfx
   DW grafico_escalera_attr
   DB <span class="re1">1</span><span class="nu0">6</span>, <span class="nu0">32</span></pre>

<p>
 A continuación definimos la pantalla en formato “codificación básica”
utilizando identificadores de tile que serán índices en la anterior
tabla:
</p>
<pre class="code z80">Pantalla:
   DB X, Y, ID_EN_TABLA_TILE, X, Y, ID_EN_TABLA_TILE, <span class="br0">(</span>...<span class="br0">)</span>, <span class="nu0">255</span></pre>

<p>
 La pantalla acabará en un valor 255 y los valores de X e Y deberán ser
coordenadas exactas de pantalla. La rutina de impresión recorrerá cada
byte de la pantalla (hasta encontrar el fin de pantalla o 255) y trazará
 todos los sprites llamando a la rutina genérica de DrawSprite_MxN.
</p>

<p>
 Nuestra rutina de impresión puede acceder a los datos del tile mediante
 multiplicación de ID_EN_TABLA_TILE por 2+2+2 e imprimir el sprite
gfx/attr/ancho/alto leído desde la tabla.
</p>

<p>
 Con este sistema se debe de diseñar y codificar manualmente la
pantalla, pero nos permite tener una riqueza gráfica que no siempre se
puede conseguir sólo con tiles de tamaños fijos.
</p>

<p>
 Por contra, nos obliga a utilizar la rutina de impresión genérica
DrawSprite_MxN, que no es tan rápida como las rutinas específicas. Para
evitar esto, lo que podemos hacer es modificar la rutina genérica para
que en caso de que el ANCHO y el ALTO del sprite coincidan con el de
alguna de las rutinas específicas disponibles hagan la llamada a dicha
rutina, y en caso contrario, utilicen el código genérico.
</p>

<p>
 El código a añadir a la rutina genérica podría ser similar al siguiente:
</p>
<pre class="code z80">DrawSprite_MxN_LD_extendida:
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_HEIGHT<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span>DS_WIDTH<span class="br0">)</span>
   <span class="kw1">LD</span> <span class="kw2">C</span>, <span class="kw2">A</span>                   <span class="co1">; Obtenemos datos del sprite</span>
&nbsp;
   <span class="co1">;;; B = ALTO de Sprite</span>
   <span class="co1">;;; C = ANCHO de Sprite</span>
&nbsp;
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                   <span class="co1">; A = ANCHO</span>
   <span class="kw1">CP</span> <span class="re1">1</span><span class="nu0">6</span>                     <span class="co1">; Comparar ancho</span>
   <span class="kw1">JR</span> NZ, dspMN_no<span class="re1">1</span><span class="nu0">6</span>         <span class="co1">; ¿es 16?</span>
&nbsp;
   <span class="kw1">SUB</span> <span class="kw2">B</span>                     <span class="co1">; A = Ancho - alto</span>
   <span class="kw1">JR</span> NZ, dspMN_generica     <span class="co1">; Si no es cero, rutina generica</span>
                             <span class="co1">; Es cero, imprimir 16x16:                 </span>
   <span class="kw1">CALL</span> DrawSprite<span class="re1">1</span>6x<span class="re1">1</span><span class="nu0">6</span>      <span class="co1">; Imprimir via especifica 16x16</span>
   <span class="kw1">RET</span>
&nbsp;
dspMN_no<span class="re1">1</span><span class="nu0">6</span>:
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="kw2">C</span>                   <span class="co1">; Recuperamos ancho</span>
   <span class="kw1">CP</span> <span class="nu0">8</span>                      <span class="co1">; ¿es 8?</span>
   <span class="kw1">JR</span> NZ, dspMN_generica     <span class="co1">; Si no es 8, ni 16, generica</span>
   <span class="kw1">SUB</span> <span class="kw2">B</span>                     <span class="co1">; A = Ancho - alto</span>
   <span class="kw1">JR</span> NZ, dspMN_generica     <span class="co1">; Si no es cero, rutina generica</span>
&nbsp;
   <span class="kw1">CALL</span> DrawSprite_8x8       <span class="co1">; Imprimir via especifica 8x8</span>
   <span class="kw1">RET</span>
&nbsp;
dspMN_generica:
   <span class="co1">;;; (resto rutina generica)</span>
   <span class="kw1">RET</span></pre>

<p>
 De esta forma, utilizaremos la rutina genérica sólo para los tamaños de
 sprite de los que no dispongamos rutinas de impresión específicas.
</p>

<p>
<br>

<br>

<strong>Tabla sólo de los tiles no estándar</strong>
<br>

</p>

<p>
 Lo más normal es que el mayor porcentaje de gráficos de la pantalla se
tomen desde un tileset y unos pocos desde bitmaps de diferentes tamaños
ajenos a éste. En ese caso nos podemos ahorrar la tabla de direcciones
de tiles si, por ejemplo, definimos estos gráficos especiales a partir
de un determinado valor numérico.
</p>

<p>
 Supongamos que tenemos 200 tiles y 20 gráficos de tamaño no estándar
que queremos ubicar en nuestros mapeados. En ese caso utilizamos los
valores numéricos del 200 al 220 como identificadores de estos tiles y
construímos la tabla de direcciones sólo con los datos de estos
gráficos:
</p>
<pre class="code z80">Tiles_Extendidos:
   DW logotipo_gfx
   DW logotipo_attr
   DB <span class="nu0">32</span>, <span class="re1">1</span><span class="nu0">6</span>
   DW piedra_gfx
   DW piedra_attr
   DB <span class="nu0">32</span>, <span class="nu0">32</span>
   DW muro_grande_gfx
   DW muro_grande_attr
   DB <span class="nu0">64</span>, <span class="nu0">64</span>
   DW grafico_escalera_gfx
   DW grafico_escalera_attr
   DB <span class="re1">1</span><span class="nu0">6</span>, <span class="nu0">32</span></pre>

<p>
 Nuestra rutina de impresión de mapeado sería idéntica a las ya vistas
con un pequeño cambio:  Cuando la rutina encontrara un identificador de
tile menor de 200 (0-199), utilizaría la rutina de impresión basada en
tileset, y cuando encontrara un tile mayor o igual a 200, utilizaría los
 datos de esta tabla usando como índice el valor (TILE-200). De esta
forma se podría utilizar la rutina de impresión de sprites específica
para nuestros tiles y la genérica sólo para estos tiles “no estándar”.
Además nos ahorramos 200*6 bytes (2 de la dirección de los gráficos, 2
de la dirección de atributos y 2 de ancho y alto) en la tabla de “tiles
extendidos”.
</p>

<p>
 Este sistema permite extender el funcionamiento “estándar” basado en un
 tileset añadiendo la posibilidad de incluir determinados gráficos “no
estándar” en la pantalla, sin complicar las rutinas de impresión y
añadiendo sólo la necesidad de una sencilla tabla que ocuparía 6 bytes
de datos por cada “tile no estándar” que queramos incluir en el mapa del
 juego.
</p>

<p>
<br>

</p>

</div>

<h2 id="fondos-personalizados-para-cada-pantalla">Fondos personalizados para cada pantalla</h2>
<div class="level2">

<p>
 Todas las rutinas que hemos visto se basan en la impresión de tiles con
 contenido y la no impresión de tiles considerados fondo o
transparencia.
</p>

<p>
 En ambos caso, el tile que se utiliza como fondo es un tile único (usualmente un tile sólido con el color del fondo).
</p>

<p>
 Si nuestro personaje es monocolor y no se va a producir <em>attribute clash</em>
 es posible que queramos un fondo no sólido basado en un patrón
repetitivo sobre el que nuestro personaje se pueda desplazar (con el
mismo color de tinta y papel que los sprites que se vayan a mover sobre
él).
</p>

<p>
 Lo que estabamos haciendo hasta ahora era borrar el área de pantalla
donde íbamos a dibujar el tileset, y trazar sólo aquellos tiles
codificados en la pantalla y que eran contenido real (diferente del
fondo).
</p>

<p>
 Si incluímos ahora en el tileset uno o varios tiles específicos para el
 fondo y los codificamos dentro de las pantallas, entonces dejará de ser
 posible la compresión ya que todos los tiles de la pantalla tendrían
que ser dibujados (ya no “ignoramos” los bloques de fondo sino que ahora
 hay que dibujarlos para trazar ese nuevo fondo gráfico). Con esto, se
esfuma nuestro ahorro de memoria.
</p>

<p>
 Podemos utilizar una sencilla solución basada en tabla para disponer de
 fondos en las pantallas y continuar ahorrando memoria con la
codificación. La tabla alojará la dirección
</p>
<pre class="code z80">FONDO_PIEDRA    <span class="kw3">EQU</span>   <span class="re1">0</span>
FONDO_BALDOSAS  <span class="kw3">EQU</span>   <span class="re1">1</span>
FONDO_HIERBA    <span class="kw3">EQU</span>   <span class="nu0">2</span>
&nbsp;
Fondos:
   DW fondo_piedra_gfx
   DW fondo_piedra_attr
   DB <span class="re1">1</span><span class="nu0">6</span>, <span class="re1">1</span><span class="nu0">6</span>
   DW fondo_baldosas_gfx
   DW fondo_baldosas_attr
   DB <span class="nu0">64</span>, <span class="nu0">64</span>
   DW fondo_hierba_gfx
   DW fondo_hierba_attr
   DB <span class="nu0">32</span>, <span class="nu0">32</span></pre>

<p>
 De nuevo, para acceder a los datos de un fondo específico lo haremos mediante:
</p>
<pre class="code">DIR_DATOS_FONDO    = [ Fondos + (ID_FONDO * 6) ]</pre>

<p>
 A continuación, definimos el mapa de forma que además de la dirección
de memoria de la pantalla y las conexiones con otras localidades incluya
 un identificador dentro de los nuestros fondos:
</p>
<pre class="code z80">Mapa:
  DW Pantalla_Inicio            <span class="co1">; ID = 0</span>
  DB <span class="sy0">-</span><span class="re1">1</span>, <span class="re1">1</span>                      <span class="co1">; Conexiones izq y derecha ID 0</span>
  DB FONDO_BALDOSAS
  DW Pantalla_Salon             <span class="co1">; ID = 1 </span>
  DB <span class="re1">0</span>, <span class="nu0">2</span>                       <span class="co1">; Conexiones izq y derecha ID 1</span>
  DB FONDO_PIEDRA
  DW Pantalla_Pasillo           <span class="co1">; ID = 2</span>
  DB <span class="re1">1</span>, <span class="nu0">3</span>                       <span class="co1">; Conexiones izq y derecha ID 2</span>
  DB FONDO_PIEDRA
  <span class="br0">(</span>...<span class="br0">)</span></pre>

<p>
 (NOTA: Esto modificará la cantidad por la que hay que multiplicar para
acceder a los datos de una pantalla ya que ahora incluyen 1 byte
adicional).
</p>

<p>
 De esta forma, cada pantalla tiene un bitmap de fondo asociado que
puede ir desde el tamaño de un simple tile 8×8 hasta 256×192 píxeles si
así lo deseamos.
</p>

<p>
 Finalmente, en lugar de realizar un borrado del área de pantalla donde
vamos a imprimir el mapa sería necesario programar una rutina que
utilice el sprite Fondo (mediante su ID y la tabla de Fondos). La rutina
 deberá “rellenar” vía impresión por repetición el área de juego con el
fondo seleccionado. Para simplificar la rutina es recomendable que todos
 los tamaños de los tiles de fondo sean dividores exactos del tamaño de
la pantalla, de forma que la rutina no tenga que calcular si la
impresión del último tile que quepa en la misma ha de ser dibujado total
 o parcialmente. Si el área de juego es de 256 píxeles, podremos
utilizar tiles de ancho 8 (32 repeticiones), 16 (16 repeticiones), 32 (8
 repeticiones), 64 (4 repeticiones), 128 (2 repeticiones) o incluso de
256 (1 repetición). Lo mismo ocurriría para la altura.
</p>

<p>
 La rutina tendría que utilizar DrawSpriteMxN (ya que los fondos pueden
tener cualquier tamaño) pero se recomienda que emplee rutinas
específicas en los tamaños de fondo para los que tengamos rutina de
impresión disponible.
</p>

<p>
 De esta forma, rellenamos el área de juego con el fondo asociado a
dicha pantalla y después llamamos a DrawMap para dibujar sobre este
“fondo” los tiles reales.
</p>

<p>
 ¿Qué ahorramos con este sistema? El ahorro consiste en que hemos
definido el fondo de una pantalla con 1 sólo byte (el Identificador de
Fondo que asociado a cada pantalla en la estructura de mapa) y ya no es
necesario codificar los tiles de fondo en las pantallas. Los tiles del
mapa que antes eran tiles con valores numéricos de fondo ahora serán
“vacíos” o “transparentes” con lo que la codificación los ignorará y las
 pantallas sólo incluirán los datos de los tiles “reales”. Los tiles
“transparentes”, al no dibujarse, permitirán ver en sus posiciones el
fondo predibujado.
</p>

<p>
 Además esto nos permite cambiar el fondo asociado a una pantalla
rápidamente (en la estructura de mapa) sin tener que modificar todos los
 valores de tiles de fondo en una o más pantallas (y/o recodificar las
pantallas). Y por si fuera poco, nada nos obliga a que el fondo sea un
tile de tamaño igual al de los bloques del tileset, lo que puede dotar
de mayor riqueza gráfica a nuestro juego.
</p>

<p>
 Una versión más óptima de este sistema pero que requiere modificar las
rutinas de impresión de mapeado podría ser que la rutina de impresión,
cuando encontrara un bloque vacío/transparente, utilizara las
coordenadas X e Y de impresión actuales como un “índice circular” en el
gráfico de fondo para dibujar una porción del mismo con tamaño de un
tile y así rellenar el “tile transparente” que estamos considerando.
Sería algo parecido a un rellenado con patrón pero sólo en el espacio de
 un tile. Esta aproximación evitaría el dibujado de toda la pantalla con
 el fondo transparente, incluídas porciones de pantalla sobre los que
después dibujaremos tiles gráficos.
</p>

<p>
<br>

</p>

</div>

<h2 id="compresion-de-los-datos-de-pantalla">Compresión de los datos de pantalla</h2>
<div class="level2">

<p>
 Todavía podríamos arañar algunos bytes adicionales a las pantallas utilizando técnicas de compresión.
</p>

<p>
<br>

<br>

<strong>Compresión por repetición</strong>
<br>

<br>

</p>

<p>
 La primera de las posibilidades de compresión se basa en repetición de
tiles consecutivos en las técnicas de agrupación, utilizando un tipo de
compresión que utilice un byte de control “253”, de tal modo que si se
encuentra un valor de tile 253, a éste valor le siga el tile a repetir y
 el número de repeticiones (o al revés).
</p>
<pre class="code z80">  DB <span class="nu0">253</span>, NUMERO_REPETICIONES, TILE_A_REPETIR</pre>

<p>
 Así, una secuencia:
</p>
<pre class="code z80">  <span class="co1">; 9 bytes</span>
  DB <span class="re1">1</span>, <span class="nu0">2</span>, <span class="nu0">2</span>, <span class="nu0">2</span>, <span class="nu0">2</span>, <span class="nu0">2</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span></pre>

<p>
 Se codificaría como:
</p>
<pre class="code z80">  <span class="co1">; 6 bytes</span>
  DB <span class="re1">1</span>, <span class="nu0">253</span>, <span class="nu0">6</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span></pre>

<p>
 En este caso, la rutina de impresión deberá expandir “253, 6, 2” como “6 veces 2” = 2, 2, 2, 2, 2, 2.
</p>

<p>
 Por desgracia, este tipo de compresión no suele resultar muy efectiva
porque requiere que haya un mínimo de 3 tiles consecutivos iguales (lo
que permitiría ahorrar el mínimo de 1 byte). En los mapeados con riqueza
 gráfica, las filas y columnas están formadas por diferentes tiles
alternados y no se suele repetir el mismo tile de forma consecutiva una y
 otra vez, ya que evidenciaría la repetición de un mismo gráfico.
</p>

<p>
 En cualquier caso, para aplicar este tipo de técnica tendríamos que
modificar el script codificador (en busca de valores idénticos
consecutivos) y la rutina de impresión (en busca del código de control
253 y con un bucle para repetir N veces el valor del tile comprimido).
</p>

<p>
<br>

<br>

<strong>Compresión por patrones</strong>
<br>

<br>

</p>

<p>
 El sistema de compresión por patrones es el método que, probablemente,
producirá los mejores resultados de reducción de tamaño de las pantallas
 en la mayoría de juegos.
</p>

<p>
 Se basa en identificar “conjuntos de tiles” (no tienen por qué tener
todos ellos el mismo valor) que se repitan a lo largo de la pantalla y
de otras pantallas. Estos patrones se almacenan en memoria y se
referencian por medio de una tabla que relaciona un “identificador de
patrón” con la dirección donde está almacenado el patrón, finalizado en
255.
</p>

<p>
 Por ejemplo, supongamos un juego de plataformas donde hay gran cantidad
 de “suelos”, “plataformas en el aire”, construcciones hechas con
bloques, etc, que se repiten entre las diferentes pantallas. Podemos
asociar cada “patrón” con un identificador y después codificar la
pantalla utilizando algún código de control y la referencia al patrón.
</p>

<p>
 Utilizaremos un código de control especial (253, por ejemplo) para
codificar una ristra de datos “patrón” en lugar de tiles reales. Para
estos tiles basados en patrones usaremos el siguiente formato
(independiente de que la codificación del resto de tiles sea básica,
horizontal, vertical o mixta):
</p>
<pre class="code z80">Pantalla:
  DB X_TILE, Y_TILE, <span class="nu0">253</span>, ID_PATRON</pre>

<p>
 (También podemos agrupar X_TILE e Y_TILE en un mismo byte como hicimos en el script codificador).
</p>

<p>
 Supongamos la siguiente pantalla ilustrativa:
</p>
<pre class="code">000000000000000878787
001232400000000878787
000000001232400878787
000000000000000878787
012324000000000878787
000000000000000879987
123240012324000879987</pre>

<p>
 Los tiles “1, 2, 3, 2, 4” representan en nuestro “ejemplo” una
plataforma de suelo sobre la que el jugador puede saltar, siendo el tile
 1 un “borde izquierdo”, el tile 4 un “borde derecho” y los tiles 2, 3, 2
 tiles que representan 3 bloques de suelo.
</p>

<p>
 Los tiles “8, 7, 8, 7, 8, 7” representan bloques de “piedra” que forman parte de un castillo cuyo tile de “puerta” es el “9”.
</p>

<p>
 En la anterior pantalla encontramos los siguientes patrones:
</p>
<pre class="code z80">CODIF_HORIZONTAL  <span class="kw3">EQU</span>   <span class="re1">0</span>
CODIF_VERTICAL    <span class="kw3">EQU</span>   <span class="re1">1</span>
&nbsp;
Patron<span class="re1">0</span>:
  DB CODIF_HORIZONTAL, <span class="re1">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">2</span>, <span class="nu0">4</span>, <span class="nu0">255</span>
&nbsp;
Patron<span class="re1">1</span>:
  DB CODIF_VERTICAL, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">255</span>
&nbsp;
Patron2:
  DB CODIF_VERTICAL, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">255</span>
&nbsp;
Patron3:
  DB CODIF_VERTICAL, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">7</span>, <span class="nu0">255</span>
&nbsp;
Patron4:
  DB CODIF_VERTICAL, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">8</span>, <span class="nu0">255</span></pre>

<p>
 A continuación creamos una tabla de direcciones de patrones relacionadas con su ID:
</p>
<pre class="code z80">Tabla_Patrones:
  DW Patron<span class="re1">0</span>
  DW Patron<span class="re1">1</span>
  DW Patron2
  DW Patron3
  DW Patron4
  <span class="br0">(</span>...<span class="br0">)</span></pre>

<p>
 Mediante esta tabla podemos acceder a los datos de cualquier patrón como <strong>Tabla_Patrones + ID_PATRON*2</strong>.
</p>

<p>
 Si llamamos a estos patrones en el orden que los hemos visto, como A,
B, C, D y E, obtenemos 1 patrón horizontal y 4 verticales:
</p>
<pre class="code">    X         11111111112
Y   012345678901234567890
  -------------------------
0 | 000000000000000BCEDBC |
1 | 00AAAAA00000000BCEDBC |
2 | 00000000AAAAA00BCEDBC |
3 | 000000000000000BCEDBC |
4 | 0AAAAA000000000BCEDBC |
5 | 000000000000000BC99BC |
6 | AAAAA00AAAAA000BC99BC |
  -------------------------</pre>

<p>
 (Nota: se ha numerado la coordenada X y la Y para facilitar la codificación manual que realizaremos a continuación)
</p>

<p>
 Vamos a codificar cada “patrón” en una línea de DBs diferente para
simplificar su lectura. Nótese que los tiles “9” no forman parte de
ningún patrón y se han codificado como 2 scanlines horizontales de
tiles:
</p>
<pre class="code z80">Pantalla:
  DB <span class="nu0">2</span>, <span class="re1">1</span>, <span class="nu0">253</span>, <span class="re1">0</span>
  DB <span class="nu0">8</span>, <span class="nu0">2</span>, <span class="nu0">253</span>, <span class="re1">0</span>
  DB <span class="re1">1</span>, <span class="nu0">4</span>, <span class="nu0">253</span>, <span class="re1">0</span>
  DB <span class="re1">0</span>, <span class="nu0">6</span>, <span class="nu0">253</span>, <span class="re1">0</span>
  DB <span class="nu0">7</span>, <span class="nu0">6</span>, <span class="nu0">253</span>, <span class="re1">0</span>
  DB <span class="re1">1</span><span class="nu0">5</span>, <span class="re1">0</span>, <span class="nu0">253</span>, <span class="re1">1</span>
  DB <span class="re1">1</span><span class="nu0">9</span>, <span class="re1">0</span>, <span class="nu0">253</span>, <span class="re1">1</span>
  DB <span class="re1">1</span><span class="nu0">6</span>, <span class="re1">0</span>, <span class="nu0">253</span>, <span class="nu0">2</span>
  DB <span class="nu0">2</span><span class="re1">0</span>, <span class="re1">0</span>, <span class="nu0">253</span>, <span class="nu0">2</span>
  DB <span class="re1">1</span><span class="nu0">7</span>, <span class="re1">0</span>, <span class="nu0">253</span>, <span class="nu0">3</span>
  DB <span class="re1">1</span><span class="nu0">8</span>, <span class="re1">0</span>, <span class="nu0">253</span>, <span class="nu0">4</span>
  DB <span class="re1">1</span><span class="nu0">7</span>, <span class="nu0">5</span>, <span class="nu0">9</span>, <span class="nu0">9</span>, <span class="nu0">255</span>
  DB <span class="re1">1</span><span class="nu0">7</span>, <span class="nu0">6</span>, <span class="nu0">9</span>, <span class="nu0">9</span>, <span class="nu0">255</span></pre>

<p>
 Nótese que las líneas de definición de patrón no necesitan acabar en
255 porque tienen un tamaño definido (4 bytes) y además el patrón en sí
ya acaba en 255.
</p>

<p>
 La pantalla original tenía un total de 67 tiles y se ha codificado con
apenas 52 bytes. La codificación con métodos sin compresión habría sido
de 67 bytes más los datos de posicionamiento y fin de scanline porque
hay que almacenar esta información para cada “ristra”, es decir, 3 bytes
 por cada “scanline” (hay 11), lo que habría sumado 11*3 = 33 bytes
adicionales dando un total de 101 bytes para codificar la pantalla (100
más el byte 254 de cambio de codificación).
</p>

<p>
 Puede que viendo una sóla pantalla no parezca un gran ahorro, pero en
el global del mapa de juego cada nueva pantalla que tenga repetido
cualquiera de los patrones que tenemos en Tabla_Patrones permitirá
codificarlo con apenas 4 bytes (X, Y, 253, ID_PATRON), ó 3 bytes si se
codifican en el mismo byte la coordenada X y la coordenada Y.
</p>

<p>
 Y cabe decir que dadas las limitaciones de memoria del Spectrum, los
juegos tienen a repetir patrones de tiles para los diferentes tipos de
suelos, techos, paredes, etc:
</p>

<p>
<br>

<img src="img/gfx5_tresluces.png" class="mediacenter" alt=" Tres luces de Glaurung "/>
<br>

</p>
<div style="text-align: center;"><em>Patrones codificables: suelo, paredes verticales, etc</em></div>
<p>
<br>

</p>

<p>
 Este sistema acaba consiguiendo ratios de compresión muy buenos pero
basa toda su técnica en el programa codificador: el script/programa debe
 analizar todas las pantallas del mapeado en una pasada (no vale con
analizar sólo la pantalla que estamos codificando).
</p>

<p>
 A partir de esas pantallas debe de crear un diccionario de “patrones”
formado por todas las combinaciones de bloques que aparezcan, así como
las mismas combinaciones de menor tamaño, y cuantificar cuántas veces
aparece cada “patrón potencial”. Finalmente, se utilizan las N entradas
que producirían más sustituciones para su uso como patrón. Es un
algoritmo muy parecido a la compresión LZW.
</p>

<p>
 Además de modificar la rutina mapeadora para añadirle la impresión de
patrones es necesario realizar un codificador específico más complejo
que los que hemos visto en este capítulo.
</p>

<p>
 Finalmente, es importante recordar que no estamos atados a utilizar una
 única técnica de las que acabamos de ver: podemos utilizar, por
ejemplo, codificación mixta con compresión y patrones, o con patrones
pero sin compresión, etc, mezclando las diferentes técnicas de
codificación y de impresión en rutinas específicas a tal efecto.
</p>

<p>
<br>

</p>

</div>

<h2 id="propiedades-de-los-tiles-y-el-mapeado">Propiedades de los tiles y el mapeado</h2>
<div class="level2">

<p>
 A la hora de diseñar el mapa del juego tenemos que tener en cuenta las
propiedades de cada uno de los tiles del mapeado. ¿Qué tiles deben de
ser sólidos de forma que el personaje no pueda atravesarlos? ¿Qué tiles,
 pese a ser dibujados, deben de ser tomados como “parte del fondo” y el
personaje puede pasar a través de ellos? ¿Qué tiles soportan el peso del
 personaje y cuáles deben “deshacerse” cuando el personaje los pise?
¿Debe un tile concreto permitir al personaje atravesarlo saltando desde
debajo de él pero ser sólido al pisarlo?
</p>

<p>
 Este tipo de características de los tiles se conoce como “<strong>propiedades</strong> o <strong>atributos</strong>”,
 y aunque no son usados por las rutinas de impresión de mapeados, sí que
 son utilizados por el bucle principal del programa a la hora de mover
los personajes o enemigos para determinar si se puede atravesar una
determinada zona de pantalla, si el personaje debe morir por pisar un
tile concreto, etc.
</p>

<p>
 La primera distinción suele ser marcar qué tiles son “sólidos” y a
través de cuáles puede pasar el jugador. En muchos juegos se utiliza el
tile 0 como tile “de fondo” y el resto de tiles como bloques sólidos
(Manic Miner, etc) pero es posible que necesitemos que algunos tiles
sean dibujados y sin embargo nuestro personaje pueda pasar a través de
ellos. Todos los tiles serán iguales para la rutina de impresión, pero
no lo serán para las rutinas de gestión de movimiento de nuestro
personaje y de los enemigos.
</p>

<p>
<br>

<img src="img/gfx5_blinky.gif" class="mediacenter" alt=" Atravesando tiles "/>
<br>

</p>
<div style="text-align: center;"><em>Nuestro personaje tiene que poder atravesar la columna</em></div>
<p>
<br>

</p>

<p>
 En ese caso, podemos utilizar un valor numérico como límite entre tiles
 no sólidos y tiles sólidos. Por ejemplo, podemos considerar que los
primeros tiles 0-99 son atravesables por el jugador y los tiles del 100
en adelante serán sólidos. La rutina que gestione el movimiento de
nuestro personaje deberá obtener del mapa el identificador de tile y
permitirnos pasar a través de él o no según el valor obtenido.
</p>

<p>
 Para ciertos juegos es posible que ni siquiera necesitemos definir
propiedades de solidez y que (según el tipo de juego) baste con que el
personaje se pueda mover sobre el color de fondo y que no pueda
atravesar cualquier color distinto de este.
</p>

<p>
<br>

<img src="img/gfx5_turrican.gif" class="mediacenter" alt=" Turrican "/>
<br>

</p>

<p>
 Aparte de la típica clasificación entre bloque sólido y no sólido,
puede sernos imprescindible otorgar ciertas propiedades a los tiles y en
 ese caso nos resultará necesario disponer de algún tipo de estructura
de datos que almacene esta información. Por ejemplo, otro caso típico de
 propiedad de tile es el de indicar si un determinado bloque de pantalla
 produce o no la muerte del jugador: como pinchos, lava, fuego, etc.
</p>

<p>
 Se pueden definir estos atributos bien en los tiles (un mismo
identificador de tile siempre cumple una determinada propiedad) o bien
en los mapas (es la posición de pantalla la que cumple esa propiedad).
</p>

<p>
 En el primero de los casos (<strong>propiedades en los tiles</strong>),
 necesitaremos una tabla que relacione cada identificador de tile con
sus propiedades (bien usando un byte por propiedad o un simple bit en el
 caso de propiedades tipo sí/no).
</p>
<pre class="code z80"><span class="co1">;;; Byte de propiedades de cada tile:</span>
<span class="co1">;;; Bit 0 -&gt; Tile solido (1) o atravesable por el jugador (0)</span>
<span class="co1">;;; Bit 1 -&gt; El tile se "rompe" al pisarlo el jugador (1), o no (0)</span>
<span class="co1">;;; Bit 2 -&gt; Si 1, cuando el jugador toca el tile, muere.</span>
<span class="co1">;;; Bit 3 -&gt; El tile es de tile "escalera" (permite subir y bajar)</span>
<span class="co1">;;; Bit 4 -&gt; El tile es un teletransportador</span>
<span class="co1">;;; (etc...)</span>
Propiedades_Tiles:
  DB <span class="re1">%00000000</span>        <span class="co1">; Propiedades tile 0 (tile vacio)</span>
  DB <span class="re1">%00000001</span>        <span class="co1">; Propiedades tile 1 (bloque)</span>
  DB <span class="re1">%00000010</span>        <span class="co1">; Propiedades tile 2 (suelo que se rompe)</span>
  DB <span class="re1">%00000001</span>        <span class="co1">; Propiedades tile 3 (otro bloque)</span>
  DB <span class="re1">%00000101</span>        <span class="co1">; Propiedades tile 4 ("pinchos")</span></pre>

<p>
 En el segundo de los casos (<strong>propiedades en un mapa alternativo</strong>),
 mucho más costoso en términos de memoria, necesitamos una “copia” del
mapa pero que en lugar de almacenar tiles almacene las propiedades de
ese punto del mapa. Esto permite que un gráfico determinado tenga un
efecto en una zona de la pantalla, y otro fuera de ella.
</p>

<p>
 Por ejemplo, con un mapa de propiedades podemos conseguir que tiles que
 son sólidos en un lugar sean atravesables en otro al estilo de las
zonas secretas de juegos como Super Mario World. Podemos simular este
efecto utilizando propiedades de tiles si “duplicamos” el tile gráfico
en cuestión y a uno le asignamos la propiedad de solidez y al otro no.
Tendríamos 2 identificadores de tile diferente a la hora de generar las
pantallas con el mismo gráfico, pero diferente comportamiento.
</p>

<p>
 Asignar propiedades a Tiles resulta en general mucho menos costoso en
términos de memoria que asignarlas a posiciones de pantalla.
</p>

<p>
<br>

</p>

</div>

<h2 id="objetos-y-enemigos-en-el-mapeado">Objetos y enemigos en el mapeado</h2>
<div class="level2">

<p>
 Por normal general, los enemigos, personajes y objetos del juego no se
definen dentro del mapeado, sino que se cargan desde estructuras de
datos separadas. Estas estructuras pueden incluir por ejemplo la
posición X, Y del objeto, el ID de Pantalla en la que están esos
objetos, así como referencias al sprite que lo representan.
</p>

<p>
 Realmente, en los juegos es posible ubicar llaves, items de comida,
salud, vidas u otros objetos en el mapeado, pero esto tiene la
desventaja de que su ubicación es la misma para todas las ejecuciones
del juego.
</p>

<p>
 Cuando tratemos el capítulo dedicados a estructuras de datos veremos
ejemplos de cómo definir estructuras que almacenen la información de
posición, datos gráficos y características de objetos, enemigos,
interruptores, puertas, y otros items del juego.
</p>

<p>
<br>

</p>

</div>

<h2 id="diseno-y-creacion-del-mapeado">Diseño y creación del mapeado</h2>
<div class="level2">

<p>
 Conocemos la teoría y la práctica sobre el diseño de pantallas y mapas
en cuanto a los mecanismos de codificación e impresión, pero a la hora
de programar un juego se hace palpable la necesidad de disponer de una
herramienta para diseñar las pantallas de forma visual en lugar de
componerlas manualmente mediante los identificadores de los tiles.
</p>

<p>
 En la mayoría de los casos, lo más rápido puede ser diseñar un sencillo
 editor en nuestra plataforma de desarrollo (por ejemplo, usando python y
 pygame o C++ y SDL) que cargue el tileset y nos permita seleccionar
bloques del mismo y “dibujar” en la pantalla utilizando el actual bloque
 seleccionado. A este programa le podemos añadir funciones de grabación y
 carga de pantallas, además de la imprescindible opción de “exportación”
 a formato ASM.
</p>

<p>
 Al diseñar el editor específicamente para nuestras necesidades, podemos
 agregar no sólo gestión de las pantallas sino del mapa en sí mismo, de
tal modo que el editor nos permita definir las conexiones entre
pantallas y genere la estructura de mapa lista para usar. También
podemos agregar algún tipo de gestión de los atributos de cada tile en
pantalla (si es sólido o no, etc). Otra función interesante sería la de
permitir modificar el orden de los tiles en el tileset alterando las
pantallas para reflejar ese cambio, lo que haría más sencillo reubicar
tiles o añadir nuevos tiles por debajo de un valor numérico dado.
</p>

<p>
 Si no tenemos el tiempo o los recursos para realizar un programa de
estas características, siempre podemos optar por utilizar alguno de los
ya existentes para nuestra plataforma de desarrollo. Es imprescindible
asumir que deberemos programar algún tipo de script/programa de
conversión del formato de pantalla utilizado por la herramienta de
mapeados al formato que nosotros deseamos, una ristra de “DBs” incluíble
 en nuestro programa.
</p>

<p>
 Alguno de los programas más conocidos para este tipo de tareas son:
</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> Mappy: <a href="http://www.tilemap.co.uk/mappy.php" class="urlextern" title="http://www.tilemap.co.uk/mappy.php">http://www.tilemap.co.uk/mappy.php</a></div>
</li>
<li><div class="li"> Mappy Linux : <a href="http://membres.multimania.fr/edorul/Mappy-1.0.tar.gz" class="urlextern" title="http://membres.multimania.fr/edorul/Mappy-1.0.tar.gz">http://membres.multimania.fr/edorul/Mappy-1.0.tar.gz</a></div>
</li>
<li><div class="li"> Map Editor: <a href="http://www.mapeditor.org/" class="urlextern" title="http://www.mapeditor.org/">http://www.mapeditor.org/</a></div>
</li>
</ul>

<p>
 Map Editor es el editor más moderno de los 3, y soporta exportación del
 mapa a formato XML lo que puede facilitar la creación del script de
conversión a formato ASM. Además, es una herramienta Free Software, por
lo que disponemos tanto del código fuente como del permiso para
modificarlo y adaptarlo a nuestras necesidades.
</p>

<p>
<br>

<img src="img/gfx5_mapeditor.png" class="mediacenter" alt=" Map Editor "/>
<br>

</p>

<p>
 Mappy es más antiguo y se diseñó para juegos basados en las librerías
de PC “Allegro” y (actualmente) “SDL”. El código fuente está basado en
la librería Allegro y puede ser también modificado a nuestro antojo.
</p>

<p>
 Mappy Linux es un pequeño programa que utiliza las bibliotecas de
MappySDL para actuar como un editor de mapeados. Al disponer del código
fuente, puede ser directamente adaptado a nuestras necesidades. Como es
un editor realmente sencillo, su código no es tan complejo como pueda
serlo el de Map Editor.
</p>

<p>
 No obstante, es probable que resulte más rápido el crear un sencillo
programa desde cero que el adaptar el código de cualquiera de estos
programas, sin olvidar que siempre nos queda la posibilidad de diseñar
las pantallas manualmente.
</p>

<p>
 Recordemos por otra parte que nuestro editor de mapeados grabará
normalmente la pantalla en formato “crudo” y que debemos utilizar
nuestro programa “codificador” para reducir el tamaño de cada pantalla.
Si estamos creando un programa propio, podemos aprovechar el script
codificador llamándolo desde el propio editor para exportar las
pantallas directamente codificadas.
</p>

<p>
<br>

</p>

</div>

<h2 id="mapeando-sobre-pantallas-virtuales">Mapeando sobre pantallas virtuales</h2>
<div class="level2">

<p>
 Aunque el tiempo de generación de una pantalla por bloques es
practicamente imperceptible por el usuario, si queremos evitar que se
vea la generación del mapa podemos utilizar una pantalla virtual como
destino de la impresión de los tiles y después realizar un volcado de la
 pantalla virtual completa sobre la videoram.
</p>

<p>
 Esto implica la necesidad de 6912 bytes de memoria para evitar que el
usuario vea la generación del mapa, por lo que no es normal utilizar
esta técnica a menos que esté realmente justificado.
</p>

<p>
 Si utilizamos pantallas virtuales necesitaremos modificar todas las
rutinas de impresión para que trabajen con una dirección destino
diferente en lugar de sobre $4000. Para que las rutinas sigan pudiendo
utilizar los trucos de composición de dirección en base a
desplazamientos de bits que vimos en capítulos anteriores lo normal es
que busquemos una dirección de memoria libre cuyos 3 bits más altos ya
no sean “010b” (caso de la videoram → $4000 → 0100000000000000b) sino,
por ejemplo “110” ($C000). De esta forma se pueden alterar las rutinas
fácilmente para trabajar sobre un área de 7KB equivalente a la videoram
pero comenzando en $C000.
</p>

<p>
 Por otra parte, si nos estamos planteando el usar una pantalla virtual
simplemente para que no se vea el proceso de construcción de la
pantalla, podemos ahorrarnos la pantalla virtual separando la rutina de
impresión de pantalla en 2: una de impresión de gráficos y otra de
impresión de atributos. Así, rellenamos el área de pantalla que aloja el
 mapa con atributos “cero” (negro), trazamos los datos gráficos (que no
podrá ver el usuario) y después trazamos los atributos. Estos atributos
podemos trazarlos directamente en pantalla tras un HALT, o en una “tabla
 de atributos virtual” de 768 que después copiaremos sobre el área de
atributos. De esta forma utilizamos una pantalla virtual de 768 bytes en
 lugar de requerir 6912.
</p>

<p>
<br>

</p>

</div>

<h2 id="mapeando-en-posiciones-de-alta-resolucion">Mapeando en posiciones de alta resolución</h2>
<div class="level2">

<p>
 Todo el capítulo se ha basado en impresión de tiles en posiciones
exáctas de bloque y con tiles múltiplos de carácter, es decir, en
impresión de tiles en baja resolución. Esta técnica es adecuada para
prácticamente cualquier juego sin scroll pixel a pixel de los tiles.
</p>

<p>
 Para poder imprimir tiles en posiciones de alta resolución que no
coincidan con caracteres exactos se tienen que utilizar técnicas de
rotación / prerotación de los tiles gráficos tal y como veremos en el
próximo capítulo.
</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><a href="src/gfx5_map16h.asm">Impresión de una pantalla 16x16</a>
</li>
<li><a href="src/gfx5_map16h.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/codificar_pantalla.py">Script codificador pantallas en python</a>
</li>
<li><a href="src/gfx5_mapdif_b.asm">Ejemplo agrupación básica</a>
</li>
<li><a href="src/gfx5_mapdif_b.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx5_mapdif_h.asm">Ejemplo agrupación scanlines horizontales</a>
</li>
<li><a href="src/gfx5_mapdif_h.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx5_mapdif_v.asm">Ejemplo agrupación scanlines verticales</a>
</li>
<li><a href="src/gfx5_mapdif_v.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx5_mapdif_m.asm">Ejemplo agrupación mixta</a>
</li>
<li><a href="src/gfx5_mapdif_m.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx5_mapdif_mxy.asm">Ejemplo agrupación mixta (X, Y agrupadas)</a>
</li>
<li><a href="src/gfx5_mapdif_mxy.tap">Tap del ejemplo anterior</a>
</li>
<li><a href="src/gfx5_maparray.asm">Mapeado de array global: movimiento con OPQA</a>
</li>
<li><a href="src/gfx5_maparray.tap">Tap del ejemplo anterior</a>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="enlaces">Enlaces</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="http://microhobby.speccy.cz/mhf/107/MH107_22.jpg" class="urlextern" title="http://microhobby.speccy.cz/mhf/107/MH107_22.jpg">El mapeado de gráficos (I)</a> (Microhobby nº 107).</div>
</li>
<li><div class="li"> <a href="http://microhobby.speccy.cz/mhf/109/MH109_34.jpg" class="urlextern" title="http://microhobby.speccy.cz/mhf/109/MH109_34.jpg">El mapeado de gráficos (II)</a> (Microhobby nº 109).</div>
</li>
<li><div class="li"> <a href="http://microhobby.speccy.cz/mhf/110/MH110_26.jpg" class="urlextern" title="http://microhobby.speccy.cz/mhf/110/MH110_26.jpg">El mapeado de gráficos (III)</a> (Microhobby nº 110).</div>
</li>
<li><div class="li"> <a href="http://microhobby.speccy.cz/mhf/112/MH112_26.jpg" class="urlextern" title="http://microhobby.speccy.cz/mhf/112/MH112_26.jpg">El mapeado de gráficos (IV)</a> (Microhobby nº 112).</div>
</li>
<li><div class="li"> <a href="http://microhobby.speccy.cz/mhf/MHEs6/mhes6_58.jpg" class="urlextern" title="http://microhobby.speccy.cz/mhf/MHEs6/mhes6_58.jpg">Técnicas de mapeado</a> (Microhobby Especial nº 6).</div>
</li>
<li><div class="li"> <a href="http://metalbrain.speccy.org/" class="urlextern" title="http://metalbrain.speccy.org">Web de SevenuP</a> (por metalbrain).</div>
</li>
<li><div class="li"> Algoritmo LZW: <a href="http://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch" class="urlextern" title="http://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">Wikipedia en Inglés</a> y <a href="http://es.wikipedia.org/wiki/LZW" class="urlextern" title="http://es.wikipedia.org/wiki/LZW">en Español</a>.</div>
</li>
<li><div class="li"> <a href="external/www.z80.info/index.html" class="urlextern" title="http://www.z80.info">Web del Z80</a>.</div>
</li>
<li><div class="li"> <a href="external/www.ticalc.org/pub/text/z80/z80time.txt" class="urlextern" title="external/www.ticalc.org/pub/text/z80/z80time.txt">Tiempos de ejecución y tamaños</a> de las instrucciones del Z80.</div>
</li>
<li><div class="li"> <a href="external/worldofspectrum.org/faq/reference/z80reference.htm" class="urlextern" title="external/worldofspectrum.org/faq/reference/z80reference.htm">Z80 Reference de WOS</a>.</div>
</li>
<li><div class="li"> <a href="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm" class="urlextern" title="http://www.speccy.org/trastero/cosas/Fichas/fichas.htm">Microfichas de CM de MicroHobby</a>.</div>
</li>
<li><div class="li"> <a href="external/pasmo.speccy.org/index.html" class="urlextern" title="external/pasmo.speccy.org/index.html">PASMO</a>.</div>
</li>
</ul>

</div>

</div>
      </article>
      <article id="dokuwiki__content" class="container">
            <div class="dw-content dw-toc-closed">
<h1 id="compresion-y-descompresion-rle">Compresión y Descompresión RLE</h1>
<div class="level1">

<p>
Como ya sabemos, la memoria disponible para datos en el Spectrum es
bastante limitada. A los 48KB de memoria base (si no usamos la técnica
de paginación de memoria de los modelos de 128KB) hay que restarles los
casi 7KB de la VideoRAM (el área de memoria que representa lo que vemos
en pantalla), el espacio de pila y, finalmente, el espacio ocupado por
nuestro programa (el código binario del mismo). El resultado de esta
operación nos dejará con una cantidad determinada de memoria en la que
deben entrar los datos del programa (gráficos, sonidos, músicas, tablas,
 áreas temporales, etc).
</p>

<p>
Ante esta tesitura, no nos queda otro remedio que aprovechar al límite
el espacio disponible, y una de las formas de hacerlo es mediante <em>compresión de datos</em>.
</p>

<p>
 La compresión sin pérdida de datos consiste en coger unos datos de un
determinado tamaño (gráficos, sonido, una pantalla de carga, etc) y
aplicarle un algoritmo que produzca como salida unos datos de un tamaño
menor que el inicial. Estos datos resultantes deben de permitir obtener a
 partir de ellos, aplicando una transformación a los mismos en tiempo
real, los datos iniciales.
</p>

<p>
 Este proceso de compresión lo realizamos durante el desarrollo de
nuestra aplicación o programa (por ejemplo, en un PC), y utilizamos los
“datos comprimidos” directamente en nuestro programa en lugar de
utilizar los “datos en crudo” o descomprimidos.
</p>

<p>
 El resultado es, por ejemplo, que una pantalla gráfica de 7KB se
reduzca a 2KB dentro de nuestro “ejecutable”, y que podamos
“descomprimirla” al vuelo sobre la VideoRAM desde los datos comprimidos.
 De esta manera, ahorramos 5KB de memoria en una única pantalla.
</p>

<p>
 En resumen:
<br>

<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> Proceso de <strong>compresión</strong>: <br>
<br>
Datos (7KB) → COMPRESION EN PC → Datos_comprimidos (2KB)</div>
</li>
</ul>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> Proceso de <strong>descompresión</strong>: <br>
<br>
Datos_comprimidos (2KB) → DESCOMPRESION AL VUELO → Datos (7KB).</div>
</li>
</ul>

<p>
<br>

</p>

<p>
 Los procesos de COMPRESION y DESCOMPRESION son funciones que reciben
como entrada los datos en crudo o los datos comprimidos
(respectivamente) y producen como salida los datos comprimidos o los
datos originales.
</p>

<p>
 Hay infinidad de algoritmos de compresión, es decir, una gran variedad
de transformaciones diferentes sobre los datos originales y que producen
 datos comprimidos. En este capítulo veremos la compresión RLE, una de
las más básicas y que produce excelentes resultados con determinados
tipos de datos (por ejemplo, los gráficos que cumplan unas ciertas
condiciones).
</p>

<p>
<br>

</p>

</div>

<h2 id="fundamentos-de-la-compresion-rle">Fundamentos de la compresión RLE</h2>
<div class="level2">

<p>
 La compresión RLE o <strong>Run Lenght Encoding</strong> se basa en la
sustitución de elementos repetidos por “comandos” que indican que un
elemento está repetido, y cuántas veces lo está.
</p>

<p>
 Lo que haremos será sustituir secuencias consecutivas de bytes por “bytes de repetición” seguidos del byte a repetir.
</p>

<p>
 Supongamos la siguiente secuencia de datos:
</p>
<pre class="code">1, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6</pre>

<p>
 Esta serie de 20 dígitos nos ocuparía en memoria 20 bytes. Pero si nos
fijamos adecuadamente en los datos repetidos, es posible comprimirla
como la siguiente secuencia:
</p>
<pre class="code">1, 2, 0, 3, "12 CEROS", 3, 4, 5, 6</pre>

<p>
 Es decir, si sustituimos los doce ceros consecutivos por algún tipo de marcador que indique “<em>esto son doce ceros</em>”, podemos ahorrar mucha memoria.
</p>

<p>
 Un primer vistazo al problema podría sugerir el siguiente flujo de datos comprimidos:
</p>
<pre class="code">1, 2, 0, 3, 12, 0, 3, 4, 5, 6</pre>

<p>
 En este ejemplo, el 12 previo al cero nos indicaría que debemos repetir
 el cero un total de doce veces. Pero … ¿cómo distinguirá nuestra rutina
 descompresora si ese número 12 es un dato en sí mismo o un indicador de
 repetición? La respuesta es, no puede saberlo, a menos que marquemos
ese 12 de alguna forma especial. Debemos pues determinar un marcador
para que nuestro descompresor distinga los “datos” de los “bytes de
repetición”.
</p>
<pre class="code">1, 2, 0, 3, *12*, 0, 3, 4, 5, 6</pre>

<p>
<br>

<br>

 Ahora bien … ¿qué tipo de marcador podemos utilizar?
</p>

<p>
<br>

 En el algoritmo RLE <strong>se utilizan como marcadores de repetición los 2 bits superiores del dato</strong>. Estos bits, el número 7 y el número 6, tienen el siguiente valor:
</p>
<div class="table-responsive sectionedit3"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> 7 </th><th class="col1"> 6 </th><th class="col2"> 5 </th><th class="col3"> 4 </th><th class="col4"> 3 </th><th class="col5"> 2 </th><th class="col6"> 1 </th><th class="col7"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 128 </td><td class="col1"> 64 </td><td class="col2"> 32 </td><td class="col3"> 16 </td><td class="col4"> 8 </td><td class="col5"> 4 </td><td class="col6"> 2 </td><td class="col7"> 1 </td>
	</tr>
</tbody></table></div>

<p>
<strong>Bit 7 + Bit 6 = 128 + 64 = 192.</strong>
<br>
<br>

 Así pues, nuestro “comando de repetición” será cualquier byte que tenga
 los bits 6 y 7 activos (con valor mayor o igual que 192). Los bits del 0
 al 5 nos indicará el número de veces que representa al elemento
repetido.
</p>
<div class="table-responsive sectionedit4"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> 7 </th><th class="col1"> 6 </th><th class="col2"> 5 </th><th class="col3"> 4 </th><th class="col4"> 3 </th><th class="col5"> 2 </th><th class="col6"> 1 </th><th class="col7"> 0 </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> RLE </td><td class="col1"> RLE </td><td class="col2" colspan="6"> Número de repeticiones </td>
	</tr>
</tbody></table></div>

<p>
 Por ejemplo, en nuestro bloque de datos anterior:
</p>
<pre class="code">1, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6</pre>

<p>
 Si sustituimos los 12 ceros por su “byte repetidor” seguido del dato a repetir, quedaría:
</p>
<pre class="code">1, 2, 0, 3, 204, 0, 3, 4, 5, 6</pre>

<p>
 ¿De dónde ha salido ese <strong>204</strong>? Pues es “<strong>192+12</strong>”, es decir, es un byte que tiene activos los bits 6 y 7 y que en los bits 0 a 5 contiene el valor “<strong>12</strong>” (el número de repeticiones). Y al dato 204 le sigue el “0”, que es el dato que hay que repetir 12 veces.
</p>

<p>
<a href="img/rlefund_01.png" class="media" title="cursos:ensamblador:rlefund_01.png"><img src="img/rlefund_01.png" class="mediacenter" alt=""></a>
</p>

<p>
 Nótese que nuestros datos en crudo ocupaban 20 bytes, y los datos
comprimidos ocupan sólo 10 bytes. Es una compresión del 50%. Si todos
nuestros datos fueran de características similares, podríamos poner en
nuestro programa o juego el doble de niveles, de gráficos o de músicas.
Obviamente no todos los bloques de datos son susceptibles de ser
comprimidos, pero la mayoría de gráficos, por ejemplo, lo son. Y poder
meter más datos en nuestro programa es algo que agradeceremos en muchas
ocasiones.
</p>

<p>
 Estos datos comprimidos (y no los originales) serían los que incluiríamos en nuestro programa, así:
</p>
<pre class="code z80">Datos_comprimidos:
                    DEFB <span class="re1">1</span>, <span class="nu0">2</span>, <span class="re1">0</span>, <span class="nu0">3</span>, <span class="nu0">2</span><span class="re1">0</span><span class="nu0">4</span>, <span class="re1">0</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span></pre>

<p>
 Después, nuestro programa debería ser capaz de descomprimirlos allá
donde vayamos a usarlos, es decir, coger los datos comprimidos, y
desempaquetarlos obteniendo los datos originales previos a la
compresión. La descompresión puede hacerse nada más arrancar el programa
 (sobre bancos de memoria, zonas de trabajo, etc), o directamente en el
momento de necesitarlos (intros, pantallas finales de juegos, etc).
</p>

<p>
 Para la descompresión sólo tenemos que asegurarnos de, byte a byte,
copiar los datos “normales” y de “repetir N veces” los datos comprimidos
 RLE. Distinguiremos los datos “comprimidos” porque son mayores de 192
(tienen los bits 6 y 7 activos).
</p>

<p>
 Así, la rutina de descompresión se basaría en:
</p>
<pre class="code">  * Desde I=0 hasta LONGITUD_DATOS
     * DATO = Datos[i]
     * Si dato &lt; 192   -&gt; Es un dato normal
         * A datos_comprimidos añado "dato".
     * Si dato &gt;= 192  -&gt; Es un dato comprimido
         * Repeticiones = dato - 192
         * Dato_Real = al siguiente valor a Dato[i]
         * A datos_comprimidos añado "Repeticiones" veces Dato_Real
  * Fin_Desde</pre>

<p>
 En el ejemplo anterior, la rutina de descompresión leería datos uno a uno y vería:
</p>
<pre class="code">Comprimido = (1, 2, 0, 3, 204, 0, 3, 4, 5, 6)
Descomprimido = (vacío inicialmente)</pre>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> 1 → (&lt;192) = No está comprimido<br>
→ El 1 lo copio en Descomprimido.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> 2 → (&lt;192) = No está comprimido<br>
→ El 2 lo copio en Descomprimido.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> 0 → (&lt;192) = No está comprimido<br>
→ El 0 lo copio en Descomprimido.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> 3 → (&lt;192) = No está comprimido<br>
→ El 3 lo copio en Descomprimido.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> 204 → (&gt;=192) = Sí está comprimido<br>
→ Calculo REPETICIONES = 204-192 = 12<br>
→ Leo el siguiente dato (un 0).<br>
→ Copio a “Descomprimido” 12 ceros.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> 0 → (&lt;192) = No está comprimido<br>
→ El 0 lo copio en Descomprimido.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> 3 → (&lt;192) = No está comprimido<br>
→ El 3 lo copio en Descomprimido.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> 4 → (&lt;192) = No está comprimido<br>
→ El 4 lo copio en Descomprimido.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> 5 → (&lt;192) = No está comprimido<br>
→ El 5 lo copio en Descomprimido.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> 6 → (&lt;192) = No está comprimido<br>
→ El 6 lo copio en Descomprimido.</div>
</li>
</ul>

<p>
<br>

 Nótese que dado que utilizamos los bits 0 al 5 para indicar el número
de repeticiones (puesto que el 6 y el 7 son marcadores RLE), eso quiere
decir que un dato “comprimido” sólo puede representar un máximo de 63
repeticiones.
</p>

<p>
 O, lo que es lo mismo, que 63 ceros seguidos se codificarían como <strong>255, 0</strong> (ya que 255-192 son 63).
</p>

<p>
 Si tuvieramos que codificar 70 ceros, sería mediante 2 bloques RLE, es
decir, codificaríamos 63 ceros en un conjunto RLE, y los 7 restantes en
otro:
<br>
<br>

 <strong>255, 0, 199, 0</strong>
</p>

<p>
<br>

</p>

</div>

<h2 id="los-datos-que-son-mayores-de-191">Los datos que son mayores de 191</h2>
<div class="level2">

<p>
 La pregunta es … ¿qué pasa si nos encontramos con datos REALES en el
array a comprimir que sean ya de por sí (sin ser bytes de repetición) de
 valor 192 o superior?
</p>

<p>
 Supongamos el siguiente flujo de datos:
</p>
<pre class="code">0, 1, 200, 2</pre>

<p>
 El valor 193 es, por sí mismo, un valor RLE (&gt;=192), por lo que
debemos encontrar una forma de indicar a nuestra rutina descompresora
que ese dato no es un dato comprimido, para evitar que (en el ejemplo
anterior), repita el siguiente valor, el 2, un total de 8 veces
(200-192).
</p>

<p>
 La solución es muy sencilla: cuando realicemos la compresión,
codificaremos los valores mayores o iguales de 192 como un bloque RLE de
 longitud uno:
</p>
<pre class="code">0, 1, 200, 2     -&gt;   0, 1, 193, 200, 2</pre>

<p>
 Nótese cómo se ha codificado el valor <strong>200</strong> como un RLE de 2 bytes: <strong>193, 200</strong>. Esto implica, en nuestra rutina de compresión, que los datos comprimidos han acabado ocupando 1 byte más que los originales.
</p>

<p>
 El aumento del tamaño de los datos comprimidos sólo ocurre cuando el
dato a comprimir es mayor que 192, y además no está repetido, ya que si
está repetido también nos beneficiaremos de la compresión RLE:
</p>
<pre class="code">0, 1, 200, 200, 200, 200, 200, 200, 200, 2    -&gt;   0, 1, 199, 200, 2</pre>

<p>
 En el ejemplo anterior, los 7 datos <strong>200</strong> se han codificado como <strong>199, 200</strong>, pasando de ocupar 7 bytes a ocupar 2.
</p>

<p>
 Es decir, sólo <strong>perderemos ratio de compresión en aquellos datos que sean mayores que 192 y que no estén repetidos de forma consecutiva</strong>. En el resto de casos nos mantendremos iguales (si no hay repeticiones) o ganaremos espacio (en el caso de las repeticiones).
</p>

<p>
 Obviamente, hay que seleccionar el mejor tipo de compresión para
nuestros datos. La compresión RLE vendrá muy bien, por ejemplo, para
todas aquellas imágenes que tengan muchos colores iguales repetidos
(imágenes rellenadas con colores planos, por ejemplo), pero será nefasta
 en imágenes con mucha variación entre cada pixel y el siguiente, si
éstos valores son mayores o iguales que 192.
</p>

<p>
 En una imagen de pantalla de Spectrum (aprox. 7KB) que tenga bastantes
colores planos, podemos pasar a obtener ratios de compresión que dejen
la imagen comprimida en 2-3KB o a veces incluso menos. Las fuentes de
letras y los sprites también son en ocasiones buenos candidatos para la
compresión.
</p>

<p>
 Obviamente, podemos provocar mejoras en la compresión a la hora de
diseñar las pantallas… si el dibujar una determinada zona con un color
de tinta o papel determinado produce valores mayores que 192, basta con
dibujar la misma zona invirtiendo la tinta y el papel (y los valores de
los bits) para que esa zona no produzca valores de compresión RLE.
</p>

<p>
 Eso quiere decir que un bloque de 8 píxeles de valor 1111000 sin
repetición se convertirá en 2 bytes (el 193 de repetición, por ser mayor
 de 192, seguido de 1111000). Pero si invertimos tinta y papel en ese
recuadro y lo dibujamos como 00001111 ya no se producirán 2 bytes por
este dato a comprimir.
</p>

<p>
 Nada nos impide tampoco el comprimir aquello que produzca un buen ahorro, y dejar sin comprimir lo que no.
</p>

<p>
<br>

</p>

</div>

<h2 id="resumen-sobre-la-compresion">Resumen sobre la compresión</h2>
<div class="level2">

<p>
 Antes de ver el pseudocódigo y las rutinas descompresoras y compresoras, vamos a resumir lo visto hasta ahora.
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> La <strong>compresión</strong> es un
 proceso que convierte una serie de datos de tamaño N en otra serie de
datos de tamaño M (siendo M menor que N), mediante un determinado
algoritmo de procesado de los datos originales.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> Los <strong>datos</strong> a
comprimir pueden ser cualquier tipo: una pantalla de imagen de 6912
bytes, un sprite o conjunto de sprites, música… En general se puede
comprimir cualquier cosa que se pueda representar como una “ristra” de
bytes (es decir, todo).</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> El <strong>algoritmo de compresión sin pérdida</strong>
 es un mecanismo de transformación de los datos que debe ser reversible.
 Es decir, a partir de los datos comprimidos debemos ser capaces de
obtener los datos originales.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> El <strong>ratio de compresión</strong>
 nos indica el ahorro de memoria obtenido. Si una secuencia de 2000
bytes se comprime en 1000 bytes, diremos que hemos obtenido un ratio de
compresión del 50%. El ratio de compresión variará según los datos a
comprimir y el algoritmo de compresión empleado. En el caso de RLE,
obtendremos grandes ratios de compresión con series de datos que
contengan muchos valores repetidos y malos ratios con datos que
contengan muchos valores mayores de 192 sin repeticiones.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> La <strong>descompresión</strong> es
 un proceso que obtiene, desde los datos comprimidos, la secuencia de
datos originales, mediante un determinado algoritmo de procesado.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> El <strong>algoritmo de descompresión</strong> es el mecanismo de transformación de los datos comprimidos que nos permite obtener los datos originales.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> La <strong>compresión RLE</strong>
es un algoritmo de compresión basado en la repetición de los datos.
Consiste en agrupar los datos consecutivos repetidos mediante un
“marcador RLE” que indica el número de repeticiones del siguiente dato
de la secuencia.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> La <strong>descompresión RLE</strong>
 es un algoritmo de descompresión que, a partir de unos datos
comprimidos con RLE, obtiene los datos originales mediante la
“expansión” de los datos “de repetición” formados por “Marcador RLE con
número de repeticiones”, y “Dato a repetir”.</div>
</li>
</ul>

<p>
<br>

</p>

<p>
<br>

</p>

</div>

<h2 id="como-trabajaremos-con-la-compresion">Cómo trabajaremos con la compresión</h2>
<div class="level2">

<p>
 A continuación vamos a ver el pseudocódigo y funciones ensamblador y C
de descompresión RLE y compresión RLE. Pero antes, es importante
destacar la forma en que usaremos estas funciones:
<br>

<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Compresión</strong>: La
compresión RLE de los datos (imágenes, sonido, o cualquier otro tipo de
datos) se realiza en nuestro PC. Es decir, cogeremos un .SCR con una
pantalla de 6912 bytes, o un .BIN con los datos gráficos de un Sprite (o
 cualquier otro tipo de datos), y los comprimiremos con un programa que
nos dará como salida un fichero binario de datos comprimidos de
(generalmente) mucho menor tamaño que el original. El programa compresor
 no es, pues, un programa para Spectrum, sino para el sistema en que
estamos desarrollando de forma cruzada el juego. Así pues, la rutina de
compresión la programaremos (o la descargaréis) en C o como fichero
ejecutable para Windows, MAC o Linux.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Inclusión de los datos</strong>:
 Los datos resultantes de la compresión serán los que incluiremos en
nuestro programa, en lugar de los originales. Es decir, nuestra pantalla
 de fondo ya no serán los 6912 bytes del .SCR original sino los (por
ejemplo) 3102 bytes resultantes de la compresión. Los datos los
incluiremos con la directiva <strong>INCBIN</strong> de pasmo, o bien convirtiéndolos a ristras de bytes con <strong>bin2code</strong> o similar.</div>
</li>
</ul>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Descompresión de los datos</strong>:
 La descompresión de los datos la realizamos en nuestro programa de
Spectrum, mediante una rutina programada en ensamblador de Z80 o C para
Z88DK. La rutina es pequeña y rápida, por lo que nos permitirá
desempaquetar nuestra pantalla de 3102 bytes directamente sobre la
VideoRAM (por ejemplo). Los 3102 bytes de nuestra pantalla de ejemplo,
expandidos, serán los 6912 bytes originales del SCR inicial. Se dice
pues que la rutina de descompresión trabaja <em>al vuelo</em> o <em>en tiempo real</em>.</div>
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="rutina-descompresora">Rutina descompresora</h2>
<div class="level2">

<p>
 La rutina descompresora de RLE debe recibir como parámetros los siguientes valores:
<br>

<br>

</p>
<ul class="fix-media-list-overlap">
<li> Los datos comprimidos con RLE a
descomprimir: Los recibiremos en forma de “puntero” o “dirección de
memoria” apuntando al principio de los datos.
</li>
<li> El tamaño de los datos comprimidos (necesario para el bucle de descompresión).
</li>
<li> Un puntero o dirección de memoria apuntando a dónde queremos descomprimir los datos.
</li>
</ul>

<p>
<br>

 La rutina deberá ir cogiendo cada byte del bloque de datos comprimido y
 decidir si es un dato “sin comprimir” (&lt;192) o un dato comprimido
(&gt;=192). Si es un dato sin comprimir lo copiará a la dirección de
memoria destino, y si está comprimido cogerá el siguiente byte y
decidirá cuántas veces debe repetirlo.
</p>

<p>
 Por ejemplo:
</p>
<div class="table-responsive sectionedit9"><table class="inline table table-striped table-condensed">
	<thead>
	<tr class="row0">
		<th class="col0"> Datos leídos del array </th><th class="col1"> Significado del dato </th>
	</tr>
	</thead>
	<tbody><tr class="row1">
		<td class="col0"> 10 </td><td class="col1"> Es menor de 192 → Es un dato sin compresión → 10 </td>
	</tr>
	<tr class="row2">
		<td class="col0"> 193, 200 </td><td class="col1"> Es mayor que 192, se repite 193-192=1 veces el 200 → 200 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> 230, 5 </td><td class="col1"> Es mayor que 192, se repite 230-192=37 veces el 4 → 5, 5, 5, 5, 5 (…) </td>
	</tr>
	<tr class="row4">
		<td class="col0"> 219, 240 </td><td class="col1"> Es mayor que 192, se repite 219-192=16 veces el 240 → 240, 240, 240 (…) </td>
	</tr>
</tbody></table></div>

<p>
 Así pues, nuestra rutina de descompresión debe hacer lo siguiente:
</p>
<pre class="code">  M = 0
  N = 0
  Desde N=0 hasta N=TAMAÑO_DATOS_COMPRIMIDOS

    Cogemos valor=Comprimidos[N]
    N = N + 1

    # Si no es un dato comprimido, simplemente lo copiamos
    Si valor &lt; 192
    Entonces
       Descomprimidos[M] = valor
       M = M + 1
    Fin Si

    # Si es un dato comprimido, lo descomprimimos:
    Si valor &gt;= 192
    Entonces
       repeticiones = valor - 192
       dato_a_repetir = Comprimidos[N]

       Repetir "repeticiones" veces:
          Descomprimidos[M] = dato_a_repetiro
          M = M + 1
       Fin Repetir
    Fin Si

  Fin Desde</pre>

<p>
 Empezaremos viendo la rutina en versión C, ya que en este formato es bastante comprensible y apenas ocupa unas 20 líneas:
</p>
<pre class="code c"><span class="co1">//-------------------------------------------------------------------------------------</span>
<span class="kw4">void</span> RLE_decompress_C<span class="br0">(</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*</span>src<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*</span>dst<span class="sy0">,</span> <span class="kw4">int</span> length <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw4">int</span> i<span class="sy0">;</span>
  <span class="kw4">unsigned</span> <span class="kw4">char</span> b1<span class="sy0">,</span> b2<span class="sy0">,</span> j<span class="sy0">;</span>
&nbsp;
  <span class="kw1">for</span><span class="br0">(</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>length<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
  <span class="br0">{</span>
     b1 <span class="sy0">=</span> <span class="sy0">*</span>src<span class="sy0">++;</span>
     <span class="kw1">if</span><span class="br0">(</span> b1 <span class="sy0">&gt;</span> <span class="nu0">192</span> <span class="br0">)</span>                    <span class="co1">// byte comprimido?</span>
     <span class="br0">{</span>
        b2 <span class="sy0">=</span> <span class="sy0">*</span>src<span class="sy0">++;</span>
        i<span class="sy0">++;</span>
        <span class="kw1">for</span><span class="br0">(</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span><span class="br0">(</span>b1 <span class="sy0">&amp;</span> <span class="nu0">63</span><span class="br0">)</span><span class="sy0">;</span> j<span class="sy0">++</span> <span class="br0">)</span>   <span class="co1">// sí, descomprime y escribe</span>
            <span class="sy0">*</span>dst<span class="sy0">++</span> <span class="sy0">=</span> b2<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">else</span>
        <span class="sy0">*</span>dst<span class="sy0">++</span> <span class="sy0">=</span> b1<span class="sy0">;</span>                   <span class="co1">// no, es un byte de dato (escribe)</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre>

<p>
 Nótese cómo:
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> Usamos los punteros src y dst para leer y escribir en memoria (operador de indirección <strong> * </strong>).</div>
</li>
<li> Cogemos un valor desde src y analizamos si está comprimido o no (&gt;= 192).
</li>
<li> Si no está comprimido, es que es un dato a guardar, de modo que lo escribimos directamente en dst.
</li>
<li> Si está comprimido, no es un dato a
guardar sino un dato RLE. Obtenemos el número de repeticiones reales (b1
 en el ejemplo) y leemos el siguiente dato desde src. Ese dato (b2)
tiene que ser escrito b1 veces.
</li>
</ul>

<p>
<br>

 Ahora trasladamos esa rutina a ensamblador de Z80, y nos queda lo siguiente:
</p>
<pre class="code z80"><span class="co1">;;</span>
<span class="co1">;; RLE_decompress</span>
<span class="co1">;; Descomprime un bloque de datos RLE de memoria a memoria.</span>
<span class="co1">;;</span>
<span class="co1">;; Entrada a la rutina:</span>
<span class="co1">;;</span>
<span class="co1">;; HL = dirección origen de los datos RLE.</span>
<span class="co1">;; DE = destino donde descomprimir los datos.</span>
<span class="co1">;; BC = tamaño de los datos comprimidos.</span>
<span class="co1">;;</span>
RLE_decompress:
&nbsp;
RLE_dec_loop:
   <span class="kw1">LD</span> <span class="kw2">A</span>,<span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>                          <span class="co1">; leemos un byte</span>
&nbsp;
   <span class="kw1">CP</span> <span class="re1">1</span><span class="nu0">92</span>
   <span class="kw1">JP</span> NC, RLE_dec_compressed          <span class="co1">; si byte &gt; 192 = está comprimido</span>
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>, <span class="kw2">A</span>                         <span class="co1">; si no está comprimido, escribirlo</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>
   <span class="kw1">DEC</span> <span class="kw2">BC</span>
&nbsp;
RLE_dec_loop2:
   <span class="kw1">LD</span> <span class="kw2">A</span>,<span class="kw2">B</span>
   <span class="kw1">OR</span> <span class="kw2">C</span>
   <span class="kw1">JR</span> NZ, RLE_dec_loop
   <span class="kw1">RET</span>                                 <span class="co1">; miramos si hemos acabado</span>
&nbsp;
RLE_dec_compressed:                    <span class="co1">; bucle para descompresión</span>
   <span class="kw1">PUSH</span> <span class="kw2">BC</span>
   <span class="kw1">AND</span> <span class="nu0">63</span>                              <span class="co1">; cogemos el numero de repeticiones</span>
   <span class="kw1">LD</span> <span class="kw2">B</span>, <span class="kw2">A</span>                             <span class="co1">; lo salvamos en B</span>
   <span class="kw1">INC</span> <span class="kw2">HL</span>                              <span class="co1">; y leemos otro byte (dato a repetir)</span>
   <span class="kw1">LD</span> <span class="kw2">A</span>, <span class="br0">(</span><span class="kw2">HL</span><span class="br0">)</span>
&nbsp;
RLE_dec_loop3:
   <span class="kw1">LD</span> <span class="br0">(</span><span class="kw2">DE</span><span class="br0">)</span>,<span class="kw2">A</span>                           <span class="co1">; bucle de escritura del dato B veces</span>
   <span class="kw1">INC</span> <span class="kw2">DE</span>
   <span class="kw1">DJNZ</span> RLE_dec_loop3
   <span class="kw1">INC</span> <span class="kw2">HL</span>
   <span class="kw1">POP</span> <span class="kw2">BC</span>                              <span class="co1">; recuperamos BC</span>
   <span class="kw1">DEC</span> <span class="kw2">BC</span>                              <span class="co1">; Este DEC BC puede hacer BC=0 si los datos</span>
                                       <span class="co1">; RLE no correctos. Cuidado (mem-smashing).</span>
   <span class="kw1">DEC</span> <span class="kw2">BC</span>
   <span class="kw1">JR</span> RLE_dec_loop2
   <span class="kw1">RET</span> </pre>

<p>
 Finalmente, para aquellos que utilizan ASM de Z80 integrado en el
compilador Z88DK, veamos la rutina descompresora integrada con el paso
de parámetros de Z88DK:
</p>
<pre class="code c"><span class="kw4">int</span> RLE_decompress_ASM<span class="br0">(</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*,</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*,</span> <span class="kw4">int</span> <span class="br0">)</span><span class="sy0">;</span>
&nbsp;
&nbsp;
<span class="co1">//---------------------------------------------------------------------------</span>
<span class="co1">// RLE_decompress_ASM( src, dst, longitud );</span>
<span class="co1">//---------------------------------------------------------------------------</span>
<span class="kw4">int</span> RLE_decompress_ASM<span class="br0">(</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*</span>src<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*</span>dst<span class="sy0">,</span> <span class="kw4">int</span> length <span class="br0">)</span>
<span class="br0">{</span>
&nbsp;
<span class="co2">#asm</span>
   ld hl<span class="sy0">,</span><span class="nu0">2</span>
   add hl<span class="sy0">,</span>sp
&nbsp;
   ld c<span class="sy0">,</span> <span class="br0">(</span>hl<span class="br0">)</span>
   inc hl
   ld b<span class="sy0">,</span> <span class="br0">(</span>hl<span class="br0">)</span>
   inc hl                              <span class="co1">// BC = lenght</span>
&nbsp;
   ld e<span class="sy0">,</span> <span class="br0">(</span>hl<span class="br0">)</span>
   inc hl
   ld d<span class="sy0">,</span> <span class="br0">(</span>hl<span class="br0">)</span>
   inc hl                              <span class="co1">// de = dst</span>
   push de
&nbsp;
   ld e<span class="sy0">,</span> <span class="br0">(</span>hl<span class="br0">)</span>
   inc hl
   ld d<span class="sy0">,</span> <span class="br0">(</span>hl<span class="br0">)</span>
   inc hl                              <span class="co1">// de = src</span>
&nbsp;
   ex de<span class="sy0">,</span> hl
   pop de                              <span class="co1">// now de = dst and hl = src</span>
&nbsp;
   <span class="co1">// After this:  HL = source, DE = destination, BC = lenght of RLE data</span>
&nbsp;
.<span class="me1">RLE_dec_loop</span>
   ld a<span class="sy0">,</span><span class="br0">(</span>hl<span class="br0">)</span>                          <span class="co1">// leemos un byte</span>
&nbsp;
   cp <span class="nu0">192</span>
   jp nc<span class="sy0">,</span> RLE_dec_compressed          <span class="co1">// si byte &gt; 192 = está comprimido</span>
   ld <span class="br0">(</span>de<span class="br0">)</span><span class="sy0">,</span> a                         <span class="co1">// si no está comprimido, escribirlo</span>
   inc de
   inc hl
   dec bc
&nbsp;
.<span class="me1">RLE_dec_loop2</span>
   ld a<span class="sy0">,</span>b
   or c
   jr nz<span class="sy0">,</span> RLE_dec_loop
   ret                                 <span class="co1">// miramos si hemos acabado</span>
&nbsp;
.<span class="me1">RLE_dec_compressed</span>                    <span class="co1">// bucle para descompresión</span>
   push bc
   and <span class="nu0">63</span>                              <span class="co1">// cogemos el numero de repeticiones</span>
   ld b<span class="sy0">,</span> a                             <span class="co1">// lo salvamos en B</span>
   inc hl                              <span class="co1">// y leemos otro byte (dato a repetir)</span>
   ld a<span class="sy0">,</span> <span class="br0">(</span>hl<span class="br0">)</span>
&nbsp;
.<span class="me1">RLE_dec_loop3</span>
   ld <span class="br0">(</span>de<span class="br0">)</span><span class="sy0">,</span>a                           <span class="co1">// bucle de escritura del dato B veces</span>
   inc de
   djnz RLE_dec_loop3
   inc hl
   pop bc                              <span class="co1">// recuperamos BC</span>
   dec bc                              <span class="co1">// Este DEC BC puede hacer BC=0 si los datos</span>
                                       <span class="co1">// RLE no correctos. Cuidado (mem-smashing).</span>
   dec bc
   jr RLE_dec_loop2
   ret
&nbsp;
<span class="co2">#endasm</span>
&nbsp;
<span class="br0">}</span></pre>

<p>
<br>

</p>

</div>

<h2 id="rutina-compresora">Rutina compresora</h2>
<div class="level2">

<p>
 El algoritmo de compresión se basa en agrupar bytes repetidos iguales
en “bloques comprimidos”, dejando sin comprimir los datos cuando los
siguientes bytes no son iguales a él.
</p>

<p>
 La rutina de compresión recibe los siguientes parámetros:
</p>
<ul class="fix-media-list-overlap">
<li> Los datos descomprimidos a
comprimir: Los recibiremos en forma de “puntero” o “dirección de
memoria” apuntando al principio de los datos.
</li>
<li> El tamaño de los datos descomprimidos.
</li>
<li> Un puntero o dirección de memoria apuntando a dónde queremos dejar los datos comprimidos.
</li>
</ul>

<p>
 La descripción “en lenguaje natural” para la compresión RLE es la siguiente:
</p>
<pre class="code">  M = 0
  N = 0
  Desde N=0 hasta N=TAMAÑO_DATOS_DESCOMPRIMIDOS

    Cogemos valor=Descomprimidos[N]
    N = N + 1

    Siguiente_valor = Descomprimidos[N]

    # No se puede comprimir el dato porque el siguiente no es igual:
    Si valor != Siguiente_valor
    Entonces

       # Si es menor que 192, lo copiamos al destino:
       Si valor &lt; 192
          Comprimidos[M] = valor
          M = M + 1
       Fin Si

       # Si es mayor/igual que 192, lo copiamos a destino como
       # dato comprimido de repetición 1 (193):
       Si valor &gt;= 192
          Comprimidos[M] = 192+1
          M = M + 1
          Comprimidos[M] = valor
          M = M + 1
       Fin Si
    Fin Si

    # Hemos encontrado repeticion de datos:
    Si valor == Siguiente_valor
    Entonces
       repeticiones = Contar cuantas veces está repetido el byte
                      desde Descomprimidos[M] hasta un máximo de 63.
          Comprimidos[M] = 192 + repeticiones
          M = M + 1
          Comprimidos[M] = valor
          M = M + 1
    Fin Si
  Fin Desde</pre>

<p>
 La rutina en C es la siguiente:
</p>
<pre class="code c"><span class="kw4">unsigned</span> <span class="kw4">int</span> RLE_compress<span class="br0">(</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*,</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*,</span>
                           <span class="kw4">char</span><span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
&nbsp;
<span class="co1">//-------------------------------------------------------------------------</span>
<span class="kw4">unsigned</span> <span class="kw4">int</span> RLE_compress<span class="br0">(</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*</span>src<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="sy0">*</span>dst<span class="sy0">,</span>
                           <span class="kw4">char</span> scanline_width<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> length <span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw4">unsigned</span> <span class="kw4">int</span> offset<span class="sy0">,</span> dst_pointer<span class="sy0">;</span>
  <span class="kw4">unsigned</span> <span class="kw4">int</span> bytecounter<span class="sy0">,</span> width<span class="sy0">;</span>
  <span class="kw4">unsigned</span> <span class="kw4">char</span> b1<span class="sy0">,</span> b2<span class="sy0">,</span> data<span class="sy0">;</span>
&nbsp;
  dst_pointer <span class="sy0">=</span> offset <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
  bytecounter <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
  width <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
  b1 <span class="sy0">=</span> src<span class="br0">[</span>offset<span class="sy0">++</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
  <span class="kw1">do</span>
  <span class="br0">{</span>
     b2 <span class="sy0">=</span> src<span class="br0">[</span>offset<span class="sy0">++</span><span class="br0">]</span><span class="sy0">;</span>
     width<span class="sy0">++;</span>
&nbsp;
     <span class="kw1">while</span> <span class="br0">(</span><span class="br0">(</span>b2 <span class="sy0">==</span> b1<span class="br0">)</span> <span class="sy0">&amp;&amp;</span>
            <span class="br0">(</span>bytecounter <span class="sy0">&lt;</span> scanline_width<span class="sy0">-</span><span class="nu0">1</span> <span class="br0">)</span> <span class="sy0">&amp;&amp;</span>
            <span class="br0">(</span>width <span class="sy0">&lt;</span> scanline_width<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span>
     <span class="br0">{</span>
         bytecounter<span class="sy0">++;</span>
         b2 <span class="sy0">=</span> src<span class="br0">[</span>offset<span class="sy0">++</span><span class="br0">]</span><span class="sy0">;</span>
         width<span class="sy0">++;</span>
     <span class="br0">}</span>
     <span class="kw1">if</span> <span class="br0">(</span>width <span class="sy0">&gt;=</span> scanline_width<span class="br0">)</span>
     <span class="br0">{</span>
        offset <span class="sy0">+=</span> scanline_width<span class="sy0">-</span>width<span class="sy0">;</span>
        width <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">if</span> <span class="br0">(</span>bytecounter <span class="sy0">!=</span> <span class="nu0">1</span><span class="br0">)</span>
     <span class="br0">{</span>
        data <span class="sy0">=</span> RLE_LIMIT<span class="sy0">+</span>bytecounter<span class="sy0">;</span>
        dst<span class="br0">[</span>dst_pointer<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> data<span class="sy0">;</span>
        dst<span class="br0">[</span>dst_pointer<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> b1<span class="sy0">;</span>
     <span class="br0">}</span>
&nbsp;
     <span class="kw1">if</span> <span class="br0">(</span>bytecounter <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
     <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>b1 <span class="sy0">&lt;</span> RLE_LIMIT<span class="br0">)</span>
        <span class="br0">{</span>
          dst<span class="br0">[</span>dst_pointer<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> b1<span class="sy0">;</span>
        <span class="br0">}</span>
        <span class="kw1">else</span>
        <span class="br0">{</span>
          data <span class="sy0">=</span> RLE_LIMIT<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span>
          dst<span class="br0">[</span>dst_pointer<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> data<span class="sy0">;</span>
          dst<span class="br0">[</span>dst_pointer<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> b1<span class="sy0">;</span>
        <span class="br0">}</span>
     <span class="br0">}</span>
&nbsp;
     bytecounter <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     b1 <span class="sy0">=</span> b2<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw1">while</span> <span class="br0">(</span>offset <span class="sy0">&lt;=</span> length<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
  <span class="kw1">return</span><span class="br0">(</span>dst_pointer<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>

<p>
 No necesitaréis la rutina de compresión en versión C de Spectrum ni Z80
 de Spectrum, puesto que esta rutina la debéis utilizar en vuestro
entorno de desarrollo (PC, MAC) para comprimir los datos e incorporarlos
 en vuestro programa.
</p>

<p>
 Lo normal durante el desarrollo del juego será “descomprimir” esos datos, no comprimirlos.
</p>

<p>
 En la sección de <em>Ficheros y Enlaces</em> tenéis disponible el compresor y descompresor “<strong>rlezx</strong>”
 para Linux y Windows (con su código fuente). Con él se pueden comprimir
 y descomprimir bloques de datos para incorporarlos en nuestros
programas.
</p>

<p>
<br>

</p>

</div>

<h2 id="ejemplo-completo">Ejemplo completo</h2>
<div class="level2">

<p>
 Vamos a agrupar todo lo visto hasta ahora en un ejemplo completo comentado. En este ejemplo haremos lo siguiente:
</p>
<ul class="fix-media-list-overlap">
<li> Comprimir con un compresor RLE propio la pantalla SCR de carga de SOKOBAN.
</li>
<li> Incluir ese fichero RLE resultante en nuestros programas.
</li>
<li> Hacer un programa descompresor del RLE obtenido directamente sobre videoram.
</li>
</ul>

<p>
<a href="img/sokoban.gif" class="media" title="cursos:ensamblador:sokoban.gif"><img src="img/sokoban.gif" class="mediacenter" alt=""></a>
</p>
<div style="text-align: center;"><em>Pantalla de carga del Sokoban</em>
</div>
<p>
<br>

</p>

<p>
 Veamos los diferentes pasos del proceso:
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit12" id="compresion-de-la-imagen">Compresión de la imagen</h3>
<div class="level3">

<p>
 Descargamos la pantalla SCR de carga de Sokoban desde su ficha en World
 Of Spectrum. Como toda pantalla de carga de Spectrum, ésta ocupará un
total de 6912 bytes (256*192 pixeles en formato 8×1, y sus 32*24 bytes
de atributos):
</p>
<pre class="code">[sromero@compiler:rlezx]$ ls -l sokoban.scr
-rw-r--r-- 1 sromero sromero 6912 2009-04-03 12:56 sokoban.scr</pre>

<p>
 A continuación comprimimos la pantalla SCR con el compresor RLE, utilizando la opción “a” (comprimir):
</p>
<pre class="code">[sromero@compiler:rlezx]$ ./rlezx a sokoban.scr sokoban.rle
Output size: 2571</pre>

<p>
 Tras el proceso de compresión comparamos el tamaño de la imagen comprimida con el tamaño sin comprimir:
</p>
<pre class="code">[sromero@compiler:rlezx]$ ls -l sokoban.scr sokoban.rle
-rw-r--r-- 1 sromero sromero 2571 2009-04-03 12:56 sokoban.rle
-rw-r--r-- 1 sromero sromero 6912 2009-04-03 12:56 sokoban.scr</pre>

<p>
 Como vemos, el tamaño de la pantalla ha pasado de 6912 bytes a 2571, lo
 que supone un ratio de compresión del 63%. La imagen ha ocupado
finalmente casi 1/3 del tamaño original. Un ahorro de este tipo puede
suponer gran cantidad de espacio aprovechable a partir de las pantallas
de presentación, introducción, menúes, game-over o finales de juegos.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit13" id="inclusion-de-la-imagen-en-nuestro-programa">Inclusión de la imagen en nuestro programa</h3>
<div class="level3">

<p>
 Ahora que ya tenemos el fichero binario de datos RLE comprimidos
(sokoban.rle), debemos incluirlo dentro de nuestro programa. Podemos
hacerlo de 2 formas:
</p>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Método INCBIN</strong>:
Incluyendo el binario directamente en PASMO con la directiva “INCBIN”,
asociándole una etiqueta para poder hacer referencia a él:<br>
<pre class="code">Datos_Comprimidos:
   INCBIN "fichero.rle"</pre>

<p>
<br>
En este caso es importante no colocar los datos binarios en una zona de
memoria que vaya a ser ejecutada. Lo normal es ubicarlos al final del
fichero, como en el ejemplo que veremos a continuación.
</p>
</div>
</li>
</ul>

<p>
<br>

</p>
<ul class="fix-media-list-overlap">
<li><div class="li"> <strong>Método BIN2CODE</strong>:
Convirtiendo los datos binarios a “texto” con una utilidad como BIN2C o
BIN2CODE (las tenéis disponibles como descargas en la sección de
ficheros). Estas utilidades para PC (Linux, MAC, DOS/Windows) toman un
fichero binario y lo convierten a datos listos para incluir en nuestros
programas:<br>
<pre class="code">[sromero@compiler:~rlezx]$ bin2code sokoban.rle datos.asm a
BIN2CODE v1.0             By NoP of Compiler SoftWare

2571 bytes from file sokoban.rle converted to datos.asm.


[sromero@compiler:~rlezx]$ cat datos.asm
;  File created with  BIN2CODE  v1.0  by  NOP of Compiler SoftWare

BINDATASIZE   EQU   2571

BINDATA LABEL BYTE
   DB   255,255,193,255,255,255,193,255,239,255,193,248,7,206,255,193
   DB   255,204,255,128,3,193,248,43,193,248,62,0,7,215,255,193
   DB   240,198,0,82,120,127,202,255,193,255,255,255,193,255,255,255
   DB   193,255,239,255,193,224,3,206,255,193,255,203,255,193,254,0
   DB   1,193,248,0,193,240,62,52,1,215,255,193,240,128,193,250
   DB   0,127,193,255,0,42,72,63,202,255,193,255,255,255,193,255
   (etc...)</pre>
</div>
</li>
</ul>

<p>
 Es decir: el método 1 hace que PASMO incluya el binario directamente
dentro de nuestro programa, y el método 2 lo convierte a directivas de
datos “DB” para que lo incluyamos con sentencias <strong>INCLUDE</strong> o copiándolas y pegandolas dentro del código.
</p>

<p>
<br>

</p>

</div>

<h3 class="sectionedit14" id="programa-de-ejemplo-de-descompresion">Programa de ejemplo de descompresión</h3>
<div class="level3">

<p>
 Finalmente, sólo tenemos que juntar todas las piezas (esqueleto de
programa básico, rutina de descompresión, datos RLE comprimidos) y
añadirle una espera de pulsación a tecla para hacer nuestro ejemplo
completo.
</p>

<p>
 El programa siguiente, <em>ejemplo_rle.asm</em>, toma la pantalla
gráfica comprimida con RLE (sokoban.rle, de 2571 bytes), y llama a la
rutina de descompresión RLE indicando como dirección de descompresión la
 ubicación de la VIDEORAM (16384), con lo que estamos desempaquetando
nuestros datos comprimidos directamente sobre la pantalla. Tras eso,
espera a la pulsación de una tecla y vuelve al BASIC.
</p>
<pre class="code asm">  <span class="co1">; Prueba de descompresion RLE </span>
  <span class="co1">; Desempaquetamos un SCR comprimido con RLE sobre la pantalla</span>
  ORG <span class="nu0">32768</span>
&nbsp;
  <span class="co1">; Cargamos los datos y preparamos nuestra rutina</span>
  LD HL<span class="sy1">,</span> Pantalla_Comprimida
  LD DE<span class="sy1">,</span> <span class="nu0">16384</span>
  LD BC<span class="sy1">,</span> <span class="nu0">2571</span>
  <span class="kw1">CALL</span> RLE_decompress
&nbsp;
&nbsp;
Wait_For_Keys_Pressed<span class="sy1">:</span>         <span class="co1">; Bucle para esperar pulsación de tecla</span>
  <span class="kw1">XOR</span> A
  <span class="kw1">IN</span> A<span class="sy1">,</span> <span class="br0">(</span><span class="nu0">254</span><span class="br0">)</span>
  <span class="kw1">OR</span> <span class="nu0">224</span>
  <span class="kw1">INC</span> A
  JR Z<span class="sy1">,</span> Wait_For_Keys_Pressed
&nbsp;
  <span class="kw1">RET</span>                          <span class="co1">; Fin del programa</span>
&nbsp;
&nbsp;
<span class="co1">;;</span>
<span class="co1">;; RLE_decompress</span>
<span class="co1">;; Descomprime un bloque de datos RLE de memoria a memoria.</span>
<span class="co1">;;</span>
<span class="co1">;; Entrada a la rutina:</span>
<span class="co1">;;</span>
<span class="co1">;; HL = dirección origen de los datos RLE.</span>
<span class="co1">;; DE = destino donde descomprimir los datos.</span>
<span class="co1">;; BC = tamaño de los datos comprimidos.</span>
<span class="co1">;;</span>
RLE_decompress<span class="sy1">:</span>
&nbsp;
RLE_dec_loop<span class="sy1">:</span>
   LD A<span class="sy1">,</span> <span class="br0">(</span>HL<span class="br0">)</span>                         <span class="co1">; leemos un byte</span>
&nbsp;
   CP <span class="nu0">192</span>
   <span class="kw1">JP</span> NC<span class="sy1">,</span> RLE_dec_compressed          <span class="co1">; si byte &gt; 192 = está comprimido</span>
   LD <span class="br0">(</span>DE<span class="br0">)</span><span class="sy1">,</span> A                         <span class="co1">; si no está comprimido, escribirlo</span>
   <span class="kw1">INC</span> DE
   <span class="kw1">INC</span> HL
   <span class="kw1">DEC</span> BC
&nbsp;
RLE_dec_loop2<span class="sy1">:</span>
   LD A<span class="sy1">,</span>B
   <span class="kw1">OR</span> C
   JR NZ<span class="sy1">,</span> RLE_dec_loop
   <span class="kw1">RET</span>                                 <span class="co1">; miramos si hemos acabado</span>
&nbsp;
RLE_dec_compressed<span class="sy1">:</span>                    <span class="co1">; bucle para descompresión</span>
   <span class="kw1">PUSH</span> BC
   <span class="kw1">AND</span> <span class="nu0">63</span>                              <span class="co1">; cogemos el numero de repeticiones</span>
   LD B<span class="sy1">,</span> A                             <span class="co1">; lo salvamos en B</span>
   <span class="kw1">INC</span> HL                              <span class="co1">; y leemos otro byte (dato a repetir)</span>
   LD A<span class="sy1">,</span> <span class="br0">(</span>HL<span class="br0">)</span>
&nbsp;
RLE_dec_loop3<span class="sy1">:</span>
   LD <span class="br0">(</span>DE<span class="br0">)</span><span class="sy1">,</span>A                           <span class="co1">; bucle de escritura del dato B veces</span>
   <span class="kw1">INC</span> DE
   DJNZ RLE_dec_loop3
   <span class="kw1">INC</span> HL
   <span class="kw1">POP</span> BC                              <span class="co1">; recuperamos BC</span>
   <span class="kw1">DEC</span> BC                              <span class="co1">; Este DEC BC puede hacer BC=0 si los datos</span>
                                       <span class="co1">; RLE no correctos. Cuidado (mem-smashing).</span>
   <span class="kw1">DEC</span> BC
   JR RLE_dec_loop2
   <span class="kw1">RET</span>
&nbsp;
&nbsp;
<span class="co1">; Aquí viene nuestra pantalla comprimida con RLE.</span>
<span class="co1">; Hay que darse cuenta de que está fuera de todo</span>
<span class="co1">; código ejecutable, es decir, el RET de la rutina</span>
<span class="co1">; principal y el RET de las subrutina de RLE_Decompress</span>
<span class="co1">; hacen que nunca se llegue a este punto para ejecución.</span>
&nbsp;
Pantalla_Comprimida<span class="sy1">:</span>
  <span class="kw5">INCBIN</span> sokoban<span class="sy1">.</span>rle
&nbsp;
  END <span class="nu0">32768</span></pre>

<p>
<br>

</p>

<p>
 Ensamblamos el programa con <strong>pasmo --tapbas ejemplo_rle.asm ejemplo_rle.tap</strong>
 y veremos que, al ejecutarlo, aparece la pantalla de carga de Sokoban,
que no es más que el bloque de datos RLE descomprimidos directamente
sobre la dirección de memoria en que empieza la videoram.
</p>

<p>
<br>

</p>

</div>

<h2 id="aportaciones-de-nuestros-lectores">Aportaciones de nuestros lectores</h2>
<div class="level2">

<p>
 El usuario Z80user, en los foros oficiales de Speccy.org, nos aporta
una modificación de nuestra rutina original y una rutina compresora
nativa:
</p>

<p>
<br>

<em>He leído el articulo del RLE, he reescrito el codigo de la rutina
descompresora y he creado la rutina compresora. He realizado la
compresion de la rom de 48K, y posterior descompresión y salen
identicas. He utilizado un pequeño truquito con el LDI y el RET PO (un
flash no muy usado, pero que usa LDI para indicar BC=#0000) y me he
ahorrado algunos bytes (compresora 62 bytes, descompresora 26 bytes).</em>
<br>

</p>
<pre class="code asm"><span class="co1">;; Creada por Z80user</span>
<span class="co1">;; Compresor / Descompresor RLE</span>
<span class="co1">;; Comprime y Descomprime un bloque de datos RLE de memoria a memoria.</span>
<span class="co1">;;</span>
<span class="co1">;; Entrada a la rutina COMPRESORA:</span>
<span class="co1">;; HL = destino de los datos RLE.</span>
<span class="co1">;; IX = datos a comprimir</span>
<span class="co1">;; BC = tamaño de los datos a comprimir.</span>
<span class="co1">;; Salida</span>
<span class="co1">;; AF,DE   desconocido</span>
<span class="co1">;; HL = HL+longitud de los datos comprimidos</span>
<span class="co1">;; IX = IX+BC</span>
<span class="co1">;;</span>
<span class="co1">;; Entrada a la rutina DESCOMPRESORA:</span>
<span class="co1">;; HL = dirección origen de los datos RLE.</span>
<span class="co1">;; DE = destino donde descomprimir los datos.</span>
<span class="co1">;; BC = tamaño de los datos a comprimir.</span>
<span class="co1">;; Salida</span>
<span class="co1">;; AF,DE   desconocido</span>
<span class="co1">;; HL = HL+longitud de los datos descomprimidos</span>
<span class="co1">;; DE = DE+BC</span>
<span class="co1">;; 26 + 62 = 88</span>
<span class="sy1">//-------------</span>
           org <span class="nu0">16384</span>
RLE_descompress
RLE_dec_loop
          LD   A<span class="sy1">,</span><span class="br0">[</span>HL<span class="br0">]</span>         <span class="co1">; Leemos 1 byte</span>
          CP   A<span class="sy1">,</span><span class="nu0">192</span>
          JR   NC<span class="sy1">,</span>RLE_dec     <span class="co1">; si byte &gt; 192 = está comprimido</span>
test_end  LDI                 <span class="co1">; Copiamos 1 byte en crudo</span>
          <span class="kw1">RET</span>   PO            <span class="co1">; Volvemos si hemos terminado</span>
          JR   RLE_dec_loop   <span class="co1">; Repetimos el bucle</span>
RLE_dec                          <span class="co1">; bucle para descompresión RLE</span>
          <span class="kw1">INC</span>   HL            <span class="co1">; Nos colocamos en el valor</span>
          <span class="kw1">AND</span>   A<span class="sy1">,</span>#<span class="nu0">3F</span>
          JR   Z<span class="sy1">,</span>test_end     <span class="co1">; Si 192, es dato en crudo</span>
          <span class="kw1">PUSH</span>   BC
          LD   B<span class="sy1">,</span>A             <span class="co1">; B= numero de repeticiones</span>
          LD   A<span class="sy1">,</span><span class="br0">[</span>HL<span class="br0">]</span>
bucle     LD   <span class="br0">[</span>DE<span class="br0">]</span><span class="sy1">,</span>A         <span class="co1">; \</span>
          <span class="kw1">INC</span>   DE             <span class="co1">;  Bucle de escritura B veces</span>
          DJNZ   bucle        <span class="co1">; /</span>
          <span class="kw1">POP</span>   BC
          <span class="kw1">DEC</span>   BC             <span class="co1">; Ajustamos el contador al usar RLE</span>
          JR   test_end        <span class="co1">; Copiamos 1 byte mas</span>
&nbsp;
&nbsp;
<span class="sy1">//---------------</span>
RLE_Comprimir
byte_1
          LD   E<span class="sy1">,</span><span class="br0">[</span>IX<span class="sy1">+</span>#<span class="nu0">00</span><span class="br0">]</span>        <span class="co1">; leer byte</span>
          <span class="kw1">INC</span>   IX                <span class="co1">; incrementar posicion</span>
          <span class="kw1">DEC</span>   BC                <span class="co1">; descontar contador</span>
          LD   A<span class="sy1">,</span>E                <span class="co1">;</span>
byte_2
          CP   A<span class="sy1">,</span>#C0             <span class="co1">; Si es un codigo RLE</span>
          JR   NC<span class="sy1">,</span>RLE_compress   <span class="co1">;  tratar como RLE</span>
          <span class="kw1">CALL</span>   get_byte        <span class="co1">; tomar el 2º byte</span>
          JR   Z<span class="sy1">,</span>ultimo_byte     <span class="co1">; falta escribir el ultimo byte</span>
          CP   A<span class="sy1">,</span>E                <span class="co1">;</span>
          JR   Z<span class="sy1">,</span>RLE_compress2   <span class="co1">; usar compresion RLE si son identicos</span>
          LD   <span class="br0">[</span>HL<span class="br0">]</span><span class="sy1">,</span>E             <span class="co1">; son distintos, escribir el byte anterior</span>
          <span class="kw1">INC</span>   HL                <span class="co1">;</span>
          LD   E<span class="sy1">,</span>A                <span class="co1">; recuperar el ultimo byte leido</span>
          JR   byte_2             <span class="co1">; continuar con la compresion</span>
ultimo_byte   LD   <span class="br0">[</span>HL<span class="br0">]</span><span class="sy1">,</span>E        <span class="co1">; escribir el ultimo byte</span>
          <span class="kw1">INC</span>   HL                <span class="co1">;</span>
          <span class="kw1">RET</span>         <span class="co1">; salir</span>
RLE_compress2
          LD   D<span class="sy1">,</span>#C1              <span class="co1">; eran identicos, empezar, con 2</span>
          JR   RLE_Repetido
RLE_compress
          LD   D<span class="sy1">,</span>#C0              <span class="co1">; era un valor RLE original</span>
RLE_Repetido
          <span class="kw1">CALL</span>   get_byte         <span class="co1">; Obtener otro byte</span>
          JR   Z<span class="sy1">,</span>RLE_distinto     <span class="co1">; Escribir el valor RLE si no hya mas bytes</span>
          CP   A<span class="sy1">,</span>E                <span class="co1">; Comprobar si es identico</span>
          JR   NZ<span class="sy1">,</span>RLE_distinto    <span class="co1">; Se encontro un byte distinto</span>
          <span class="kw1">INC</span>   D                  <span class="co1">; incrementar el contador de repeticiones</span>
          JR   NZ<span class="sy1">,</span>RLE_Repetido    <span class="co1">; Otro byte identico</span>
          <span class="kw1">DEC</span>   D                 <span class="co1">; Se acabo el contador de repeticiones</span>
RLE_distinto
          LD   <span class="br0">[</span>HL<span class="br0">]</span><span class="sy1">,</span>D              <span class="co1">; \</span>
          <span class="kw1">INC</span>   HL                 <span class="co1">;  \ escribir valor RLE</span>
byte_simple
          LD   <span class="br0">[</span>HL<span class="br0">]</span><span class="sy1">,</span>E              <span class="co1">;  /</span>
          <span class="kw1">INC</span>   HL                 <span class="co1">; /</span>
          LD   E<span class="sy1">,</span>A                 <span class="co1">; Recuperar el ultimo byte distinto</span>
          JR   byte_2              <span class="co1">; seguir comprimiendo</span>
get_byte
          LD   A<span class="sy1">,</span>B                 <span class="co1">; \</span>
          <span class="kw1">OR</span>   A<span class="sy1">,</span>C                 <span class="co1">;  Comprobar si es el ultimo byte</span>
          <span class="kw1">RET</span>   Z                  <span class="co1">; /</span>
          <span class="kw1">DEC</span>   BC                 <span class="co1">; descontar contador</span>
          LD   A<span class="sy1">,</span><span class="br0">[</span>IX<span class="sy1">+</span>#<span class="nu0">00</span><span class="br0">]</span>          <span class="co1">; leer byte</span>
          <span class="kw1">INC</span>   IX                 <span class="co1">; incrementar posicion</span>
          <span class="kw1">RET</span>           </pre>

<p>
 Agradecemos a Z80user su aportación, y aunque advertimos a los lectores
 que no podemos certificar el código, lo listamos para quien le pueda
resultar de interés.
</p>

<p>
<br>

</p>

</div>

<h2 id="ficheros">Ficheros</h2>
<div class="level2">
<ul class="fix-media-list-overlap">
<li><div class="li"> <a href="src/rlezx.c">rlezx.c</a>: Código fuente del Compresor / Descompresor rlezx.<br>
(Compilar con <em>make rlezx</em>).</div>
</li>
<li><a href="src/rlezx_win32.zip">RLEZX_WIN32.zip</a> : Compresor/Descompresor versión DOS/Windows.
</li>
<li><a href="src/bin2code.c">bin2code.c</a> : Convertidor de ficheros binarios a C, ASM, o PASCAL.
</li>
<li><a href="src/bin2code_win32.zip">bin2code.exe</a> : Convertidor de ficheros binarios versión DOS/Windows.
</li>
<li><a href="src/bin2c.c">bin2.c</a> : Otro convertidor de binarios a texto.
</li>
<li><a href="src/scr_sokoban.zip">Pantalla de carga de SOKOBAN</a> sin comprimir (SCR) y comprimida (RLE).
</li>
<li><a href="src/ejemplo_rle.zip">Ejemplo_rle</a> : Programa de ejemplo (ASM, TAP y RLE).
</li>
</ul>

<p>
<br>

</p>

</div>

<h2 id="en-resumen">En resumen</h2>
<div class="level2">

<p>
 Hemos visto los fundamentos de la compresión y descompresión RLE, así
como rutinas C y ASM para implementarlos en nuestros programas. Mediante
 lo visto en este capítulo, podemos obtener un gran ahorro de memoria en
 nuestros programas, pudiendo introducir más cantidad de gráficos en el
mismo espacio. También permite que pueda caber más código, más sonido o
más texto, ya que aunque no apliquemos la compresión sobre este tipo de
datos, podremos aprovechar el espacio que dejen libre nuestros gráficos
comprimidos.
</p>

<p>
<br>

</p>
<div style="text-align: right;"><strong id="author">Santiago Romero<br>
Abril 2009<br>
<a href="https://wiki.speccy.org/cursos/ensamblador/indice" >Wiki Speccy.org</a></strong>
</div>
</div>

</div>
      </article>
</body></html>
