<HTML>
<HEAD>
<META NAME="keywords" CONTENT="Sprites, sprite, bitmaps, bitmap, aligned sprites, TI-86,TI86,Z80,zilog,asm,assembly,programming,coding,graphic,calculator,TI,Texas Instruments,games,programs,software,docs,faq,tutorials,tutors,articles,links,tools,IDE,emulate,emulators,LCD,display,keypad,link,link port,David Phillips">
<META NAME="description" CONTENT="86 Central - A general tutorial on sprites, including aligned and non-aligned sprites.">
<TITLE>86 Central - Sprites</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" VLINK="#0055FF">

<CENTER><IMG SRC="images/86Central.gif" ALT="86 Central Logo" BORDER=0 HEIGHT=76 WIDTH=301></CENTER>

<CENTER>
<H5>
Best viewed in 1024x768</H5></CENTER>

<CENTER>
<H2>
Sprites</H2></CENTER>

<CENTER><IMG SRC="images/dude1.gif" ALT="Megaman enemy - Black and White" BORDER=0 HEIGHT=76 WIDTH=78></CENTER>


<P><FONT SIZE=+1>S</FONT>prites are small images used in graphics or games.
These images are generally mobile, and represent animate objects such as
the bug (insect) in SQRXZ, the frog in frogger, the space ship in Galaxian,
or maybe an enemy in Mega Man (from a Game Boy game, not a calculator game--shown
above). A sprite can easily be visualized as a grid of pixels. When an
image is zoomed in, this becomes apparent (as shown below).
<BR>&nbsp;
<CENTER><IMG SRC="images/dude1head.gif" ALT="Portion of the mega man enemy zoomed in" BORDER=0 HEIGHT=240 WIDTH=320></CENTER>
&nbsp;
<BR>&nbsp;
<H3>
How the Sprites are stored</H3>
The common size of a sprite is 8 x 8, meaning 8 pixels across by 8 pixels
down. Since there are 8 pixels per byte, it only takes one byte to represent
all 8 columns of an 8 x 8 sprite. It takes 8 <I>bytes</I> to represent
8 rows of an 8 x 8 sprite.&nbsp; If we wanted to have a sprite that looked
like the letter <B>A,</B> it would look like this:
<PRE>Letter_A:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %00111000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01101100
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %11000110
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %11000110
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %11111110
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %11000110
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %11000110
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %00000000</PRE>

<H3>
Methods of Drawing Sprites</H3>
There are three basic methods of drawing sprites to the screen, though
they are all similiar:
<UL>
<LI>
Aligned - This is the fastest way to draw sprites, though they cannot be
drawn just <I>anywhere</I> on the screen.</LI>

<LI>
Non-aligned - Sprites can be drawn anywhere, but they must fit entirely
on the screen</LI>

<LI>
Clipped - They can be located anywhere, even just partially on the screen.&nbsp;
This is the slowest way to draw sprites, though.</LI>
</UL>

<H3>
Drawing Aligned Sprites--Fast</H3>
An aligned sprite is almost always an 8x8 sprite.&nbsp; For it to be aligned,
every byte of the sprite must fit evenly into a video memory.&nbsp; Remember
that every pixel in the screen takes up one bit, so each byte would compose
8 pixels (see the page on the&nbsp; <A HREF="lcd.htm">lcd display</A> for
a better explanation).&nbsp; To visualize this, think about how the display
works when it is in "text mode", like at the homescreen.&nbsp; It is composed
of 8 by 21 characters.&nbsp; These can only be at specific places, as character
can't be drawn just anywhere.&nbsp; They cannot overlap.&nbsp; When using
aligned sprites, it is the same way.&nbsp; The screen is 64x128, so you
have a grid of 8 by 16 sprites (each sprite is 8 pixels wide/tall).

<P>Even though you can only draw a sprite at a position in the "grid",
they have their advantages because they are very fast to draw compared
to any type of non-aligned sprite.&nbsp; Once the offset in the video buffer
is calculated, they can just be copied to the video memory--no shifting
is involved.&nbsp; And if speed is really important, the entire copy loop
of the routine can be unrolled.&nbsp; This super fast routine was posted
on the assembly-86 mailing list in September of 97 by Dan Eble:
<PRE>;===========================================================
; GridPutSprite:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Dan Eble]
;&nbsp; Puts an aligned sprite at (E, D), where HL -> Sprite
;===========================================================
; IN : D&nbsp; = y (0-7 inclusive)
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E&nbsp; = x (0-15 inclusive)
;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HL-> sprite
;
; OUT: AF, BC, DE, HL, IX modified
; Current total : 28b/567t (not counting ret)
;===========================================================
GridPutSprite:
&nbsp;push hl
&nbsp;pop ix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ix-> sprite
&nbsp;srl d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; de = 128y+x (16 bytes/row, 8 rows)
&nbsp;rra
&nbsp;and $80
&nbsp;or e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; add x offset (remember x &lt;= 15)
&nbsp;ld e,a
&nbsp;ld hl,$fc00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; hl-> video ram
&nbsp;add hl,de&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; hl-> video ram + offset
&nbsp;ld b,8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; initialize loop counter
&nbsp;ld de,$10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; initialize line increment
GPS_Loop
&nbsp;ld a,(ix+0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; get byte from sprite
&nbsp;ld (hl),a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; put byte on screen
&nbsp;inc ix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; move to next byte in sprite
&nbsp;add hl,de&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; move to next line on screen
&nbsp;djnz GPS_Loop
&nbsp;ret</PRE>

<H3>
Drawing Non-Aligned Sprites anywhere to the Screen</H3>
There is a routine for plotting (blitting) sprites on the screen I have
developed which was based on Dan Eble's Findpixel routine and Jimmy Mardell's
PutSprite routine. I figured out how Mardell's routine worked and also
modified it for 16 by X sprites. Thus I will describe two PutSprite routines
I use, one is for 8 by X sprites (up to 8 pixels across and X pixels down),
and a 16 by X sprite routine (9-16 pixels across and X pixels down).

<P>Here is how an 8 x 8 sprite is stored:
<PRE>Knight:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db 8, 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01110000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01110000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %00100100
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01111111
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %10110100
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01110000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %00101000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01101100</PRE>
The first byte is the width (in pixels) of the sprite, which is up to 8
pixels if you are using the 8 by X PutSprite routine. The second byte is
the height of the sprite, which can be as long as you want (within reason).
The shorter the X_width or Y_height the faster the sprite will be blitted
(since it is smaller).

<P>Sometimes you may need (or want) a larger sprite then 8 x 8. I modified
the PutSprite routine for 16 by X pixels down. The sprite must be 2 bytes
wide, so the minimum amount X_width can be is 9. Y_height can be as many
pixels as necessary (within reason). Here is how a 16 x 22 sprite is stored:
<PRE>Chef: ' 16 pixels by 22 pixels
.db 16, 22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; X_width by Y_width
.db %00011111, %11110000
.db %00100000, %00001000
.db %00100111, %11001000
.db %00111000, %00111000
.db %00001010, %10100000
.db %00001000, %00100000
.db %00000100, %01000000
.db %00011100, %01111000
.db %01100111, %10000100
.db %10000000, %00000010
.db %10011000, %00110001
.db %10101000, %00101001
.db %10101000, %00100101
.db %11101111, %11100111
.db %01001000, %00010010
.db %11101001, %00010111
.db %11010001, %10001011
.db %00100010, %01000100
.db %00100010, %01000100
.db %00100010, %01000100
.db %01111100, %00111110
.db %11111100, %00111111</PRE>

<H3>
Drawing the Sprite to the Screen</H3>

<CENTER><IMG SRC="images/knight.gif" ALT="Knight - 8 x 8 sprite" BORDER=5 HEIGHT=192 WIDTH=285>&nbsp;<IMG SRC="images/cook.gif" ALT="Chef - 16 by 22 sprite" BORDER=5 HEIGHT=191 WIDTH=301></CENTER>


<P>Here is an example of how the knight was drawn to the screen:
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld hl, Knight&nbsp; ; HL points to the Sprite data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld b, 63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 63 pixels across&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld c, 23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 23 pixels down
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call PutSprite ; Put sprite stored in (HL) at B, C</PRE>
..and here is an example of how the "cook" was drawn to the screen:
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld hl, Chef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; HL points to the Sprite data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld b, 63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 63 pixels across
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld c, 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 15 pixels down
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call PutSprite16 ; Put sprite (16 by X) stored in (HL) at B, C</PRE>
The example source code for the two PutSprite routines are shown below.
The 8 by X PutSprite example program displays a knight; 16 by X PutSprite
example program displays a "chef". The PutSprite routine has been well
commented by me. The commented version of the Findpixel routine can be
found on my tutorial (Tutorial #4 - Simple Display). Enjoy!

<P>
<HR>
<CENTER>
<H2>
8 by X PutSprite routine (example program)</H2></CENTER>

<HR>
<PRE>#include "ti86asm.inc"

.org _asm_exec_ram

; =============================================================
; Example Program
; =============================================================

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Start of Program

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld hl, Knight
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld b, 63
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld c, 23
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call PutSprite ; Put sprite stored in (HL) at B, C
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret


; =============================================================
; Sprite Data&nbsp;
; =============================================================


Knight:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db 8, 8
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01110000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01110000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %00100100
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01111111
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %10110100
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01110000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %00101000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .db %01101100

; =============================================================
; Puts a sprite stored at (HL) at B,C
; =============================================================
PutSprite:

&nbsp;push bc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save BC (X, Y)&nbsp;
&nbsp;push de&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save DE
&nbsp;push hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save HL (Start of Sprite Data)
&nbsp;push hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save HL (Start of Sprite Data)

&nbsp;push bc
&nbsp;ld d, c
&nbsp;ld e, b
&nbsp;call FindPixel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Finds pixel at E, D
&nbsp;pop bc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; PutSprite needs pixel at B, C
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; A = Bitmask with one bit set; this will be the bit (pixel) "counter"

&nbsp;ex de,hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DE = Address in Display of Sprite
&nbsp;pop hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; HL = Start of Sprite Data
&nbsp;ld b,(hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; B = X width of Sprite&nbsp;
&nbsp;inc hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next byte
&nbsp;ld c,(hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; C = Y width of Sprite
&nbsp;inc hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next byte (now pointing at actual sprite data)
&nbsp;push hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save the twice incremented HL into stack
&nbsp;pop ix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; IX = The recently twice incremented HL

&nbsp;ex de,hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; HL = Address in Display of Sprite

PS_NewRow:
&nbsp;push bc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save X width of Sprite and Y width of Sprite
&nbsp;ld d,(ix)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; D = (IX), so D = First byte from Sprite
&nbsp;inc ix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; IX points to next row
&nbsp;push af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save Bitmask&nbsp;
&nbsp;push hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save HL, Address in Display of Sprite

PS_NewCol:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Now the fun begins, remember A is the bitmask, D = the Left Column Byte from Sprite
&nbsp;rl d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Rotate D left through carry, Leftmost pixel of Sprite Byte is carry
&nbsp;ld e,a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; E = bitmask
&nbsp;jr nc,PS_NoPixel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Check pixel from sprite to see if it is set
&nbsp;or (hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Sets Pixel at the "current bit" (Bitmask is the "bit counter")
&nbsp;ld (hl),a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; (HL) = A, Save changes to
&nbsp;jr PS_NextPixel

PS_NoPixel:
&nbsp;cpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Invert Bitmask
&nbsp;and (hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Clears pixel at the "current bit" (Bitmask is the "bit counter")
&nbsp;ld (hl),a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; (HL) = A Save changes
PS_NextPixel:
&nbsp;ld a,e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; A = Bitmask
&nbsp;rrca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; A is rotated right *through* carry
&nbsp;jr nc,PS_SameByte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; If the carry was set, that means that one bit set in A (bit counter)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp; rotated all the way to the end right into carry and recycles back into Bit 7
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp; so it can be used for the next byte

&nbsp;inc hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Go to the next byte in the display
PS_SameByte:
&nbsp;djnz PS_NewCol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; B = X (width of sprite), so it loops to PS_NewCol X times. This means that is X = 6,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; it will Shift Right the bitmask (move the bit counter to the right) 6 times, comparing&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; each bit of the bitmask and the sprite and setting or clearing the pixel in that
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; particular bit. It then moves on the the next pixel.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Move on to the next row
&nbsp;pop hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Recover HL, the Address in Display of the Sprite
&nbsp;pop af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Recover AF, A = Bitmask
&nbsp;ld de,16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DE = 16
&nbsp;add hl,de&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; HL = HL + 16, this moves down ONE row in the Display Area (128 width / (8 bits/pixel) = 16 bytes)
&nbsp;pop bc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Recover X_width and Y_height of Sprite
&nbsp;dec c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; C = Y_height of Sprite, subract one, which means one row of the Sprite has been drawn

&nbsp;jr nz,PS_NewRow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; If there are more rows to be drawn, go back to PS_NewRow

; No more rows. Since there were "effectively" 3 pushes before PS_NewRow, there must be three pops that way the
; ret statement will retrieve the correct address when it returns to the calling program.

&nbsp;pop hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;pop de
&nbsp;pop bc
&nbsp;ret

; =============================================================
; Dan Eble &amp; James Yopp FindPixel routine
; Input:&nbsp; D = y, E = x
; Output: HL= addr in vid mem, A = bitmask, C is modified
; =============================================================
FindPixel:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld hl,FP_Bits
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld a,e
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and $07&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; a = bit offset
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add a,l
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld l,a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adc a,h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub l
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld h,a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld c,(hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; c = bitmask for (hl)
;48 t-states up to this point
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld hl,FP_RLD
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld (hl),d
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld a,e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; a = x/8 (byte offset within row)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rrca
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rrca&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rrca
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rld
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or $FC&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld l,(hl)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld h,a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; hl -> byte in vid mem
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld a,c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; now a = bitmask for (hl)
;121 t-states up to this point
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret

FP_RLD:&nbsp; .db $00
FP_Bits: .db $80,$40,$20,$10,$08,$04,$02,$01

.end</PRE>

<HR>
<CENTER>
<H2>
16 by X PutSprite routine (example program)</H2></CENTER>

<HR>
<PRE>#include "ti86asm.inc"

.org _asm_exec_ram


; =============================================================
; Example Program
; =============================================================

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Start of Program

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld hl, Chef
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld b, 63
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld c, 15
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call PutSprite16 ; Put sprite (16 by X) stored in (HL) at B, C
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret


; =============================================================
; Sprite Data&nbsp;
; =============================================================

Chef: ' 16 pixels by 22 pixels
.db 16, 22
.db %00011111, %11110000
.db %00100000, %00001000
.db %00100111, %11001000
.db %00111000, %00111000
.db %00001010, %10100000
.db %00001000, %00100000
.db %00000100, %01000000
.db %00011100, %01111000
.db %01100111, %10000100
.db %10000000, %00000010
.db %10011000, %00110001
.db %10101000, %00101001
.db %10101000, %00100101
.db %11101111, %11100111
.db %01001000, %00010010
.db %11101001, %00010111
.db %11010001, %10001011
.db %00100010, %01000100
.db %00100010, %01000100
.db %00100010, %01000100
.db %01111100, %00111110
.db %11111100, %00111111



; =============================================================
; Puts a sprite stored at (HL) at B,C
; =============================================================
PutSprite16:

&nbsp;push bc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save BC (X, Y)&nbsp;
&nbsp;push de&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save DE
&nbsp;push hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save HL (Start of Sprite Data)
&nbsp;push hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save HL (Start of Sprite Data)

&nbsp;push bc
&nbsp;ld d, c
&nbsp;ld e, b
&nbsp;call FindPixel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Finds pixel at E, D
&nbsp;pop bc
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; PutSprite16 needs pixel at B, C
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; A = Bitmask with one bit set; this will be the bit (pixel) "counter"

&nbsp;ex de,hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DE = Address in Display of Sprite
&nbsp;pop hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; HL = Start of Sprite Data
&nbsp;ld b,(hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; B = X width of Sprite&nbsp;
&nbsp;inc hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next byte
&nbsp;ld c,(hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; C = Y width of Sprite
&nbsp;inc hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next byte (now pointing at actual sprite data)
&nbsp;push hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save the twice incremented HL into stack
&nbsp;pop ix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; IX = The recently twice incremented HL

&nbsp;ex de,hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; HL = Address in Display of Sprite

PS_NewRow:
&nbsp;push bc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save X width of Sprite and Y width of Sprite
&nbsp;ld d,(ix)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; D = (IX), so D = First byte from Sprite
&nbsp;inc ix
&nbsp;ld e,(ix)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; E = (IX), so E = Second byte from Sprite
&nbsp;inc ix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; IX points to next row

&nbsp;push af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save Bitmask&nbsp;
&nbsp;push hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save HL, Address in Display of Sprite

PS_NewCol:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Now the fun begins, remember A is the bitmask, D = the Left Column Byte from Sprite, E = the Right Column Byte from Sprite
&nbsp;sla e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 16-bit rotation DE
&nbsp;rl&nbsp; d

&nbsp;push af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save Bitmask
&nbsp;jr nc,PS_NoPixel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Check pixel from sprite to see if it is set
&nbsp;
&nbsp;or (hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Sets Pixel at the "current bit" (Bitmask is the "bit counter")
&nbsp;ld (hl),a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; (HL) = A, Save changes to
&nbsp;jr PS_NextPixel

PS_NoPixel:
&nbsp;cpl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Invert Bitmask
&nbsp;and (hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Clears pixel at the "current bit" (Bitmask is the "bit counter")
&nbsp;ld (hl),a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; (HL) = A Save changes
PS_NextPixel:
&nbsp;pop af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Restore Bitmask
&nbsp;rrca&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; A is rotated right *through* carry
&nbsp;jr nc,PS_SameByte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; If the carry was set, that means that one bit set in A (bit counter)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp; rotated all the way to the end right into carry and recycles back into Bit 7
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp; so it can be used for the next byte

&nbsp;inc hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Move on to next byte

PS_SameByte:
&nbsp;djnz PS_NewCol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; B = X (width of sprite), so it loops to PS_NewCol X times. This means that is X = 6,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; it will Shift Right the bitmask (move the bit counter to the right) 6 times, comparing&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; each bit of the bitmask and the sprite and setting or clearing the pixel in that
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; particular bit. It then moves on the the next pixel.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Move on to the next row
&nbsp;pop hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Recover HL, the Address in Display of the Sprite
&nbsp;pop af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Recover AF, A = Bitmask
&nbsp;ld de,16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; DE = 16
&nbsp;add hl,de&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; HL = HL + 16, this moves down ONE row in the Display Area (128 width / (8 bits/pixel) = 16 bytes)
&nbsp;pop bc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Recover X_width and Y_height of Sprite
&nbsp;dec c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; C = Y_height of Sprite, subract one, which means one row of the Sprite has been drawn

&nbsp;jr nz,PS_NewRow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; If there are more rows to be drawn, go back to PS_NewRow

; No more rows. Since there were "effectively" 3 pushes before PS_NewRow, there must be three pops that way the
; ret statement will retrieve the correct address when it returns to the calling program.

&nbsp;pop hl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;pop de
&nbsp;pop bc
&nbsp;ret

; =============================================================
; Dan Eble &amp; James Yopp FindPixel routine
; Input:&nbsp; D = y, E = x
; Output: HL= addr in vid mem, A = bitmask, C is modified
; =============================================================
FindPixel:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld hl,FP_Bits
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld a,e
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and $07&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; a = bit offset
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add a,l
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld l,a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adc a,h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub l
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld h,a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld c,(hl)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; c = bitmask for (hl)
;48 t-states up to this point
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld hl,FP_RLD
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld (hl),d
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld a,e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; a = x/8 (byte offset within row)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rrca
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rrca&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rrca
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rld
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or $FC&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld l,(hl)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld h,a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; hl -> byte in vid mem
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ld a,c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; now a = bitmask for (hl)
;121 t-states up to this point
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret

FP_RLD:&nbsp; .db $00
FP_Bits: .db $80,$40,$20,$10,$08,$04,$02,$01

.end</PRE>
More Information:
<BR>&nbsp; <B><A HREF="http://www.ti.com/calc/docs/86asmdisp.htm">TI-86
Offical Asm Documentation - Display</A></B>
<BR>&nbsp; <A HREF="coding/z80ti864.htm">Matt Johnson's Simple Display
Tutorial</A>
<BR>&nbsp; <A HREF="http://www.calpoly.edu/~tllilleh/a86/examples2.html">Trent
Lillehaugen's Asm86 Tutorial - Video Examples</A>

<P>
<BR>
<HR>
<p>
<center>
<script language="JavaScript" type="text/javascript"> <!--
function go() {
	if (document.selecter.select1.options[document.selecter.select1.selectedIndex].value != "none")
		window.top.location = document.selecter.select1.options[document.selecter.select1.selectedIndex].value; }
//--> </script>
<form name="selecter"><select name="select1" size=1>
<option value=none>Our Websites</option>
<option value=none>---------------------------------</option>
<option value="http://www.acz.org">ACZ Frontpage</option>
<option value="http://ti83plus.acz.org">83+ Asm Central</option>
<option value="http://ti86.acz.org">86 Asm Central</option>
<option value="http://ti89.acz.org">89 Asm Central</option>
<option value="http://vti.acz.org">Virtual TI Emulator Site</option>
<option value="http://asmstudio.acz.org">Assembly Studio Site</option>
<option value=none>----------------------------------</option>
<option value="http://brett.acz.org">Brett's Homepage</option>
<option value="http://corey.acz.org">Corey's Homepage</option>
<option value="http://david.acz.org">David's Homepage</option>
<option value="http://dux.acz.org">Dux's Homepage</option>
<option value="http://james.acz.org">James' Homepage</option>
<option value="http://jeremy.acz.org">Jeremy's Homepage</option>
<option value="http://matt.acz.org">Matt's Homepage</option>
<option value="http://rusty.acz.org">Rusty's Homepage</option>
<option value="http://scott.acz.org">Scott's Homepage</option>
<option value=none>----------------------------------</option>
</select>
<input type="button" value="Go" onclick="go()">
</form>
</center>

<p><center>&copy; 1998 - 1999 <A HREF="http://www.acz.org" TARGET="_TOP">ACZ</A></center>
</BODY>
</HTML>
