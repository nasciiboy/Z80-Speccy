		DEFB	+A0,stk-zero	0
		DEFB	+C2,st-mem-2	0	mem-2 holds 0

 iii. The main loop:
The series is generated by looping, using BREG as a counter; the constants in the calling subroutine are stacked in turn by calling STK-DATA; the calculator is re-entered at GEN-ENT-2 so as not to disturb the value of BREG; and the series is built up in the form:
B(R) = 2*Z*B(R-1) - B(R-2) + A(R), for R = 1,2,...,N, where A(1), A(2),..., A(N) are the constants supplied by the calling subroutine (SIN, ATN, LN and EXP) and B(0) = 0 = B(-1).
The (R+1)th loop starts with B(R) on the stack and with 2*Z, B(R-2) and B(R-1) in mem-0, mem-1 and mem-2 respectively.

3453	G-LOOP	DEFB	+31,duplicate	B(R),B(R)
		DEFB	+E0,get-mem-0	B(R),B(R),2*Z
		DEFB	+04,multiply	B(R),2*B(R)*Z
		DEFB	+E2,get-mem-2	B(R),2*B(R)*Z,B(R-1)
		DEFB	+C1,st-mem-1	mem-1 holds B(R-1)
DEFB	+38,end-calc	DEFB	+03,subtract	B(R),2*B(R)*Z-B(R-1)
The next constant is placed on the calculator stack.
		CALL	33C6,STK-DATA	B(R),2*B(R)*Z-B(R-1),A(R+1)
The Calculator is re-entered without disturbing BREG.
		CALL	3362,GEN-ENT-2
		DEFB	+0F,addition	B(R),2*B(R)*Z-B(R-1)+A(R+1)
		DEFB	+01,exchange	2*B(R)*Z-B(R-1)+A(R+1),B(R)
		DEFB	+C2,st-mem-2	mem-2 holds B(R)
		DEFB	+02,delete	2*B(R)*Z-B(R-1)+A(R!1) =
				B(R!1)
		DEFB	+35,dec-jr-nz	B(R+1)
		DEFB	+EE,to 3453,G-LOOP

  iv. The subtraction of B(N-2):
The loop above leaves B(N) on the stack and the required result is given by B(N) - B(N-2).
		DEFB	+E1,get-mem-1	B(N),B(N-2)
		DEFB	+03,subtract	B(N)-B(N-2)
		DEFB	+38,end-calc
		RET		Finished

THE 'ABSOLUTE MAGNITUDE' FUNCTION
(Offset 2A:'abs')
This subroutine performs its unary operation by ensuring that the sign bit of a floating-point number is reset.
'Small integers' have to be treated separately. Most of the work is shared with the 'unary minus' operation.

346A	abs	LD	B,+FF	B is set to FF hex.
		JR	3474,NEG-TEST	The jump is made into 'unary
				minus'.

THE 'UNARY MINUS' OPERATION
(Offset 1B:'negate')
This subroutine performs its unary operation by changing the sign of the 'last value' on the calculator stack.
Zero is simply returned unchanged. Full five byte floating-point numbers have their sign bit manipulated so that it ends up reset (for 'abs') or changed (for 'negate'). 'Small integers' have their sign byte set to zero (for 'abs') or changed (for 'negate').

346E	NEGATE	CALL	34E9,TEST-ZERO	If the number is zero, the
		RET	C	subroutine returns leaving
				00 00 00 00 00 unchanged.
