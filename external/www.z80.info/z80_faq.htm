<HTML><Head>
<TITLE>Thomas Scherrer Z80 FAQ</TITLE>
<META name="title" content="Thomas Scherrer Z80-Family HomePage">
<META name="keywords" content="Z80,Z180,Z280,Z380,Programming,Hardware,Software,Utilities,FAQ,Support,CPU,assembler,emulators,simulators">
<META name="description" content="Z80, Z180, Z280, Z380, Programming, Hardware, Software, Utilities, FAQ, Support, CPU, assembler">
</Head><body background="gfx/zand.jpg">
<A HREF="index.htm">
<IMG SRC="gfx/zlogo1.gif" ALT="Z80 Home" HEIGHT=98 WIDTH=198 border=0></A>
<h2>This is the Z80 CPU Hardware and Software FAQ...</h2>
<hr>
Questions - from all you guys via email.<br><p>
Answers by:<br>
<ul>
<li> <a href="contact.htm">Thomas Scherrer</a> - <a href="http://www.geocities.com/SiliconValley/Peaks/3938/">Z80 HomePage</a><br>
<li> <a href="mailto:n2wx@tapr.org">Howard Goldstein</a> - <a href="http://www.tapr.org/~n2wx/">HomePage</a><br>
<li> <a href="mailto:tcj@psyber.com">Dave Baldwin,</a> Editor/Publisher of <a href="http://www.psyber.com/~tcj/">The Computer Journal</a><br>
<li> <a href="mailto:inde@nra.lv">Einars Inde</a><br>
<li> <a href="mailto:wcc3@occs.cs.oberlin.edu">Will Colley</a><br>
</UL>
<p>
<hr>
<a href="z80_faq.htm#Q-1">Q-1: I AND R REGISTERS.  What do they do?</a><br>
<a href="z80_faq.htm#Q-2">Q-2: I AND R REGISTERS.  Will EXX change them or is there only one copy of them?</a><br>
<a href="z80_faq.htm#Q-3">Q-3: IM x instruction.  What does it do?</a><br>
<a href="z80_faq.htm#Q-4">Q-4: On the LD (IX + %D),%D Instruction. Does the index byte come first?</a><br>
<a href="z80_faq.htm#Q-5">Q-5: Are indexes (IX + %D) signed or unsigned?</a><br>
<a href="z80_faq.htm#Q-6">Q-6: What happens when the Z80 CPU is RESET?</a><br>
<a href="z80_faq.htm#Q-7">Q-7: What reg does DJNZ affect?  Does it affect the flags or does it just test the B register against zero?</a><br>
<a href="z80_faq.htm#Q-8">Q-8: I need to know which rotates & shifts go through the carry and which ones don't</a><br>
<a href="z80_faq.htm#Q-9">Q-9: CPL is a ones complement of A?</a><br>
<a href="z80_faq.htm#Q-10">Q-10: NEG is a twos complement?</a><br>
<a href="z80_faq.htm#Q-11">Q-11: How does DAA work?</a><br>
<a href="z80_faq.htm#Q-12">Q-12: Do the RST instructions have any side effects?</a><br>
<a href="z80_faq.htm#Q-13">Q-13: What does RETI do?</a><br>
<a href="z80_faq.htm#Q-14">Q-14: What does RETN do?</a><br>
<a href="z80_faq.htm#Q-15">Q-15: I assume RRD and RLD rotate the number in HL.  Do they use or affect the carry?</a><br>
<a href="z80_faq.htm#Q-16">Q-16: I need to know the effects of: LDI, LDIR, CPI, CPIR, INI, INIR, OUTI, OTIR</a><br>
<a href="z80_faq.htm#Q-17">Q-17: When AF is pushed which goes lower on the stack, A or F?</a><br>
<a href="z80_faq.htm#Q-18">Q-18: I assume when HL is pushed the L register is lower?</a><br>
<a href="z80_faq.htm#Q-19">Q-19: I assume the stack is predecremented before putting pushed data on it?</a><br>
<a href="z80_faq.htm#Q-20">Q-20: When you do a RST (or an interrupt in mode 1 or 2) Do interrupts get disabled until the RETI?</a><br>
<a href="z80_faq.htm#Q-21">Q-21: Can the NMI procedure be interrupted by an interrupt or by an NMI?</a><br>
<a href="z80_faq.htm#Q-22">Q-22: I assume DAA uses the N bit to do either an ADD adjustment or a SUBTRACT adjustment?</a><br>
<a href="z80_faq.htm#Q-23">Q-23: What are the flags of RRD and RLD based on? The new contents of A or the new contents of HL?</a><br>
<a href="z80_faq.htm#Q-24">Q-24: How is the HC flag set on IN instructions?</a><br>
<a href="z80_faq.htm#Q-25">Q-25: On the CPIR and CPDR instructions, how are the flags set on success?</a><br>
<a href="z80_faq.htm#Q-26">Q-26: How do I implement a less-than/greater-than test in assembly?</a><br>
<a href="z80_faq.htm#Q-27">Q-27: When I do "cp 6", does the processor do "a-6" or "6-a"?</a><br>
<a href="z80_faq.htm#Q-28">Q-28: Is there a good 8 bit multiplication Asm routine?</a><br>
<a href="z80_faq.htm#Q-29">Q-29: What is the differece between EDh,63h,00,00 and 22h,00,00 = LD (0000),HL ?</a><br>
<a href="z80_faq.htm#Q-30">Q-30: How does the Z80's opcode 0FDh,0CBh work?  RLC (IY+d)</a><br>
<a href="z80_faq.htm#Q-31">Q-31: Is there repetition in the Z80's instruction set? Two opcodes that do the same thing ?</a><br>
<a href="z80_faq.htm#Q-32">Q-32: What does SLL do?</a><br>
<a href="z80_faq.htm#Q-33">Q-33: EEprom with Z80 CPU, does it hook up like EPROM or is it different?</a><br>
<a href="z80_faq.htm#Q-34">Q-34: EEprom data polling, how does it work?</a><br>
<a href="z80_faq.htm#Q-35">Q-35: Z80 M1 signal:  Does it only go low on the first M1 cycle?</a><br>
<a href="z80_faq.htm#Q-36">Q-36: How do I assemble some of the Z80 sources found around?</a><br>
<hr>
<pre>

-------
<a name="Q-1">
<b><big>Q-1:</b></big> I AND R REGISTERS.  What they do.

  <b>Answer:</b> I is the Interrupt page address register.
The Z-80 CPU can be operated in mode2 where an indirect call to any memory
location can be achieved in responce to an interrupt. The I register is used
for this purpose to store the high order 8-bits of the indirect address while
the interrupting device provides the lower 8-bits of the address. This
feature allows interrupt routines to be located anywhere in memory.

  <b>Answer:</b> R is the memory Refresh register.
The Z-80 CPU contains a memory refresh counter to enable dynamic memories
to be used with the same ease as static memories. Seven bits of this 8 bit
register are automatically incremented after each instruction fetch.
The eight bits will remain as programmed with the LD R,A instruction.
The data in the refresh counter is sent out on the lower portion of the
address bus along with a refresh control signal while the CPU is decoding
and executing the instruction. The programmer can load the R register for
testing purposes, but this register is normally NOT used by the programmer.
During refresh, the contents of the I register are placed on the upper
8 bits of the address bus.

[snip]

Answer: R is the memory Refresh register. The Z-80 CPU contains a memory
refresh counter to enable dynamic memories to be used with the same ease
as static memories. Seven bits of this 8 bit register are automatically
incremented after each instruction fetch.

[snip some more]&quot;

This last statement isn't quite true: DDCBxx will increase R by 2,
despite there being 3 instruction fetches made.



-------
<a name="Q-2">
<b><big>Q-2:</b></big> I AND R REGISTERS.  Will EXX change them or is there only one copy of them?

  <b>Answer:</b> There is only one copy of the I and R registers, EXX don't
affect I and R at all.

-------
<a name="Q-3">
<b><big>Q-3:</b></big> IM x instruction.  What does it do.

  <b>Answer:</b> IM0, IM1, IM2 sets the interrupt mode.

Mode 0: The interrupting device can insert any instruction on the data
bus and allow the CPU to execute it (the old 8080 mode, default mode).
The Z80 will execute any one-byte instruction properly like a RST xx.  Where
the 8080 would execute any instruction, the Z80 needs some external logic
to execute multi-byte instructions like CALL xxxx.

Mode 1: Is a simplified mode where the CPU automatically executes a
restart (RST) to location 0038h so that no external hardware is required
(the old PC content is pushed onto the stack, and returned with a regular
return instruction, RET.

Mode 2: Is the most powerful, in that it allows for an indirect call to
any location in memory. With this mode the CPU forms a 16-bit memory address
where the upper 8-bits are the content of register I and the lower 8-bits
are supplied by the interrupting device. This address points to the first of
two sequential bytes in a table where the address of the service routine is
located. The CPU automatically obtains the starting address and performs a
CALL to this address. The RETI is also used to return to the main programm.


-------
<a name="Q-4">
<b><big>Q-4:</b></big> On the LD (IX + %D),%D instruction, does the index byte come first?

  <b>Answer:</b> Yes the index byte comes first.
  it's like:
  LD  (IX + yy),xx   ; yy = index or adr offset, xx = data written. 
  DD 36 yy xx

-------
<a name="Q-5">
<b><big>Q-5:</b></big> Are indexes (IX + %D) signed or unsigned?

  <b>Answer:</b> Signed (2's complement) with range -128 to +127.

-------
<a name="Q-6">
<b><big>Q-6:</b></big>What happens when the Z80 CPU is RESET?

  <b>Thomas Scherrer:</b> 
  The program counter is reset to 0000h
  Interrupt mode 0. 
  Interrupt are dissabled.
  The register I = 00h
  The register R = 00h
  
  During reset time, the address bus and data bus go to a hight impadance state and all controll output signals go to the inactive state.
  
  The Z80 CPU will execute instruction at address 0000h

-------
<a name="Q-7">
<b><big>Q-7:</b></big> What reg does DJNZ affect?  Does it affect the flags or does it just test the register against zero?

  <b>Answer:+</b> DJNZ means "Decrement and Jump if Not Zero" this instruction uses only
the B register as a counter...
Example:  LD   B,100
loop:     NOP
          DJNZ loop   The nop will be executed 100 times.
Remember this form of jump is relative 8 bit only.

-------
<a name="Q-8">
<b><big>Q-8:</b></big> I need to know which rotates & shifts go through the carry and which
ones don't; also if there are any that don't affect the carry at all I need to know it.

  <b>Answer:</b>

<b>Howard Goldstein:</b> - All of the rotate and shift operands _affect_ carry.
The real question is which rotates and shifts treat carry as a bit separate
from bit 7 (since the z-80 only recognizes 8 bit signed operands).
See the databook to see which instructions treat the carry flag as a unique
bit in a rotate operation (in shift operations the carry bit is always a unique bit).

<b>Thomas Scherrer:</b> - Check the Z80 syntax. It's growing, and now there are docs 
about the rotates & shifts.

-------
<a name="Q-9">
<b><big>Q-9:</b></big> CPL is a ones complement of A?

  <b>Answer:</b> Unsigned complement, 11000111B will be 00111000B after execution of CPL

-------
<a name="Q-10">
<b><big>Q-10:</b></big> NEG is a twos complement?

  <b>Answer:</b> Yes 100 wil be -100, after execution of NEG.

-------
<a name="Q-11">
<b><big>Q-11:</b></big> How does DAA work?

  <b>Answer:</b>

<b>Dave Baldwin:</b> - DAA (Decimal Adjust Accumulator) adds a correction factor to
 the contents of the Accumulator so that it will properly represent the results of a Packed
BCD operation.  It uses the 'N' flag to determine whether the previous instruction was an
addition or subtraction.

<b>Thomas Scherrer:</b> - <a href="z80syntx.htm#DAA">See the Z80Syntax</a>

-------
<a name="Q-12">
<b><big>Q-12:</b></big> Do the RST instructions have any side effects?

  <b>Answer:</b> Well one side effect is that it's a one-byte CALL intstruction which means
 that it pushes the location of PC (Program Counter) onto the stack, so you can return later with RET.

CALL ADDRESS   MNEMONIC
-----------------------
0000h          RST 00h
0008h          RST 08h
0010h          RST 10h
0018h          RST 18h
0020h          RST 20h
0028h          RST 28h
0030h          RST 30h
0038h          RST 38h

-------
<a name="Q-13">
<b><big>Q-13:</b></big> What does RETI do?

  <b>Answer:</b>

<b>Dave Baldwin:</b> - RETI (Return from interrupt) pops the return address from the stack,
like RET.  RETI is also decoded by the Z80 peripheral chips (SIO, CTC, PIO, DMA) and tells
them to reset the interrupt daisy chain so the next interrupt can be accepted.

<b>Howard Goldstein:</b> - RETI acts like RET except that some zilog
peripherals recognize the RETI instruction sequence (0xed, 0x4d) for
purposes of clearing their internal interrupt-pending flags.
This has repercussions for the daisy-chain interrupt technique used by the Z-80 family.

-------
<a name="Q-14">
<b><big>Q-14:</b></big> What does RETN do?

  <b>Answer:</b>

<b>Thomas Scherrer:</b> - This is a 'return' instruction used with the NON-maskable
hardware interrupt NMI.  It's special purpose is to restore the CPU's internal interrupt control
flags so that regular interrupts can be processed.  A NMI is a restart (CALL) to location 0066h.


RETN also causes the Z80 to copy IFF2 to IFF1 -- this is mentioned in
Q21, but could probably also be mentioned here.

-------
<a name="Q-15">
<b><big>Q-15:</b></big> I assume RRD and RLD rotate the number in HL.  Do they use or affect the carry?

  <b>Answer:</b>

<b>Philip Kendall:</b>  RRD and RLD do not affect the carry flag.

-------
<a name="Q-16">
<b><big>Q-16:</b></big> I need to know the effects of this class of instructions:

LDI, LDIR
CPI, CPIR
INI, INIR
OUTI, OTIR

-------
<a name="Q-17">
<b><big>Q-17:</b></big> When AF is pushed which goes lower on the stack, A or F?

  <b>Answer:</b>

<b>Dave Baldwin:</b> A is the high byte, F is the low.  If you 'PUSH AF' then 'POP BC',
 the contents of A will be in B and the contents of F will be in C.

-------
<a name="Q-18">
<b><big>Q-18:</b></big> I assume when HL is pushed the L register is lower.

  <b>Answer:</b>

<b>Dave Baldwin:</b> Yes. The low order byte is also lower on the stack when any 
of the 16-bit register pairs are pushed on the stack  (AF, BC, DE, HL, IX, IY, and PC).

-------
<a name="Q-19">
<b><big>Q-19:</b></big> I assume the stack is predecremented before putting pushed data
on it.  And postincremented after popping data.  This keeps the stack pointer pointing to the TOS.

-------
<a name="Q-20">
<b><big>Q-20:</b></big> When you do a RST  (or an interrupt in mode 1 or 2)
Do interrupts get disabled until the RETI?

  <b>Answer:</b> An RST instruction does not disable interrupts, though it can be used
as a response to an interrupt acknowledge in Mode 0.  Any interrupt that is acknowledged
by the CPU disables further maskable interrupts (/INT pin) until they are enabled by
the EI instruction.  The NMI (Non-maskable interrupt) can interrupt a maskable interrupt.

-------
<a name="Q-21">
<b><big>Q-21:</b></big> Can the NMI procedure be interrupted by an interrupt or by an NMI?

  <b>Answer:</b>

<b>Howard Goldstein:</b> - (a) The NMI cannot be interrupted by a maskable interrupt (/INT)
because the NMI is defined to atomically copy the IFF1 to IFF2 and then set IFF1 to 0.

<b>Howard Goldstein:</b> - (b) The NMI may be interrupted by another NMI.  Hardware is
responsible for ensuring the /NMI input is adequately processed to ensure
the NMI procedure is completed before another NMI is issued.
  Another thing to watch out for is the IFF2 state, when the second NMI begins.
It is lost, and that would f*ck up the old IE state when RETN runs
(RETN of course also restores IFF2 to IFF1) leaving the system with interrupts
disabled.  Makes it even more important to damp /NMI with hardware
(low pass filter?  one shot?)

<b>Thomas Scherrer:</b> - Use an RS-FlipFlop, so the /NMI can't be triggerd
before you reset(enable) the RS-FF, you can use a output port bit for this.

-------
<a name="Q-22">
<b><big>Q-22:</b></big> I assume DAA uses the N bit to do either an ADD adjustment or a SUBTRACT adjustment.

<b>Thomas Scherrer:</b> - <a href="z80syntx.htm#DAA">See the Z80Syntax under DAA</a>

-------
<a name="Q-23">
<b><big>Q-23:</b></big> What are the flags of RRD and RLD based on?  The new contents
        of A or the new contents of HL?

<b>Einars Inde:</b>  New contents of A

-------
<a name="Q-24">
<b><big>Q-24:</b></big> How is the HC flag set on IN instructions

ups I have no answer to this yet...

-------
<a name="Q-25">
<b><big>Q-25:</b></big> On the CPIR and CPDR instructions, how are the flags
set on success?  On failure?  In particular I'm looking for the difference
between aborting when A = [HL] and aborting when BC = 0.

<b>Einars Inde:</b> Let's see how the command CPIR work.

<img src="gfx/z-cpir.gif" border=0 width=202 height=172>

Flags: CY Z  PV S  N  H 
       .  ~  ~  ~  1  ~ (~ = changes, . = no change)

And the flags: if byte found: Z=1; HL - address of next byte;
                                   BC - figure out by yourself.
                   not found: Z=0
I believe, that if on exit BC=0 then PV=0 else PV=1, that's so with CPI
(CPD) command, so why shouldn't it be with CPIR (CPDR)?

So the difference between if a byte, is or is not found, is expressed
by the Zero flag. Sorry, don't know exactly how are S and H affected...

-------
<a name="Q-26">
<b><big>Q-26:</b></big> How do I implement a less-than/greater-than test in assembly?

<b>A:</b> To compare stuff, simply do a CP, and if the zero flag is set,
A and the argument were equal, else if the carry is set the argument was greater, and finally, if neither is set, then A must be greater (CP does nothing to the registers, only the F (flag) register is changed). <BR>
-------
<a name="Q-27">
<b><big>Q-27:</b></big> When I do "cp 6", does the processor do "a-6" or "6-a"?

<b>A:</b> It does "a-6".

-------
<a name="Q-28">
<b><big>Q-28:</b></big> Is there a good 8 bit multiplication Asm routine?

<b>David Kastrup:</b> Here it is, this works.


        HL=H*E

        LD    L, 0
        LD    D, L    ; L = 0  and  D = 0
        LD    B, 8
MULT:   ADD   HL, HL
        JR    NC, NOADD
        ADD   HL, DE

NOADD:  DJNZ  MULT

In case H is known in advance, you can normalize it by shifting it
left until its MSB is set, and use an accordingly smaller starting
value of B.


Note that a relative branch not taken consumes 7 cycles, and if taken,
12, whereas an absolute branch takes 10 always.  So if the number of
set bits in H is expected to be less than 40% of all examined bits
(profile away!), it will pay to use an absolute jump.

------
<a name="Q-29">
<b><big>Q-29:</b></big> What is the differece between EDh,63h,00,00 and 22h,00,00?
   In some manual I've find that is both an LD (0000),HL.
   Is this true?

<b>Thomas Scherrer:</b>   
   22h,00,00  =  LD (0000),HL    
   ED,63,00,00  = undocumented opcode in the Z80 manual, but it does the same.. And uses more time...

<b>Philip Kendall:</b>
   22h,00h,00h will increase R by one, whilst EDh,63h,00h,00h, will increase R by two,
   so there is a (small) difference between these forms other than the
   speed and size.

-------
<a name="Q-30">
<b><big>Q-30:</b></big> The Z80's opcode 0FDh,0CBh how does it work?
   What does it do? Is there other opcodes like this?

<b>Thomas Scherrer:</b>   
   It's FD,CB,d,06  = RLC (IY+d)  where d is the ofset
   and there is alot opcodes like that.

-------
<a name="Q-31">
<b><big>Q-31:</b></big> Is there repetition in the Z80's instruction set?
   Two opcodes that mean the same mnemonic insruction?

<b>Thomas Scherrer:</b>   

   Yes there is several opcodes that does the same, but the short
   version is recomented to use, it's faster..

-------
<a name="Q-32">
<b><big>Q-32:</b></big> What does SLL do?

<b>Thomas Scherrer:</b>
   
   There are no SLL opcode in the Zilog official list, but
   The block CB 30 - CB 37 (missing from the official list)
   These instructions, usually denoted by the mnemonic SLL, Shift Left Logical, shift left the operand 
   and make bit 0 always one.
   
   Try some of the official mnemonics below:

   SLA =  SHIFT LEFT ARITHMETIC register
   SRA =  SHIFT RIGHT ARITHMETIC register
   SRL =  SHIFT RIGHT LOGICAL register

-------
<a name="Q-33">
<b><big>Q-33:</b></big>EEprom with Z80 CPU, does it hook up like EPROM or is it different?


<b>Thomas Scherrer:</b>   

Ok the EEprom is almost like the Read/Write RAM, but the differences are:
1. EEprom remember all data when power is off.
2. EEprom is alot slower in writes, not read.
3. When writing to EEprom you must insert a sertain delay before writing to the enxt adr. -
or you can use data polling to see when data is realy writtin (prefered)


-------
<a name="Q-34">
<b><big>Q-34:</b></big>EEprom data polling, how does it work?


<b>Thomas Scherrer:</b>   

After writing to EEprom it will internaly save the data in its cells, this take from about 1 - 40 mSecs. 
Then you keep reading from that address last written to, and when Read-data that is <b>EQUAL</b> to the data you wrote then you are
ready to proceed to the next address location..

<b>Examble:</b>
        ld    a,65           ; just some data..

        ld    (EErom),a      ; write data to EEprom
        ld    b,a            ; save ok written data.
poll:   ld    a,(EErom)      ; read data from EEprom
        cp    b              ; compare read with written
        jp    nz,poll        ; if Not Equal read again.
next:

You could also use the instruction "CP (HL)" this will speed up, like this:

        ld    a,65           ; just some data..
        ld    hl,EEprom      ; HL point to EEprom location,

        ld    (HL),a         ; write data to EEprom
poll:   cp    (HL)           ; compare read with written, (a reg) 
        jp    nz,poll        ; if Not Equal read again.
next:


-------
<a name="Q-35">
<b><big>Q-35:</b></big>Z80 M1 Signal?

> Could some kind Z80 expert enlighten me on the use of the M1 pin on the Z80.
> Does it only go low on the first M1 cycle or does it go low on all M cycles.


<b>Dave Baldwin dibald@netcom.com </b>   

The /M1 signal goes low only instruction fetch cycles and interupt 
acknowledge cycles.  It does not go low on I/O and memory read/write 
cycles that follow the instructions.
 
<b>Will Colley wcc3@occs.cs.oberlin.edu</b>

The Z-80's M1 pin used to be useful for building logic to
single-instruction step the machine.  You did this by withholding the
memory ready signal on M1 and not IRQ.  That stopped the machine on
the opcode fetch with the address showing on the address bus and the
opcode byte showing on the data bus.  Back in the bad old days (1976
or so), we actually had LEDs on those busses on a front panel.  To
move the machine ahead, you gave it the memory ready signal until the
next M1 and not IRQ.  Historically interesting, but probably
irrelevant in these days of reasonably-priced ICE boxes.

It does occur to me that DRAM main memory was rare in microcomputers
back then.  One of the main reasons was that it was hard to design a
DRAM card that would stuff in refresh cycles when the machine was
stopped by either single-instruction or single-cycle stepping logic.
Since these were the two primary debugging mechanisms of the time,
losing them for the sake of a few bucks in the memory system was a bad
tradeoff.

-------
<a name="Q-36">
<b><big>Q-36:</b></big>How do I assemble some of the Z80 sources found arround?


<b>Thomas Scherrer:</b>   

You download the TASM assembler, then you make a BAT file like this:

cls
tasm -80 -b -fFF -q -i -y test.asm test.bin

where test.asm is your assembler source text file, and
test.bin are the binary executable file, ready for programming into a
eprom and then put in your Z80 system..
<hr></pre>
</body></html>

