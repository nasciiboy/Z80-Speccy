<html>
<head>
<title>(non)-recursive makefiles and why you should (not) use them :)</title>
</head>
<body>
<b>
(non)-recursive makefiles and why you should (not) use them :)
</b>
<h1>Introduction</h1>
Makefiles have always been a pain for me and I used to leave writing them to other people or use
makefiles generated by development-tools, for instance <a href="http://www.bloodshed.net">Dev-cpp</a>
or TheIde from <a href="http://upp.sf.net">Ultimate++</a>. 

In retrospect, the main problem for me with makefiles was that I never really took the time to understand 
them (or their syntax) properly. If you're also not familiar with Make and/or creating makefile, I
suggest you read <a href="http://aegis.sourceforge.net/auug97.pdf">this</a> article by Peter Miller first.
If have used the advices in this document to write the makefiles (with a few minor changes) and
reading this article will help you understand why/how they work. I choose the title of this document not to 
cause more confusion but to express that I think both recursive and non-recursive makefiles have their
place. If you have read Peter Miller's article you will understand why using recursive makefile thoughtlessly
is bad and why it will cause the build-too-much or build-to-little problem in many cases.

I have choosen to split up several things: 

- two levels / two different makefiles (you could say recursion at only two levels)
- seporate project-specific changes into seporate files (module.mk)
- automate the configurion of a new or existing project as much as possible

<h1>Using make</h1>
<p>
Once I read the Make documentation got know my way around make I found out it is a powerful tool, that (in
my opinion) does what it was designed to do very well; that is: it creates a DAC to find out in what order
to build targets based on a description of their dependancies and their current state.
State in this context refers mainly to the change-date of the files, the main rule is: targets that
are older then the files they depend on (also called prerequisates) are rebuild using their build-rule.
<b>(todo: add comment here about first-match/best-match)</b>
It does however have it's limitations when it comes to stringparsing and writing to files. This is quite understandable 
because this was obviously not what the authors had in mind when they designed the program. Also it has its origins on
a unix based system where sed/awk etc could be used for special parsing. I my case development is done on win32 based
systems and depending on tools other then gcc and make is undesireable.
</p>

<h1>Generic makefile</h1>

<p>
I have spend quite some time writing a more or less universal makefile. The main idea was creating a makefile that does
not have to be changed once it's configured for a project.
The makefile has become a little more complex than it could have been, because of a few requirements
I had to make it fit into existing projects.
</p>
<p>
The basic requirements are:

- Only objects that are out-of-date should be rebuild (avoid the build-to-much syndrome), this is
  achieved by automatically generating dependancy files (.d) for each sourcefile by using a 
  gcc-feature that finds out on what headerfiles a source file depends.
- Automatically re-generate these (.d) files to avoid the build-to-little syndrome, this is achieved
  by having the (.d) files depend on both their corrensponding (.c) files and 
  the dependancies of that (.c) file.

Some extra project specific requirements are:
<br>
- there are two levels in the project, I will refer to them as "top" level and "sub" level,
  this also means I created two types of makefile, one for each level.
- source files will be stored in a sub-directory called /src
- header files included within the same sub-level (also called a module) 
  are stored in a directory called /inc
- header files included by a different module are stored in a directory called /exp
- object files will be created in seporate directories called /obj_rel or /obj_dbg 
  depending on what kind of build is being done. (this specifically makes the makefile somewhat
  more complex, because in several places stringreplacement is needed to find the sources-file for
  a corresponding object-file or vise-versa.)
  If you do not mind that objectfiles "polute" your source directories, you can simplify the 
  sub-level makefile somewhat.
- it should be possible to build each module seporately and a module should NOT be rebuild automatically 
  (even if the objects are out-of-date) IF only rebuilding a different module is specifically requested.
  For example "make all" will always rebuild all out-of-date objects in all modules while a "make PHAL" would only 
  check for changes in the module PHAL but not in other modules.
  This requirement allows rebuilding/testing of one module while changes to the sources of another module
  are not yet completed.
</p>
<p>
Having these requirements the following files could exist:  
<br>
\project\Makefile			; top-level makefile<br>
\project\module.mk			; configuration file<br>
\project\Makefile.module		; sub-level makefile, dorment once it is copied to sub-levels by "make init" at the top-level.<br>
\project\module1\Makefile		; sub-level makefile (an automatic copy of \project\module1\Makefile) <br>
\project\module1\module.mk		; configuration file generated by the top-level makefile (but only if it does not already exist)<br>
\project\module1\src\foo.c<br>
\project\module1\src\foobar.c<br>
\project\module1\inc\foo.h<br>
\project\module1\exp\foobar.h<br>
\project\module1\obj_rel\foobar.o<br>
</p>

<b>(todo: add part about mingw32 environment and installing gnuMake)</b>
<p>

Settings up the build-environment for a new or existing project is fairly simple if the source
files are already stored in structure indicated above. In fact you probably will not need
to change anything in the makefiles at all. If they are not, you wil have to modify the makefiles
to fit your needs (which will in many cases mean they can become shorter and simpler).
</p>

<h2>How can you make this work for your project?</h1>
<p>
Assuming you have the above structure, you copy three files into the top-level directory: Makefile, Makefile.module and 
module.mk. If you're interested you could open up the makefiles are see how they work, but for the impatient I will
describe the procedure to get started. First edit module.mk to you needs, this means add all sub-module to the MODULES
variable and if needed add extra library-source directories to INCS, VPATH and finally library-binary 
directories to LIBS. Now run "make init" at the top-level, this will generated module.mk-files for each module 
specified in the MODULES variable and generated dependancy-files (.d) for all sources found in their /src subdirectories.
If there are source files in /src subdirectories that you want to keep there do are not part of the build itself.
(for example other versions) just remove them from the generated module.mk file at that sub-level. The module.mk files
will only be created if they do not yet exist and it is your responsibility to keep them up-to-date if source
files are added. You might be able to do this automatically but I consider this neither worth the effort nor derisable.
</p>
 
todo: <br>
 <br>
- explain trickery/pokery used to generated .d files without depending on sed or awk. <br>
- finish writing this document, it's a work-in-progress <br>
- <br>
<br><br>
Please mail any comments to <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;%77%40%64&#100;&#115;%2E%6E&#108;">Jan Wilmans</A> 
<hr>
</P></BODY></HTML>
